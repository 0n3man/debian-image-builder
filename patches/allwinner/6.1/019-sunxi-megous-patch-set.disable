From 14423ce3aeed64b91b44ba9588d3f51ecfdbde5c Mon Sep 17 00:00:00 2001
From: Patrick Yavitz <pyavitz@xxxxx.com>
Date: Sun, 30 Jul 2023 10:26:34 -0400
Subject: [PATCH] sunxi: megous: patch set

https://github.com/megous/linux

Signed-off-by: Patrick Yavitz <pyavitz@xxxxx.com>
---
 drivers/clk/sunxi-ng/ccu-sun50i-a64.c         |   41 +-
 drivers/gpu/drm/bridge/synopsys/dw-hdmi.c     |   67 +-
 drivers/gpu/drm/bridge/synopsys/dw-mipi-dsi.c |   51 +-
 drivers/gpu/drm/drm_fb_helper.c               |   14 +
 drivers/gpu/drm/lima/lima_drv.c               |   26 +-
 drivers/gpu/drm/lima/lima_gem.c               |    7 +-
 drivers/gpu/drm/lima/lima_gem.h               |    4 +-
 drivers/gpu/drm/lima/lima_vm.c                |   13 +-
 drivers/gpu/drm/panel/Kconfig                 |    9 +
 drivers/gpu/drm/panel/Makefile                |    1 +
 drivers/gpu/drm/panel/panel-himax-hx8394.c    |  430 +++++++
 drivers/gpu/drm/panel/panel-sitronix-st7703.c |   62 +-
 drivers/gpu/drm/sun4i/sun4i_crtc.c            |   14 +
 drivers/gpu/drm/sun4i/sun4i_tcon.c            |  120 +-
 drivers/gpu/drm/sun4i/sun4i_tcon.h            |   15 +-
 drivers/gpu/drm/sun4i/sun6i_mipi_dsi.c        |   16 +-
 drivers/gpu/drm/sun4i/sun6i_mipi_dsi.h        |    2 +
 drivers/gpu/drm/sun4i/sun8i_mixer.c           |   60 +-
 drivers/gpu/drm/sun4i/sun8i_mixer.h           |    3 +
 drivers/gpu/drm/sun4i/sun8i_ui_layer.c        |  138 ++-
 drivers/gpu/drm/sun4i/sun8i_ui_layer.h        |    3 +-
 drivers/gpu/drm/sun4i/sun8i_vi_layer.c        |  139 ++-
 drivers/mfd/ac100.c                           |    3 +
 include/linux/mfd/ac100.h                     |    1 +
 include/linux/mfd/sun4i-gpadc.h               |    4 +-
 include/uapi/drm/lima_drm.h                   |    9 +-
 sound/soc/codecs/Kconfig                      |    3 +
 sound/soc/codecs/Makefile                     |    2 +
 sound/soc/codecs/ec25.c                       |   95 ++
 sound/soc/sunxi/Kconfig                       |   23 +-
 sound/soc/sunxi/Makefile                      |    2 +
 sound/soc/sunxi/ac100-codec.c                 | 1002 +++++++++++++++++
 sound/soc/sunxi/sun50i-codec-analog.c         |   97 +-
 sound/soc/sunxi/sun8i-codec.c                 |  632 ++++++++++-
 sound/soc/sunxi/sun9i-hdmi-audio.c            |  180 +++
 35 files changed, 3076 insertions(+), 212 deletions(-)
 create mode 100644 drivers/gpu/drm/panel/panel-himax-hx8394.c
 create mode 100644 sound/soc/codecs/ec25.c
 create mode 100644 sound/soc/sunxi/ac100-codec.c
 create mode 100644 sound/soc/sunxi/sun9i-hdmi-audio.c

diff --git a/drivers/clk/sunxi-ng/ccu-sun50i-a64.c b/drivers/clk/sunxi-ng/ccu-sun50i-a64.c
index 41519185600a..5d92cf8e2eab 100644
--- a/drivers/clk/sunxi-ng/ccu-sun50i-a64.c
+++ b/drivers/clk/sunxi-ng/ccu-sun50i-a64.c
@@ -47,15 +47,35 @@ static struct ccu_nkmp pll_cpux_clk = {
  * With sigma-delta modulation for fractional-N on the audio PLL,
  * we have to use specific dividers. This means the variable divider
  * can no longer be used, as the audio codec requests the exact clock
- * rates we support through this mechanism. So we now hard code the
- * variable divider to 1. This means the clock rates will no longer
- * match the clock names.
+ * rates we support through this mechanism.
+ *
+ * For the audio codec to work correctly, pll-audio must be exactly
+ * 22579200 Hz or 24576000 Hz, and pll-audio-4x (1x the base) must be
+ * between 3x and 8x that frequency. For the SRC to work at 96 kHz,
+ * pll-audio-4x must be at least 6x pll-audio.
+ *
+ * For now, hard code the variable divider to 3.
  */
 #define SUN50I_A64_PLL_AUDIO_REG	0x008
+#define SUN50I_A64_PLL_AUDIO_BIAS_REG	0x224
 
 static struct ccu_sdm_setting pll_audio_sdm_table[] = {
-	{ .rate = 22579200, .pattern = 0xc0010d84, .m = 8, .n = 7 },
-	{ .rate = 24576000, .pattern = 0xc000ac02, .m = 14, .n = 14 },
+	/* 24000000 * (  7 + 0x10d84 / 131072 ) /  8 / 1 - 22579200 == -6.9Hz */
+	{ .rate =  22579200, .pattern = 0xc0010d84, .m =  8, .n =  7 },
+	/* 24000000 * ( 14 + 0x0ac02 / 131072 ) / 14 / 1 - 24576000 == -2.5Hz */
+	{ .rate =  24576000, .pattern = 0xc000ac08, .m = 14, .n = 14 },
+	/* 24000000 * (  8 + 0x0ef35 / 131072 ) /  3 / 3 - 22579200 ==  3.3Hz */
+	{ .rate =  67737600, .pattern = 0xc000ef35, .m =  3, .n =  8 },
+	/* 24000000 * ( 15 + 0x0b852 / 131072 ) /  5 / 3 - 24576000 ==  1.0Hz */
+	{ .rate =  73728000, .pattern = 0xc000b852, .m =  5, .n = 15 },
+	/* 24000000 * (  7 + 0x10d84 / 131072 ) /  2 / 4 - 22579200 == -6.9Hz */
+	{ .rate =  90316800, .pattern = 0xc0010d84, .m =  2, .n =  7 },
+	/* 24000000 * ( 16 + 0x0c49c / 131072 ) /  4 / 4 - 24576000 ==  4.0Hz */
+	{ .rate =  98304000, .pattern = 0xc000c49c, .m =  4, .n = 16 },
+	/* 24000000 * (  5 + 0x14a23 / 131072 ) /  1 / 6 - 22579200 == -6.9Hz */
+	{ .rate = 135475200, .pattern = 0xc0014a23, .m =  1, .n =  5 },
+	/* 24000000 * ( 12 + 0x09375 / 131072 ) /  2 / 6 - 24576000 ==  4.0Hz */
+	{ .rate = 147456000, .pattern = 0xc0009375, .m =  2, .n = 12 },
 };
 
 static SUNXI_CCU_NM_WITH_SDM_GATE_LOCK(pll_audio_base_clk, "pll-audio-base",
@@ -604,10 +624,10 @@ static const struct clk_hw *clk_parent_pll_audio[] = {
 	&pll_audio_base_clk.common.hw
 };
 
-/* We hardcode the divider to 1 for now */
+/* We hardcode the divider to 3 for now */
 static CLK_FIXED_FACTOR_HWS(pll_audio_clk, "pll-audio",
 			    clk_parent_pll_audio,
-			    1, 1, CLK_SET_RATE_PARENT);
+			    3, 1, CLK_SET_RATE_PARENT);
 static CLK_FIXED_FACTOR_HWS(pll_audio_2x_clk, "pll-audio-2x",
 			    clk_parent_pll_audio,
 			    2, 1, CLK_SET_RATE_PARENT);
@@ -946,10 +966,13 @@ static int sun50i_a64_ccu_probe(struct platform_device *pdev)
 	if (IS_ERR(reg))
 		return PTR_ERR(reg);
 
-	/* Force the PLL-Audio-1x divider to 1 */
+	/* Force the pll-audio variable divider to 3 */
 	val = readl(reg + SUN50I_A64_PLL_AUDIO_REG);
 	val &= ~GENMASK(19, 16);
-	writel(val | (0 << 16), reg + SUN50I_A64_PLL_AUDIO_REG);
+	writel(val | (2 << 16), reg + SUN50I_A64_PLL_AUDIO_REG);
+
+	/* Decrease the PLL AUDIO bias current to reduce noise. */
+	writel(0x10040000, reg + SUN50I_A64_PLL_AUDIO_BIAS_REG);
 
 	writel(0x515, reg + SUN50I_A64_PLL_MIPI_REG);
 
diff --git a/drivers/gpu/drm/bridge/synopsys/dw-hdmi.c b/drivers/gpu/drm/bridge/synopsys/dw-hdmi.c
index aa51c61a78c7..4bb7d2cd8b69 100644
--- a/drivers/gpu/drm/bridge/synopsys/dw-hdmi.c
+++ b/drivers/gpu/drm/bridge/synopsys/dw-hdmi.c
@@ -9,6 +9,7 @@
 #include <linux/clk.h>
 #include <linux/delay.h>
 #include <linux/err.h>
+#include <linux/extcon.h>
 #include <linux/hdmi.h>
 #include <linux/i2c.h>
 #include <linux/irq.h>
@@ -211,6 +212,8 @@ struct dw_hdmi {
 	hdmi_codec_plugged_cb plugged_cb;
 	struct device *codec_dev;
 	enum drm_connector_status last_connector_result;
+	struct extcon_dev *extcon;
+	struct notifier_block extcon_nb;
 };
 
 #define HDMI_IH_PHY_STAT0_RX_SENSE \
@@ -1703,6 +1706,12 @@ static void dw_hdmi_phy_disable(struct dw_hdmi *hdmi, void *data)
 enum drm_connector_status dw_hdmi_phy_read_hpd(struct dw_hdmi *hdmi,
 					       void *data)
 {
+	if (hdmi->extcon) {
+		return extcon_get_state(hdmi->extcon, EXTCON_DISP_HDMI) > 0
+			? connector_status_connected
+			: connector_status_disconnected;
+	}
+
 	return hdmi_readb(hdmi, HDMI_PHY_STAT0) & HDMI_PHY_HPD ?
 		connector_status_connected : connector_status_disconnected;
 }
@@ -1713,7 +1722,7 @@ void dw_hdmi_phy_update_hpd(struct dw_hdmi *hdmi, void *data,
 {
 	u8 old_mask = hdmi->phy_mask;
 
-	if (force || disabled || !rxsense)
+	if (force || disabled || !rxsense || hdmi->extcon)
 		hdmi->phy_mask |= HDMI_PHY_RX_SENSE;
 	else
 		hdmi->phy_mask &= ~HDMI_PHY_RX_SENSE;
@@ -2466,7 +2475,7 @@ static enum drm_connector_status dw_hdmi_detect(struct dw_hdmi *hdmi)
 
 	mutex_lock(&hdmi->mutex);
 	if (result != hdmi->last_connector_result) {
-		dev_dbg(hdmi->dev, "read_hpd result: %d", result);
+		dev_info(hdmi->dev, "read_hpd result: %d", result);
 		handle_plugged_change(hdmi,
 				      result == connector_status_connected);
 		hdmi->last_connector_result = result;
@@ -3143,8 +3152,8 @@ static irqreturn_t dw_hdmi_irq(int irq, void *dev_id)
 			status = connector_status_disconnected;
 	}
 
-	if (status != connector_status_unknown) {
-		dev_dbg(hdmi->dev, "EVENT=%s\n",
+	if (status != connector_status_unknown && !hdmi->extcon) {
+		dev_info(hdmi->dev, "EVENT=%s\n",
 			status == connector_status_connected ?
 			"plugin" : "plugout");
 
@@ -3346,6 +3355,25 @@ static int dw_hdmi_parse_dt(struct dw_hdmi *hdmi)
 	return 0;
 }
 
+static int dw_hdmi_extcon_notifier(struct notifier_block *nb,
+				   unsigned long event, void *ptr)
+{
+	struct dw_hdmi *hdmi = container_of(nb, struct dw_hdmi, extcon_nb);
+
+	enum drm_connector_status status = dw_hdmi_phy_read_hpd(hdmi, NULL);
+
+	dev_info(hdmi->dev, "EVENT=%s\n",
+		 status == connector_status_connected ? "plugin" : "plugout");
+
+	if (hdmi->bridge.dev) {
+		//XXX: ???
+		drm_helper_hpd_irq_event(hdmi->bridge.dev);
+		drm_bridge_hpd_notify(&hdmi->bridge, status);
+	}
+
+	return NOTIFY_DONE;
+}
+
 struct dw_hdmi *dw_hdmi_probe(struct platform_device *pdev,
 			      const struct dw_hdmi_plat_data *plat_data)
 {
@@ -3387,15 +3415,38 @@ struct dw_hdmi *dw_hdmi_probe(struct platform_device *pdev,
 	if (ret < 0)
 		return ERR_PTR(ret);
 
+	hdmi->extcon = extcon_get_edev_by_phandle(dev, 0);
+	if (IS_ERR(hdmi->extcon)) {
+		if (PTR_ERR(hdmi->extcon) == -ENODEV) {
+			hdmi->extcon = NULL;
+		} else {
+			if (PTR_ERR(hdmi->extcon) != -EPROBE_DEFER)
+				dev_err(dev, "Invalid or missing extcon\n");
+			return ERR_CAST(hdmi->extcon);
+		}
+	}
+
+	if (hdmi->extcon) {
+		/* don't register IRQ for native HPD */
+		hdmi->phy_mask = (u8)~(HDMI_PHY_RX_SENSE);
+
+		hdmi->extcon_nb.notifier_call = dw_hdmi_extcon_notifier;
+		ret = extcon_register_notifier_all(hdmi->extcon, &hdmi->extcon_nb);
+		if (ret < 0) {
+			dev_err(dev, "failed to register extcon notifier\n");
+			return ERR_PTR(ret);
+		}
+	}
+
 	ddc_node = of_parse_phandle(np, "ddc-i2c-bus", 0);
 	if (ddc_node) {
 		hdmi->ddc = of_get_i2c_adapter_by_node(ddc_node);
 		of_node_put(ddc_node);
 		if (!hdmi->ddc) {
 			dev_dbg(hdmi->dev, "failed to read ddc node\n");
-			return ERR_PTR(-EPROBE_DEFER);
+			ret = -EPROBE_DEFER;
+			goto err_extcon;
 		}
-
 	} else {
 		dev_dbg(hdmi->dev, "no ddc property found\n");
 	}
@@ -3639,6 +3690,8 @@ struct dw_hdmi *dw_hdmi_probe(struct platform_device *pdev,
 	clk_disable_unprepare(hdmi->isfr_clk);
 err_res:
 	i2c_put_adapter(hdmi->ddc);
+err_extcon:
+	extcon_unregister_notifier_all(hdmi->extcon, &hdmi->extcon_nb);
 
 	return ERR_PTR(ret);
 }
@@ -3646,6 +3699,8 @@ EXPORT_SYMBOL_GPL(dw_hdmi_probe);
 
 void dw_hdmi_remove(struct dw_hdmi *hdmi)
 {
+	extcon_unregister_notifier_all(hdmi->extcon, &hdmi->extcon_nb);
+
 	drm_bridge_remove(&hdmi->bridge);
 
 	if (hdmi->audio && !IS_ERR(hdmi->audio))
diff --git a/drivers/gpu/drm/bridge/synopsys/dw-mipi-dsi.c b/drivers/gpu/drm/bridge/synopsys/dw-mipi-dsi.c
index b2efecf7d160..6e2007688dec 100644
--- a/drivers/gpu/drm/bridge/synopsys/dw-mipi-dsi.c
+++ b/drivers/gpu/drm/bridge/synopsys/dw-mipi-dsi.c
@@ -265,6 +265,7 @@ struct dw_mipi_dsi {
 	struct dw_mipi_dsi *master; /* dual-dsi master ptr */
 	struct dw_mipi_dsi *slave; /* dual-dsi slave ptr */
 
+	struct drm_display_mode mode;
 	const struct dw_mipi_dsi_plat_data *plat_data;
 };
 
@@ -571,6 +572,8 @@ static void dw_mipi_dsi_set_mode(struct dw_mipi_dsi *dsi,
 {
 	u32 val;
 
+	dev_info(dsi->dev, "mode %d\n", (int)mode_flags);
+
 	dsi_write(dsi, DSI_PWR_UP, RESET);
 
 	if (mode_flags & MIPI_DSI_MODE_VIDEO) {
@@ -845,12 +848,22 @@ static void dw_mipi_dsi_clear_err(struct dw_mipi_dsi *dsi)
 	dsi_write(dsi, DSI_INT_MSK1, 0);
 }
 
-static void dw_mipi_dsi_bridge_post_atomic_disable(struct drm_bridge *bridge,
+static void dw_mipi_dsi_bridge_atomic_disable(struct drm_bridge *bridge,
+					      struct drm_bridge_state *old_bridge_state)
+{
+	struct dw_mipi_dsi *dsi = bridge_to_dsi(bridge);
+
+	dev_info(dsi->dev, "disable\n");
+}
+
+static void dw_mipi_dsi_bridge_atomic_post_disable(struct drm_bridge *bridge,
 						   struct drm_bridge_state *old_bridge_state)
 {
 	struct dw_mipi_dsi *dsi = bridge_to_dsi(bridge);
 	const struct dw_mipi_dsi_phy_ops *phy_ops = dsi->plat_data->phy_ops;
 
+	dev_info(dsi->dev, "post disable\n");
+
 	/*
 	 * Switch to command mode before panel-bridge post_disable &
 	 * panel unprepare.
@@ -859,15 +872,6 @@ static void dw_mipi_dsi_bridge_post_atomic_disable(struct drm_bridge *bridge,
 	 */
 	dw_mipi_dsi_set_mode(dsi, 0);
 
-	/*
-	 * TODO Only way found to call panel-bridge post_disable &
-	 * panel unprepare before the dsi "final" disable...
-	 * This needs to be fixed in the drm_bridge framework and the API
-	 * needs to be updated to manage our own call chains...
-	 */
-	if (dsi->panel_bridge->funcs->post_disable)
-		dsi->panel_bridge->funcs->post_disable(dsi->panel_bridge);
-
 	if (phy_ops->power_off)
 		phy_ops->power_off(dsi->plat_data->priv_data);
 
@@ -896,7 +900,7 @@ static unsigned int dw_mipi_dsi_get_lanes(struct dw_mipi_dsi *dsi)
 	return dsi->lanes;
 }
 
-static void dw_mipi_dsi_mode_set(struct dw_mipi_dsi *dsi,
+static void dw_mipi_dsi_enable(struct dw_mipi_dsi *dsi,
 				 const struct drm_display_mode *adjusted_mode)
 {
 	const struct dw_mipi_dsi_phy_ops *phy_ops = dsi->plat_data->phy_ops;
@@ -948,9 +952,23 @@ static void dw_mipi_dsi_bridge_mode_set(struct drm_bridge *bridge,
 {
 	struct dw_mipi_dsi *dsi = bridge_to_dsi(bridge);
 
-	dw_mipi_dsi_mode_set(dsi, adjusted_mode);
+	dev_info(dsi->dev, "mode set\n");
+
+	/* Store the display mode for plugin/DKMS poweron events */
+	memcpy(&dsi->mode, mode, sizeof(dsi->mode));
+}
+
+static void dw_mipi_dsi_bridge_atomic_pre_enable(struct drm_bridge *bridge,
+						 struct drm_bridge_state *old_bridge_state)
+{
+	struct dw_mipi_dsi *dsi = bridge_to_dsi(bridge);
+
+	dev_info(dsi->dev, "pre enable\n");
+
+	/* power up the dsi ctl into a command mode */
+	dw_mipi_dsi_enable(dsi, &dsi->mode);
 	if (dsi->slave)
-		dw_mipi_dsi_mode_set(dsi->slave, adjusted_mode);
+		dw_mipi_dsi_enable(dsi->slave, &dsi->mode);
 }
 
 static void dw_mipi_dsi_bridge_atomic_enable(struct drm_bridge *bridge,
@@ -958,7 +976,8 @@ static void dw_mipi_dsi_bridge_atomic_enable(struct drm_bridge *bridge,
 {
 	struct dw_mipi_dsi *dsi = bridge_to_dsi(bridge);
 
-	/* Switch to video mode for panel-bridge enable & panel enable */
+	dev_info(dsi->dev, "enable\n");
+
 	dw_mipi_dsi_set_mode(dsi, MIPI_DSI_MODE_VIDEO);
 	if (dsi->slave)
 		dw_mipi_dsi_set_mode(dsi->slave, MIPI_DSI_MODE_VIDEO);
@@ -1004,8 +1023,10 @@ static const struct drm_bridge_funcs dw_mipi_dsi_bridge_funcs = {
 	.atomic_duplicate_state	= drm_atomic_helper_bridge_duplicate_state,
 	.atomic_destroy_state	= drm_atomic_helper_bridge_destroy_state,
 	.atomic_reset		= drm_atomic_helper_bridge_reset,
+	.atomic_pre_enable	= dw_mipi_dsi_bridge_atomic_pre_enable,
 	.atomic_enable		= dw_mipi_dsi_bridge_atomic_enable,
-	.atomic_post_disable	= dw_mipi_dsi_bridge_post_atomic_disable,
+	.atomic_disable		= dw_mipi_dsi_bridge_atomic_disable,
+	.atomic_post_disable	= dw_mipi_dsi_bridge_atomic_post_disable,
 	.mode_set		= dw_mipi_dsi_bridge_mode_set,
 	.mode_valid		= dw_mipi_dsi_bridge_mode_valid,
 	.attach			= dw_mipi_dsi_bridge_attach,
diff --git a/drivers/gpu/drm/drm_fb_helper.c b/drivers/gpu/drm/drm_fb_helper.c
index 442746d9777a..44958cbcc6de 100644
--- a/drivers/gpu/drm/drm_fb_helper.c
+++ b/drivers/gpu/drm/drm_fb_helper.c
@@ -2435,6 +2435,7 @@ static int drm_fb_helper_generic_probe(struct drm_fb_helper *fb_helper,
 	struct fb_info *fbi;
 	u32 format;
 	struct iosys_map map;
+	u32 fb_start;
 	int ret;
 
 	drm_dbg_kms(dev, "surface width(%d), height(%d) and bpp(%d)\n",
@@ -2493,6 +2494,19 @@ static int drm_fb_helper_generic_probe(struct drm_fb_helper *fb_helper,
 			fbi->fix.smem_start =
 				page_to_phys(virt_to_page(fbi->screen_buffer));
 #endif
+
+		ret = of_property_read_u32_index(of_chosen, "p-boot,framebuffer-start", 0, &fb_start);
+		if (ret == 0 && !map.is_iomem) {
+			// copy framebuffer contents from p-boot if reasonable
+			if (fbi->screen_size != 720 * 1440 * 4) {
+				drm_err(dev, "surface width(%d), height(%d) and bpp(%d) does not match p-boot requirements\n",
+					    sizes->surface_width, sizes->surface_height,
+					    sizes->surface_bpp);
+				return 0;
+			}
+
+			memcpy(map.vaddr, __va(fb_start), fbi->screen_size);
+		}
 	}
 
 	return 0;
diff --git a/drivers/gpu/drm/lima/lima_drv.c b/drivers/gpu/drm/lima/lima_drv.c
index 39cab4a55f57..9c02e0629822 100644
--- a/drivers/gpu/drm/lima/lima_drv.c
+++ b/drivers/gpu/drm/lima/lima_drv.c
@@ -79,16 +79,27 @@ static int lima_ioctl_gem_create(struct drm_device *dev, void *data, struct drm_
 {
 	struct drm_lima_gem_create *args = data;
 
-	if (args->pad)
-		return -EINVAL;
-
-	if (args->flags & ~(LIMA_BO_FLAG_HEAP))
+	if (args->flags & ~(LIMA_BO_FLAG_HEAP | LIMA_BO_FLAG_FORCE_VA))
 		return -EINVAL;
 
 	if (args->size == 0)
 		return -EINVAL;
 
-	return lima_gem_create_handle(dev, file, args->size, args->flags, &args->handle);
+	if (args->flags & LIMA_BO_FLAG_FORCE_VA) {
+		u64 max = (u64)args->va + (u64)args->size;
+
+		if (max > LIMA_VA_RESERVE_START)
+			return -EINVAL;
+
+		if (!IS_ALIGNED(args->va, PAGE_SIZE))
+			return -EINVAL;
+	} else {
+		if (args->va)
+			return -EINVAL;
+	}
+
+	return lima_gem_create_handle(dev, file, args->size, args->flags,
+				      &args->handle, args->va);
 }
 
 static int lima_ioctl_gem_info(struct drm_device *dev, void *data, struct drm_file *file)
@@ -259,6 +270,7 @@ DEFINE_DRM_GEM_FOPS(lima_drm_driver_fops);
  * Changelog:
  *
  * - 1.1.0 - add heap buffer support
+ * - 1.2.0 - add force va support
  */
 
 static const struct drm_driver lima_drm_driver = {
@@ -270,9 +282,9 @@ static const struct drm_driver lima_drm_driver = {
 	.fops               = &lima_drm_driver_fops,
 	.name               = "lima",
 	.desc               = "lima DRM",
-	.date               = "20191231",
+	.date               = "20200215",
 	.major              = 1,
-	.minor              = 1,
+	.minor              = 2,
 	.patchlevel         = 0,
 
 	.gem_create_object  = lima_gem_create_object,
diff --git a/drivers/gpu/drm/lima/lima_gem.c b/drivers/gpu/drm/lima/lima_gem.c
index 0f1ca0b0db49..0e0349332662 100644
--- a/drivers/gpu/drm/lima/lima_gem.c
+++ b/drivers/gpu/drm/lima/lima_gem.c
@@ -101,7 +101,7 @@ int lima_heap_alloc(struct lima_bo *bo, struct lima_vm *vm)
 }
 
 int lima_gem_create_handle(struct drm_device *dev, struct drm_file *file,
-			   u32 size, u32 flags, u32 *handle)
+			   u32 size, u32 flags, u32 *handle, u32 va)
 {
 	int err;
 	gfp_t mask;
@@ -122,8 +122,11 @@ int lima_gem_create_handle(struct drm_device *dev, struct drm_file *file,
 	mask |= __GFP_DMA32;
 	mapping_set_gfp_mask(obj->filp->f_mapping, mask);
 
+	bo = to_lima_bo(obj);
+	bo->flags = flags;
+	bo->force_va = va;
+
 	if (is_heap) {
-		bo = to_lima_bo(obj);
 		err = lima_heap_alloc(bo, NULL);
 		if (err)
 			goto out;
diff --git a/drivers/gpu/drm/lima/lima_gem.h b/drivers/gpu/drm/lima/lima_gem.h
index ccea06142f4b..2a6db0c0be89 100644
--- a/drivers/gpu/drm/lima/lima_gem.h
+++ b/drivers/gpu/drm/lima/lima_gem.h
@@ -15,6 +15,8 @@ struct lima_bo {
 	struct mutex lock;
 	struct list_head va;
 
+	u32 flags;
+	u32 force_va;
 	size_t heap_size;
 };
 
@@ -37,7 +39,7 @@ static inline struct dma_resv *lima_bo_resv(struct lima_bo *bo)
 int lima_heap_alloc(struct lima_bo *bo, struct lima_vm *vm);
 struct drm_gem_object *lima_gem_create_object(struct drm_device *dev, size_t size);
 int lima_gem_create_handle(struct drm_device *dev, struct drm_file *file,
-			   u32 size, u32 flags, u32 *handle);
+			   u32 size, u32 flags, u32 *handle, u32 va);
 int lima_gem_get_info(struct drm_file *file, u32 handle, u32 *va, u64 *offset);
 int lima_gem_submit(struct drm_file *file, struct lima_submit *submit);
 int lima_gem_wait(struct drm_file *file, u32 handle, u32 op, s64 timeout_ns);
diff --git a/drivers/gpu/drm/lima/lima_vm.c b/drivers/gpu/drm/lima/lima_vm.c
index 2b2739adc7f5..5554c2548d9c 100644
--- a/drivers/gpu/drm/lima/lima_vm.c
+++ b/drivers/gpu/drm/lima/lima_vm.c
@@ -3,6 +3,7 @@
 
 #include <linux/slab.h>
 #include <linux/dma-mapping.h>
+#include <drm/lima_drm.h>
 
 #include "lima_device.h"
 #include "lima_vm.h"
@@ -93,6 +94,7 @@ int lima_vm_bo_add(struct lima_vm *vm, struct lima_bo *bo, bool create)
 	struct lima_bo_va *bo_va;
 	struct sg_dma_page_iter sg_iter;
 	int offset = 0, err;
+	u64 start, end;
 
 	mutex_lock(&bo->lock);
 
@@ -120,7 +122,16 @@ int lima_vm_bo_add(struct lima_vm *vm, struct lima_bo *bo, bool create)
 
 	mutex_lock(&vm->lock);
 
-	err = drm_mm_insert_node(&vm->mm, &bo_va->node, lima_bo_size(bo));
+	if (bo->flags & LIMA_BO_FLAG_FORCE_VA) {
+		start = bo->force_va;
+		end = start + lima_bo_size(bo);
+	} else {
+		start = 0;
+		end = U64_MAX;
+	}
+
+	err = drm_mm_insert_node_in_range(&vm->mm, &bo_va->node, lima_bo_size(bo),
+					  0, 0, start, end, 0);
 	if (err)
 		goto err_out1;
 
diff --git a/drivers/gpu/drm/panel/Kconfig b/drivers/gpu/drm/panel/Kconfig
index a582ddd583c2..4746f36b6032 100644
--- a/drivers/gpu/drm/panel/Kconfig
+++ b/drivers/gpu/drm/panel/Kconfig
@@ -154,6 +154,15 @@ config DRM_PANEL_FEIYANG_FY07024DI26A30D
 	  Say Y if you want to enable support for panels based on the
 	  Feiyang FY07024DI26A30-D MIPI-DSI interface.
 
+config DRM_PANEL_HIMAX_HX8394
+	tristate "HIMAX HX8394 MIPI-DSI LCD panel"
+	depends on OF
+	depends on DRM_MIPI_DSI
+	depends on BACKLIGHT_CLASS_DEVICE
+	help
+	  Say Y if you want to enable support for panels based on the
+	  HIMAX HX8394 MIPI-DSI interface.
+
 config DRM_PANEL_ILITEK_IL9322
 	tristate "Ilitek ILI9322 320x240 QVGA panels"
 	depends on OF && SPI
diff --git a/drivers/gpu/drm/panel/Makefile b/drivers/gpu/drm/panel/Makefile
index 34e717382dbb..9b5023351fa5 100644
--- a/drivers/gpu/drm/panel/Makefile
+++ b/drivers/gpu/drm/panel/Makefile
@@ -73,3 +73,4 @@ obj-$(CONFIG_DRM_PANEL_TRULY_NT35597_WQXGA) += panel-truly-nt35597.o
 obj-$(CONFIG_DRM_PANEL_VISIONOX_RM69299) += panel-visionox-rm69299.o
 obj-$(CONFIG_DRM_PANEL_WIDECHIPS_WS2401) += panel-widechips-ws2401.o
 obj-$(CONFIG_DRM_PANEL_XINPENG_XPP055C272) += panel-xinpeng-xpp055c272.o
+obj-$(CONFIG_DRM_PANEL_HIMAX_HX8394) += panel-himax-hx8394.o
diff --git a/drivers/gpu/drm/panel/panel-himax-hx8394.c b/drivers/gpu/drm/panel/panel-himax-hx8394.c
new file mode 100644
index 000000000000..7a2f74ab85fe
--- /dev/null
+++ b/drivers/gpu/drm/panel/panel-himax-hx8394.c
@@ -0,0 +1,430 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Driver for panels based on Himax HX8394 controller, souch as:
+ *
+ * - HannStar HSD060BHW4 5.99" MIPI-DSI panel
+ *
+ * Copyright (C) Kamil Trzciński
+ */
+
+#include <linux/debugfs.h>
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/media-bus-format.h>
+#include <linux/mod_devicetable.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/regulator/consumer.h>
+
+#include <video/display_timing.h>
+#include <video/mipi_display.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+
+#define DRV_NAME "panel-himax-hx8394"
+
+struct hx8394 {
+	struct device *dev;
+	struct drm_panel panel;
+	struct gpio_desc *reset_gpio;
+	struct regulator *vcc;
+	struct regulator *iovcc;
+	bool prepared;
+
+	struct dentry *debugfs;
+	const struct hx8394_panel_desc *desc;
+};
+
+struct hx8394_panel_desc {
+	const struct drm_display_mode *mode;
+	unsigned int lanes;
+	unsigned long mode_flags;
+	enum mipi_dsi_pixel_format format;
+	int (*init_sequence)(struct hx8394 *ctx);
+};
+
+static inline struct hx8394 *panel_to_hx8394(struct drm_panel *panel)
+{
+	return container_of(panel, struct hx8394, panel);
+}
+
+#define dsi_generic_write_seq(dsi, seq...) do {				\
+		static const u8 d[] = { seq };				\
+		int ret;						\
+		ret = mipi_dsi_generic_write(dsi, d, ARRAY_SIZE(d));	\
+		if (ret < 0)						\
+			return ret;					\
+	} while (0)
+
+#define dsi_dcs_write_seq(dsi, cmd, seq...) do {			\
+		static const u8 d[] = { seq };				\
+		int ret;						\
+		ret = mipi_dsi_dcs_write(dsi, cmd, d, ARRAY_SIZE(d));	\
+		if (ret < 0)						\
+			return ret;					\
+	} while (0)
+
+
+static int hsd060bhw4_init_sequence(struct hx8394 *ctx)
+{
+	struct mipi_dsi_device *dsi = to_mipi_dsi_device(ctx->dev);
+
+	dsi_dcs_write_seq(dsi, 0xb9, 0xff, 0x83, 0x94);
+	dsi_dcs_write_seq(dsi, 0xb1, 0x48, 0x11, 0x71, 0x09, 0x32, 0x24, 0x71, 0x31, 0x55, 0x30);
+	dsi_dcs_write_seq(dsi, 0xba, 0x63, 0x03, 0x68, 0x6b, 0xb2, 0xc0);
+	dsi_dcs_write_seq(dsi, 0xb2, 0x00, 0x80, 0x78, 0x0c, 0x07);
+	dsi_dcs_write_seq(dsi, 0xb4, 0x12, 0x63, 0x12, 0x63, 0x12, 0x63, 0x01, 0x0c, 0x7c, 0x55, 0x00, 0x3f, 0x12, 0x6b, 0x12, 0x6b, 0x12, 0x6b, 0x01, 0x0c, 0x7c);
+	dsi_dcs_write_seq(dsi, 0xd3, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x1c, 0x00, 0x00, 0x32, 0x10, 0x09, 0x00, 0x09, 0x32, 0x15, 0xad, 0x05, 0xad, 0x32, 0x00, 0x00, 0x00, 0x00, 0x37, 0x03, 0x0b, 0x0b, 0x37, 0x00, 0x00, 0x00, 0x0c, 0x40);
+	dsi_dcs_write_seq(dsi, 0xd5, 0x19, 0x19, 0x18, 0x18, 0x1b, 0x1b, 0x1a, 0x1a, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x20, 0x21, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x24, 0x25, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18);
+	dsi_dcs_write_seq(dsi, 0xd6, 0x18, 0x18, 0x19, 0x19, 0x1b, 0x1b, 0x1a, 0x1a, 0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01, 0x00, 0x25, 0x24, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x21, 0x20, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18);
+	dsi_dcs_write_seq(dsi, 0xe0, 0x00, 0x04, 0x0c, 0x12, 0x14, 0x18, 0x1a, 0x18, 0x31, 0x3f, 0x4d, 0x4c, 0x54, 0x65, 0x6b, 0x70, 0x7f, 0x82, 0x7e, 0x8a, 0x99, 0x4a, 0x48, 0x49, 0x4b, 0x4a, 0x4c, 0x4b, 0x7f, 0x00, 0x04, 0x0c, 0x11, 0x13, 0x17, 0x1a, 0x18, 0x31, 0x3f, 0x4d, 0x4c, 0x54, 0x65, 0x6b, 0x70, 0x7f, 0x82, 0x7e, 0x8a, 0x99, 0x4a, 0x48, 0x49, 0x4b, 0x4a, 0x4c, 0x4b, 0x7f);
+	dsi_dcs_write_seq(dsi, 0xcc, 0x0b);
+	dsi_dcs_write_seq(dsi, 0xc0, 0x1f, 0x31);
+	dsi_dcs_write_seq(dsi, 0xb6, 0x7d, 0x7d);
+	dsi_dcs_write_seq(dsi, 0xd4, 0x02);
+	dsi_dcs_write_seq(dsi, 0xbd, 0x01);
+	dsi_dcs_write_seq(dsi, 0xb1, 0x00);
+	dsi_dcs_write_seq(dsi, 0xbd, 0x00);
+	dsi_dcs_write_seq(dsi, 0xc6, 0xed);
+
+	return 0;
+}
+
+static const struct drm_display_mode hsd060bhw4_mode = {
+	.hdisplay    = 720,
+	.hsync_start = 720 + 40,
+	.hsync_end   = 720 + 40 + 40,
+	.htotal	     = 720 + 40 + 40 + 40,
+	.vdisplay    = 1440,
+	.vsync_start = 1440 + 18,
+	.vsync_end   = 1440 + 18 + 10,
+	.vtotal	     = 1440 + 18 + 10 + 17,
+	.clock	     = 66000, /*XXX: only 66MHz works */
+	.flags	     = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC,
+	.width_mm    = 68,
+	.height_mm   = 136,
+};
+
+static const struct drm_display_mode hsd060bhw4_mode2 = {
+	.hdisplay    = 720,
+	.hsync_start = 720 + 50,
+	.hsync_end   = 720 + 50 + 10,
+	.htotal	     = 720 + 50 + 10 + 50,
+	.vdisplay    = 1440,
+	.vsync_start = 1440 + 17,
+	.vsync_end   = 1440 + 17 + 4,
+	.vtotal	     = 1440 + 17 + 4 + 10,
+	.clock	     = 60000,
+	.flags	     = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC,
+	.width_mm    = 68,
+	.height_mm   = 136,
+};
+
+static const struct hx8394_panel_desc hsd060bhw4_desc = {
+	.mode = &hsd060bhw4_mode,
+	.lanes = 4,
+	.mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST,// | MIPI_DSI_MODE_LPM,//, // 0x843
+	.format = MIPI_DSI_FMT_RGB888,
+	.init_sequence = hsd060bhw4_init_sequence,
+};
+
+static int hx8394_enable(struct drm_panel *panel)
+{
+	struct hx8394 *ctx = panel_to_hx8394(panel);
+	struct mipi_dsi_device *dsi = to_mipi_dsi_device(ctx->dev);
+	int ret;
+
+	dev_info(ctx->dev, "enable\n");
+
+	ret = ctx->desc->init_sequence(ctx);
+	if (ret) {
+		dev_err(ctx->dev, "Panel init sequence failed: %d\n", ret);
+		return ret;
+	}
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret) {
+		dev_err(ctx->dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+
+	/* Panel is operational 120 msec after reset */
+	msleep(120);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret) {
+		dev_err(ctx->dev, "Failed to turn on the display: %d\n", ret);
+		goto sleep_in;
+	}
+
+	return 0;
+
+sleep_in:
+	/* This will probably fail, but let's try orderly power off anyway. */
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (!ret)
+		msleep(50);
+
+        return ret;
+}
+
+static int hx8394_disable(struct drm_panel *panel)
+{
+	struct hx8394 *ctx = panel_to_hx8394(panel);
+	struct mipi_dsi_device *dsi = to_mipi_dsi_device(ctx->dev);
+	int ret;
+
+	dev_info(ctx->dev, "disable\n");
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret) {
+		dev_err(ctx->dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+
+	msleep(50); /* about 3 frames */
+
+	return 0;
+}
+
+static int hx8394_unprepare(struct drm_panel *panel)
+{
+	struct hx8394 *ctx = panel_to_hx8394(panel);
+	//struct mipi_dsi_device *dsi = to_mipi_dsi_device(ctx->dev);
+	//int ret;
+
+	if (!ctx->prepared)
+		return 0;
+
+	dev_info(ctx->dev, "unprepare\n");
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+
+	regulator_disable(ctx->iovcc);
+	regulator_disable(ctx->vcc);
+
+	ctx->prepared = false;
+
+	return 0;
+}
+
+static int hx8394_prepare(struct drm_panel *panel)
+{
+	struct hx8394 *ctx = panel_to_hx8394(panel);
+	//struct mipi_dsi_device *dsi = to_mipi_dsi_device(ctx->dev);
+	int ret;
+
+	if (ctx->prepared)
+		return 0;
+
+	dev_info(ctx->dev, "prepare\n");
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+
+	ret = regulator_enable(ctx->vcc);
+	if (ret) {
+		dev_err(ctx->dev, "Failed to enable vcc supply: %d\n", ret);
+		return ret;
+	}
+
+	ret = regulator_enable(ctx->iovcc);
+	if (ret) {
+		dev_err(ctx->dev, "Failed to enable iovcc supply: %d\n", ret);
+		goto disable_vcc;
+	}
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+
+	msleep(180);
+
+	ctx->prepared = true;
+
+	return 0;
+
+disable_vcc:
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	regulator_disable(ctx->vcc);
+	return ret;
+}
+
+static int hx8394_get_modes(struct drm_panel *panel,
+			    struct drm_connector *connector)
+{
+	struct hx8394 *ctx = panel_to_hx8394(panel);
+	struct drm_display_mode *mode;
+
+	mode = drm_mode_duplicate(connector->dev, ctx->desc->mode);
+	if (!mode) {
+		dev_err(ctx->dev, "Failed to add mode %ux%u@%u\n",
+			ctx->desc->mode->hdisplay, ctx->desc->mode->vdisplay,
+			drm_mode_vrefresh(ctx->desc->mode));
+		return -ENOMEM;
+	}
+
+	drm_mode_set_name(mode);
+
+	mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
+	connector->display_info.width_mm = mode->width_mm;
+	connector->display_info.height_mm = mode->height_mm;
+	drm_mode_probed_add(connector, mode);
+
+	return 1;
+}
+
+static const struct drm_panel_funcs hx8394_drm_funcs = {
+	.disable   = hx8394_disable,
+	.unprepare = hx8394_unprepare,
+	.prepare   = hx8394_prepare,
+	.enable	   = hx8394_enable,
+	.get_modes = hx8394_get_modes,
+};
+
+static int allpixelson_set(void *data, u64 val)
+{
+	struct hx8394 *ctx = data;
+	struct mipi_dsi_device *dsi = to_mipi_dsi_device(ctx->dev);
+
+	dev_dbg(ctx->dev, "Setting all pixels on\n");
+	dsi_generic_write_seq(dsi, 0x23);
+	msleep(val * 1000);
+
+	/* Reset the panel to get video back */
+	drm_panel_disable(&ctx->panel);
+	drm_panel_unprepare(&ctx->panel);
+
+	drm_panel_prepare(&ctx->panel);
+	drm_panel_enable(&ctx->panel);
+
+	return 0;
+}
+
+DEFINE_SIMPLE_ATTRIBUTE(allpixelson_fops, NULL,
+			allpixelson_set, "%llu\n");
+
+static void hx8394_debugfs_init(struct hx8394 *ctx)
+{
+	ctx->debugfs = debugfs_create_dir(DRV_NAME, NULL);
+
+	debugfs_create_file("allpixelson", 0600, ctx->debugfs, ctx,
+			    &allpixelson_fops);
+}
+
+static void hx8394_debugfs_remove(struct hx8394 *ctx)
+{
+	debugfs_remove_recursive(ctx->debugfs);
+	ctx->debugfs = NULL;
+}
+
+static int hx8394_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct hx8394 *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset gpio\n");
+
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	ctx->dev = dev;
+	ctx->desc = of_device_get_match_data(dev);
+
+	dsi->mode_flags = ctx->desc->mode_flags;
+	dsi->format = ctx->desc->format;
+	dsi->lanes = ctx->desc->lanes;
+
+	ctx->vcc = devm_regulator_get(dev, "vcc");
+	if (IS_ERR(ctx->vcc))
+		return dev_err_probe(dev, PTR_ERR(ctx->vcc),
+				     "Failed to request vcc regulator\n");
+
+	ctx->iovcc = devm_regulator_get(dev, "iovcc");
+	if (IS_ERR(ctx->iovcc))
+		return dev_err_probe(dev, PTR_ERR(ctx->iovcc),
+				     "Failed to request iovcc regulator\n");
+
+	drm_panel_init(&ctx->panel, dev, &hx8394_drm_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+
+	ret = drm_panel_of_backlight(&ctx->panel);
+	if (ret)
+		return ret;
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		dev_err_probe(dev, ret, "mipi_dsi_attach failed\n");
+		drm_panel_remove(&ctx->panel);
+		return ret;
+	}
+
+	dev_info(dev, "%ux%u@%u %ubpp dsi %udl - ready\n",
+		 ctx->desc->mode->hdisplay, ctx->desc->mode->vdisplay,
+		 drm_mode_vrefresh(ctx->desc->mode),
+		 mipi_dsi_pixel_format_to_bpp(dsi->format), dsi->lanes);
+
+	hx8394_debugfs_init(ctx);
+	return 0;
+}
+
+static void hx8394_shutdown(struct mipi_dsi_device *dsi)
+{
+	struct hx8394 *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = drm_panel_disable(&ctx->panel);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to disable panel: %d\n", ret);
+
+	ret = drm_panel_unprepare(&ctx->panel);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to unprepare panel: %d\n", ret);
+}
+
+static int hx8394_remove(struct mipi_dsi_device *dsi)
+{
+	struct hx8394 *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	hx8394_shutdown(dsi);
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+
+	hx8394_debugfs_remove(ctx);
+
+	return 0;
+}
+
+static const struct of_device_id hx8394_of_match[] = {
+	{ .compatible = "hannstar,hsd060bhw4", .data = &hsd060bhw4_desc },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, hx8394_of_match);
+
+static struct mipi_dsi_driver hx8394_driver = {
+	.probe	= hx8394_probe,
+	.remove = hx8394_remove,
+	.shutdown = hx8394_shutdown,
+	.driver = {
+		.name = DRV_NAME,
+		.of_match_table = hx8394_of_match,
+	},
+};
+module_mipi_dsi_driver(hx8394_driver);
+
+MODULE_AUTHOR("Kamil Trzciński <ayufan@ayufan.eu>");
+MODULE_DESCRIPTION("DRM driver for Himax HX8394 based MIPI DSI panels");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpu/drm/panel/panel-sitronix-st7703.c b/drivers/gpu/drm/panel/panel-sitronix-st7703.c
index 86a472b01360..580b6f38b0a0 100644
--- a/drivers/gpu/drm/panel/panel-sitronix-st7703.c
+++ b/drivers/gpu/drm/panel/panel-sitronix-st7703.c
@@ -58,6 +58,7 @@ struct st7703 {
 
 	struct dentry *debugfs;
 	const struct st7703_panel_desc *desc;
+	bool hw_preenabled;
 };
 
 struct st7703_panel_desc {
@@ -290,7 +291,6 @@ static int xbd599_init_sequence(struct st7703 *ctx)
 	dsi_dcs_write_seq(dsi, ST7703_CMD_SETBGP,
 			  0x07, /* VREF_SEL = 4.2V */
 			  0x07  /* NVREF_SEL = 4.2V */);
-	msleep(20);
 
 	dsi_dcs_write_seq(dsi, ST7703_CMD_SETVCOM,
 			  0x2C, /* VCOMDC_F = -0.67V */
@@ -334,14 +334,14 @@ static int xbd599_init_sequence(struct st7703 *ctx)
 
 static const struct drm_display_mode xbd599_mode = {
 	.hdisplay    = 720,
-	.hsync_start = 720 + 40,
-	.hsync_end   = 720 + 40 + 40,
-	.htotal	     = 720 + 40 + 40 + 40,
+	.hsync_start = 720 + 30,
+	.hsync_end   = 720 + 30 + 28,
+	.htotal	     = 720 + 30 + 28 + 30,
 	.vdisplay    = 1440,
 	.vsync_start = 1440 + 18,
 	.vsync_end   = 1440 + 18 + 10,
 	.vtotal	     = 1440 + 18 + 10 + 17,
-	.clock	     = 69000,
+	.clock	     = 72000,
 	.flags	     = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC,
 	.width_mm    = 68,
 	.height_mm   = 136,
@@ -361,22 +361,25 @@ static int st7703_enable(struct drm_panel *panel)
 	struct mipi_dsi_device *dsi = to_mipi_dsi_device(ctx->dev);
 	int ret;
 
+	if (ctx->hw_preenabled) {
+		ctx->hw_preenabled = false;
+		return 0;
+	}
+
 	ret = ctx->desc->init_sequence(ctx);
 	if (ret < 0) {
 		dev_err(ctx->dev, "Panel init sequence failed: %d\n", ret);
 		return ret;
 	}
 
-	msleep(20);
-
 	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
 	if (ret < 0) {
 		dev_err(ctx->dev, "Failed to exit sleep mode: %d\n", ret);
 		return ret;
 	}
 
-	/* Panel is operational 120 msec after reset */
-	msleep(60);
+	/* Display on can be issued 120 msec after sleep out */
+	msleep(120);
 
 	ret = mipi_dsi_dcs_set_display_on(dsi);
 	if (ret)
@@ -401,6 +404,9 @@ static int st7703_disable(struct drm_panel *panel)
 	if (ret < 0)
 		dev_err(ctx->dev, "Failed to enter sleep mode: %d\n", ret);
 
+	/* Display needs to be drained of charge, in order to work correctly on next power on. */
+	msleep(120);
+
 	return 0;
 }
 
@@ -427,30 +433,35 @@ static int st7703_prepare(struct drm_panel *panel)
 	if (ctx->prepared)
 		return 0;
 
+	if (!ctx->hw_preenabled) {
 	dev_dbg(ctx->dev, "Resetting the panel\n");
-	ret = regulator_enable(ctx->vcc);
-	if (ret < 0) {
-		dev_err(ctx->dev, "Failed to enable vcc supply: %d\n", ret);
-		return ret;
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
 	}
+
 	ret = regulator_enable(ctx->iovcc);
 	if (ret < 0) {
 		dev_err(ctx->dev, "Failed to enable iovcc supply: %d\n", ret);
-		goto disable_vcc;
+		return ret;
 	}
 
-	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
-	usleep_range(20, 40);
+	ret = regulator_enable(ctx->vcc);
+	if (ret < 0) {
+		dev_err(ctx->dev, "Failed to enable vcc supply: %d\n", ret);
+		regulator_disable(ctx->iovcc);
+		return ret;
+	}
+
+	/* Give power supplies time to stabilize before deasserting reset. */
+	if (!ctx->hw_preenabled) {
+	usleep_range(10000, 20000);
+
 	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
-	msleep(20);
+	usleep_range(15000, 20000);
+	}
 
 	ctx->prepared = true;
 
 	return 0;
-
-disable_vcc:
-	regulator_disable(ctx->vcc);
-	return ret;
 }
 
 static const u32 mantix_bus_formats[] = {
@@ -531,12 +542,19 @@ static int st7703_probe(struct mipi_dsi_device *dsi)
 {
 	struct device *dev = &dsi->dev;
 	struct st7703 *ctx;
+	u32 fb_start;
 	int ret;
 
 	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
 	if (!ctx)
 		return -ENOMEM;
 
+	ret = of_property_read_u32_index(of_chosen, "p-boot,framebuffer-start", 0, &fb_start);
+	if (ret == 0) {
+		/* the display pipeline is already initialized by p-boot */
+		ctx->hw_preenabled = true;
+	}
+
 	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_LOW);
 	if (IS_ERR(ctx->reset_gpio))
 		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio), "Failed to get reset gpio\n");
@@ -570,7 +588,7 @@ static int st7703_probe(struct mipi_dsi_device *dsi)
 
 	ret = mipi_dsi_attach(dsi);
 	if (ret < 0) {
-		dev_err(dev, "mipi_dsi_attach failed (%d). Is host ready?\n", ret);
+		dev_err_probe(dev, ret, "mipi_dsi_attach failed\n");
 		drm_panel_remove(&ctx->panel);
 		return ret;
 	}
diff --git a/drivers/gpu/drm/sun4i/sun4i_crtc.c b/drivers/gpu/drm/sun4i/sun4i_crtc.c
index c06d7cd45388..c30dc95baaea 100644
--- a/drivers/gpu/drm/sun4i/sun4i_crtc.c
+++ b/drivers/gpu/drm/sun4i/sun4i_crtc.c
@@ -103,6 +103,20 @@ static void sun4i_crtc_atomic_flush(struct drm_crtc *crtc,
 			drm_crtc_send_vblank_event(crtc, event);
 		spin_unlock_irq(&crtc->dev->event_lock);
 	}
+
+	if (crtc->state->color_mgmt_changed) {
+		if (crtc->state->gamma_lut) {
+			/* LUT can be only updated when gamma correction is
+			 * disabled
+			 */
+			sun4i_tcon_enable_gamma(scrtc->tcon, false);
+			sun4i_tcon_load_gamma_lut(scrtc->tcon,
+						  crtc->state->gamma_lut->data);
+			sun4i_tcon_enable_gamma(scrtc->tcon, true);
+		} else
+			sun4i_tcon_enable_gamma(scrtc->tcon, false);
+	}
+
 }
 
 static void sun4i_crtc_atomic_disable(struct drm_crtc *crtc,
diff --git a/drivers/gpu/drm/sun4i/sun4i_tcon.c b/drivers/gpu/drm/sun4i/sun4i_tcon.c
index 936796851ffd..0ed5ea1e0ba2 100644
--- a/drivers/gpu/drm/sun4i/sun4i_tcon.c
+++ b/drivers/gpu/drm/sun4i/sun4i_tcon.c
@@ -40,6 +40,8 @@
 #include "sun8i_tcon_top.h"
 #include "sunxi_engine.h"
 
+static bool hw_preconfigured;
+
 static struct drm_connector *sun4i_tcon_get_connector(const struct drm_encoder *encoder)
 {
 	struct drm_connector *connector;
@@ -108,9 +110,11 @@ static void sun4i_tcon_channel_set_status(struct sun4i_tcon *tcon, int channel,
 
 	if (enabled) {
 		clk_prepare_enable(clk);
-		clk_rate_exclusive_get(clk);
+		if (!tcon->quirks->clk_kept_by_ccu)
+			clk_rate_exclusive_get(clk);
 	} else {
-		clk_rate_exclusive_put(clk);
+		if (!tcon->quirks->clk_kept_by_ccu)
+			clk_rate_exclusive_put(clk);
 		clk_disable_unprepare(clk);
 	}
 }
@@ -240,6 +244,34 @@ void sun4i_tcon_enable_vblank(struct sun4i_tcon *tcon, bool enable)
 }
 EXPORT_SYMBOL(sun4i_tcon_enable_vblank);
 
+void sun4i_tcon_load_gamma_lut(struct sun4i_tcon *tcon,
+			       struct drm_color_lut *lut)
+{
+	int i;
+
+	for (i = 0; i < SUN4I_TCON_GAMMA_LUT_SIZE; i++) {
+		u32 r, g, b;
+
+		r = drm_color_lut_extract(lut[i].red, 8);
+		g = drm_color_lut_extract(lut[i].green, 8);
+		b = drm_color_lut_extract(lut[i].blue, 8);
+
+		regmap_write(tcon->regs, SUN4I_TCON_GAMMA_TABLE_REG + 4 * i,
+			     SUN4I_TCON_GAMMA_TABLE_R(r) |
+			     SUN4I_TCON_GAMMA_TABLE_G(g) |
+			     SUN4I_TCON_GAMMA_TABLE_B(b));
+	}
+}
+EXPORT_SYMBOL(sun4i_tcon_load_gamma_lut);
+
+void sun4i_tcon_enable_gamma(struct sun4i_tcon *tcon, bool enable)
+{
+	regmap_update_bits(tcon->regs, SUN4I_TCON_GCTL_REG,
+			   SUN4I_TCON_GCTL_GAMMA_ENABLE,
+			   enable ? SUN4I_TCON_GCTL_GAMMA_ENABLE : 0);
+}
+EXPORT_SYMBOL(sun4i_tcon_enable_gamma);
+
 /*
  * This function is a helper for TCON output muxing. The TCON output
  * muxing control register in earlier SoCs (without the TCON TOP block)
@@ -291,18 +323,6 @@ static int sun4i_tcon_get_clk_delay(const struct drm_display_mode *mode,
 	return delay;
 }
 
-static void sun4i_tcon0_mode_set_common(struct sun4i_tcon *tcon,
-					const struct drm_display_mode *mode)
-{
-	/* Configure the dot clock */
-	clk_set_rate(tcon->dclk, mode->crtc_clock * 1000);
-
-	/* Set the resolution */
-	regmap_write(tcon->regs, SUN4I_TCON0_BASIC0_REG,
-		     SUN4I_TCON0_BASIC0_X(mode->crtc_hdisplay) |
-		     SUN4I_TCON0_BASIC0_Y(mode->crtc_vdisplay));
-}
-
 static void sun4i_tcon0_mode_set_dithering(struct sun4i_tcon *tcon,
 					   const struct drm_connector *connector)
 {
@@ -365,12 +385,18 @@ static void sun4i_tcon0_mode_set_cpu(struct sun4i_tcon *tcon,
 	u8 bpp = mipi_dsi_pixel_format_to_bpp(device->format);
 	u8 lanes = device->lanes;
 	u32 block_space, start_delay;
-	u32 tcon_div;
 
 	tcon->dclk_min_div = SUN6I_DSI_TCON_DIV;
 	tcon->dclk_max_div = SUN6I_DSI_TCON_DIV;
 
-	sun4i_tcon0_mode_set_common(tcon, mode);
+	/* Configure the dot clock */
+	clk_set_rate(tcon->dclk, mode->crtc_clock * 1000
+				 * bpp / (lanes * SUN6I_DSI_TCON_DIV));
+
+        /* Set the resolution */
+	regmap_write(tcon->regs, SUN4I_TCON0_BASIC0_REG,
+		     SUN4I_TCON0_BASIC0_X(mode->crtc_hdisplay) |
+		     SUN4I_TCON0_BASIC0_Y(mode->crtc_vdisplay));
 
 	/* Set dithering if needed */
 	sun4i_tcon0_mode_set_dithering(tcon, sun4i_tcon_get_connector(encoder));
@@ -394,9 +420,7 @@ static void sun4i_tcon0_mode_set_cpu(struct sun4i_tcon *tcon,
 	 * The datasheet says that this should be set higher than 20 *
 	 * pixel cycle, but it's not clear what a pixel cycle is.
 	 */
-	regmap_read(tcon->regs, SUN4I_TCON0_DCLK_REG, &tcon_div);
-	tcon_div &= GENMASK(6, 0);
-	block_space = mode->htotal * bpp / (tcon_div * lanes);
+	block_space = mode->htotal * bpp / (SUN6I_DSI_TCON_DIV * lanes);
 	block_space -= mode->hdisplay + 40;
 
 	regmap_write(tcon->regs, SUN4I_TCON0_CPU_TRI0_REG,
@@ -438,7 +462,14 @@ static void sun4i_tcon0_mode_set_lvds(struct sun4i_tcon *tcon,
 
 	tcon->dclk_min_div = 7;
 	tcon->dclk_max_div = 7;
-	sun4i_tcon0_mode_set_common(tcon, mode);
+
+	/* Configure the dot clock */
+	clk_set_rate(tcon->dclk, mode->crtc_clock * 1000);
+
+        /* Set the resolution */
+	regmap_write(tcon->regs, SUN4I_TCON0_BASIC0_REG,
+		     SUN4I_TCON0_BASIC0_X(mode->crtc_hdisplay) |
+		     SUN4I_TCON0_BASIC0_Y(mode->crtc_vdisplay));
 
 	/* Set dithering if needed */
 	sun4i_tcon0_mode_set_dithering(tcon, sun4i_tcon_get_connector(encoder));
@@ -475,7 +506,9 @@ static void sun4i_tcon0_mode_set_lvds(struct sun4i_tcon *tcon,
 		     SUN4I_TCON0_BASIC2_V_TOTAL(mode->crtc_vtotal * 2) |
 		     SUN4I_TCON0_BASIC2_V_BACKPORCH(bp));
 
-	reg = SUN4I_TCON0_LVDS_IF_CLK_SEL_TCON0;
+	reg = SUN4I_TCON0_LVDS_IF_CLK_SEL_TCON0 |
+		SUN4I_TCON0_LVDS_IF_DATA_POL_NORMAL |
+		SUN4I_TCON0_LVDS_IF_CLK_POL_NORMAL;
 	if (sun4i_tcon_get_pixel_depth(encoder) == 24)
 		reg |= SUN4I_TCON0_LVDS_IF_BITWIDTH_24BITS;
 	else
@@ -515,7 +548,14 @@ static void sun4i_tcon0_mode_set_rgb(struct sun4i_tcon *tcon,
 
 	tcon->dclk_min_div = tcon->quirks->dclk_min_div;
 	tcon->dclk_max_div = 127;
-	sun4i_tcon0_mode_set_common(tcon, mode);
+
+	/* Configure the dot clock */
+	clk_set_rate(tcon->dclk, mode->crtc_clock * 1000);
+
+	/* Set the resolution */
+	regmap_write(tcon->regs, SUN4I_TCON0_BASIC0_REG,
+		     SUN4I_TCON0_BASIC0_X(mode->crtc_hdisplay) |
+		     SUN4I_TCON0_BASIC0_Y(mode->crtc_vdisplay));
 
 	/* Set dithering if needed */
 	sun4i_tcon0_mode_set_dithering(tcon, connector);
@@ -707,6 +747,13 @@ void sun4i_tcon_mode_set(struct sun4i_tcon *tcon,
 			 const struct drm_encoder *encoder,
 			 const struct drm_display_mode *mode)
 {
+	if (tcon->hw_preconfigured) {
+		// avoid the first modeset
+		tcon->hw_preconfigured = false;
+		hw_preconfigured = false;
+		return;
+	}
+
 	switch (encoder->encoder_type) {
 	case DRM_MODE_ENCODER_DSI:
 		/* DSI is tied to special case of CPU interface */
@@ -790,6 +837,7 @@ static int sun4i_tcon_init_clocks(struct device *dev,
 			dev_err(dev, "Couldn't get the TCON channel 0 clock\n");
 			return PTR_ERR(tcon->sclk0);
 		}
+		clk_prepare_enable(tcon->sclk0);
 	}
 
 	if (tcon->quirks->has_channel_1) {
@@ -847,6 +895,7 @@ static int sun4i_tcon_init_regmap(struct device *dev,
 		return PTR_ERR(tcon->regs);
 	}
 
+	if (!tcon->hw_preconfigured) {
 	/* Make sure the TCON is disabled and all IRQs are off */
 	regmap_write(tcon->regs, SUN4I_TCON_GCTL_REG, 0);
 	regmap_write(tcon->regs, SUN4I_TCON_GINT0_REG, 0);
@@ -855,6 +904,7 @@ static int sun4i_tcon_init_regmap(struct device *dev,
 	/* Disable IO lines and set them to tristate */
 	regmap_write(tcon->regs, SUN4I_TCON0_IO_TRI_REG, ~0);
 	regmap_write(tcon->regs, SUN4I_TCON1_IO_TRI_REG, ~0);
+	}
 
 	return 0;
 }
@@ -1126,6 +1176,9 @@ static int sun4i_tcon_bind(struct device *dev, struct device *master,
 	tcon->dev = dev;
 	tcon->id = engine->id;
 	tcon->quirks = of_device_get_match_data(dev);
+	
+	if (tcon->id == 0)
+		tcon->hw_preconfigured = hw_preconfigured;
 
 	tcon->lcd_rst = devm_reset_control_get(dev, "lcd");
 	if (IS_ERR(tcon->lcd_rst)) {
@@ -1147,12 +1200,14 @@ static int sun4i_tcon_bind(struct device *dev, struct device *master,
 		}
 	}
 
+	if (!tcon->hw_preconfigured) {
 	/* Make sure our TCON is reset */
 	ret = reset_control_reset(tcon->lcd_rst);
 	if (ret) {
 		dev_err(dev, "Couldn't deassert our reset line\n");
 		return ret;
 	}
+	}
 
 	if (tcon->quirks->supports_lvds) {
 		/*
@@ -1280,6 +1335,11 @@ static int sun4i_tcon_bind(struct device *dev, struct device *master,
 
 	list_add_tail(&tcon->list, &drv->tcon_list);
 
+	drm_mode_crtc_set_gamma_size(&tcon->crtc->crtc,
+				     SUN4I_TCON_GAMMA_LUT_SIZE);
+	drm_crtc_enable_color_mgmt(&tcon->crtc->crtc, 0, false,
+				   tcon->crtc->crtc.gamma_size);
+
 	return 0;
 
 err_free_dotclock:
@@ -1311,8 +1371,15 @@ static int sun4i_tcon_probe(struct platform_device *pdev)
 	const struct sun4i_tcon_quirks *quirks;
 	struct drm_bridge *bridge;
 	struct drm_panel *panel;
+	u32 fb_start;
 	int ret;
 
+	ret = of_property_read_u32_index(of_chosen, "p-boot,framebuffer-start", 0, &fb_start);
+	if (ret == 0) {
+		/* the display pipeline is already initialized by p-boot */
+		hw_preconfigured = true;
+	}
+
 	quirks = of_device_get_match_data(&pdev->dev);
 
 	/* panels and bridges are present only on TCONs with channel 0 */
@@ -1499,6 +1566,14 @@ static const struct sun4i_tcon_quirks sun8i_a33_quirks = {
 	.supports_lvds		= true,
 };
 
+static const struct sun4i_tcon_quirks sun50i_a64_lcd_quirks = {
+	.supports_lvds		= true,
+	.has_channel_0		= true,
+	.clk_kept_by_ccu	= true,
+	.dclk_min_div		= 1,
+	.setup_lvds_phy		= sun6i_tcon_setup_lvds_phy,
+};
+
 static const struct sun4i_tcon_quirks sun8i_a83t_lcd_quirks = {
 	.supports_lvds		= true,
 	.has_channel_0		= true,
@@ -1557,6 +1632,7 @@ const struct of_device_id sun4i_tcon_of_table[] = {
 	{ .compatible = "allwinner,sun9i-a80-tcon-tv", .data = &sun9i_a80_tcon_tv_quirks },
 	{ .compatible = "allwinner,sun20i-d1-tcon-lcd", .data = &sun20i_d1_lcd_quirks },
 	{ .compatible = "allwinner,sun20i-d1-tcon-tv", .data = &sun8i_r40_tv_quirks },
+	{ .compatible = "allwinner,sun50i-a64-tcon-lcd", .data = &sun50i_a64_lcd_quirks },
 	{ }
 };
 MODULE_DEVICE_TABLE(of, sun4i_tcon_of_table);
diff --git a/drivers/gpu/drm/sun4i/sun4i_tcon.h b/drivers/gpu/drm/sun4i/sun4i_tcon.h
index fa23aa23fe4a..7ba3df9e27df 100644
--- a/drivers/gpu/drm/sun4i/sun4i_tcon.h
+++ b/drivers/gpu/drm/sun4i/sun4i_tcon.h
@@ -19,6 +19,7 @@
 
 #define SUN4I_TCON_GCTL_REG			0x0
 #define SUN4I_TCON_GCTL_TCON_ENABLE			BIT(31)
+#define SUN4I_TCON_GCTL_GAMMA_ENABLE			BIT(30)
 #define SUN4I_TCON_GCTL_IOMAP_MASK			BIT(0)
 #define SUN4I_TCON_GCTL_IOMAP_TCON1			(1 << 0)
 #define SUN4I_TCON_GCTL_IOMAP_TCON0			(0 << 0)
@@ -229,7 +230,13 @@
 #define SUN4I_TCON1_FILL_BEG2_REG		0x31c
 #define SUN4I_TCON1_FILL_END2_REG		0x320
 #define SUN4I_TCON1_FILL_DATA2_REG		0x324
-#define SUN4I_TCON1_GAMMA_TABLE_REG		0x400
+
+#define SUN4I_TCON_GAMMA_TABLE_REG		0x400
+#define SUN4I_TCON_GAMMA_TABLE_B(x)		((x) & 0xff)
+#define SUN4I_TCON_GAMMA_TABLE_G(x)		(((x) & 0xff) << 8)
+#define SUN4I_TCON_GAMMA_TABLE_R(x)		(((x) & 0xff) << 16)
+
+#define SUN4I_TCON_GAMMA_LUT_SIZE		256
 
 #define SUN4I_TCON_MAX_CHANNELS		2
 
@@ -243,6 +250,7 @@ struct sun4i_tcon_quirks {
 	bool    needs_edp_reset; /* a80 edp reset needed for tcon0 access */
 	bool	supports_lvds;   /* Does the TCON support an LVDS output? */
 	bool	polarity_in_ch0; /* some tcon1 channels have polarity bits in tcon0 pol register */
+	bool	clk_kept_by_ccu; /* On A64 we rely on CCU to keep TCON0 clock stable */
 	u8	dclk_min_div;	/* minimum divider for TCON0 DCLK */
 
 	/* callback to handle tcon muxing options */
@@ -286,6 +294,8 @@ struct sun4i_tcon {
 
 	/* TCON list management */
 	struct list_head		list;
+
+	bool hw_preconfigured;
 };
 
 struct drm_bridge *sun4i_tcon_find_bridge(struct device_node *node);
@@ -297,6 +307,9 @@ void sun4i_tcon_mode_set(struct sun4i_tcon *tcon,
 			 const struct drm_display_mode *mode);
 void sun4i_tcon_set_status(struct sun4i_tcon *crtc,
 			   const struct drm_encoder *encoder, bool enable);
+void sun4i_tcon_load_gamma_lut(struct sun4i_tcon *tcon,
+			       struct drm_color_lut *lut);
+void sun4i_tcon_enable_gamma(struct sun4i_tcon *tcon, bool enable);
 
 extern const struct of_device_id sun4i_tcon_of_table[];
 
diff --git a/drivers/gpu/drm/sun4i/sun6i_mipi_dsi.c b/drivers/gpu/drm/sun4i/sun6i_mipi_dsi.c
index 34234a144e87..df657efd0fd3 100644
--- a/drivers/gpu/drm/sun4i/sun6i_mipi_dsi.c
+++ b/drivers/gpu/drm/sun4i/sun6i_mipi_dsi.c
@@ -732,6 +732,7 @@ static void sun6i_dsi_encoder_enable(struct drm_encoder *encoder)
 	reset_control_deassert(dsi->reset);
 	clk_prepare_enable(dsi->mod_clk);
 
+	if (!dsi->hw_preconfigured) {
 	/*
 	 * Enable the DSI block.
 	 */
@@ -758,6 +759,7 @@ static void sun6i_dsi_encoder_enable(struct drm_encoder *encoder)
 	sun6i_dsi_setup_inst_loop(dsi, mode);
 	sun6i_dsi_setup_format(dsi, mode);
 	sun6i_dsi_setup_timings(dsi, mode);
+	}
 
 	phy_init(dsi->dphy);
 
@@ -787,11 +789,15 @@ static void sun6i_dsi_encoder_enable(struct drm_encoder *encoder)
 	if (dsi->panel)
 		drm_panel_enable(dsi->panel);
 
+	if (!dsi->hw_preconfigured) {
 	sun6i_dsi_start(dsi, DSI_START_HSC);
 
 	udelay(1000);
 
 	sun6i_dsi_start(dsi, DSI_START_HSD);
+	}
+
+	dsi->hw_preconfigured = false;
 }
 
 static void sun6i_dsi_encoder_disable(struct drm_encoder *encoder)
@@ -852,7 +858,7 @@ static u32 sun6i_dsi_dcs_build_pkt_hdr(struct sun6i_dsi *dsi,
 {
 	u32 pkt = msg->type;
 
-	if (msg->type == MIPI_DSI_DCS_LONG_WRITE) {
+	if (msg->type == MIPI_DSI_DCS_LONG_WRITE || msg->type == MIPI_DSI_GENERIC_LONG_WRITE) {
 		pkt |= ((msg->tx_len) & 0xffff) << 8;
 		pkt |= (((msg->tx_len) >> 8) & 0xffff) << 16;
 	} else {
@@ -1015,6 +1021,7 @@ static ssize_t sun6i_dsi_transfer(struct mipi_dsi_host *host,
 		ret = sun6i_dsi_dcs_write_short(dsi, msg);
 		break;
 
+	case MIPI_DSI_GENERIC_LONG_WRITE:
 	case MIPI_DSI_DCS_LONG_WRITE:
 		ret = sun6i_dsi_dcs_write_long(dsi, msg);
 		break;
@@ -1105,6 +1112,7 @@ static int sun6i_dsi_probe(struct platform_device *pdev)
 	const char *bus_clk_name = NULL;
 	struct sun6i_dsi *dsi;
 	void __iomem *base;
+	u32 fb_start;
 	int ret;
 
 	dsi = devm_kzalloc(dev, sizeof(*dsi), GFP_KERNEL);
@@ -1115,6 +1123,12 @@ static int sun6i_dsi_probe(struct platform_device *pdev)
 	dsi->host.ops = &sun6i_dsi_host_ops;
 	dsi->host.dev = dev;
 
+	ret = of_property_read_u32_index(of_chosen, "p-boot,framebuffer-start", 0, &fb_start);
+	if (ret == 0) {
+		/* the display pipeline is already initialized by p-boot */
+		dsi->hw_preconfigured = true;
+	}
+
 	if (of_device_is_compatible(dev->of_node,
 				    "allwinner,sun6i-a31-mipi-dsi"))
 		bus_clk_name = "bus";
diff --git a/drivers/gpu/drm/sun4i/sun6i_mipi_dsi.h b/drivers/gpu/drm/sun4i/sun6i_mipi_dsi.h
index c863900ae3b4..7f80ff130e44 100644
--- a/drivers/gpu/drm/sun4i/sun6i_mipi_dsi.h
+++ b/drivers/gpu/drm/sun4i/sun6i_mipi_dsi.h
@@ -31,6 +31,8 @@ struct sun6i_dsi {
 	struct mipi_dsi_device	*device;
 	struct drm_device	*drm;
 	struct drm_panel	*panel;
+	
+	bool hw_preconfigured;
 };
 
 static inline struct sun6i_dsi *host_to_sun6i_dsi(struct mipi_dsi_host *host)
diff --git a/drivers/gpu/drm/sun4i/sun8i_mixer.c b/drivers/gpu/drm/sun4i/sun8i_mixer.c
index bafee05f6b24..e7b4ec81d8be 100644
--- a/drivers/gpu/drm/sun4i/sun8i_mixer.c
+++ b/drivers/gpu/drm/sun4i/sun8i_mixer.c
@@ -21,6 +21,7 @@
 #include <drm/drm_probe_helper.h>
 
 #include "sun4i_drv.h"
+#include "sun4i_tcon.h"
 #include "sun8i_mixer.h"
 #include "sun8i_ui_layer.h"
 #include "sun8i_vi_layer.h"
@@ -31,6 +32,8 @@ struct de2_fmt_info {
 	u32	de2_fmt;
 };
 
+static bool hw_preconfigured;
+
 static const struct de2_fmt_info de2_formats[] = {
 	{
 		.drm_fmt = DRM_FORMAT_ARGB8888,
@@ -249,8 +252,36 @@ int sun8i_mixer_drm_format_to_hw(u32 format, u32 *hw_format)
 
 static void sun8i_mixer_commit(struct sunxi_engine *engine)
 {
+	struct sun8i_mixer* mixer = engine_to_sun8i_mixer(engine);
+	struct sun4i_tcon* tcon;
+	u32 val, saved, ret;
+
 	DRM_DEBUG_DRIVER("Committing changes\n");
 
+	if (mixer->hw_preconfigured && engine->id == 0) {
+		/*
+		 * This is the first commit, wait for vblank on tcon0 before continuing.
+		 */
+		list_for_each_entry(tcon, &mixer->drv->tcon_list, list) {
+			if (tcon->id == 0) {
+				regmap_read(tcon->regs, SUN4I_TCON_GINT0_REG, &saved);
+				saved &= 0xffff0000;
+
+				regmap_write(tcon->regs, SUN4I_TCON_GINT0_REG, 0);
+
+				ret = regmap_read_poll_timeout(tcon->regs, SUN4I_TCON_GINT0_REG, val,
+							 val & (SUN4I_TCON_GINT0_VBLANK_INT(0) |
+								SUN4I_TCON_GINT0_VBLANK_INT(1) |
+								SUN4I_TCON_GINT0_TCON0_TRI_FINISH_INT),
+							 100, 40000);
+
+				regmap_write(tcon->regs, SUN4I_TCON_GINT0_REG, saved);
+			}
+		}
+
+		mixer->hw_preconfigured = false;
+	}
+
 	regmap_write(engine->regs, SUN8I_MIXER_GLOBAL_DBUFF,
 		     SUN8I_MIXER_GLOBAL_DBUFF_ENABLE);
 }
@@ -283,8 +314,13 @@ static struct drm_plane **sun8i_layers_init(struct drm_device *drm,
 
 	for (i = 0; i < mixer->cfg->ui_num; i++) {
 		struct sun8i_ui_layer *layer;
+		enum drm_plane_type type = DRM_PLANE_TYPE_OVERLAY;
+		if (i == 0)
+			type = DRM_PLANE_TYPE_PRIMARY;
+		else if (i == (mixer->cfg->ui_num - 1))
+			type = DRM_PLANE_TYPE_CURSOR;
 
-		layer = sun8i_ui_layer_init_one(drm, mixer, i);
+		layer = sun8i_ui_layer_init_one(drm, mixer, i, type);
 		if (IS_ERR(layer)) {
 			dev_err(drm->dev, "Couldn't initialize %s plane\n",
 				i ? "overlay" : "primary");
@@ -390,6 +426,7 @@ static int sun8i_mixer_bind(struct device *dev, struct device *master,
 	dev_set_drvdata(dev, mixer);
 	mixer->engine.ops = &sun8i_engine_ops;
 	mixer->engine.node = dev->of_node;
+	mixer->drv = drv;
 
 	if (of_find_property(dev->of_node, "iommus", NULL)) {
 		/*
@@ -414,6 +451,11 @@ static int sun8i_mixer_bind(struct device *dev, struct device *master,
 	 */
 	mixer->engine.id = sun8i_mixer_of_get_id(dev->of_node);
 
+	if (mixer->engine.id == 0) {
+		mixer->hw_preconfigured = hw_preconfigured;
+		hw_preconfigured = false;
+	}
+
 	mixer->cfg = of_device_get_match_data(dev);
 	if (!mixer->cfg)
 		return -EINVAL;
@@ -461,8 +503,11 @@ static int sun8i_mixer_bind(struct device *dev, struct device *master,
 	 * reason for the mixer to be functional. Make sure it's the
 	 * case.
 	 */
+
+	if (!mixer->hw_preconfigured) {
 	if (mixer->cfg->mod_rate)
 		clk_set_rate(mixer->mod_clk, mixer->cfg->mod_rate);
+	}
 
 	clk_prepare_enable(mixer->mod_clk);
 
@@ -470,6 +515,7 @@ static int sun8i_mixer_bind(struct device *dev, struct device *master,
 
 	base = sun8i_blender_base(mixer);
 
+	if (!mixer->hw_preconfigured) {
 	/* Reset registers and disable unused sub-engines */
 	if (mixer->cfg->is_de3) {
 		for (i = 0; i < DE3_MIXER_UNIT_SIZE; i += 4)
@@ -501,6 +547,7 @@ static int sun8i_mixer_bind(struct device *dev, struct device *master,
 	/* Enable the mixer */
 	regmap_write(mixer->engine.regs, SUN8I_MIXER_GLOBAL_CTL,
 		     SUN8I_MIXER_GLOBAL_CTL_RT_EN);
+	} /* hw_preconfigured */
 
 	/* Set background color to black */
 	regmap_write(mixer->engine.regs, SUN8I_MIXER_BLEND_BKCOLOR(base),
@@ -521,8 +568,10 @@ static int sun8i_mixer_bind(struct device *dev, struct device *master,
 			     SUN8I_MIXER_BLEND_MODE(base, i),
 			     SUN8I_MIXER_BLEND_MODE_DEF);
 
+	if (!mixer->hw_preconfigured) {
 	regmap_update_bits(mixer->engine.regs, SUN8I_MIXER_BLEND_PIPE_CTL(base),
 			   SUN8I_MIXER_BLEND_PIPE_CTL_EN_MSK, 0);
+	}
 
 	return 0;
 
@@ -552,6 +601,15 @@ static const struct component_ops sun8i_mixer_ops = {
 
 static int sun8i_mixer_probe(struct platform_device *pdev)
 {
+	int ret;
+	u32 fb_start;
+
+	ret = of_property_read_u32_index(of_chosen, "p-boot,framebuffer-start", 0, &fb_start);
+	if (ret == 0) {
+		/* the display pipeline is already initialized by p-boot */
+		hw_preconfigured = true;
+	}
+
 	return component_add(&pdev->dev, &sun8i_mixer_ops);
 }
 
diff --git a/drivers/gpu/drm/sun4i/sun8i_mixer.h b/drivers/gpu/drm/sun4i/sun8i_mixer.h
index 85c94884fb9a..9ed85dd73a2a 100644
--- a/drivers/gpu/drm/sun4i/sun8i_mixer.h
+++ b/drivers/gpu/drm/sun4i/sun8i_mixer.h
@@ -183,6 +183,9 @@ struct sun8i_mixer {
 
 	struct clk			*bus_clk;
 	struct clk			*mod_clk;
+
+	struct sun4i_drv		*drv;
+	bool				hw_preconfigured;
 };
 
 static inline struct sun8i_mixer *
diff --git a/drivers/gpu/drm/sun4i/sun8i_ui_layer.c b/drivers/gpu/drm/sun4i/sun8i_ui_layer.c
index ca75ca0835a6..0ccd9921f61e 100644
--- a/drivers/gpu/drm/sun4i/sun8i_ui_layer.c
+++ b/drivers/gpu/drm/sun4i/sun8i_ui_layer.c
@@ -25,10 +25,12 @@
 #include "sun8i_ui_scaler.h"
 
 static void sun8i_ui_layer_enable(struct sun8i_mixer *mixer, int channel,
-				  int overlay, bool enable, unsigned int zpos,
-				  unsigned int old_zpos)
+				  int overlay, bool was_enabled, bool enable,
+				  unsigned int zpos, unsigned int old_zpos)
 {
 	u32 val, bld_base, ch_base;
+	unsigned int old_pipe_ch;
+	unsigned tmp;
 
 	bld_base = sun8i_blender_base(mixer);
 	ch_base = sun8i_channel_base(mixer, channel);
@@ -36,28 +38,56 @@ static void sun8i_ui_layer_enable(struct sun8i_mixer *mixer, int channel,
 	DRM_DEBUG_DRIVER("%sabling channel %d overlay %d\n",
 			 enable ? "En" : "Dis", channel, overlay);
 
-	if (enable)
-		val = SUN8I_MIXER_CHAN_UI_LAYER_ATTR_EN;
-	else
-		val = 0;
-
+	/* We always update the layer enable bit, because it can clear
+	 * spontaneously for unknown reasons. */
+	val = enable ? SUN8I_MIXER_CHAN_UI_LAYER_ATTR_EN : 0;
 	regmap_update_bits(mixer->engine.regs,
 			   SUN8I_MIXER_CHAN_UI_LAYER_ATTR(ch_base, overlay),
 			   SUN8I_MIXER_CHAN_UI_LAYER_ATTR_EN, val);
 
-	if (!enable || zpos != old_zpos) {
-		regmap_update_bits(mixer->engine.regs,
-				   SUN8I_MIXER_BLEND_PIPE_CTL(bld_base),
-				   SUN8I_MIXER_BLEND_PIPE_CTL_EN(old_zpos),
-				   0);
-
-		regmap_update_bits(mixer->engine.regs,
+	/*
+	 * If this layer was enabled and is being disabled or if it is
+	 * enabled and just changing zpos, clear the old route, if it is
+	 * still configured to this layer in HW.
+	 */
+	if ((was_enabled && !enable) || (enable && zpos != old_zpos)) {
+		/* get channel the pipe for old_zpos is routed to from the HW */
+		regmap_read(mixer->engine.regs,
 				   SUN8I_MIXER_BLEND_ROUTE(bld_base),
-				   SUN8I_MIXER_BLEND_ROUTE_PIPE_MSK(old_zpos),
-				   0);
+				   &old_pipe_ch);
+		old_pipe_ch &= SUN8I_MIXER_BLEND_ROUTE_PIPE_MSK(old_zpos);
+		old_pipe_ch >>= SUN8I_MIXER_BLEND_ROUTE_PIPE_SHIFT(old_zpos);
+
+		/*
+		 * Check that pipe for old_zpos is still routed to our layer,
+		 * and clear/disable it if it is.
+		 */
+
+		if (old_pipe_ch == channel) {
+			DRM_DEBUG_DRIVER("chan=%d en=%d->%d zpos=%d->%d\n",
+			       channel, was_enabled, enable, old_zpos, zpos);
+
+			DRM_DEBUG_DRIVER("  disable pipe %d\n", old_zpos);
+
+			regmap_update_bits(mixer->engine.regs,
+					   SUN8I_MIXER_BLEND_ROUTE(bld_base),
+					   SUN8I_MIXER_BLEND_ROUTE_PIPE_MSK(old_zpos),
+					   0);
+
+			regmap_update_bits(mixer->engine.regs,
+					   SUN8I_MIXER_BLEND_PIPE_CTL(bld_base),
+					   SUN8I_MIXER_BLEND_PIPE_CTL_EN(old_zpos),
+					   0);
+		}
 	}
 
-	if (enable) {
+	/*
+	 * If enabling this layer or changin zpos, set route to this layer.
+	 */
+	if ((enable && !was_enabled) || (enable && zpos != old_zpos)) {
+		DRM_DEBUG_DRIVER("chan=%d en=%d->%d zpos=%d->%d\n",
+		       channel, was_enabled, enable, old_zpos, zpos);
+
 		val = SUN8I_MIXER_BLEND_PIPE_CTL_EN(zpos);
 
 		regmap_update_bits(mixer->engine.regs,
@@ -70,7 +100,13 @@ static void sun8i_ui_layer_enable(struct sun8i_mixer *mixer, int channel,
 				   SUN8I_MIXER_BLEND_ROUTE(bld_base),
 				   SUN8I_MIXER_BLEND_ROUTE_PIPE_MSK(zpos),
 				   val);
+
+		DRM_DEBUG_DRIVER("  enable pipe %d <- ch %d\n", zpos, channel);
 	}
+
+	regmap_read(mixer->engine.regs,
+			   SUN8I_MIXER_CHAN_UI_LAYER_ATTR(ch_base, overlay), &tmp);
+	DRM_DEBUG_DRIVER("  post-en-dis %08x\n", tmp);
 }
 
 static void sun8i_ui_layer_update_alpha(struct sun8i_mixer *mixer, int channel,
@@ -168,6 +204,7 @@ static int sun8i_ui_layer_update_formats(struct sun8i_mixer *mixer, int channel,
 	struct drm_plane_state *state = plane->state;
 	const struct drm_format_info *fmt;
 	u32 val, ch_base, hw_fmt;
+	unsigned tmp;
 	int ret;
 
 	ch_base = sun8i_channel_base(mixer, channel);
@@ -179,11 +216,19 @@ static int sun8i_ui_layer_update_formats(struct sun8i_mixer *mixer, int channel,
 		return -EINVAL;
 	}
 
+	regmap_read(mixer->engine.regs,
+			   SUN8I_MIXER_CHAN_UI_LAYER_ATTR(ch_base, overlay), &tmp);
+	DRM_DEBUG_DRIVER("  pre-format %08x\n", tmp);
+
 	val = hw_fmt << SUN8I_MIXER_CHAN_UI_LAYER_ATTR_FBFMT_OFFSET;
 	regmap_update_bits(mixer->engine.regs,
 			   SUN8I_MIXER_CHAN_UI_LAYER_ATTR(ch_base, overlay),
 			   SUN8I_MIXER_CHAN_UI_LAYER_ATTR_FBFMT_MASK, val);
 
+	regmap_read(mixer->engine.regs,
+			   SUN8I_MIXER_CHAN_UI_LAYER_ATTR(ch_base, overlay), &tmp);
+	DRM_DEBUG_DRIVER("  post-format %08x\n", tmp);
+
 	return 0;
 }
 
@@ -259,19 +304,6 @@ static int sun8i_ui_layer_atomic_check(struct drm_plane *plane,
 						   true, true);
 }
 
-static void sun8i_ui_layer_atomic_disable(struct drm_plane *plane,
-					  struct drm_atomic_state *state)
-{
-	struct drm_plane_state *old_state = drm_atomic_get_old_plane_state(state,
-									   plane);
-	struct sun8i_ui_layer *layer = plane_to_sun8i_ui_layer(plane);
-	unsigned int old_zpos = old_state->normalized_zpos;
-	struct sun8i_mixer *mixer = layer->mixer;
-
-	sun8i_ui_layer_enable(mixer, layer->channel, layer->overlay, false, 0,
-			      old_zpos);
-}
-
 static void sun8i_ui_layer_atomic_update(struct drm_plane *plane,
 					 struct drm_atomic_state *state)
 {
@@ -283,28 +315,37 @@ static void sun8i_ui_layer_atomic_update(struct drm_plane *plane,
 	unsigned int zpos = new_state->normalized_zpos;
 	unsigned int old_zpos = old_state->normalized_zpos;
 	struct sun8i_mixer *mixer = layer->mixer;
+	bool was_enabled = old_state->crtc && old_state->visible;
+	bool enable = new_state->crtc && new_state->visible;
 
-	if (!new_state->visible) {
-		sun8i_ui_layer_enable(mixer, layer->channel,
-				      layer->overlay, false, 0, old_zpos);
-		return;
+	if (enable) {
+		sun8i_ui_layer_update_coord(mixer, layer->channel,
+					    layer->overlay, plane, zpos);
+		sun8i_ui_layer_update_alpha(mixer, layer->channel,
+					    layer->overlay, plane);
+		sun8i_ui_layer_update_formats(mixer, layer->channel,
+					      layer->overlay, plane);
+		sun8i_ui_layer_update_buffer(mixer, layer->channel,
+					     layer->overlay, plane);
 	}
 
-	sun8i_ui_layer_update_coord(mixer, layer->channel,
-				    layer->overlay, plane, zpos);
-	sun8i_ui_layer_update_alpha(mixer, layer->channel,
-				    layer->overlay, plane);
-	sun8i_ui_layer_update_formats(mixer, layer->channel,
-				      layer->overlay, plane);
-	sun8i_ui_layer_update_buffer(mixer, layer->channel,
-				     layer->overlay, plane);
 	sun8i_ui_layer_enable(mixer, layer->channel, layer->overlay,
-			      true, zpos, old_zpos);
+			      was_enabled, enable, zpos, old_zpos);
+}
+
+void sun8i_ui_layer_plane_reset(struct drm_plane *plane)
+{
+	struct sun8i_ui_layer *layer = plane_to_sun8i_ui_layer(plane);
+
+	drm_atomic_helper_plane_reset(plane);
+	if (!plane->state)
+		return;
+
+	plane->state->zpos = layer->channel;
 }
 
 static const struct drm_plane_helper_funcs sun8i_ui_layer_helper_funcs = {
 	.atomic_check	= sun8i_ui_layer_atomic_check,
-	.atomic_disable	= sun8i_ui_layer_atomic_disable,
 	.atomic_update	= sun8i_ui_layer_atomic_update,
 };
 
@@ -313,7 +354,7 @@ static const struct drm_plane_funcs sun8i_ui_layer_funcs = {
 	.atomic_duplicate_state	= drm_atomic_helper_plane_duplicate_state,
 	.destroy		= drm_plane_cleanup,
 	.disable_plane		= drm_atomic_helper_disable_plane,
-	.reset			= drm_atomic_helper_plane_reset,
+	.reset			= sun8i_ui_layer_plane_reset,
 	.update_plane		= drm_atomic_helper_update_plane,
 };
 
@@ -347,9 +388,9 @@ static const uint64_t sun8i_layer_modifiers[] = {
 
 struct sun8i_ui_layer *sun8i_ui_layer_init_one(struct drm_device *drm,
 					       struct sun8i_mixer *mixer,
-					       int index)
+					       int index,
+					       enum drm_plane_type type)
 {
-	enum drm_plane_type type = DRM_PLANE_TYPE_OVERLAY;
 	int channel = mixer->cfg->vi_num + index;
 	struct sun8i_ui_layer *layer;
 	unsigned int plane_cnt;
@@ -359,9 +400,6 @@ struct sun8i_ui_layer *sun8i_ui_layer_init_one(struct drm_device *drm,
 	if (!layer)
 		return ERR_PTR(-ENOMEM);
 
-	if (index == 0)
-		type = DRM_PLANE_TYPE_PRIMARY;
-
 	/* possible crtcs are set later */
 	ret = drm_universal_plane_init(drm, &layer->plane, 0,
 				       &sun8i_ui_layer_funcs,
diff --git a/drivers/gpu/drm/sun4i/sun8i_ui_layer.h b/drivers/gpu/drm/sun4i/sun8i_ui_layer.h
index e3e32ee1178d..552703b9fe3c 100644
--- a/drivers/gpu/drm/sun4i/sun8i_ui_layer.h
+++ b/drivers/gpu/drm/sun4i/sun8i_ui_layer.h
@@ -63,5 +63,6 @@ plane_to_sun8i_ui_layer(struct drm_plane *plane)
 
 struct sun8i_ui_layer *sun8i_ui_layer_init_one(struct drm_device *drm,
 					       struct sun8i_mixer *mixer,
-					       int index);
+					       int index,
+					       enum drm_plane_type type);
 #endif /* _SUN8I_UI_LAYER_H_ */
diff --git a/drivers/gpu/drm/sun4i/sun8i_vi_layer.c b/drivers/gpu/drm/sun4i/sun8i_vi_layer.c
index f9c0a56d3a14..ae21976c5435 100644
--- a/drivers/gpu/drm/sun4i/sun8i_vi_layer.c
+++ b/drivers/gpu/drm/sun4i/sun8i_vi_layer.c
@@ -19,10 +19,12 @@
 #include "sun8i_vi_scaler.h"
 
 static void sun8i_vi_layer_enable(struct sun8i_mixer *mixer, int channel,
-				  int overlay, bool enable, unsigned int zpos,
-				  unsigned int old_zpos)
+				  int overlay, bool was_enabled, bool enable,
+				  unsigned int zpos, unsigned int old_zpos)
 {
 	u32 val, bld_base, ch_base;
+	unsigned int old_pipe_ch;
+	unsigned  tmp;
 
 	bld_base = sun8i_blender_base(mixer);
 	ch_base = sun8i_channel_base(mixer, channel);
@@ -30,28 +32,56 @@ static void sun8i_vi_layer_enable(struct sun8i_mixer *mixer, int channel,
 	DRM_DEBUG_DRIVER("%sabling VI channel %d overlay %d\n",
 			 enable ? "En" : "Dis", channel, overlay);
 
-	if (enable)
-		val = SUN8I_MIXER_CHAN_VI_LAYER_ATTR_EN;
-	else
-		val = 0;
-
+	/* We always update the layer enable bit, because it can clear
+	 * spontaneously for unknown reasons. */
+	val = enable ? SUN8I_MIXER_CHAN_VI_LAYER_ATTR_EN : 0;
 	regmap_update_bits(mixer->engine.regs,
 			   SUN8I_MIXER_CHAN_VI_LAYER_ATTR(ch_base, overlay),
 			   SUN8I_MIXER_CHAN_VI_LAYER_ATTR_EN, val);
 
-	if (!enable || zpos != old_zpos) {
-		regmap_update_bits(mixer->engine.regs,
-				   SUN8I_MIXER_BLEND_PIPE_CTL(bld_base),
-				   SUN8I_MIXER_BLEND_PIPE_CTL_EN(old_zpos),
-				   0);
-
-		regmap_update_bits(mixer->engine.regs,
+	/*
+	 * If this layer was enabled and is being disabled or if it is
+	 * enabled and just changing zpos, clear the old route, if it is
+	 * still configured to this layer in HW.
+	 */
+	if ((was_enabled && !enable) || (enable && zpos != old_zpos)) {
+		/* get channel the pipe for old_zpos is routed to from the HW */
+		regmap_read(mixer->engine.regs,
 				   SUN8I_MIXER_BLEND_ROUTE(bld_base),
-				   SUN8I_MIXER_BLEND_ROUTE_PIPE_MSK(old_zpos),
-				   0);
+				   &old_pipe_ch);
+		old_pipe_ch &= SUN8I_MIXER_BLEND_ROUTE_PIPE_MSK(old_zpos);
+		old_pipe_ch >>= SUN8I_MIXER_BLEND_ROUTE_PIPE_SHIFT(old_zpos);
+
+		/*
+		 * Check that pipe for old_zpos is still routed to our layer,
+		 * and clear/disable it if it is.
+		 */
+
+		if (old_pipe_ch == channel) {
+			DRM_DEBUG_DRIVER("chan=%d en=%d->%d zpos=%d->%d\n",
+			       channel, was_enabled, enable, old_zpos, zpos);
+
+			DRM_DEBUG_DRIVER("  disable pipe %d\n", old_zpos);
+
+			regmap_update_bits(mixer->engine.regs,
+					   SUN8I_MIXER_BLEND_ROUTE(bld_base),
+					   SUN8I_MIXER_BLEND_ROUTE_PIPE_MSK(old_zpos),
+					   0);
+
+			regmap_update_bits(mixer->engine.regs,
+					   SUN8I_MIXER_BLEND_PIPE_CTL(bld_base),
+					   SUN8I_MIXER_BLEND_PIPE_CTL_EN(old_zpos),
+					   0);
+		}
 	}
 
-	if (enable) {
+	/*
+	 * If enabling this layer or changin zpos, set route to this layer.
+	 */
+	if ((enable && !was_enabled) || (enable && zpos != old_zpos)) {
+		DRM_DEBUG_DRIVER("chan=%d en=%d->%d zpos=%d->%d\n",
+		       channel, was_enabled, enable, old_zpos, zpos);
+
 		val = SUN8I_MIXER_BLEND_PIPE_CTL_EN(zpos);
 
 		regmap_update_bits(mixer->engine.regs,
@@ -64,7 +94,13 @@ static void sun8i_vi_layer_enable(struct sun8i_mixer *mixer, int channel,
 				   SUN8I_MIXER_BLEND_ROUTE(bld_base),
 				   SUN8I_MIXER_BLEND_ROUTE_PIPE_MSK(zpos),
 				   val);
+
+		DRM_DEBUG_DRIVER("  enable pipe %d <- ch %d\n", zpos, channel);
 	}
+
+	regmap_read(mixer->engine.regs,
+			   SUN8I_MIXER_CHAN_VI_LAYER_ATTR(ch_base, overlay), &tmp);
+	DRM_DEBUG_DRIVER("  post-en-dis %08x\n", tmp);
 }
 
 static void sun8i_vi_layer_update_alpha(struct sun8i_mixer *mixer, int channel,
@@ -264,6 +300,7 @@ static int sun8i_vi_layer_update_formats(struct sun8i_mixer *mixer, int channel,
 	struct drm_plane_state *state = plane->state;
 	u32 val, ch_base, csc_mode, hw_fmt;
 	const struct drm_format_info *fmt;
+	unsigned  tmp;
 	int ret;
 
 	ch_base = sun8i_channel_base(mixer, channel);
@@ -275,11 +312,19 @@ static int sun8i_vi_layer_update_formats(struct sun8i_mixer *mixer, int channel,
 		return ret;
 	}
 
+	regmap_read(mixer->engine.regs,
+			   SUN8I_MIXER_CHAN_VI_LAYER_ATTR(ch_base, overlay), &tmp);
+	DRM_DEBUG_DRIVER("  pre-format %08x\n", tmp);
+
 	val = hw_fmt << SUN8I_MIXER_CHAN_VI_LAYER_ATTR_FBFMT_OFFSET;
 	regmap_update_bits(mixer->engine.regs,
 			   SUN8I_MIXER_CHAN_VI_LAYER_ATTR(ch_base, overlay),
 			   SUN8I_MIXER_CHAN_VI_LAYER_ATTR_FBFMT_MASK, val);
 
+	regmap_read(mixer->engine.regs,
+			   SUN8I_MIXER_CHAN_VI_LAYER_ATTR(ch_base, overlay), &tmp);
+	DRM_DEBUG_DRIVER("  mid1-format %08x\n", tmp);
+
 	csc_mode = sun8i_vi_layer_get_csc_mode(fmt);
 	if (csc_mode != SUN8I_CSC_MODE_OFF) {
 		sun8i_csc_set_ccsc_coefficients(mixer, channel, csc_mode,
@@ -290,6 +335,10 @@ static int sun8i_vi_layer_update_formats(struct sun8i_mixer *mixer, int channel,
 		sun8i_csc_enable_ccsc(mixer, channel, false);
 	}
 
+	regmap_read(mixer->engine.regs,
+			   SUN8I_MIXER_CHAN_VI_LAYER_ATTR(ch_base, overlay), &tmp);
+	DRM_DEBUG_DRIVER("  mid2-format %08x\n", tmp);
+
 	if (!fmt->is_yuv)
 		val = SUN8I_MIXER_CHAN_VI_LAYER_ATTR_RGB_MODE;
 	else
@@ -299,6 +348,10 @@ static int sun8i_vi_layer_update_formats(struct sun8i_mixer *mixer, int channel,
 			   SUN8I_MIXER_CHAN_VI_LAYER_ATTR(ch_base, overlay),
 			   SUN8I_MIXER_CHAN_VI_LAYER_ATTR_RGB_MODE, val);
 
+	regmap_read(mixer->engine.regs,
+			   SUN8I_MIXER_CHAN_VI_LAYER_ATTR(ch_base, overlay), &tmp);
+	DRM_DEBUG_DRIVER("  post-format %08x\n", tmp);
+
 	return 0;
 }
 
@@ -393,19 +446,6 @@ static int sun8i_vi_layer_atomic_check(struct drm_plane *plane,
 						   true, true);
 }
 
-static void sun8i_vi_layer_atomic_disable(struct drm_plane *plane,
-					  struct drm_atomic_state *state)
-{
-	struct drm_plane_state *old_state = drm_atomic_get_old_plane_state(state,
-									   plane);
-	struct sun8i_vi_layer *layer = plane_to_sun8i_vi_layer(plane);
-	unsigned int old_zpos = old_state->normalized_zpos;
-	struct sun8i_mixer *mixer = layer->mixer;
-
-	sun8i_vi_layer_enable(mixer, layer->channel, layer->overlay, false, 0,
-			      old_zpos);
-}
-
 static void sun8i_vi_layer_atomic_update(struct drm_plane *plane,
 					 struct drm_atomic_state *state)
 {
@@ -417,28 +457,37 @@ static void sun8i_vi_layer_atomic_update(struct drm_plane *plane,
 	unsigned int zpos = new_state->normalized_zpos;
 	unsigned int old_zpos = old_state->normalized_zpos;
 	struct sun8i_mixer *mixer = layer->mixer;
+	bool was_enabled = old_state->crtc && old_state->visible;
+	bool enable = new_state->crtc && new_state->visible;
 
-	if (!new_state->visible) {
-		sun8i_vi_layer_enable(mixer, layer->channel,
-				      layer->overlay, false, 0, old_zpos);
-		return;
+	if (enable) {
+		sun8i_vi_layer_update_coord(mixer, layer->channel,
+					    layer->overlay, plane, zpos);
+		sun8i_vi_layer_update_alpha(mixer, layer->channel,
+					    layer->overlay, plane);
+		sun8i_vi_layer_update_formats(mixer, layer->channel,
+					      layer->overlay, plane);
+		sun8i_vi_layer_update_buffer(mixer, layer->channel,
+					     layer->overlay, plane);
 	}
 
-	sun8i_vi_layer_update_coord(mixer, layer->channel,
-				    layer->overlay, plane, zpos);
-	sun8i_vi_layer_update_alpha(mixer, layer->channel,
-				    layer->overlay, plane);
-	sun8i_vi_layer_update_formats(mixer, layer->channel,
-				      layer->overlay, plane);
-	sun8i_vi_layer_update_buffer(mixer, layer->channel,
-				     layer->overlay, plane);
 	sun8i_vi_layer_enable(mixer, layer->channel, layer->overlay,
-			      true, zpos, old_zpos);
+			      was_enabled, enable, zpos, old_zpos);
+}
+
+void sun8i_vi_layer_plane_reset(struct drm_plane *plane)
+{
+	struct sun8i_vi_layer *layer = plane_to_sun8i_vi_layer(plane);
+
+	drm_atomic_helper_plane_reset(plane);
+	if (!plane->state)
+		return;
+
+	plane->state->zpos = layer->channel;
 }
 
 static const struct drm_plane_helper_funcs sun8i_vi_layer_helper_funcs = {
 	.atomic_check	= sun8i_vi_layer_atomic_check,
-	.atomic_disable	= sun8i_vi_layer_atomic_disable,
 	.atomic_update	= sun8i_vi_layer_atomic_update,
 };
 
@@ -447,7 +496,7 @@ static const struct drm_plane_funcs sun8i_vi_layer_funcs = {
 	.atomic_duplicate_state	= drm_atomic_helper_plane_duplicate_state,
 	.destroy		= drm_plane_cleanup,
 	.disable_plane		= drm_atomic_helper_disable_plane,
-	.reset			= drm_atomic_helper_plane_reset,
+	.reset			= sun8i_vi_layer_plane_reset,
 	.update_plane		= drm_atomic_helper_update_plane,
 };
 
diff --git a/drivers/mfd/ac100.c b/drivers/mfd/ac100.c
index 6d49d7fb5f14..b02f2c015d58 100644
--- a/drivers/mfd/ac100.c
+++ b/drivers/mfd/ac100.c
@@ -79,6 +79,9 @@ static struct mfd_cell ac100_cells[] = {
 	{
 		.name		= "ac100-codec",
 		.of_compatible	= "x-powers,ac100-codec",
+	}, {
+		.name		= "ac100-codec-analog",
+		.of_compatible	= "x-powers,ac100-codec-analog",
 	}, {
 		.name		= "ac100-rtc",
 		.of_compatible	= "x-powers,ac100-rtc",
diff --git a/include/linux/mfd/ac100.h b/include/linux/mfd/ac100.h
index 88005c3a1b2d..621bd10b79b2 100644
--- a/include/linux/mfd/ac100.h
+++ b/include/linux/mfd/ac100.h
@@ -80,6 +80,7 @@ struct ac100_dev {
 #define AC100_ERPOUT_CTRL		0x57
 #define AC100_SPKOUT_CTRL		0x58
 #define AC100_LINEOUT_CTRL		0x59
+#define AC100_ADDA_TUNE1 		0x5a
 
 /* ADC digital audio processing (high pass filter & auto gain control */
 #define AC100_ADC_DAP_L_STA		0x80
diff --git a/include/linux/mfd/sun4i-gpadc.h b/include/linux/mfd/sun4i-gpadc.h
index ea0ccf33a459..021f820f9d52 100644
--- a/include/linux/mfd/sun4i-gpadc.h
+++ b/include/linux/mfd/sun4i-gpadc.h
@@ -81,8 +81,8 @@
 #define SUN4I_GPADC_TEMP_DATA				0x20
 #define SUN4I_GPADC_DATA				0x24
 
-#define SUN4I_GPADC_IRQ_FIFO_DATA			0
-#define SUN4I_GPADC_IRQ_TEMP_DATA			1
+#define SUN4I_GPADC_IRQ_FIFO_DATA			1
+#define SUN4I_GPADC_IRQ_TEMP_DATA			2
 
 /* 10s delay before suspending the IP */
 #define SUN4I_GPADC_AUTOSUSPEND_DELAY			10000
diff --git a/include/uapi/drm/lima_drm.h b/include/uapi/drm/lima_drm.h
index 1ec58d652a5a..3e699bb78394 100644
--- a/include/uapi/drm/lima_drm.h
+++ b/include/uapi/drm/lima_drm.h
@@ -37,7 +37,12 @@ struct drm_lima_get_param {
  * due to lack of heap memory. size field of heap buffer is an up bound of
  * the backup memory which can be set to a fairly large value.
  */
-#define LIMA_BO_FLAG_HEAP  (1 << 0)
+#define LIMA_BO_FLAG_HEAP        (1 << 0)
+/*
+ * force buffer GPU virtual address to be drm_lima_gem_create.va, this is
+ * used to replay some task with fixed GPU virtual address
+ */
+#define LIMA_BO_FLAG_FORCE_VA    (1 << 1)
 
 /**
  * create a buffer for used by GPU
@@ -46,7 +51,7 @@ struct drm_lima_gem_create {
 	__u32 size;    /* in, buffer size */
 	__u32 flags;   /* in, buffer flags */
 	__u32 handle;  /* out, GEM buffer handle */
-	__u32 pad;     /* pad, must be zero */
+	__u32 va;      /* in, buffer va */
 };
 
 /**
diff --git a/sound/soc/codecs/Kconfig b/sound/soc/codecs/Kconfig
index 965ae55fa160..e9d3617bb068 100644
--- a/sound/soc/codecs/Kconfig
+++ b/sound/soc/codecs/Kconfig
@@ -919,6 +919,9 @@ config SND_SOC_HDMI_CODEC
 	select SND_PCM_IEC958
 	select HDMI
 
+config SND_SOC_EC25
+	tristate "EC25 LTE module CODEC"
+
 config SND_SOC_ES7134
 	tristate "Everest Semi ES7134 CODEC"
 
diff --git a/sound/soc/codecs/Makefile b/sound/soc/codecs/Makefile
index 71d3ce5867e4..e2d463a317e5 100644
--- a/sound/soc/codecs/Makefile
+++ b/sound/soc/codecs/Makefile
@@ -99,6 +99,7 @@ snd-soc-da7219-objs := da7219.o da7219-aad.o
 snd-soc-da732x-objs := da732x.o
 snd-soc-da9055-objs := da9055.o
 snd-soc-dmic-objs := dmic.o
+snd-soc-ec25-objs := ec25.o
 snd-soc-es7134-objs := es7134.o
 snd-soc-es7241-objs := es7241.o
 snd-soc-es8316-objs := es8316.o
@@ -460,6 +461,7 @@ obj-$(CONFIG_SND_SOC_DA7219)	+= snd-soc-da7219.o
 obj-$(CONFIG_SND_SOC_DA732X)	+= snd-soc-da732x.o
 obj-$(CONFIG_SND_SOC_DA9055)	+= snd-soc-da9055.o
 obj-$(CONFIG_SND_SOC_DMIC)	+= snd-soc-dmic.o
+obj-$(CONFIG_SND_SOC_EC25)	+= snd-soc-ec25.o
 obj-$(CONFIG_SND_SOC_ES7134)	+= snd-soc-es7134.o
 obj-$(CONFIG_SND_SOC_ES7241)	+= snd-soc-es7241.o
 obj-$(CONFIG_SND_SOC_ES8316)    += snd-soc-es8316.o
diff --git a/sound/soc/codecs/ec25.c b/sound/soc/codecs/ec25.c
new file mode 100644
index 000000000000..5dc302d26450
--- /dev/null
+++ b/sound/soc/codecs/ec25.c
@@ -0,0 +1,95 @@
+// SPDX-License-Identifier: GPL-2.0-only
+
+#include <linux/module.h>
+#include <sound/soc.h>
+
+static const struct snd_soc_dapm_widget ec25_dapm_widgets[] = {
+	SND_SOC_DAPM_OUTPUT("AOUT"),
+	SND_SOC_DAPM_INPUT("AIN"),
+};
+
+static const struct snd_soc_dapm_route ec25_dapm_routes[] = {
+	{ "AOUT", NULL, "Playback" },
+	{ "AOUT", NULL, "Wideband Playback" },
+	{ "Capture", NULL, "AIN" },
+	{ "Wideband Capture", NULL, "AIN" },
+};
+
+static const struct snd_soc_component_driver ec25_component_driver = {
+	.dapm_widgets		= ec25_dapm_widgets,
+	.num_dapm_widgets	= ARRAY_SIZE(ec25_dapm_widgets),
+	.dapm_routes		= ec25_dapm_routes,
+	.num_dapm_routes	= ARRAY_SIZE(ec25_dapm_routes),
+	.endianness		= 1,
+	.non_legacy_dai_naming	= 1,
+};
+
+static struct snd_soc_dai_driver ec25_dais[] = {
+	{
+		.name = "ec25",
+		.capture = {
+			.stream_name	= "Capture",
+			.channels_min	= 1,
+			.channels_max	= 1,
+			.rates		= SNDRV_PCM_RATE_8000,
+			.formats	= SNDRV_PCM_FMTBIT_S16_LE,
+		},
+		.playback = {
+			.stream_name	= "Playback",
+			.channels_min	= 1,
+			.channels_max	= 1,
+			.rates		= SNDRV_PCM_RATE_8000,
+			.formats	= SNDRV_PCM_FMTBIT_S16_LE,
+		},
+		.symmetric_rate = 1,
+		.symmetric_channels = 1,
+		.symmetric_sample_bits = 1,
+	},
+	{
+		.name = "ec25-wb",
+		.capture = {
+			.stream_name	= "Wideband Capture",
+			.channels_min	= 1,
+			.channels_max	= 1,
+			.rates		= SNDRV_PCM_RATE_16000,
+			.formats	= SNDRV_PCM_FMTBIT_S16_LE,
+		},
+		.playback = {
+			.stream_name	= "Wideband Playback",
+			.channels_min	= 1,
+			.channels_max	= 1,
+			.rates		= SNDRV_PCM_RATE_16000,
+			.formats	= SNDRV_PCM_FMTBIT_S16_LE,
+		},
+		.symmetric_rate = 1,
+		.symmetric_channels = 1,
+		.symmetric_sample_bits = 1,
+	},
+};
+
+static int ec25_codec_probe(struct platform_device *pdev)
+{
+	return devm_snd_soc_register_component(&pdev->dev, &ec25_component_driver,
+					       ec25_dais, ARRAY_SIZE(ec25_dais));
+}
+
+static const struct of_device_id ec25_codec_of_match[] = {
+	{ .compatible = "quectel,ec25", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, ec25_codec_of_match);
+
+static struct platform_driver ec25_codec_driver = {
+	.driver	= {
+		.name		= "ec25",
+		.of_match_table	= of_match_ptr(ec25_codec_of_match),
+	},
+	.probe	= ec25_codec_probe,
+};
+
+module_platform_driver(ec25_codec_driver);
+
+MODULE_DESCRIPTION("ASoC ec25 driver");
+MODULE_AUTHOR("Samuel Holland <samuel@sholland.org>");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:ec25");
diff --git a/sound/soc/sunxi/Kconfig b/sound/soc/sunxi/Kconfig
index 1f18f016acbb..753c38c5d554 100644
--- a/sound/soc/sunxi/Kconfig
+++ b/sound/soc/sunxi/Kconfig
@@ -16,12 +16,25 @@ config SND_SUN8I_CODEC
 	depends on MACH_SUN8I || (ARM64 && ARCH_SUNXI) || COMPILE_TEST
 	depends on COMMON_CLK
 	select REGMAP_MMIO
+	select MFD_AC100
 	help
 	  This option enables the digital part of the internal audio codec for
-	  Allwinner sun8i SoC (and particularly A33).
+	  Allwinner sun8i SoC (and particularly A33). It also supports digital
+	  part of X-Powers AC100.
 
 	  Say Y or M if you want to add sun8i digital audio codec support.
 
+config SND_AC100_CODEC
+	tristate "Allwinner (X-Powers) AC100 audio codec (analog part)"
+	depends on OF
+	depends on MACH_SUN8I || COMPILE_TEST
+	select MFD_AC100
+	help
+	  This option enables the audio codec support for Allwinner (X-Powers)
+	  AC100 chip.
+
+	  Say Y or M if you want to add AC100 audio codec support.
+
 config SND_SUN8I_CODEC_ANALOG
 	tristate "Allwinner sun8i Codec Analog Controls Support"
 	depends on MACH_SUN8I || (ARM64 && ARCH_SUNXI) || COMPILE_TEST
@@ -63,6 +76,14 @@ config SND_SUN50I_DMIC
 	  Say Y or M to add support for the DMIC audio block in the Allwinner
 	  H6 and affiliated SoCs.
 
+config SND_SUN9I_HDMI_AUDIO
+	tristate "Allwinner sun9i HDMI Audio Sound Card"
+	depends on OF
+	depends on SND_SUN4I_I2S
+	help
+	  Say Y or M to add support for the HDMI Audio sound card for Allwinner
+	  SoCs with DW-HDMI core.
+
 config SND_SUN8I_ADDA_PR_REGMAP
 	tristate
 	select REGMAP
diff --git a/sound/soc/sunxi/Makefile b/sound/soc/sunxi/Makefile
index 4483fe9c94ef..0dccdaa35bec 100644
--- a/sound/soc/sunxi/Makefile
+++ b/sound/soc/sunxi/Makefile
@@ -7,3 +7,5 @@ obj-$(CONFIG_SND_SUN50I_CODEC_ANALOG) += sun50i-codec-analog.o
 obj-$(CONFIG_SND_SUN8I_CODEC) += sun8i-codec.o
 obj-$(CONFIG_SND_SUN8I_ADDA_PR_REGMAP) += sun8i-adda-pr-regmap.o
 obj-$(CONFIG_SND_SUN50I_DMIC) += sun50i-dmic.o
+obj-$(CONFIG_SND_SUN9I_HDMI_AUDIO) += sun9i-hdmi-audio.o
+obj-$(CONFIG_SND_AC100_CODEC) += ac100-codec.o
diff --git a/sound/soc/sunxi/ac100-codec.c b/sound/soc/sunxi/ac100-codec.c
new file mode 100644
index 000000000000..7d0cdba9c3a9
--- /dev/null
+++ b/sound/soc/sunxi/ac100-codec.c
@@ -0,0 +1,1002 @@
+/*
+ * This driver supports the controls for X-Powers (Allwinner)
+ * AC100 audio codec. This codec is co-packaged with AXP81x PMICs.
+ *
+ * (C) Copyright 2020 Ondrej Jirman <megi@xff.cz>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/pm_runtime.h>
+#include <linux/regmap.h>
+#include <linux/mfd/ac100.h>
+
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/tlv.h>
+#include <sound/soc-dapm.h>
+
+#define AC100_ADC_APC_CTRL_ADCR_EN_OFF                          15
+#define AC100_ADC_APC_CTRL_ADCR_EN_MASK                         BIT(15)
+#define AC100_ADC_APC_CTRL_ADCR_EN_DISABLED                     0
+#define AC100_ADC_APC_CTRL_ADCR_EN_ENABLED                      BIT(15)
+#define AC100_ADC_APC_CTRL_ADCR_GAIN_OFF                        12
+#define AC100_ADC_APC_CTRL_ADCR_GAIN(v)                         (((v) & 0x7) << 12)
+#define AC100_ADC_APC_CTRL_ADCL_EN_OFF                          11
+#define AC100_ADC_APC_CTRL_ADCL_EN_MASK                         BIT(11)
+#define AC100_ADC_APC_CTRL_ADCL_EN_DISABLED                     0
+#define AC100_ADC_APC_CTRL_ADCL_EN_ENABLED                      BIT(11)
+#define AC100_ADC_APC_CTRL_ADCL_GAIN_OFF                        8
+#define AC100_ADC_APC_CTRL_ADCL_GAIN(v)                         (((v) & 0x7) << 8)
+#define AC100_ADC_APC_CTRL_MBIAS_EN_OFF                         7
+#define AC100_ADC_APC_CTRL_MBIAS_EN_MASK                        BIT(7)
+#define AC100_ADC_APC_CTRL_MBIAS_EN_DISABLED                    0
+#define AC100_ADC_APC_CTRL_MBIAS_EN_ENABLED                     BIT(7)
+#define AC100_ADC_APC_CTRL_MMIC_BIAS_CHOPPER_EN_OFF             6
+#define AC100_ADC_APC_CTRL_MMIC_BIAS_CHOPPER_EN_MASK            BIT(6)
+#define AC100_ADC_APC_CTRL_MMIC_BIAS_CHOPPER_EN_DISABLED        0
+#define AC100_ADC_APC_CTRL_MMIC_BIAS_CHOPPER_EN_ENABLED         BIT(6)
+#define AC100_ADC_APC_CTRL_MMIC_BIAS_CHOPPER_CKS_OFF            4
+#define AC100_ADC_APC_CTRL_MMIC_BIAS_CHOPPER_CKS_MASK           GENMASK(5, 4)
+#define AC100_ADC_APC_CTRL_MMIC_BIAS_CHOPPER_CKS_250K           (0x0 << 4)
+#define AC100_ADC_APC_CTRL_MMIC_BIAS_CHOPPER_CKS_500K           (0x1 << 4)
+#define AC100_ADC_APC_CTRL_MMIC_BIAS_CHOPPER_CKS_1M             (0x2 << 4)
+#define AC100_ADC_APC_CTRL_MMIC_BIAS_CHOPPER_CKS_2M             (0x3 << 4)
+#define AC100_ADC_APC_CTRL_HBIAS_MODE_OFF                       2
+#define AC100_ADC_APC_CTRL_HBIAS_MODE_MASK                      BIT(2)
+#define AC100_ADC_APC_CTRL_HBIAS_MODE_LOAD                      0
+#define AC100_ADC_APC_CTRL_HBIAS_MODE_HBIAS_EN                  BIT(2)
+#define AC100_ADC_APC_CTRL_HBIAS_EN_OFF                         1
+#define AC100_ADC_APC_CTRL_HBIAS_EN_MASK                        BIT(1)
+#define AC100_ADC_APC_CTRL_HBIAS_EN_DISABLED                    0
+#define AC100_ADC_APC_CTRL_HBIAS_EN_ENABLED                     BIT(1)
+#define AC100_ADC_APC_CTRL_HBIAS_ADC_EN_OFF                     0
+#define AC100_ADC_APC_CTRL_HBIAS_ADC_EN_MASK                    BIT(0)
+#define AC100_ADC_APC_CTRL_HBIAS_ADC_EN_DISABLED                0
+#define AC100_ADC_APC_CTRL_HBIAS_ADC_EN_ENABLED                 BIT(0)
+
+#define AC100_ADC_SRC_ADCR_MIC1_BOOST_OFF                       13
+#define AC100_ADC_SRC_ADCR_MIC1_BOOST_MASK                      BIT(13)
+#define AC100_ADC_SRC_ADCR_MIC1_BOOST_DISABLED                  0
+#define AC100_ADC_SRC_ADCR_MIC1_BOOST_ENABLED                   BIT(13)
+#define AC100_ADC_SRC_ADCR_MIC2_BOOST_OFF                       12
+#define AC100_ADC_SRC_ADCR_MIC2_BOOST_MASK                      BIT(12)
+#define AC100_ADC_SRC_ADCR_MIC2_BOOST_DISABLED                  0
+#define AC100_ADC_SRC_ADCR_MIC2_BOOST_ENABLED                   BIT(12)
+#define AC100_ADC_SRC_ADCR_LINEINL_LINEINR_OFF                  11
+#define AC100_ADC_SRC_ADCR_LINEINL_LINEINR_MASK                 BIT(11)
+#define AC100_ADC_SRC_ADCR_LINEINL_LINEINR_DISABLED             0
+#define AC100_ADC_SRC_ADCR_LINEINL_LINEINR_ENABLED              BIT(11)
+#define AC100_ADC_SRC_ADCR_LINEINR_OFF                          10
+#define AC100_ADC_SRC_ADCR_LINEINR_MASK                         BIT(10)
+#define AC100_ADC_SRC_ADCR_LINEINR_DISABLED                     0
+#define AC100_ADC_SRC_ADCR_LINEINR_ENABLED                      BIT(10)
+#define AC100_ADC_SRC_ADCR_AUXINR_OFF                           9
+#define AC100_ADC_SRC_ADCR_AUXINR_MASK                          BIT(9)
+#define AC100_ADC_SRC_ADCR_AUXINR_DISABLED                      0
+#define AC100_ADC_SRC_ADCR_AUXINR_ENABLED                       BIT(9)
+#define AC100_ADC_SRC_ADCR_ROUTMIX_OFF                          8
+#define AC100_ADC_SRC_ADCR_ROUTMIX_MASK                         BIT(8)
+#define AC100_ADC_SRC_ADCR_ROUTMIX_DISABLED                     0
+#define AC100_ADC_SRC_ADCR_ROUTMIX_ENABLED                      BIT(8)
+#define AC100_ADC_SRC_ADCR_LOUTMIX_OFF                          7
+#define AC100_ADC_SRC_ADCR_LOUTMIX_MASK                         BIT(7)
+#define AC100_ADC_SRC_ADCR_LOUTMIX_DISABLED                     0
+#define AC100_ADC_SRC_ADCR_LOUTMIX_ENABLED                      BIT(7)
+#define AC100_ADC_SRC_ADCL_MIC1_BOOST_OFF                       6
+#define AC100_ADC_SRC_ADCL_MIC1_BOOST_MASK                      BIT(6)
+#define AC100_ADC_SRC_ADCL_MIC1_BOOST_DISABLED                  0
+#define AC100_ADC_SRC_ADCL_MIC1_BOOST_ENABLED                   BIT(6)
+#define AC100_ADC_SRC_ADCL_MIC2_BOOST_OFF                       5
+#define AC100_ADC_SRC_ADCL_MIC2_BOOST_MASK                      BIT(5)
+#define AC100_ADC_SRC_ADCL_MIC2_BOOST_DISABLED                  0
+#define AC100_ADC_SRC_ADCL_MIC2_BOOST_ENABLED                   BIT(5)
+#define AC100_ADC_SRC_ADCL_LINEINL_LINEINR_OFF                  4
+#define AC100_ADC_SRC_ADCL_LINEINL_LINEINR_MASK                 BIT(4)
+#define AC100_ADC_SRC_ADCL_LINEINL_LINEINR_DISABLED             0
+#define AC100_ADC_SRC_ADCL_LINEINL_LINEINR_ENABLED              BIT(4)
+#define AC100_ADC_SRC_ADCL_LINEINL_OFF                          3
+#define AC100_ADC_SRC_ADCL_LINEINL_MASK                         BIT(3)
+#define AC100_ADC_SRC_ADCL_LINEINL_DISABLED                     0
+#define AC100_ADC_SRC_ADCL_LINEINL_ENABLED                      BIT(3)
+#define AC100_ADC_SRC_ADCL_AUXINL_OFF                           2
+#define AC100_ADC_SRC_ADCL_AUXINL_MASK                          BIT(2)
+#define AC100_ADC_SRC_ADCL_AUXINL_DISABLED                      0
+#define AC100_ADC_SRC_ADCL_AUXINL_ENABLED                       BIT(2)
+#define AC100_ADC_SRC_ADCL_LOUTMIX_OFF                          1
+#define AC100_ADC_SRC_ADCL_LOUTMIX_MASK                         BIT(1)
+#define AC100_ADC_SRC_ADCL_LOUTMIX_DISABLED                     0
+#define AC100_ADC_SRC_ADCL_LOUTMIX_ENABLED                      BIT(1)
+#define AC100_ADC_SRC_ADCL_ROUTMIX_OFF                          0
+#define AC100_ADC_SRC_ADCL_ROUTMIX_MASK                         BIT(0)
+#define AC100_ADC_SRC_ADCL_ROUTMIX_DISABLED                     0
+#define AC100_ADC_SRC_ADCL_ROUTMIX_ENABLED                      BIT(0)
+
+#define AC100_ADC_SRC_BST_CTRL_MIC1AMPEN_OFF                    15
+#define AC100_ADC_SRC_BST_CTRL_MIC1AMPEN_MASK                   BIT(15)
+#define AC100_ADC_SRC_BST_CTRL_MIC1AMPEN_DISABLED               0
+#define AC100_ADC_SRC_BST_CTRL_MIC1AMPEN_ENABLED                BIT(15)
+#define AC100_ADC_SRC_BST_CTRL_MIC1BOOST_OFF                    12
+#define AC100_ADC_SRC_BST_CTRL_MIC1BOOST(v)                     (((v) & 0x7) << 12)
+#define AC100_ADC_SRC_BST_CTRL_MIC2AMPEN_OFF                    11
+#define AC100_ADC_SRC_BST_CTRL_MIC2AMPEN_MASK                   BIT(11)
+#define AC100_ADC_SRC_BST_CTRL_MIC2AMPEN_DISABLED               0
+#define AC100_ADC_SRC_BST_CTRL_MIC2AMPEN_ENABLED                BIT(11)
+#define AC100_ADC_SRC_BST_CTRL_MIC2BOOST_OFF                    8
+#define AC100_ADC_SRC_BST_CTRL_MIC2BOOST(v)                     (((v) & 0x7) << 8)
+#define AC100_ADC_SRC_BST_CTRL_MIC2SLT_OFF                      7
+#define AC100_ADC_SRC_BST_CTRL_MIC2SLT_MASK                     BIT(7)
+#define AC100_ADC_SRC_BST_CTRL_MIC2SLT_MIC2                     0
+#define AC100_ADC_SRC_BST_CTRL_MIC2SLT_MIC3                     BIT(7)
+#define AC100_ADC_SRC_BST_CTRL_LINEIN_DIFF_PREG_OFF             4
+#define AC100_ADC_SRC_BST_CTRL_LINEIN_DIFF_PREG(v)              (((v) & 0x7) << 4)
+#define AC100_ADC_SRC_BST_CTRL_AXI_PREG_OFF                     0
+#define AC100_ADC_SRC_BST_CTRL_AXI_PREG(v)                      ((v) & 0x7)
+
+#define AC100_OUT_MXR_DAC_A_CTRL_DAC_AR_EN_OFF                  15
+#define AC100_OUT_MXR_DAC_A_CTRL_DAC_AR_EN_MASK                 BIT(15)
+#define AC100_OUT_MXR_DAC_A_CTRL_DAC_AR_EN_DISABLED             0
+#define AC100_OUT_MXR_DAC_A_CTRL_DAC_AR_EN_ENABLED              BIT(15)
+#define AC100_OUT_MXR_DAC_A_CTRL_DAC_AL_EN_OFF                  14
+#define AC100_OUT_MXR_DAC_A_CTRL_DAC_AL_EN_MASK                 BIT(14)
+#define AC100_OUT_MXR_DAC_A_CTRL_DAC_AL_EN_DISABLED             0
+#define AC100_OUT_MXR_DAC_A_CTRL_DAC_AL_EN_ENABLED              BIT(14)
+#define AC100_OUT_MXR_DAC_A_CTRL_AR_MIX_EN_OFF                  13
+#define AC100_OUT_MXR_DAC_A_CTRL_AR_MIX_EN_MASK                 BIT(13)
+#define AC100_OUT_MXR_DAC_A_CTRL_AR_MIX_EN_DISABLED             0
+#define AC100_OUT_MXR_DAC_A_CTRL_AR_MIX_EN_ENABLED              BIT(13)
+#define AC100_OUT_MXR_DAC_A_CTRL_AL_MIX_EN_OFF                  12
+#define AC100_OUT_MXR_DAC_A_CTRL_AL_MIX_EN_MASK                 BIT(12)
+#define AC100_OUT_MXR_DAC_A_CTRL_AL_MIX_EN_DISABLED             0
+#define AC100_OUT_MXR_DAC_A_CTRL_AL_MIX_EN_ENABLED              BIT(12)
+#define AC100_OUT_MXR_DAC_A_CTRL_HP_DCRM_EN_OFF                 8
+#define AC100_OUT_MXR_DAC_A_CTRL_HP_DCRM_EN(v)                  (((v) & 0xf) << 8)
+
+#define AC100_OUT_MXR_SRC_RMIX_MIC1_BOOST_OFF                   13
+#define AC100_OUT_MXR_SRC_RMIX_MIC1_BOOST_MASK                  BIT(13)
+#define AC100_OUT_MXR_SRC_RMIX_MIC1_BOOST_DISABLED              0
+#define AC100_OUT_MXR_SRC_RMIX_MIC1_BOOST_ENABLED               BIT(13)
+#define AC100_OUT_MXR_SRC_RMIX_MIC2_BOOST_OFF                   12
+#define AC100_OUT_MXR_SRC_RMIX_MIC2_BOOST_MASK                  BIT(12)
+#define AC100_OUT_MXR_SRC_RMIX_MIC2_BOOST_DISABLED              0
+#define AC100_OUT_MXR_SRC_RMIX_MIC2_BOOST_ENABLED               BIT(12)
+#define AC100_OUT_MXR_SRC_RMIX_LINEINL_LINEINR_OFF              11
+#define AC100_OUT_MXR_SRC_RMIX_LINEINL_LINEINR_MASK             BIT(11)
+#define AC100_OUT_MXR_SRC_RMIX_LINEINL_LINEINR_DISABLED         0
+#define AC100_OUT_MXR_SRC_RMIX_LINEINL_LINEINR_ENABLED          BIT(11)
+#define AC100_OUT_MXR_SRC_RMIX_LINEINR_OFF                      10
+#define AC100_OUT_MXR_SRC_RMIX_LINEINR_MASK                     BIT(10)
+#define AC100_OUT_MXR_SRC_RMIX_LINEINR_DISABLED                 0
+#define AC100_OUT_MXR_SRC_RMIX_LINEINR_ENABLED                  BIT(10)
+#define AC100_OUT_MXR_SRC_RMIX_AUXINR_OFF                       9
+#define AC100_OUT_MXR_SRC_RMIX_AUXINR_MASK                      BIT(9)
+#define AC100_OUT_MXR_SRC_RMIX_AUXINR_DISABLED                  0
+#define AC100_OUT_MXR_SRC_RMIX_AUXINR_ENABLED                   BIT(9)
+#define AC100_OUT_MXR_SRC_RMIX_DACR_OFF                         8
+#define AC100_OUT_MXR_SRC_RMIX_DACR_MASK                        BIT(8)
+#define AC100_OUT_MXR_SRC_RMIX_DACR_DISABLED                    0
+#define AC100_OUT_MXR_SRC_RMIX_DACR_ENABLED                     BIT(8)
+#define AC100_OUT_MXR_SRC_RMIX_DACL_OFF                         7
+#define AC100_OUT_MXR_SRC_RMIX_DACL_MASK                        BIT(7)
+#define AC100_OUT_MXR_SRC_RMIX_DACL_DISABLED                    0
+#define AC100_OUT_MXR_SRC_RMIX_DACL_ENABLED                     BIT(7)
+#define AC100_OUT_MXR_SRC_LMIX_MIC1_BOOST_OFF                   6
+#define AC100_OUT_MXR_SRC_LMIX_MIC1_BOOST_MASK                  BIT(6)
+#define AC100_OUT_MXR_SRC_LMIX_MIC1_BOOST_DISABLED              0
+#define AC100_OUT_MXR_SRC_LMIX_MIC1_BOOST_ENABLED               BIT(6)
+#define AC100_OUT_MXR_SRC_LMIX_MIC2_BOOST_OFF                   5
+#define AC100_OUT_MXR_SRC_LMIX_MIC2_BOOST_MASK                  BIT(5)
+#define AC100_OUT_MXR_SRC_LMIX_MIC2_BOOST_DISABLED              0
+#define AC100_OUT_MXR_SRC_LMIX_MIC2_BOOST_ENABLED               BIT(5)
+#define AC100_OUT_MXR_SRC_LMIX_LINEINL_LINEINR_OFF              4
+#define AC100_OUT_MXR_SRC_LMIX_LINEINL_LINEINR_MASK             BIT(4)
+#define AC100_OUT_MXR_SRC_LMIX_LINEINL_LINEINR_DISABLED         0
+#define AC100_OUT_MXR_SRC_LMIX_LINEINL_LINEINR_ENABLED          BIT(4)
+#define AC100_OUT_MXR_SRC_LMIX_LINEINL_OFF                      3
+#define AC100_OUT_MXR_SRC_LMIX_LINEINL_MASK                     BIT(3)
+#define AC100_OUT_MXR_SRC_LMIX_LINEINL_DISABLED                 0
+#define AC100_OUT_MXR_SRC_LMIX_LINEINL_ENABLED                  BIT(3)
+#define AC100_OUT_MXR_SRC_LMIX_AUXINL_OFF                       2
+#define AC100_OUT_MXR_SRC_LMIX_AUXINL_MASK                      BIT(2)
+#define AC100_OUT_MXR_SRC_LMIX_AUXINL_DISABLED                  0
+#define AC100_OUT_MXR_SRC_LMIX_AUXINL_ENABLED                   BIT(2)
+#define AC100_OUT_MXR_SRC_LMIX_DACL_OFF                         1
+#define AC100_OUT_MXR_SRC_LMIX_DACL_MASK                        BIT(1)
+#define AC100_OUT_MXR_SRC_LMIX_DACL_DISABLED                    0
+#define AC100_OUT_MXR_SRC_LMIX_DACL_ENABLED                     BIT(1)
+#define AC100_OUT_MXR_SRC_LMIX_DACR_OFF                         0
+#define AC100_OUT_MXR_SRC_LMIX_DACR_MASK                        BIT(0)
+#define AC100_OUT_MXR_SRC_LMIX_DACR_DISABLED                    0
+#define AC100_OUT_MXR_SRC_LMIX_DACR_ENABLED                     BIT(0)
+
+#define AC100_OUT_MXR_SRC_BST_HMICBIAS_VOLTAGE_OFF              14
+#define AC100_OUT_MXR_SRC_BST_HMICBIAS_VOLTAGE_MASK             GENMASK(15, 14)
+#define AC100_OUT_MXR_SRC_BST_HMICBIAS_VOLTAGE_1_88V            (0x0 << 14)
+#define AC100_OUT_MXR_SRC_BST_HMICBIAS_VOLTAGE_2_09V            (0x1 << 14)
+#define AC100_OUT_MXR_SRC_BST_HMICBIAS_VOLTAGE_2_33V            (0x2 << 14)
+#define AC100_OUT_MXR_SRC_BST_HMICBIAS_VOLTAGE_2_50V            (0x3 << 14)
+#define AC100_OUT_MXR_SRC_BST_MMICBIAS_VOLTAGE_OFF              12
+#define AC100_OUT_MXR_SRC_BST_MMICBIAS_VOLTAGE_MASK             GENMASK(13, 12)
+#define AC100_OUT_MXR_SRC_BST_MMICBIAS_VOLTAGE_1_88V            (0x0 << 12)
+#define AC100_OUT_MXR_SRC_BST_MMICBIAS_VOLTAGE_2_09V            (0x1 << 12)
+#define AC100_OUT_MXR_SRC_BST_MMICBIAS_VOLTAGE_2_33V            (0x2 << 12)
+#define AC100_OUT_MXR_SRC_BST_MMICBIAS_VOLTAGE_2_50V            (0x3 << 12)
+#define AC100_OUT_MXR_SRC_BST_AX_GAIN_OFF                       9
+#define AC100_OUT_MXR_SRC_BST_AX_GAIN(v)                        (((v) & 0x7) << 9)
+#define AC100_OUT_MXR_SRC_BST_MIC1_GAIN_OFF                     6
+#define AC100_OUT_MXR_SRC_BST_MIC1_GAIN(v)                      (((v) & 0x7) << 6)
+#define AC100_OUT_MXR_SRC_BST_MIC2_GAIN_OFF                     3
+#define AC100_OUT_MXR_SRC_BST_MIC2_GAIN(v)                      (((v) & 0x7) << 3)
+#define AC100_OUT_MXR_SRC_BST_LINEIN_GAIN_OFF                   0
+#define AC100_OUT_MXR_SRC_BST_LINEIN_GAIN(v)                    ((v) & 0x7)
+
+#define AC100_HPOUT_CTRL_RIGHT_SRC_OFF                          15
+#define AC100_HPOUT_CTRL_RIGHT_SRC_MASK                         BIT(15)
+#define AC100_HPOUT_CTRL_RIGHT_SRC_DACR                         0
+#define AC100_HPOUT_CTRL_RIGHT_SRC_RAMIX                        BIT(15)
+#define AC100_HPOUT_CTRL_LEFT_SRC_OFF                           14
+#define AC100_HPOUT_CTRL_LEFT_SRC_MASK                          BIT(14)
+#define AC100_HPOUT_CTRL_LEFT_SRC_DACL                          0
+#define AC100_HPOUT_CTRL_LEFT_SRC_LAMIX                         BIT(14)
+#define AC100_HPOUT_CTRL_RIGHT_PA_MUTE_OFF                      13
+#define AC100_HPOUT_CTRL_RIGHT_PA_MUTE_MASK                     BIT(13)
+#define AC100_HPOUT_CTRL_RIGHT_PA_MUTE_MUTE                     0
+#define AC100_HPOUT_CTRL_RIGHT_PA_MUTE_NOT_MUTE                 BIT(13)
+#define AC100_HPOUT_CTRL_LEFT_PA_MUTE_OFF                       12
+#define AC100_HPOUT_CTRL_LEFT_PA_MUTE_MASK                      BIT(12)
+#define AC100_HPOUT_CTRL_LEFT_PA_MUTE_MUTE                      0
+#define AC100_HPOUT_CTRL_LEFT_PA_MUTE_NOT_MUTE                  BIT(12)
+#define AC100_HPOUT_CTRL_PA_EN_OFF                              11
+#define AC100_HPOUT_CTRL_PA_EN_MASK                             BIT(11)
+#define AC100_HPOUT_CTRL_PA_EN_DISABLED                         0
+#define AC100_HPOUT_CTRL_PA_EN_ENABLED                          BIT(11)
+#define AC100_HPOUT_CTRL_VOLUME_OFF                             4
+#define AC100_HPOUT_CTRL_VOLUME(v)                              (((v) & 0x3f) << 4)
+#define AC100_HPOUT_CTRL_STARTUP_DELAY_OFF                      2
+#define AC100_HPOUT_CTRL_STARTUP_DELAY_MASK                     GENMASK(3, 2)
+#define AC100_HPOUT_CTRL_STARTUP_DELAY_4ms                      (0x0 << 2)
+#define AC100_HPOUT_CTRL_STARTUP_DELAY_8ms                      (0x1 << 2)
+#define AC100_HPOUT_CTRL_STARTUP_DELAY_16ms                     (0x2 << 2)
+#define AC100_HPOUT_CTRL_STARTUP_DELAY_32ms                     (0x3 << 2)
+#define AC100_HPOUT_CTRL_OUTPUT_CURRENT_OFF                     0
+#define AC100_HPOUT_CTRL_OUTPUT_CURRENT(v)                      ((v) & 0x3)
+
+#define AC100_ERPOUT_CTRL_RAMP_TIME_OFF                         11
+#define AC100_ERPOUT_CTRL_RAMP_TIME_MASK                        GENMASK(12, 11)
+#define AC100_ERPOUT_CTRL_RAMP_TIME_256ms                       (0x0 << 11)
+#define AC100_ERPOUT_CTRL_RAMP_TIME_512ms                       (0x1 << 11)
+#define AC100_ERPOUT_CTRL_RAMP_TIME_640ms                       (0x2 << 11)
+#define AC100_ERPOUT_CTRL_RAMP_TIME_768ms                       (0x3 << 11)
+#define AC100_ERPOUT_CTRL_OUT_CURRENT_OFF                       9
+#define AC100_ERPOUT_CTRL_OUT_CURRENT(v)                        (((v) & 0x3) << 9)
+#define AC100_ERPOUT_CTRL_INPUT_SOURCE_OFF                      7
+#define AC100_ERPOUT_CTRL_INPUT_SOURCE_MASK                     GENMASK(8, 7)
+#define AC100_ERPOUT_CTRL_INPUT_SOURCE_DACR                     (0x0 << 7)
+#define AC100_ERPOUT_CTRL_INPUT_SOURCE_DACL                     (0x1 << 7)
+#define AC100_ERPOUT_CTRL_INPUT_SOURCE_RAMIX                    (0x2 << 7)
+#define AC100_ERPOUT_CTRL_INPUT_SOURCE_LAMIX                    (0x3 << 7)
+#define AC100_ERPOUT_CTRL_MUTE_OFF                              6
+#define AC100_ERPOUT_CTRL_MUTE_MASK                             BIT(6)
+#define AC100_ERPOUT_CTRL_MUTE_MUTE                             0
+#define AC100_ERPOUT_CTRL_MUTE_NOT_MUTE                         BIT(6)
+#define AC100_ERPOUT_CTRL_PA_EN_OFF                             5
+#define AC100_ERPOUT_CTRL_PA_EN_MASK                            BIT(5)
+#define AC100_ERPOUT_CTRL_PA_EN_DISABLED                        0
+#define AC100_ERPOUT_CTRL_PA_EN_ENABLED                         BIT(5)
+#define AC100_ERPOUT_CTRL_VOLUME_OFF                            0
+#define AC100_ERPOUT_CTRL_VOLUME(v)                             ((v) & 0x1f)
+
+#define AC100_SPKOUT_CTRL_RIGHT_SRC_OFF                         12
+#define AC100_SPKOUT_CTRL_RIGHT_SRC_MASK                        BIT(12)
+#define AC100_SPKOUT_CTRL_RIGHT_SRC_MIXR                        0
+#define AC100_SPKOUT_CTRL_RIGHT_SRC_MIXL_MIXR                   BIT(12)
+#define AC100_SPKOUT_CTRL_RIGHT_INV_EN_OFF                      11
+#define AC100_SPKOUT_CTRL_RIGHT_INV_EN_MASK                     BIT(11)
+#define AC100_SPKOUT_CTRL_RIGHT_INV_EN_DISABLED                 0
+#define AC100_SPKOUT_CTRL_RIGHT_INV_EN_ENABLED                  BIT(11)
+#define AC100_SPKOUT_CTRL_RIGHT_EN_OFF                          9
+#define AC100_SPKOUT_CTRL_RIGHT_EN_MASK                         BIT(9)
+#define AC100_SPKOUT_CTRL_RIGHT_EN_DISABLED                     0
+#define AC100_SPKOUT_CTRL_RIGHT_EN_ENABLED                      BIT(9)
+#define AC100_SPKOUT_CTRL_LEFT_SRC_OFF                          8
+#define AC100_SPKOUT_CTRL_LEFT_SRC_MASK                         BIT(8)
+#define AC100_SPKOUT_CTRL_LEFT_SRC_MIXL                         0
+#define AC100_SPKOUT_CTRL_LEFT_SRC_MIXL_MIXR                    BIT(8)
+#define AC100_SPKOUT_CTRL_LEFT_INV_EN_OFF                       7
+#define AC100_SPKOUT_CTRL_LEFT_INV_EN_MASK                      BIT(7)
+#define AC100_SPKOUT_CTRL_LEFT_INV_EN_DISABLED                  0
+#define AC100_SPKOUT_CTRL_LEFT_INV_EN_ENABLED                   BIT(7)
+#define AC100_SPKOUT_CTRL_LEFT_EN_OFF                           5
+#define AC100_SPKOUT_CTRL_LEFT_EN_MASK                          BIT(5)
+#define AC100_SPKOUT_CTRL_LEFT_EN_DISABLED                      0
+#define AC100_SPKOUT_CTRL_LEFT_EN_ENABLED                       BIT(5)
+#define AC100_SPKOUT_CTRL_VOLUME_OFF                            0
+#define AC100_SPKOUT_CTRL_VOLUME(v)                             ((v) & 0x1f)
+
+#define AC100_LINEOUT_CTRL_LINEOUT_GAIN_OFF                     5
+#define AC100_LINEOUT_CTRL_LINEOUT_GAIN(v)                      (((v) & 0x7) << 5)
+#define AC100_LINEOUT_CTRL_LINEOUT_EN_OFF                       4
+#define AC100_LINEOUT_CTRL_LINEOUT_EN_MASK                      BIT(4)
+#define AC100_LINEOUT_CTRL_LINEOUT_EN_DISABLED                  0
+#define AC100_LINEOUT_CTRL_LINEOUT_EN_ENABLED                   BIT(4)
+#define AC100_LINEOUT_CTRL_LINEOUT_S0_OFF                       3
+#define AC100_LINEOUT_CTRL_LINEOUT_S0_MASK                      BIT(3)
+#define AC100_LINEOUT_CTRL_LINEOUT_S0_MUTE                      0
+#define AC100_LINEOUT_CTRL_LINEOUT_S0_ON                        BIT(3)
+#define AC100_LINEOUT_CTRL_LINEOUT_S1_OFF                       2
+#define AC100_LINEOUT_CTRL_LINEOUT_S1_MASK                      BIT(2)
+#define AC100_LINEOUT_CTRL_LINEOUT_S1_MUTE                      0
+#define AC100_LINEOUT_CTRL_LINEOUT_S1_ON                        BIT(2)
+#define AC100_LINEOUT_CTRL_LINEOUT_S2_OFF                       1
+#define AC100_LINEOUT_CTRL_LINEOUT_S2_MASK                      BIT(1)
+#define AC100_LINEOUT_CTRL_LINEOUT_S2_MUTE                      0
+#define AC100_LINEOUT_CTRL_LINEOUT_S2_ON                        BIT(1)
+#define AC100_LINEOUT_CTRL_LINEOUT_S3_OFF                       0
+#define AC100_LINEOUT_CTRL_LINEOUT_S3_MASK                      BIT(0)
+#define AC100_LINEOUT_CTRL_LINEOUT_S3_MUTE                      0
+#define AC100_LINEOUT_CTRL_LINEOUT_S3_ON                        BIT(0)
+
+#define AC100_ADDA_TUNE1_ZERO_CROSSOVER_EN_OFF                  8
+#define AC100_ADDA_TUNE1_ZERO_CROSSOVER_EN_MASK                 BIT(8)
+#define AC100_ADDA_TUNE1_ZERO_CROSSOVER_EN_DIS                  0
+#define AC100_ADDA_TUNE1_ZERO_CROSSOVER_EN_EN                   BIT(8)
+#define AC100_ADDA_TUNE1_ZERO_CROSSOVER_TIME_OFF                7
+#define AC100_ADDA_TUNE1_ZERO_CROSSOVER_TIME                    BIT(7)
+
+struct ac100_codec {
+	struct device *dev;
+	struct snd_soc_component component;
+};
+
+/* ADC mixer controls */
+static const struct snd_kcontrol_new ac100_codec_adc_mixer_controls[] = {
+	SOC_DAPM_DOUBLE("Mic1 Capture Switch",
+			AC100_ADC_SRC,
+			AC100_ADC_SRC_ADCL_MIC1_BOOST_OFF,
+			AC100_ADC_SRC_ADCR_MIC1_BOOST_OFF, 1, 0),
+	SOC_DAPM_DOUBLE("Mic2 Capture Switch",
+			AC100_ADC_SRC,
+			AC100_ADC_SRC_ADCL_MIC2_BOOST_OFF,
+			AC100_ADC_SRC_ADCR_MIC2_BOOST_OFF, 1, 0),
+	SOC_DAPM_DOUBLE("Line In Differential Capture Switch",
+			AC100_ADC_SRC,
+			AC100_ADC_SRC_ADCL_LINEINL_LINEINR_OFF,
+			AC100_ADC_SRC_ADCR_LINEINL_LINEINR_OFF, 1, 0),
+	SOC_DAPM_DOUBLE("Line In Capture Switch",
+			AC100_ADC_SRC,
+			AC100_ADC_SRC_ADCL_LINEINL_OFF,
+			AC100_ADC_SRC_ADCR_LINEINR_OFF, 1, 0),
+	SOC_DAPM_DOUBLE("Aux In Capture Switch",
+			AC100_ADC_SRC,
+			AC100_ADC_SRC_ADCL_AUXINL_OFF,
+			AC100_ADC_SRC_ADCR_AUXINR_OFF, 1, 0),
+	SOC_DAPM_DOUBLE("Mixer Capture Switch",
+			AC100_ADC_SRC,
+			AC100_ADC_SRC_ADCL_LOUTMIX_OFF,
+			AC100_ADC_SRC_ADCR_ROUTMIX_OFF, 1, 0),
+	SOC_DAPM_DOUBLE("Mixer Reversed Capture Switch",
+			AC100_ADC_SRC,
+			AC100_ADC_SRC_ADCL_ROUTMIX_OFF,
+			AC100_ADC_SRC_ADCR_LOUTMIX_OFF, 1, 0),
+};
+
+/* Output mixer controls */
+static const struct snd_kcontrol_new ac100_codec_mixer_controls[] = {
+	SOC_DAPM_DOUBLE("Mic1 Playback Switch",
+			AC100_OUT_MXR_SRC,
+			AC100_OUT_MXR_SRC_LMIX_MIC1_BOOST_OFF,
+			AC100_OUT_MXR_SRC_RMIX_MIC1_BOOST_OFF, 1, 0),
+	SOC_DAPM_DOUBLE("Mic2 Playback Switch",
+			AC100_OUT_MXR_SRC,
+			AC100_OUT_MXR_SRC_LMIX_MIC2_BOOST_OFF,
+			AC100_OUT_MXR_SRC_RMIX_MIC2_BOOST_OFF, 1, 0),
+	SOC_DAPM_DOUBLE("Line In Differential Playback Switch",
+			AC100_OUT_MXR_SRC,
+			AC100_OUT_MXR_SRC_LMIX_LINEINL_LINEINR_OFF,
+			AC100_OUT_MXR_SRC_RMIX_LINEINL_LINEINR_OFF, 1, 0),
+	SOC_DAPM_DOUBLE("Line In Playback Switch",
+			AC100_OUT_MXR_SRC,
+			AC100_OUT_MXR_SRC_LMIX_LINEINL_OFF,
+			AC100_OUT_MXR_SRC_RMIX_LINEINR_OFF, 1, 0),
+	SOC_DAPM_DOUBLE("Aux In Playback Switch",
+			AC100_OUT_MXR_SRC,
+			AC100_OUT_MXR_SRC_LMIX_AUXINL_OFF,
+			AC100_OUT_MXR_SRC_RMIX_AUXINR_OFF, 1, 0),
+	SOC_DAPM_DOUBLE("DAC Playback Switch",
+			AC100_OUT_MXR_SRC,
+			AC100_OUT_MXR_SRC_LMIX_DACL_OFF,
+			AC100_OUT_MXR_SRC_RMIX_DACR_OFF, 1, 0),
+	SOC_DAPM_DOUBLE("DAC Reversed Playback Switch",
+			AC100_OUT_MXR_SRC,
+			AC100_OUT_MXR_SRC_LMIX_DACR_OFF,
+			AC100_OUT_MXR_SRC_RMIX_DACL_OFF, 1, 0),
+};
+
+static const DECLARE_TLV_DB_SCALE(ac100_codec_out_mixer_pregain_scale,
+				  -450, 150, 0);
+
+static const DECLARE_TLV_DB_RANGE(ac100_codec_mic_gain_scale,
+	0, 0, TLV_DB_SCALE_ITEM(0, 0, 0),
+	1, 7, TLV_DB_SCALE_ITEM(3000, 300, 0),
+);
+
+static const DECLARE_TLV_DB_SCALE(ac100_codec_pre_gain_scale,
+				  -1200, 300, 0);
+
+static const DECLARE_TLV_DB_RANGE(ac100_codec_earpiece_vol_scale,
+	0, 1, TLV_DB_SCALE_ITEM(TLV_DB_GAIN_MUTE, 0, 1),
+	2, 31, TLV_DB_SCALE_ITEM(-4350, 150, 0),
+);
+
+static const DECLARE_TLV_DB_SCALE(ac100_codec_lineout_vol_scale, -450, 150, 0);
+
+static const DECLARE_TLV_DB_SCALE(ac100_codec_hp_vol_scale, -6300, 100, 1);
+
+static const char *ac100_codec_hp_pa_delay_texts[] = {
+	"4ms", "8ms", "16ms", "32ms"
+};
+
+static SOC_ENUM_SINGLE_DECL(ac100_codec_hp_pa_delay_enum,
+			    AC100_HPOUT_CTRL,
+			    AC100_HPOUT_CTRL_STARTUP_DELAY_OFF,
+			    ac100_codec_hp_pa_delay_texts);
+
+static const char *ac100_codec_hp_pa_cur_texts[] = {
+	"low", "mid", "higher", "highest"
+};
+
+static SOC_ENUM_SINGLE_DECL(ac100_codec_hp_pa_cur_enum,
+			    AC100_HPOUT_CTRL,
+			    AC100_HPOUT_CTRL_OUTPUT_CURRENT_OFF,
+			    ac100_codec_hp_pa_cur_texts);
+
+static SOC_ENUM_SINGLE_DECL(ac100_codec_ep_pa_cur_enum,
+			    AC100_ERPOUT_CTRL,
+			    AC100_ERPOUT_CTRL_OUT_CURRENT_OFF,
+			    ac100_codec_hp_pa_cur_texts);
+
+static const char *ac100_codec_ep_pa_ramp_time_texts[] = {
+	"256ms", "512ms", "640ms", "768ms"
+};
+
+static SOC_ENUM_SINGLE_DECL(ac100_codec_ep_pa_ramp_time_enum,
+			    AC100_ERPOUT_CTRL,
+			    AC100_ERPOUT_CTRL_RAMP_TIME_OFF,
+			    ac100_codec_ep_pa_ramp_time_texts);
+
+static const char *ac100_codec_mic_bv_texts[] = {
+	"1.88V", "2.09V", "2.33V", "2.5V"
+};
+
+static SOC_ENUM_SINGLE_DECL(ac100_codec_mic1_bv_enum,
+			    AC100_OUT_MXR_SRC_BST,
+			    AC100_OUT_MXR_SRC_BST_MMICBIAS_VOLTAGE_OFF,
+			    ac100_codec_mic_bv_texts);
+
+static SOC_ENUM_SINGLE_DECL(ac100_codec_mic2_bv_enum,
+			    AC100_OUT_MXR_SRC_BST,
+			    AC100_OUT_MXR_SRC_BST_HMICBIAS_VOLTAGE_OFF,
+			    ac100_codec_mic_bv_texts);
+
+/* volume / mute controls */
+static const struct snd_kcontrol_new ac100_codec_controls[] = {
+	/* Microphone Amp boost gain */
+	SOC_SINGLE_TLV("Mic1 Boost Volume", AC100_ADC_SRC_BST_CTRL,
+		       AC100_ADC_SRC_BST_CTRL_MIC1BOOST_OFF, 0x7, 0,
+		       ac100_codec_mic_gain_scale),
+
+	SOC_SINGLE_TLV("Mic2 Boost Volume", AC100_ADC_SRC_BST_CTRL,
+		       AC100_ADC_SRC_BST_CTRL_MIC2BOOST_OFF, 0x7, 0,
+		       ac100_codec_mic_gain_scale),
+
+	SOC_SINGLE_TLV("Line In Pre-Gain Volume", AC100_ADC_SRC_BST_CTRL,
+		       AC100_ADC_SRC_BST_CTRL_LINEIN_DIFF_PREG_OFF, 0x7, 0,
+		       ac100_codec_pre_gain_scale),
+
+	SOC_SINGLE_TLV("Aux In Pre-Gain Volume", AC100_ADC_SRC_BST_CTRL,
+		       AC100_ADC_SRC_BST_CTRL_AXI_PREG_OFF, 0x7, 0,
+		       ac100_codec_pre_gain_scale),
+
+	/* ADC */
+	SOC_DOUBLE_TLV("ADC Gain Capture Volume", AC100_ADC_APC_CTRL,
+		       AC100_ADC_APC_CTRL_ADCL_GAIN_OFF,
+		       AC100_ADC_APC_CTRL_ADCR_GAIN_OFF, 0x7, 0,
+		       ac100_codec_out_mixer_pregain_scale),
+
+	/* Mixer pre-gain */
+	SOC_SINGLE_TLV("Mic1 Playback Volume", AC100_OUT_MXR_SRC_BST,
+		       AC100_OUT_MXR_SRC_BST_MIC1_GAIN_OFF,
+		       0x7, 0, ac100_codec_out_mixer_pregain_scale),
+
+	SOC_SINGLE_TLV("Mic2 Playback Volume", AC100_OUT_MXR_SRC_BST,
+		       AC100_OUT_MXR_SRC_BST_MIC2_GAIN_OFF,
+		       0x7, 0, ac100_codec_out_mixer_pregain_scale),
+
+	SOC_SINGLE_TLV("Line In Playback Volume", AC100_OUT_MXR_SRC_BST,
+		       AC100_OUT_MXR_SRC_BST_LINEIN_GAIN_OFF,
+		       0x7, 0, ac100_codec_out_mixer_pregain_scale),
+
+	SOC_SINGLE_TLV("Aux In Playback Volume", AC100_OUT_MXR_SRC_BST,
+		       AC100_OUT_MXR_SRC_BST_AX_GAIN_OFF,
+		       0x7, 0, ac100_codec_out_mixer_pregain_scale),
+
+	SOC_SINGLE_TLV("Headphone Playback Volume",
+		       AC100_HPOUT_CTRL,
+		       AC100_HPOUT_CTRL_VOLUME_OFF, 0x3f, 0,
+		       ac100_codec_hp_vol_scale),
+
+	SOC_SINGLE_TLV("Earpiece Playback Volume",
+		       AC100_ERPOUT_CTRL,
+		       AC100_ERPOUT_CTRL_VOLUME_OFF, 0x1f, 0,
+		       ac100_codec_earpiece_vol_scale),
+
+	SOC_SINGLE_TLV("Speaker Playback Volume",
+		       AC100_SPKOUT_CTRL,
+		       AC100_SPKOUT_CTRL_VOLUME_OFF, 0x1f, 0,
+		       ac100_codec_earpiece_vol_scale),
+
+	SOC_SINGLE_TLV("Line Out Playback Volume",
+		       AC100_LINEOUT_CTRL,
+		       AC100_LINEOUT_CTRL_LINEOUT_GAIN_OFF, 0x7, 0,
+		       ac100_codec_lineout_vol_scale),
+
+	SOC_ENUM("Headphone Amplifier Startup Delay",
+		 ac100_codec_hp_pa_delay_enum),
+	SOC_ENUM("Headphone Amplifier Current", ac100_codec_hp_pa_cur_enum),
+
+	SOC_ENUM("Earpiece Amplifier Ramp Time",
+		 ac100_codec_ep_pa_ramp_time_enum),
+	SOC_ENUM("Earpiece Amplifier Current", ac100_codec_ep_pa_cur_enum),
+
+	SOC_ENUM("Mic1 Bias Voltage", ac100_codec_mic1_bv_enum),
+	SOC_ENUM("Mic2 Bias Voltage", ac100_codec_mic2_bv_enum),
+};
+
+/* Headphone */
+
+static const char * const ac100_codec_hp_src_enum_text[] = {
+	"DAC", "Mixer",
+};
+
+static SOC_ENUM_DOUBLE_DECL(ac100_codec_hp_src_enum,
+			    AC100_HPOUT_CTRL,
+			    AC100_HPOUT_CTRL_LEFT_SRC_OFF,
+			    AC100_HPOUT_CTRL_RIGHT_SRC_OFF,
+			    ac100_codec_hp_src_enum_text);
+
+static const struct snd_kcontrol_new ac100_codec_hp_src[] = {
+	SOC_DAPM_ENUM("Headphone Source Playback Route",
+		      ac100_codec_hp_src_enum),
+};
+
+static const struct snd_kcontrol_new ac100_codec_hp_switch =
+	SOC_DAPM_DOUBLE("Headphone Playback Switch",
+			AC100_HPOUT_CTRL,
+			AC100_HPOUT_CTRL_LEFT_PA_MUTE_OFF,
+			AC100_HPOUT_CTRL_RIGHT_PA_MUTE_OFF, 1, 0);
+
+/* Earpiece */
+
+static const struct snd_kcontrol_new ac100_codec_earpiece_switch =
+	SOC_DAPM_SINGLE("Playback Switch",
+			AC100_ERPOUT_CTRL,
+			AC100_ERPOUT_CTRL_MUTE_OFF, 1, 0);
+
+static const char * const ac100_codec_earpiece_src_enum_text[] = {
+	"DACR", "DACL", "Right Mixer", "Left Mixer",
+};
+
+static SOC_ENUM_SINGLE_DECL(ac100_codec_earpiece_src_enum,
+			    AC100_ERPOUT_CTRL,
+			    AC100_ERPOUT_CTRL_INPUT_SOURCE_OFF,
+			    ac100_codec_earpiece_src_enum_text);
+
+static const struct snd_kcontrol_new ac100_codec_earpiece_src[] = {
+	SOC_DAPM_ENUM("Earpiece Source Playback Route",
+		      ac100_codec_earpiece_src_enum),
+};
+
+/* Speaker */
+
+static const char * const ac100_codec_spk_src_enum_text[] = {
+	"Stereo", "Mono",
+};
+
+static SOC_ENUM_DOUBLE_DECL(ac100_codec_spk_src_enum,
+			    AC100_SPKOUT_CTRL,
+			    AC100_SPKOUT_CTRL_LEFT_SRC_OFF,
+			    AC100_SPKOUT_CTRL_RIGHT_SRC_OFF,
+			    ac100_codec_spk_src_enum_text);
+
+static const struct snd_kcontrol_new ac100_codec_spk_src[] = {
+	SOC_DAPM_ENUM("Speaker Source Playback Route",
+		      ac100_codec_spk_src_enum),
+};
+
+static const struct snd_kcontrol_new ac100_codec_spk_switch =
+	SOC_DAPM_DOUBLE("Speaker Playback Switch",
+			AC100_SPKOUT_CTRL,
+			AC100_SPKOUT_CTRL_LEFT_EN_OFF,
+			AC100_SPKOUT_CTRL_RIGHT_EN_OFF, 1, 0);
+
+static const struct snd_kcontrol_new ac100_codec_spk_inv_switch =
+	SOC_DAPM_DOUBLE("Speaker Invert Switch",
+			AC100_SPKOUT_CTRL,
+			AC100_SPKOUT_CTRL_LEFT_INV_EN_OFF,
+			AC100_SPKOUT_CTRL_RIGHT_INV_EN_OFF, 1, 0);
+
+/* Line Out */
+
+static const struct snd_kcontrol_new ac100_codec_lineout_mixer_controls[] = {
+	SOC_DAPM_SINGLE("Mic1 Playback Switch",
+			AC100_LINEOUT_CTRL,
+			AC100_LINEOUT_CTRL_LINEOUT_S0_OFF, 1, 0),
+	SOC_DAPM_SINGLE("Mic2 Playback Switch",
+			AC100_LINEOUT_CTRL,
+			AC100_LINEOUT_CTRL_LINEOUT_S1_OFF, 1, 0),
+	SOC_DAPM_SINGLE("Right Mixer Playback Switch",
+			AC100_LINEOUT_CTRL,
+			AC100_LINEOUT_CTRL_LINEOUT_S2_OFF, 1, 0),
+	SOC_DAPM_SINGLE("Left Mixer Playback Switch",
+			AC100_LINEOUT_CTRL,
+			AC100_LINEOUT_CTRL_LINEOUT_S3_OFF, 1, 0),
+};
+
+static const struct snd_kcontrol_new ac100_codec_lineout_switch =
+	SOC_DAPM_SINGLE("Playback Switch",
+			AC100_LINEOUT_CTRL,
+			AC100_LINEOUT_CTRL_LINEOUT_EN_OFF, 1, 0);
+
+/* Mic2 Boost Source */
+
+static const char * const ac100_codec_mic2boost_src_enum_text[] = {
+	"Mic2", "Mic3",
+};
+
+static SOC_ENUM_SINGLE_DECL(ac100_codec_mic2boost_src_enum,
+			    AC100_ADC_SRC_BST_CTRL,
+			    AC100_ADC_SRC_BST_CTRL_MIC2SLT_OFF,
+			    ac100_codec_mic2boost_src_enum_text);
+
+static const struct snd_kcontrol_new ac100_codec_mic2boost_src[] = {
+	SOC_DAPM_ENUM("Mic2 Source Capture Route",
+		      ac100_codec_mic2boost_src_enum),
+};
+
+/* This is done to remove the headphone buffer DC offset. */
+static int ac100_codec_hp_power(struct snd_soc_dapm_widget *w,
+				struct snd_kcontrol *k, int event)
+{
+	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+	unsigned int val = SND_SOC_DAPM_EVENT_ON(event) ? 0xf : 0;
+
+	// zero cross detection
+	if (SND_SOC_DAPM_EVENT_OFF(event)) {
+		snd_soc_component_update_bits(component,
+					      AC100_ADDA_TUNE1,
+					      AC100_ADDA_TUNE1_ZERO_CROSSOVER_EN_MASK,
+					      AC100_ADDA_TUNE1_ZERO_CROSSOVER_EN_EN);
+	} else {
+		snd_soc_component_update_bits(component,
+					      AC100_ADDA_TUNE1,
+					      AC100_ADDA_TUNE1_ZERO_CROSSOVER_EN_MASK,
+					      AC100_ADDA_TUNE1_ZERO_CROSSOVER_EN_DIS);
+	}
+
+	snd_soc_component_update_bits(component, AC100_OUT_MXR_DAC_A_CTRL,
+				      AC100_OUT_MXR_DAC_A_CTRL_HP_DCRM_EN(0xf),
+				      AC100_OUT_MXR_DAC_A_CTRL_HP_DCRM_EN(val));
+	return 0;
+}
+
+static const struct snd_soc_dapm_widget ac100_codec_widgets[] = {
+	/* DAC */
+	SND_SOC_DAPM_DAC("Left DAC", NULL, AC100_OUT_MXR_DAC_A_CTRL,
+			 AC100_OUT_MXR_DAC_A_CTRL_DAC_AL_EN_OFF, 0),
+	SND_SOC_DAPM_DAC("Right DAC", NULL, AC100_OUT_MXR_DAC_A_CTRL,
+			 AC100_OUT_MXR_DAC_A_CTRL_DAC_AR_EN_OFF, 0),
+
+	/* ADC */
+	SND_SOC_DAPM_ADC("Left ADC", NULL, AC100_ADC_APC_CTRL,
+			 AC100_ADC_APC_CTRL_ADCL_EN_OFF, 0),
+	SND_SOC_DAPM_ADC("Right ADC", NULL, AC100_ADC_APC_CTRL,
+			 AC100_ADC_APC_CTRL_ADCR_EN_OFF, 0),
+
+	/*
+	 * Due to this component and the codec belonging to separate DAPM
+	 * contexts, we need to manually link the above widgets to their
+	 * stream widgets at the card level.
+	 */
+
+        /* Headphones */
+
+	SND_SOC_DAPM_REGULATOR_SUPPLY("cpvdd", 0, 0),
+	SND_SOC_DAPM_MUX("Left Headphone Source",
+			 SND_SOC_NOPM, 0, 0, ac100_codec_hp_src),
+	SND_SOC_DAPM_MUX("Right Headphone Source",
+			 SND_SOC_NOPM, 0, 0, ac100_codec_hp_src),
+	SND_SOC_DAPM_SWITCH("Left Headphone Switch",
+			    SND_SOC_NOPM, 0, 0, &ac100_codec_hp_switch),
+	SND_SOC_DAPM_SWITCH("Right Headphone Switch",
+			    SND_SOC_NOPM, 0, 0, &ac100_codec_hp_switch),
+	SND_SOC_DAPM_OUT_DRV("Left Headphone Amp",
+			     SND_SOC_NOPM, 0, 0, NULL, 0),
+	SND_SOC_DAPM_OUT_DRV("Right Headphone Amp",
+			     SND_SOC_NOPM, 0, 0, NULL, 0),
+	SND_SOC_DAPM_SUPPLY("Headphone Amp", AC100_HPOUT_CTRL,
+			    AC100_HPOUT_CTRL_PA_EN_OFF, 0,
+			    ac100_codec_hp_power,
+			    SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_PRE_PMD),
+	SND_SOC_DAPM_OUTPUT("HP"),
+
+        /* Earpiece */
+
+	SND_SOC_DAPM_MUX("Earpiece Source Playback Route",
+			 SND_SOC_NOPM, 0, 0, ac100_codec_earpiece_src),
+	SND_SOC_DAPM_SWITCH("Earpiece",
+			    SND_SOC_NOPM, 0, 0, &ac100_codec_earpiece_switch),
+	SND_SOC_DAPM_OUT_DRV("Earpiece Amp", AC100_ERPOUT_CTRL,
+			     AC100_ERPOUT_CTRL_PA_EN_OFF, 0, NULL, 0),
+	SND_SOC_DAPM_OUTPUT("EARPIECE"),
+
+	/* Speaker */
+
+	SND_SOC_DAPM_MUX("Left Speaker Source",
+			 SND_SOC_NOPM, 0, 0, ac100_codec_spk_src),
+	SND_SOC_DAPM_MUX("Right Speaker Source",
+			 SND_SOC_NOPM, 0, 0, ac100_codec_spk_src),
+	SND_SOC_DAPM_SWITCH("Left Speaker Switch",
+			    SND_SOC_NOPM, 0, 0, &ac100_codec_spk_switch),
+	SND_SOC_DAPM_SWITCH("Right Speaker Switch",
+			    SND_SOC_NOPM, 0, 0, &ac100_codec_spk_switch),
+	SND_SOC_DAPM_SWITCH("Left Speaker Invert Switch",
+			    SND_SOC_NOPM, 0, 0, &ac100_codec_spk_inv_switch),
+	SND_SOC_DAPM_SWITCH("Right Speaker Invert Switch",
+			    SND_SOC_NOPM, 0, 0, &ac100_codec_spk_inv_switch),
+	SND_SOC_DAPM_OUTPUT("SPKOUTL"),
+	SND_SOC_DAPM_OUTPUT("SPKOUTR"),
+
+	/* Line Out */
+
+	SND_SOC_DAPM_MIXER("Line Out Mixer", SND_SOC_NOPM, 0, 0,
+			   ac100_codec_lineout_mixer_controls,
+			   ARRAY_SIZE(ac100_codec_lineout_mixer_controls)),
+	SND_SOC_DAPM_SWITCH("Line Out",
+			    SND_SOC_NOPM, 0, 0, &ac100_codec_lineout_switch),
+	SND_SOC_DAPM_OUTPUT("LINEOUT"),
+
+	/* Microphone 1 */
+
+	SND_SOC_DAPM_INPUT("MIC1"),
+	SND_SOC_DAPM_SUPPLY("MBIAS", AC100_ADC_APC_CTRL,
+			    AC100_ADC_APC_CTRL_MBIAS_EN_OFF,
+			    0, NULL, 0),
+	SND_SOC_DAPM_PGA("Mic1 Amplifier", AC100_ADC_SRC_BST_CTRL,
+			 AC100_ADC_SRC_BST_CTRL_MIC1AMPEN_OFF, 0, NULL, 0),
+
+        /* Microphone 2 and 3 */
+
+	SND_SOC_DAPM_INPUT("MIC2"),
+	SND_SOC_DAPM_INPUT("MIC3"),
+	SND_SOC_DAPM_MUX("Mic2 Amplifier Source",
+			 SND_SOC_NOPM, 0, 0, ac100_codec_mic2boost_src),
+	SND_SOC_DAPM_SUPPLY("HBIAS", AC100_ADC_APC_CTRL,
+			    AC100_ADC_APC_CTRL_HBIAS_EN_OFF,
+			    0, NULL, 0),
+	SND_SOC_DAPM_PGA("Mic2 Amplifier", AC100_ADC_SRC_BST_CTRL,
+			 AC100_ADC_SRC_BST_CTRL_MIC2AMPEN_OFF, 0, NULL, 0),
+
+	/* Line input */
+
+	SND_SOC_DAPM_INPUT("LINEIN"),
+
+	/* Aux input */
+
+	SND_SOC_DAPM_INPUT("AUXIN"),
+
+	/* Output mixers */
+	SND_SOC_DAPM_MIXER("Left Mixer", AC100_OUT_MXR_DAC_A_CTRL,
+			   AC100_OUT_MXR_DAC_A_CTRL_AL_MIX_EN_OFF, 0,
+			   ac100_codec_mixer_controls,
+			   ARRAY_SIZE(ac100_codec_mixer_controls)),
+	SND_SOC_DAPM_MIXER("Right Mixer", AC100_OUT_MXR_DAC_A_CTRL,
+			   AC100_OUT_MXR_DAC_A_CTRL_AR_MIX_EN_OFF, 0,
+			   ac100_codec_mixer_controls,
+			   ARRAY_SIZE(ac100_codec_mixer_controls)),
+
+	/* Input mixers */
+	SND_SOC_DAPM_MIXER("Left ADC Mixer", SND_SOC_NOPM, 0, 0,
+			   ac100_codec_adc_mixer_controls,
+			   ARRAY_SIZE(ac100_codec_adc_mixer_controls)),
+	SND_SOC_DAPM_MIXER("Right ADC Mixer", SND_SOC_NOPM, 0, 0,
+			   ac100_codec_adc_mixer_controls,
+			   ARRAY_SIZE(ac100_codec_adc_mixer_controls)),
+};
+
+static const struct snd_soc_dapm_route ac100_codec_routes[] = {
+	/* Microphone Routes */
+	{ "Mic1 Amplifier", NULL, "MIC1"},
+	{ "Mic2 Amplifier", NULL, "Mic2 Amplifier Source"},
+	{ "Mic2 Amplifier Source", "Mic2", "MIC2" },
+	{ "Mic2 Amplifier Source", "Mic3", "MIC3" },
+
+	/* Mixer Routes */
+	{ "Left Mixer", "Mic1 Playback Switch", "Mic1 Amplifier" },
+	{ "Left Mixer", "Mic2 Playback Switch", "Mic2 Amplifier" },
+	{ "Left Mixer", "Line In Differential Playback Switch", "LINEIN" },
+	{ "Left Mixer", "Line In Playback Switch", "LINEIN" },
+	{ "Left Mixer", "Aux In Playback Switch", "AUXIN" },
+	{ "Left Mixer", "DAC Playback Switch", "Left DAC" },
+	{ "Left Mixer", "DAC Reversed Playback Switch", "Right DAC" },
+
+	{ "Right Mixer", "Mic1 Playback Switch", "Mic1 Amplifier" },
+	{ "Right Mixer", "Mic2 Playback Switch", "Mic2 Amplifier" },
+	{ "Right Mixer", "Line In Differential Playback Switch", "LINEIN" },
+	{ "Right Mixer", "Line In Playback Switch", "LINEIN" },
+	{ "Right Mixer", "Aux In Playback Switch", "AUXIN" },
+	{ "Right Mixer", "DAC Playback Switch", "Right DAC" },
+	{ "Right Mixer", "DAC Reversed Playback Switch", "Left DAC" },
+
+	/* ADC Mixer Routes */
+	{ "Left ADC Mixer", "Mic1 Capture Switch", "Mic1 Amplifier" },
+	{ "Left ADC Mixer", "Mic2 Capture Switch", "Mic2 Amplifier" },
+	{ "Left ADC Mixer", "Line In Differential Capture Switch", "LINEIN" },
+	{ "Left ADC Mixer", "Line In Capture Switch", "LINEIN" },
+	{ "Left ADC Mixer", "Aux In Capture Switch", "AUXIN" },
+	{ "Left ADC Mixer", "Mixer Capture Switch", "Left Mixer" },
+	{ "Left ADC Mixer", "Mixer Reversed Capture Switch", "Right Mixer" },
+
+	{ "Right ADC Mixer", "Mic1 Capture Switch", "Mic1 Amplifier" },
+	{ "Right ADC Mixer", "Mic2 Capture Switch", "Mic2 Amplifier" },
+	{ "Right ADC Mixer", "Line In Differential Capture Switch", "LINEIN" },
+	{ "Right ADC Mixer", "Line In Capture Switch", "LINEIN" },
+	{ "Right ADC Mixer", "Aux In Capture Switch", "AUXIN" },
+	{ "Right ADC Mixer", "Mixer Capture Switch", "Right Mixer" },
+	{ "Right ADC Mixer", "Mixer Reversed Capture Switch", "Left Mixer" },
+
+	/* ADC Routes */
+	{ "Left ADC", NULL, "Left ADC Mixer" },
+	{ "Right ADC", NULL, "Right ADC Mixer" },
+
+	/* Headphone Routes */
+	{ "Left Headphone Source", "DAC", "Left DAC" },
+	{ "Left Headphone Source", "Mixer", "Left Mixer" },
+	{ "Left Headphone Switch", "Headphone Playback Switch", "Left Headphone Source" },
+	{ "Left Headphone Amp", NULL, "Left Headphone Switch" },
+	{ "Left Headphone Amp", NULL, "Headphone Amp" },
+	{ "HP", NULL, "Left Headphone Amp" },
+
+	{ "Right Headphone Source", "DAC", "Right DAC" },
+	{ "Right Headphone Source", "Mixer", "Right Mixer" },
+	{ "Right Headphone Switch", "Headphone Playback Switch", "Right Headphone Source" },
+	{ "Right Headphone Amp", NULL, "Right Headphone Switch" },
+	{ "Right Headphone Amp", NULL, "Headphone Amp" },
+	{ "HP", NULL, "Right Headphone Amp" },
+
+	{ "Headphone Amp", NULL, "cpvdd" },
+
+	/* Speaker Routes */
+	{ "Left Speaker Source", "Stereo", "Left Mixer" },
+	{ "Left Speaker Source", "Mono", "Right Mixer" },
+	{ "Left Speaker Source", "Mono", "Left Mixer" },
+	{ "Left Speaker Switch", "Speaker Playback Switch", "Left Speaker Source" },
+	{ "SPKOUTL", NULL, "Left Speaker Switch" },
+
+	{ "Right Speaker Source", "Stereo", "Right Mixer" },
+	{ "Right Speaker Source", "Mono", "Right Mixer" },
+	{ "Right Speaker Source", "Mono", "Left Mixer" },
+	{ "Right Speaker Switch", "Speaker Playback Switch", "Right Speaker Source" },
+	{ "SPKOUTR", NULL, "Right Speaker Switch" },
+
+	/* Earpiece Routes */
+	{ "Earpiece Source Playback Route", "DACR", "Right DAC" },
+	{ "Earpiece Source Playback Route", "DACL", "Left DAC" },
+	{ "Earpiece Source Playback Route", "Right Mixer", "Right Mixer" },
+	{ "Earpiece Source Playback Route", "Left Mixer", "Left Mixer" },
+	{ "Earpiece", "Playback Switch", "Earpiece Source Playback Route" },
+	{ "Earpiece Amp", NULL, "Earpiece" },
+	{ "EARPIECE", NULL, "Earpiece Amp" },
+
+	/* Line-out Routes */
+	{ "Line Out", "Playback Switch", "Line Out Mixer" },
+	{ "Line Out Mixer", "Mic1 Playback Switch", "Mic1 Amplifier" },
+	{ "Line Out Mixer", "Mic2 Playback Switch", "Mic2 Amplifier" },
+	{ "Line Out Mixer", "Right Mixer Playback Switch", "Right Mixer" },
+	{ "Line Out Mixer", "Left Mixer Playback Switch", "Left Mixer" },
+	{ "LINEOUT", NULL, "Line Out" },
+};
+
+static int ac100_codec_set_bias_level(struct snd_soc_component *component,
+				      enum snd_soc_bias_level level)
+{
+	if (level == SND_SOC_BIAS_OFF) {
+		pr_err("XX: idle bias off\n");
+	}
+
+	return 0;
+}
+
+static const struct snd_soc_component_driver ac100_codec_analog_cmpnt_drv = {
+	.controls		= ac100_codec_controls,
+	.num_controls		= ARRAY_SIZE(ac100_codec_controls),
+	.dapm_widgets		= ac100_codec_widgets,
+	.num_dapm_widgets	= ARRAY_SIZE(ac100_codec_widgets),
+	.dapm_routes		= ac100_codec_routes,
+	.num_dapm_routes	= ARRAY_SIZE(ac100_codec_routes),
+	.set_bias_level		= ac100_codec_set_bias_level,
+};
+
+static int ac100_codec_probe(struct platform_device *pdev)
+{
+	struct ac100_dev *ac100 = dev_get_drvdata(pdev->dev.parent);
+	struct ac100_codec *codec;
+	int ret = 0;
+
+	codec = devm_kzalloc(&pdev->dev, sizeof(*codec), GFP_KERNEL);
+	if (!codec)
+		return -ENOMEM;
+
+	codec->dev = &pdev->dev;
+	platform_set_drvdata(pdev, codec);
+
+	snd_soc_component_init_regmap(&codec->component, ac100->regmap);
+
+	ret = snd_soc_component_initialize(&codec->component,
+					   &ac100_codec_analog_cmpnt_drv,
+					   &pdev->dev);
+	if (ret < 0)
+		return ret;
+
+	ret = snd_soc_add_component(&codec->component, NULL, 0);
+	if (ret) {
+		dev_err(&pdev->dev,
+			"Failed to register codec component (%d)\n", ret);
+		return ret;
+	}
+
+	return ret;
+}
+
+static int ac100_codec_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_component(&pdev->dev);
+
+	/*
+	 * We do not call snd_soc_component_exit_regmap, because regmap
+	 * is still owned by the mfd device.
+	 */
+	return 0;
+}
+
+static const struct of_device_id ac100_codec_of_match[] = {
+	{ .compatible = "x-powers,ac100-codec-analog" },
+	{}
+};
+MODULE_DEVICE_TABLE(of, ac100_codec_of_match);
+
+static struct platform_driver ac100_codec_driver = {
+	.driver = {
+		.name = "ac100-codec-analog",
+		.of_match_table = ac100_codec_of_match,
+	},
+	.probe = ac100_codec_probe,
+	.remove = ac100_codec_remove,
+};
+module_platform_driver(ac100_codec_driver);
+
+MODULE_DESCRIPTION("X-Powers AC100 codec driver");
+MODULE_AUTHOR("Ondrej Jirman <megi@xff.cz>");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:ac100-codec");
diff --git a/sound/soc/sunxi/sun50i-codec-analog.c b/sound/soc/sunxi/sun50i-codec-analog.c
index e1e5e8de0130..b78af30961f2 100644
--- a/sound/soc/sunxi/sun50i-codec-analog.c
+++ b/sound/soc/sunxi/sun50i-codec-analog.c
@@ -116,9 +116,20 @@
 #define SUN50I_ADDA_HS_MBIAS_CTRL	0x0e
 #define SUN50I_ADDA_HS_MBIAS_CTRL_MMICBIASEN	7
 
+#define SUN50I_ADDA_MDET_CTRL		0x1c
+#define SUN50I_ADDA_MDET_CTRL_SELDETADC_FS	4
+#define SUN50I_ADDA_MDET_CTRL_SELDETADC_DB	2
+#define SUN50I_ADDA_MDET_CTRL_SELDETADC_BF	0
+
 #define SUN50I_ADDA_JACK_MIC_CTRL	0x1d
+#define SUN50I_ADDA_JACK_MIC_CTRL_JACKDETEN	7
 #define SUN50I_ADDA_JACK_MIC_CTRL_INNERRESEN	6
 #define SUN50I_ADDA_JACK_MIC_CTRL_HMICBIASEN	5
+#define SUN50I_ADDA_JACK_MIC_CTRL_MICADCEN	4
+
+struct sun50i_codec_analog {
+	bool	internal_bias_resistor;
+};
 
 /* mixer controls */
 static const struct snd_kcontrol_new sun50i_a64_codec_mixer_controls[] = {
@@ -297,6 +308,19 @@ static const struct snd_kcontrol_new sun50i_codec_earpiece_switch[] = {
 			SUN50I_ADDA_EARPIECE_CTRL1_ESPPA_MUTE, 1, 0),
 };
 
+static int sun50i_codec_hbias_event(struct snd_soc_dapm_widget *w,
+				    struct snd_kcontrol *kcontrol, int event)
+{
+	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+	u32 value = !!SND_SOC_DAPM_EVENT_ON(event);
+
+	regmap_update_bits(component->regmap, SUN50I_ADDA_JACK_MIC_CTRL,
+			   BIT(SUN50I_ADDA_JACK_MIC_CTRL_MICADCEN),
+			   value << SUN50I_ADDA_JACK_MIC_CTRL_MICADCEN);
+
+	return 0;
+}
+
 static const struct snd_soc_dapm_widget sun50i_a64_codec_widgets[] = {
 	/* DAC */
 	SND_SOC_DAPM_DAC("Left DAC", NULL, SUN50I_ADDA_MIX_DAC_CTRL,
@@ -368,7 +392,8 @@ static const struct snd_soc_dapm_widget sun50i_a64_codec_widgets[] = {
 	/* Microphone Bias */
 	SND_SOC_DAPM_SUPPLY("HBIAS", SUN50I_ADDA_JACK_MIC_CTRL,
 			    SUN50I_ADDA_JACK_MIC_CTRL_HMICBIASEN,
-			    0, NULL, 0),
+			    0, sun50i_codec_hbias_event,
+			    SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),
 
 	/* Mic input path */
 	SND_SOC_DAPM_PGA("Mic2 Amplifier", SUN50I_ADDA_MIC2_CTRL,
@@ -472,17 +497,57 @@ static const struct snd_soc_dapm_route sun50i_a64_codec_routes[] = {
 	{ "EARPIECE", NULL, "Earpiece Amp" },
 };
 
-static int sun50i_a64_codec_suspend(struct snd_soc_component *component)
+static int sun50i_a64_codec_probe(struct snd_soc_component *component)
 {
-	return regmap_update_bits(component->regmap, SUN50I_ADDA_HP_CTRL,
-				  BIT(SUN50I_ADDA_HP_CTRL_PA_CLK_GATE),
-				  BIT(SUN50I_ADDA_HP_CTRL_PA_CLK_GATE));
+	struct sun50i_codec_analog *codec = snd_soc_component_get_drvdata(component);
+
+	regmap_update_bits(component->regmap, SUN50I_ADDA_JACK_MIC_CTRL,
+			   BIT(SUN50I_ADDA_JACK_MIC_CTRL_INNERRESEN),
+			   codec->internal_bias_resistor <<
+				SUN50I_ADDA_JACK_MIC_CTRL_INNERRESEN);
+
+	/* Select sample interval of the ADC sample to 32ms */
+	regmap_update_bits(component->regmap, SUN50I_ADDA_MDET_CTRL,
+			   0x7 << SUN50I_ADDA_MDET_CTRL_SELDETADC_FS |
+			   0x3 << SUN50I_ADDA_MDET_CTRL_SELDETADC_BF,
+			   0x3 << SUN50I_ADDA_MDET_CTRL_SELDETADC_FS |
+			   0x3 << SUN50I_ADDA_MDET_CTRL_SELDETADC_BF);
+
+	return 0;
 }
 
-static int sun50i_a64_codec_resume(struct snd_soc_component *component)
+static int sun50i_a64_codec_set_bias_level(struct snd_soc_component *component,
+					   enum snd_soc_bias_level level)
 {
-	return regmap_update_bits(component->regmap, SUN50I_ADDA_HP_CTRL,
-				  BIT(SUN50I_ADDA_HP_CTRL_PA_CLK_GATE), 0);
+	struct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);
+	int hbias;
+
+	switch (level) {
+	case SND_SOC_BIAS_OFF:
+		regmap_update_bits(component->regmap, SUN50I_ADDA_JACK_MIC_CTRL,
+				   BIT(SUN50I_ADDA_JACK_MIC_CTRL_JACKDETEN) |
+				   BIT(SUN50I_ADDA_JACK_MIC_CTRL_MICADCEN), 0);
+
+		regmap_update_bits(component->regmap, SUN50I_ADDA_HP_CTRL,
+				   BIT(SUN50I_ADDA_HP_CTRL_PA_CLK_GATE),
+				   BIT(SUN50I_ADDA_HP_CTRL_PA_CLK_GATE));
+		break;
+	case SND_SOC_BIAS_STANDBY:
+		regmap_update_bits(component->regmap, SUN50I_ADDA_HP_CTRL,
+				   BIT(SUN50I_ADDA_HP_CTRL_PA_CLK_GATE), 0);
+
+		hbias = snd_soc_dapm_get_pin_status(dapm, "HBIAS");
+		regmap_update_bits(component->regmap, SUN50I_ADDA_JACK_MIC_CTRL,
+				   BIT(SUN50I_ADDA_JACK_MIC_CTRL_JACKDETEN) |
+				   BIT(SUN50I_ADDA_JACK_MIC_CTRL_MICADCEN),
+				   BIT(SUN50I_ADDA_JACK_MIC_CTRL_JACKDETEN) |
+				   hbias << SUN50I_ADDA_JACK_MIC_CTRL_MICADCEN);
+		break;
+	default:
+		break;
+	}
+
+	return 0;
 }
 
 static const struct snd_soc_component_driver sun50i_codec_analog_cmpnt_drv = {
@@ -492,8 +557,10 @@ static const struct snd_soc_component_driver sun50i_codec_analog_cmpnt_drv = {
 	.num_dapm_widgets	= ARRAY_SIZE(sun50i_a64_codec_widgets),
 	.dapm_routes		= sun50i_a64_codec_routes,
 	.num_dapm_routes	= ARRAY_SIZE(sun50i_a64_codec_routes),
-	.suspend		= sun50i_a64_codec_suspend,
-	.resume			= sun50i_a64_codec_resume,
+	.probe			= sun50i_a64_codec_probe,
+	.set_bias_level		= sun50i_a64_codec_set_bias_level,
+	.idle_bias_on		= true,
+	.suspend_bias_off	= true,
 };
 
 static const struct of_device_id sun50i_codec_analog_of_match[] = {
@@ -506,10 +573,20 @@ MODULE_DEVICE_TABLE(of, sun50i_codec_analog_of_match);
 
 static int sun50i_codec_analog_probe(struct platform_device *pdev)
 {
+	struct sun50i_codec_analog *codec;
 	struct regmap *regmap;
 	void __iomem *base;
 	bool enable;
 
+	codec = devm_kzalloc(&pdev->dev, sizeof(*codec), GFP_KERNEL);
+	if (!codec)
+		return -ENOMEM;
+
+	codec->internal_bias_resistor = of_property_read_bool(pdev->dev.of_node,
+					"allwinner,internal-bias-resistor");
+
+	platform_set_drvdata(pdev, codec);
+
 	base = devm_platform_ioremap_resource(pdev, 0);
 	if (IS_ERR(base)) {
 		dev_err(&pdev->dev, "Failed to map the registers\n");
diff --git a/sound/soc/sunxi/sun8i-codec.c b/sound/soc/sunxi/sun8i-codec.c
index 9844978d91e6..342b097b5249 100644
--- a/sound/soc/sunxi/sun8i-codec.c
+++ b/sound/soc/sunxi/sun8i-codec.c
@@ -12,12 +12,18 @@
 #include <linux/module.h>
 #include <linux/delay.h>
 #include <linux/clk.h>
+#include <linux/input.h>
 #include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/mutex.h>
 #include <linux/of_device.h>
 #include <linux/pm_runtime.h>
 #include <linux/regmap.h>
+#include <linux/regulator/consumer.h>
 #include <linux/log2.h>
+#include <linux/mfd/ac100.h>
 
+#include <sound/jack.h>
 #include <sound/pcm_params.h>
 #include <sound/soc.h>
 #include <sound/soc-dapm.h>
@@ -118,6 +124,23 @@
 #define SUN8I_ADC_VOL_CTRL				0x104
 #define SUN8I_ADC_VOL_CTRL_ADCL_VOL			8
 #define SUN8I_ADC_VOL_CTRL_ADCR_VOL			0
+#define SUN8I_HMIC_CTRL1				0x110
+#define SUN8I_HMIC_CTRL1_HMIC_M				12
+#define SUN8I_HMIC_CTRL1_HMIC_N				8
+#define SUN8I_HMIC_CTRL1_MDATA_THRESHOLD_DB		5
+#define SUN8I_HMIC_CTRL1_JACK_OUT_IRQ_EN		4
+#define SUN8I_HMIC_CTRL1_JACK_IN_IRQ_EN			3
+#define SUN8I_HMIC_CTRL1_HMIC_DATA_IRQ_EN		0
+#define SUN8I_HMIC_CTRL2				0x114
+#define SUN8I_HMIC_CTRL2_HMIC_SAMPLE			14
+#define SUN8I_HMIC_CTRL2_HMIC_MDATA_THRESHOLD		8
+#define SUN8I_HMIC_CTRL2_HMIC_SF			6
+#define SUN8I_HMIC_STS					0x118
+#define SUN8I_HMIC_STS_MDATA_DISCARD			13
+#define SUN8I_HMIC_STS_HMIC_DATA			8
+#define SUN8I_HMIC_STS_JACK_OUT_IRQ_ST			4
+#define SUN8I_HMIC_STS_JACK_IN_IRQ_ST			3
+#define SUN8I_HMIC_STS_HMIC_DATA_IRQ_ST			0
 #define SUN8I_DAC_DIG_CTRL				0x120
 #define SUN8I_DAC_DIG_CTRL_ENDA				15
 #define SUN8I_DAC_VOL_CTRL				0x124
@@ -143,6 +166,16 @@
 #define SUN8I_AIF_CLK_CTRL_WORD_SIZ_MASK	GENMASK(5, 4)
 #define SUN8I_AIF_CLK_CTRL_DATA_FMT_MASK	GENMASK(3, 2)
 #define SUN8I_AIF3_CLK_CTRL_AIF3_CLK_SRC_MASK	GENMASK(1, 0)
+#define SUN8I_HMIC_CTRL1_HMIC_M_MASK		GENMASK(15, 12)
+#define SUN8I_HMIC_CTRL1_HMIC_N_MASK		GENMASK(11, 8)
+#define SUN8I_HMIC_CTRL1_MDATA_THRESHOLD_DB_MASK GENMASK(6, 5)
+#define SUN8I_HMIC_CTRL2_HMIC_SAMPLE_MASK	GENMASK(15, 14)
+#define SUN8I_HMIC_CTRL2_HMIC_SF_MASK		GENMASK(7, 6)
+#define SUN8I_HMIC_STS_HMIC_DATA_MASK		GENMASK(12, 8)
+
+#define SUN8I_CODEC_BUTTONS	(SND_JACK_BTN_0|\
+				 SND_JACK_BTN_1|\
+				 SND_JACK_BTN_2)
 
 #define SUN8I_CODEC_PASSTHROUGH_SAMPLE_RATE 48000
 
@@ -177,17 +210,42 @@ struct sun8i_codec_aif {
 };
 
 struct sun8i_codec_quirks {
-	bool legacy_widgets	: 1;
-	bool lrck_inversion	: 1;
+	bool	bus_clock	: 1;
+	bool	jack_detection	: 1;
+	bool	legacy_widgets	: 1;
+	bool	lrck_inversion	: 1;
+};
+
+enum {
+	SUN8I_JACK_STATUS_DISCONNECTED,
+	SUN8I_JACK_STATUS_WAITING_HBIAS,
+	SUN8I_JACK_STATUS_CONNECTED,
 };
 
+#define AC100_NUM_SUPPLIES 4
+
 struct sun8i_codec {
 	struct regmap			*regmap;
+	struct snd_soc_card		*card;
+	struct clk			*clk_bus;
 	struct clk			*clk_module;
 	const struct sun8i_codec_quirks	*quirks;
 	struct sun8i_codec_aif		aifs[SUN8I_CODEC_NAIFS];
+	struct snd_soc_jack		jack;
+	struct delayed_work		jack_work;
+	int				jack_irq;
+	int				jack_status;
+	int				jack_last_sample;
+	int				jack_last_btn;
+	ktime_t				jack_hbias_ready;
+	int				jack_type;
+	int				last_hmic_irq;
+	struct mutex			jack_mutex;
 	unsigned int			sysclk_rate;
 	int				sysclk_refcnt;
+
+	struct regmap			*ac100_regmap;
+	struct regulator_bulk_data	supplies[AC100_NUM_SUPPLIES];
 };
 
 static struct snd_soc_dai_driver sun8i_codec_dais[];
@@ -197,6 +255,14 @@ static int sun8i_codec_runtime_resume(struct device *dev)
 	struct sun8i_codec *scodec = dev_get_drvdata(dev);
 	int ret;
 
+	if (scodec->clk_bus) {
+		ret = clk_prepare_enable(scodec->clk_bus);
+		if (ret) {
+			dev_err(dev, "Failed to enable the bus clock\n");
+			return ret;
+		}
+	}
+
 	regcache_cache_only(scodec->regmap, false);
 
 	ret = regcache_sync(scodec->regmap);
@@ -215,6 +281,9 @@ static int sun8i_codec_runtime_suspend(struct device *dev)
 	regcache_cache_only(scodec->regmap, true);
 	regcache_mark_dirty(scodec->regmap);
 
+	if (scodec->clk_bus)
+		clk_disable_unprepare(scodec->clk_bus);
+
 	return 0;
 }
 
@@ -580,6 +649,7 @@ static int sun8i_codec_hw_params(struct snd_pcm_substream *substream,
 			   SUN8I_AIF_CLK_CTRL_BCLK_DIV_MASK,
 			   bclk_div << SUN8I_AIF_CLK_CTRL_BCLK_DIV);
 
+	if (!scodec->ac100_regmap) {
 	/*
 	 * SYSCLK rate
 	 *
@@ -601,6 +671,7 @@ static int sun8i_codec_hw_params(struct snd_pcm_substream *substream,
 	if (!aif->open_streams)
 		scodec->sysclk_refcnt++;
 	scodec->sysclk_rate = sysclk_rate;
+	}
 
 	aif->lrck_div_order = lrck_div_order;
 	aif->sample_rate = sample_rate;
@@ -619,8 +690,11 @@ static int sun8i_codec_hw_free(struct snd_pcm_substream *substream,
 	if (aif->open_streams != BIT(substream->stream))
 		goto done;
 
-	clk_rate_exclusive_put(scodec->clk_module);
-	scodec->sysclk_refcnt--;
+	if (!scodec->ac100_regmap) {
+		clk_rate_exclusive_put(scodec->clk_module);
+		scodec->sysclk_refcnt--;
+	}
+
 	aif->lrck_div_order = 0;
 	aif->sample_rate = 0;
 
@@ -893,8 +967,6 @@ static const struct snd_kcontrol_new sun8i_dac_mixer_controls[] = {
 
 static const struct snd_soc_dapm_widget sun8i_codec_dapm_widgets[] = {
 	/* System Clocks */
-	SND_SOC_DAPM_CLOCK_SUPPLY("mod"),
-
 	SND_SOC_DAPM_SUPPLY("AIF1CLK",
 			    SUN8I_SYSCLK_CTL,
 			    SUN8I_SYSCLK_CTL_AIF1CLK_ENA, 0, NULL, 0),
@@ -1055,8 +1127,6 @@ static const struct snd_soc_dapm_widget sun8i_codec_dapm_widgets[] = {
 
 static const struct snd_soc_dapm_route sun8i_codec_dapm_routes[] = {
 	/* Clock Routes */
-	{ "AIF1CLK", NULL, "mod" },
-
 	{ "SYSCLK", NULL, "AIF1CLK" },
 
 	{ "CLK AIF1", NULL, "AIF1CLK" },
@@ -1226,12 +1296,103 @@ static const struct snd_soc_dapm_route sun8i_codec_legacy_routes[] = {
 	{ "AIF1 Slot 0 Right", NULL, "DACR" },
 };
 
+static const struct snd_soc_dapm_widget sun8i_codec_dapm_widgets_sun8i[] = {
+	SND_SOC_DAPM_CLOCK_SUPPLY("mod"),
+};
+
+static const struct snd_soc_dapm_route sun8i_codec_dapm_routes_sun8i[] = {
+	{ "AIF1CLK", NULL, "mod" },
+};
+
+static struct snd_soc_jack_pin sun8i_codec_jack_pins[] = {
+	{
+		.pin	= "Headphone Jack",
+		.mask	= SND_JACK_HEADPHONE,
+	},
+	{
+		.pin	= "Headset Microphone",
+		.mask	= SND_JACK_MICROPHONE,
+	},
+};
+
+static int sun8i_codec_jack_init(struct sun8i_codec *scodec)
+{
+	int pins = 0;
+	int type = 0;
+	int i, ret;
+
+	for (i = 0; i < ARRAY_SIZE(sun8i_codec_jack_pins); ++i) {
+		struct snd_soc_jack_pin *pin = &sun8i_codec_jack_pins[i];
+		struct snd_soc_dapm_widget *w;
+
+		for_each_card_widgets(scodec->card, w) {
+			if (!strcmp(pin->pin, w->name)) {
+				pins |= BIT(i);
+				type |= pin->mask;
+				break;
+			}
+		}
+	}
+
+	if (!type)
+		return 0;
+
+	if (type & SND_JACK_MICROPHONE)
+		type |= SUN8I_CODEC_BUTTONS;
+
+	ret = snd_soc_card_jack_new(scodec->card, "Headset Jack", type,
+				    &scodec->jack);
+	if (ret)
+		return ret;
+
+	for (i = 0; i < ARRAY_SIZE(sun8i_codec_jack_pins); ++i) {
+		struct snd_soc_jack_pin *pin = &sun8i_codec_jack_pins[i];
+
+		if (pins & BIT(i)) {
+			ret = snd_soc_jack_add_pins(&scodec->jack, 1, pin);
+			if (ret)
+				return ret;
+		}
+	}
+
+	if (type & SND_JACK_MICROPHONE) {
+		struct snd_jack *jack = scodec->jack.jack;
+
+		snd_jack_set_key(jack, SND_JACK_BTN_0, KEY_PLAYPAUSE);
+		snd_jack_set_key(jack, SND_JACK_BTN_1, KEY_VOLUMEUP);
+		snd_jack_set_key(jack, SND_JACK_BTN_2, KEY_VOLUMEDOWN);
+	}
+
+	scodec->jack_type = type;
+
+	return 0;
+}
+
+static int ac100_codec_component_probe(struct snd_soc_component *component);
+
 static int sun8i_codec_component_probe(struct snd_soc_component *component)
 {
 	struct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);
 	struct sun8i_codec *scodec = snd_soc_component_get_drvdata(component);
 	int ret;
 
+	if (scodec->ac100_regmap)
+                return ac100_codec_component_probe(component);
+
+	ret = snd_soc_dapm_new_controls(dapm,
+					sun8i_codec_dapm_widgets_sun8i,
+					ARRAY_SIZE(sun8i_codec_dapm_widgets_sun8i));
+	if (ret)
+		return ret;
+
+	ret = snd_soc_dapm_add_routes(dapm,
+				      sun8i_codec_dapm_routes_sun8i,
+				      ARRAY_SIZE(sun8i_codec_dapm_routes_sun8i));
+	if (ret)
+		return ret;
+
+	scodec->card = component->card;
+
 	/* Add widgets for backward compatibility with old device trees. */
 	if (scodec->quirks->legacy_widgets) {
 		ret = snd_soc_dapm_new_controls(dapm, sun8i_codec_legacy_widgets,
@@ -1265,9 +1426,57 @@ static int sun8i_codec_component_probe(struct snd_soc_component *component)
 	/* Program the default sample rate. */
 	sun8i_codec_update_sample_rate(scodec);
 
+	if (scodec->quirks->jack_detection) {
+		ret = sun8i_codec_jack_init(scodec);
+		if (ret)
+			return ret;
+	}
+
+	if (scodec->jack_type) {
+		int irq_mask = BIT(SUN8I_HMIC_CTRL1_JACK_OUT_IRQ_EN) |
+			       BIT(SUN8I_HMIC_CTRL1_JACK_IN_IRQ_EN);
+
+		/* Reserved value required for jack IRQs to trigger. */
+		regmap_write(scodec->regmap, SUN8I_HMIC_CTRL1,
+				   0xf << SUN8I_HMIC_CTRL1_HMIC_N |
+				   0x0 << SUN8I_HMIC_CTRL1_MDATA_THRESHOLD_DB |
+				   0x4 << SUN8I_HMIC_CTRL1_HMIC_M);
+
+		/* Sample the ADC at 128 Hz; bypass smooth filter. */
+		regmap_write(scodec->regmap, SUN8I_HMIC_CTRL2,
+				   0x0 << SUN8I_HMIC_CTRL2_HMIC_SAMPLE |
+				   0x17 << SUN8I_HMIC_CTRL2_HMIC_MDATA_THRESHOLD |
+				   0x0 << SUN8I_HMIC_CTRL2_HMIC_SF);
+
+		/* Do not discard any MDATA, enable user written MDATA threshold. */
+		regmap_write(scodec->regmap, SUN8I_HMIC_STS, 0);
+
+		regmap_update_bits(scodec->regmap, SUN8I_HMIC_CTRL1,
+				   irq_mask, irq_mask);
+
+		enable_irq(scodec->jack_irq);
+	}
+
 	return 0;
 }
 
+static void sun8i_codec_component_remove(struct snd_soc_component *component)
+{
+	struct sun8i_codec *scodec = snd_soc_component_get_drvdata(component);
+
+	if (scodec->jack_type) {
+		int irq_mask = BIT(SUN8I_HMIC_CTRL1_JACK_OUT_IRQ_EN) |
+			       BIT(SUN8I_HMIC_CTRL1_JACK_IN_IRQ_EN)  |
+			       BIT(SUN8I_HMIC_CTRL1_HMIC_DATA_IRQ_EN);
+
+		disable_irq(scodec->jack_irq);
+		cancel_delayed_work_sync(&scodec->jack_work);
+
+		regmap_update_bits(scodec->regmap, SUN8I_HMIC_CTRL1,
+				   irq_mask, 0);
+	}
+}
+
 static const struct snd_soc_component_driver sun8i_soc_component = {
 	.controls		= sun8i_codec_controls,
 	.num_controls		= ARRAY_SIZE(sun8i_codec_controls),
@@ -1276,29 +1485,397 @@ static const struct snd_soc_component_driver sun8i_soc_component = {
 	.dapm_routes		= sun8i_codec_dapm_routes,
 	.num_dapm_routes	= ARRAY_SIZE(sun8i_codec_dapm_routes),
 	.probe			= sun8i_codec_component_probe,
+	.remove			= sun8i_codec_component_remove,
 	.idle_bias_on		= 1,
+	.suspend_bias_off	= 1,
 	.endianness		= 1,
 };
 
-static const struct regmap_config sun8i_codec_regmap_config = {
+static bool sun8i_codec_volatile_reg(struct device *dev, unsigned int reg)
+{
+	return reg == SUN8I_HMIC_STS;
+}
+
+static struct regmap_config sun8i_codec_regmap_config = {
 	.reg_bits	= 32,
 	.reg_stride	= 4,
 	.val_bits	= 32,
+	.volatile_reg	= sun8i_codec_volatile_reg,
 	.max_register	= SUN8I_DAC_MXR_SRC,
 
 	.cache_type	= REGCACHE_FLAT,
 };
 
+static void sun8i_codec_set_hmic_bias(struct sun8i_codec *scodec, bool enable)
+{
+	struct snd_soc_dapm_context *dapm = &scodec->card->dapm;
+	int irq_mask = BIT(SUN8I_HMIC_CTRL1_HMIC_DATA_IRQ_EN);
+
+	if (enable)
+		snd_soc_dapm_force_enable_pin(dapm, "HBIAS");
+	else
+		snd_soc_dapm_disable_pin(dapm, "HBIAS");
+	snd_soc_dapm_sync(dapm);
+
+	dev_dbg(scodec->card->dev, "HMIC bias %s\n", enable ? "on" : "off");
+
+	regmap_update_bits(scodec->regmap, SUN8I_HMIC_CTRL1,
+			   irq_mask, enable ? irq_mask : 0);
+}
+
+static void sun8i_codec_jack_work(struct work_struct *work)
+{
+	struct sun8i_codec *scodec = container_of(work, struct sun8i_codec,
+						  jack_work.work);
+	unsigned int mdata;
+	int type;
+
+	mutex_lock(&scodec->jack_mutex);
+
+	if (scodec->jack_status == SUN8I_JACK_STATUS_DISCONNECTED) {
+		if (scodec->last_hmic_irq != SUN8I_HMIC_STS_JACK_IN_IRQ_ST)
+			goto out_unlock;
+
+		scodec->jack_last_sample = -1;
+		scodec->jack_last_btn = 0;
+
+		if (scodec->jack_type & SND_JACK_MICROPHONE) {
+			/*
+			 * If we were in disconnected state, we just enable HBIAS and
+			 * wait 500ms before reading initial HDATA value.
+			 */
+			scodec->jack_hbias_ready = ktime_add_ms(ktime_get(), 600);
+			scodec->jack_status = SUN8I_JACK_STATUS_WAITING_HBIAS;
+			sun8i_codec_set_hmic_bias(scodec, true);
+			queue_delayed_work(system_power_efficient_wq,
+					   &scodec->jack_work,
+					   msecs_to_jiffies(610));
+		} else {
+			type = SND_JACK_HEADPHONE;
+			snd_soc_jack_report(&scodec->jack, 0, scodec->jack_type);
+			scodec->jack_status = SUN8I_JACK_STATUS_CONNECTED;
+		}
+	} else if (scodec->jack_status == SUN8I_JACK_STATUS_WAITING_HBIAS) {
+		/*
+		 * If we're waiting for HBIAS to stabilize, and we get plug-out
+		 * interrupt and nothing more for > 100ms, just cancel the
+		 * initialization.
+		 */
+		if (scodec->last_hmic_irq == SUN8I_HMIC_STS_JACK_OUT_IRQ_ST) {
+			scodec->jack_status = SUN8I_JACK_STATUS_DISCONNECTED;
+			sun8i_codec_set_hmic_bias(scodec, false);
+			goto out_unlock;
+		}
+
+		/*
+		 * If we're not done waiting for things to stabilize, wait more.
+		 */
+		if (!ktime_after(ktime_get(), scodec->jack_hbias_ready)) {
+			s64 msecs = ktime_ms_delta(scodec->jack_hbias_ready, ktime_get());
+
+			queue_delayed_work(system_power_efficient_wq,
+					   &scodec->jack_work,
+					   msecs_to_jiffies(msecs + 10));
+			goto out_unlock;
+		}
+
+		/*
+		 * Everything is stabilized, determine jack type and report it.
+		 */
+		regmap_read(scodec->regmap, SUN8I_HMIC_STS, &mdata);
+		mdata &= SUN8I_HMIC_STS_HMIC_DATA_MASK;
+		mdata >>= SUN8I_HMIC_STS_HMIC_DATA;
+
+		regmap_write(scodec->regmap, SUN8I_HMIC_STS, 0);
+
+		if (mdata < 0x10) {
+			type = SND_JACK_HEADPHONE;
+
+			sun8i_codec_set_hmic_bias(scodec, false);
+		} else {
+			type = SND_JACK_HEADSET;
+
+			/* Set MDATA threshold for triggering DATA interrupts
+			 * slightly bellow the initial value read at connection
+			 * time. This assumes that user is not pressing a button
+			 * when connecting the jack cable. It's an unlinkely
+			 * situation, unless the person has 3 hands or more.
+			 */
+			/*
+			pr_err("jack: new mdata threshold: %#x\n", mdata);
+			regmap_write(scodec->regmap, SUN8I_HMIC_CTRL2,
+					   0x0 << SUN8I_HMIC_CTRL2_HMIC_SAMPLE |
+					   (mdata - 3) << SUN8I_HMIC_CTRL2_HMIC_MDATA_THRESHOLD |
+					   0x0 << SUN8I_HMIC_CTRL2_HMIC_SF);
+			   */
+		}
+
+		snd_soc_jack_report(&scodec->jack, type, scodec->jack_type);
+		scodec->jack_status = SUN8I_JACK_STATUS_CONNECTED;
+
+		pr_err("jack: plug-in reported\n");
+	} else if (scodec->jack_status == SUN8I_JACK_STATUS_CONNECTED) {
+		if (scodec->last_hmic_irq == SUN8I_HMIC_STS_JACK_OUT_IRQ_ST) {
+			scodec->jack_status = SUN8I_JACK_STATUS_DISCONNECTED;
+			if (scodec->jack_type & SND_JACK_MICROPHONE)
+				sun8i_codec_set_hmic_bias(scodec, false);
+
+			snd_soc_jack_report(&scodec->jack, 0, scodec->jack_type);
+			pr_err("jack: plug-out reported\n");
+		}
+	}
+
+out_unlock:
+	mutex_unlock(&scodec->jack_mutex);
+}
+
+static irqreturn_t sun8i_codec_jack_irq(int irq, void *dev_id)
+{
+	struct sun8i_codec *scodec = dev_id;
+	unsigned int status;
+
+	mutex_lock(&scodec->jack_mutex);
+
+	regmap_read(scodec->regmap, SUN8I_HMIC_STS, &status);
+	regmap_write(scodec->regmap, SUN8I_HMIC_STS, status);
+
+	if (status & BIT(SUN8I_HMIC_STS_JACK_OUT_IRQ_ST)) {
+		pr_err("jack: irq plug-out\n");
+
+		scodec->last_hmic_irq = SUN8I_HMIC_STS_JACK_OUT_IRQ_ST;
+		queue_delayed_work(system_power_efficient_wq,
+				   &scodec->jack_work,
+				   msecs_to_jiffies(100));
+	} else if (status & BIT(SUN8I_HMIC_STS_JACK_IN_IRQ_ST)) {
+		pr_err("jack: irq plug-in\n");
+
+		scodec->last_hmic_irq = SUN8I_HMIC_STS_JACK_IN_IRQ_ST;
+		queue_delayed_work(system_power_efficient_wq,
+				   &scodec->jack_work,
+				   msecs_to_jiffies(100));
+	} else if (status & BIT(SUN8I_HMIC_STS_HMIC_DATA_IRQ_ST)) {
+		if (scodec->jack_status == SUN8I_JACK_STATUS_CONNECTED) {
+			unsigned int value;
+			int type = SND_JACK_HEADSET;
+			int btn_chg = 0;
+
+			regmap_read(scodec->regmap, SUN8I_HMIC_STS, &value);
+			value  &= SUN8I_HMIC_STS_HMIC_DATA_MASK;
+			value >>= SUN8I_HMIC_STS_HMIC_DATA;
+
+			if (value < 0x2)
+				type |= SND_JACK_BTN_0;
+			else if (value < 0x7)
+				type |= SND_JACK_BTN_1;
+			else if (value < 0x10)
+				type |= SND_JACK_BTN_2;
+
+			if (scodec->jack_last_sample >= 0 && scodec->jack_last_sample == value) {
+				btn_chg = (scodec->jack_last_btn ^ type) & 0x7000;
+				scodec->jack_last_btn = type;
+
+				//XXX: temporary for debugging
+				if (btn_chg) {
+					if (btn_chg & SND_JACK_BTN_0)
+						pr_err("jack: key_%spress BTN_0 (%#x)\n", type & SND_JACK_BTN_0 ? "" : "de", value);
+					if (btn_chg & SND_JACK_BTN_1)
+						pr_err("jack: key_%spress BTN_1 (%#x)\n", type & SND_JACK_BTN_1 ? "" : "de", value);
+					if (btn_chg & SND_JACK_BTN_2)
+						pr_err("jack: key_%spress BTN_2 (%#x)\n", type & SND_JACK_BTN_2 ? "" : "de", value);
+				}
+
+				snd_soc_jack_report(&scodec->jack, type, scodec->jack_type);
+			}
+
+			scodec->jack_last_sample = value;
+		}
+	} else {
+		mutex_unlock(&scodec->jack_mutex);
+		return IRQ_NONE;
+	}
+
+	mutex_unlock(&scodec->jack_mutex);
+	return IRQ_HANDLED;
+}
+
+/* AC100 Codec Support (digital parts) */
+
+static int sun8i_codec_ac100_regmap_read(void *context, unsigned int reg, unsigned int *val)
+{
+	struct sun8i_codec *scodec = context;
+
+	return regmap_read(scodec->ac100_regmap, reg / 4, val);
+}
+
+static int sun8i_codec_ac100_regmap_write(void *context, unsigned int reg, unsigned int val)
+{
+	struct sun8i_codec *scodec = context;
+
+	return regmap_write(scodec->ac100_regmap, reg / 4, val);
+}
+
+static struct regmap_bus sun8i_codec_ac100_regmap_bus = {
+	.reg_write = sun8i_codec_ac100_regmap_write,
+	.reg_read = sun8i_codec_ac100_regmap_read,
+};
+
+static const char *const ac100_supply_names[AC100_NUM_SUPPLIES] = {
+	"LDOIN",
+	"AVCC",
+	"VDDIO1",
+	"VDDIO2",
+};
+
+#define AC100_SYSCLK_CTRL_PLLCLK_ENA_OFF                        15
+#define AC100_SYSCLK_CTRL_PLLCLK_ENA_MASK                       BIT(15)
+#define AC100_SYSCLK_CTRL_PLLCLK_ENA_DISABLED                   0
+#define AC100_SYSCLK_CTRL_PLLCLK_ENA_ENABLED                    BIT(15)
+#define AC100_SYSCLK_CTRL_PLLCLK_SRC_OFF                        12
+#define AC100_SYSCLK_CTRL_PLLCLK_SRC_MASK                       GENMASK(13, 12)
+#define AC100_SYSCLK_CTRL_PLLCLK_SRC_MCLK1                      (0x0 << 12)
+#define AC100_SYSCLK_CTRL_PLLCLK_SRC_MCLK2                      (0x1 << 12)
+#define AC100_SYSCLK_CTRL_PLLCLK_SRC_BCLK1                      (0x2 << 12)
+#define AC100_SYSCLK_CTRL_PLLCLK_SRC_BCLK2                      (0x3 << 12)
+#define AC100_SYSCLK_CTRL_I2S1CLK_ENA_OFF                       11
+#define AC100_SYSCLK_CTRL_I2S1CLK_ENA_MASK                      BIT(11)
+#define AC100_SYSCLK_CTRL_I2S1CLK_ENA_DISABLED                  0
+#define AC100_SYSCLK_CTRL_I2S1CLK_ENA_ENABLED                   BIT(11)
+#define AC100_SYSCLK_CTRL_I2S1CLK_SRC_OFF                       8
+#define AC100_SYSCLK_CTRL_I2S1CLK_SRC_MASK                      GENMASK(9, 8)
+#define AC100_SYSCLK_CTRL_I2S1CLK_SRC_MCLK1                     (0x0 << 8)
+#define AC100_SYSCLK_CTRL_I2S1CLK_SRC_MCLK2                     (0x1 << 8)
+#define AC100_SYSCLK_CTRL_I2S1CLK_SRC_PLL                       (0x2 << 8)
+#define AC100_SYSCLK_CTRL_I2S2CLK_ENA_OFF                       7
+#define AC100_SYSCLK_CTRL_I2S2CLK_ENA_MASK                      BIT(7)
+#define AC100_SYSCLK_CTRL_I2S2CLK_ENA_DISABLED                  0
+#define AC100_SYSCLK_CTRL_I2S2CLK_ENA_ENABLED                   BIT(7)
+#define AC100_SYSCLK_CTRL_I2S2CLK_SRC_OFF                       4
+#define AC100_SYSCLK_CTRL_I2S2CLK_SRC_MASK                      GENMASK(5, 4)
+#define AC100_SYSCLK_CTRL_I2S2CLK_SRC_MCLK1                     (0x0 << 4)
+#define AC100_SYSCLK_CTRL_I2S2CLK_SRC_MCLK2                     (0x1 << 4)
+#define AC100_SYSCLK_CTRL_I2S2CLK_SRC_PLL                       (0x2 << 4)
+#define AC100_SYSCLK_CTRL_SYSCLK_ENA_OFF                        3
+#define AC100_SYSCLK_CTRL_SYSCLK_ENA_MASK                       BIT(3)
+#define AC100_SYSCLK_CTRL_SYSCLK_ENA_DISABLED                   0
+#define AC100_SYSCLK_CTRL_SYSCLK_ENA_ENABLED                    BIT(3)
+#define AC100_SYSCLK_CTRL_SYSCLK_SRC_OFF                        0
+#define AC100_SYSCLK_CTRL_SYSCLK_SRC_MASK                       BIT(0)
+#define AC100_SYSCLK_CTRL_SYSCLK_SRC_I2S1CLK                    0
+#define AC100_SYSCLK_CTRL_SYSCLK_SRC_I2S2CLK                    BIT(0)
+
+
+static int ac100_codec_component_probe(struct snd_soc_component *component)
+{
+	struct sun8i_codec *scodec = snd_soc_component_get_drvdata(component);
+
+        // The system clock(SYSCLK) of AC100 must be 512*fs(fs=48KHz or 44.1KHz)
+
+        // Source clocks from the SoC
+
+        regmap_update_bits(scodec->ac100_regmap, AC100_SYSCLK_CTRL,
+                            AC100_SYSCLK_CTRL_I2S1CLK_SRC_MASK,
+                            AC100_SYSCLK_CTRL_I2S1CLK_SRC_MCLK1);
+        regmap_update_bits(scodec->ac100_regmap, AC100_SYSCLK_CTRL,
+                            AC100_SYSCLK_CTRL_I2S2CLK_SRC_MASK,
+                            AC100_SYSCLK_CTRL_I2S2CLK_SRC_MCLK1);
+        regmap_update_bits(scodec->ac100_regmap, AC100_SYSCLK_CTRL,
+                            AC100_SYSCLK_CTRL_SYSCLK_SRC_MASK,
+                            AC100_SYSCLK_CTRL_SYSCLK_SRC_I2S1CLK);
+
+	/* Program the default sample rate. */
+	sun8i_codec_update_sample_rate(scodec);
+
+        return 0;
+}
+
+static int sun8i_codec_probe_ac100(struct platform_device *pdev)
+{
+	struct ac100_dev *ac100 = dev_get_drvdata(pdev->dev.parent);
+	struct device* dev = &pdev->dev;
+	struct sun8i_codec *scodec;
+	int ret, i;
+
+	scodec = devm_kzalloc(dev, sizeof(*scodec), GFP_KERNEL);
+	if (!scodec)
+		return -ENOMEM;
+
+	scodec->quirks = of_device_get_match_data(&pdev->dev);
+	scodec->ac100_regmap = ac100->regmap;
+
+	platform_set_drvdata(pdev, scodec);
+
+	// caching is done by the MFD regmap
+	sun8i_codec_regmap_config.cache_type = REGCACHE_NONE;
+
+	// we need to create a custom regmap_bus that will map reads/writes to the MFD regmap
+	scodec->regmap = __regmap_lockdep_wrapper(__devm_regmap_init,
+		 "ac100-regmap-codec", dev,
+		  &sun8i_codec_ac100_regmap_bus, scodec,
+		  &sun8i_codec_regmap_config);
+	if (IS_ERR(scodec->regmap)) {
+		dev_err(dev, "Failed to create our regmap\n");
+		return PTR_ERR(scodec->regmap);
+	}
+
+	for (i = 0; i < ARRAY_SIZE(scodec->supplies); i++)
+		scodec->supplies[i].supply = ac100_supply_names[i];
+
+        ret = devm_regulator_bulk_get(dev, ARRAY_SIZE(scodec->supplies),
+                                      scodec->supplies);
+        if (ret != 0) {
+              if (ret != -EPROBE_DEFER)
+                       dev_err(dev, "Failed to request supplies: %d\n", ret);
+                return ret;
+        }
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(scodec->supplies),
+				    scodec->supplies);
+	if (ret != 0) {
+		dev_err(dev, "Failed to enable supplies: %d\n", ret);
+		return ret;
+	}
+
+	ret = devm_snd_soc_register_component(dev, &sun8i_soc_component,
+					      sun8i_codec_dais,
+					      ARRAY_SIZE(sun8i_codec_dais));
+	if (ret) {
+		dev_err(dev, "Failed to register codec\n");
+		goto err_disable_reg;
+	}
+
+	return ret;
+
+err_disable_reg:
+	regulator_bulk_disable(ARRAY_SIZE(scodec->supplies),
+			       scodec->supplies);
+	return ret;
+}
+
 static int sun8i_codec_probe(struct platform_device *pdev)
 {
 	struct sun8i_codec *scodec;
 	void __iomem *base;
 	int ret;
 
+	if (of_device_is_compatible(pdev->dev.of_node, "x-powers,ac100-codec"))
+		return sun8i_codec_probe_ac100(pdev);
+
 	scodec = devm_kzalloc(&pdev->dev, sizeof(*scodec), GFP_KERNEL);
 	if (!scodec)
 		return -ENOMEM;
 
+	scodec->quirks = of_device_get_match_data(&pdev->dev);
+
+	platform_set_drvdata(pdev, scodec);
+
+	if (scodec->quirks->bus_clock) {
+		scodec->clk_bus = devm_clk_get(&pdev->dev, "bus");
+		if (IS_ERR(scodec->clk_bus)) {
+			dev_err(&pdev->dev, "Failed to get the bus clock\n");
+			return PTR_ERR(scodec->clk_bus);
+		}
+	}
+
 	scodec->clk_module = devm_clk_get(&pdev->dev, "mod");
 	if (IS_ERR(scodec->clk_module)) {
 		dev_err(&pdev->dev, "Failed to get the module clock\n");
@@ -1311,17 +1888,31 @@ static int sun8i_codec_probe(struct platform_device *pdev)
 		return PTR_ERR(base);
 	}
 
-	scodec->regmap = devm_regmap_init_mmio_clk(&pdev->dev, "bus", base,
-						   &sun8i_codec_regmap_config);
+	scodec->regmap = devm_regmap_init_mmio(&pdev->dev, base,
+					       &sun8i_codec_regmap_config);
 	if (IS_ERR(scodec->regmap)) {
 		dev_err(&pdev->dev, "Failed to create our regmap\n");
 		return PTR_ERR(scodec->regmap);
 	}
 
-	scodec->quirks = of_device_get_match_data(&pdev->dev);
+	if (scodec->quirks->jack_detection) {
+		scodec->jack_irq = platform_get_irq(pdev, 0);
+		if (scodec->jack_irq < 0)
+			return scodec->jack_irq;
 
-	platform_set_drvdata(pdev, scodec);
+		irq_set_status_flags(scodec->jack_irq, IRQ_NOAUTOEN);
+		ret = devm_request_threaded_irq(&pdev->dev, scodec->jack_irq,
+						NULL, sun8i_codec_jack_irq,
+						IRQF_ONESHOT,
+						dev_name(&pdev->dev), scodec);
+		if (ret)
+			return ret;
+
+		INIT_DELAYED_WORK(&scodec->jack_work, sun8i_codec_jack_work);
+		mutex_init(&scodec->jack_mutex);
+	}
 
+	regcache_cache_only(scodec->regmap, true);
 	pm_runtime_enable(&pdev->dev);
 	if (!pm_runtime_enabled(&pdev->dev)) {
 		ret = sun8i_codec_runtime_resume(&pdev->dev);
@@ -1351,6 +1942,14 @@ static int sun8i_codec_probe(struct platform_device *pdev)
 
 static int sun8i_codec_remove(struct platform_device *pdev)
 {
+	struct sun8i_codec *scodec = dev_get_drvdata(&pdev->dev);
+
+	if (scodec->ac100_regmap) {
+		regulator_bulk_disable(ARRAY_SIZE(scodec->supplies),
+				       scodec->supplies);
+		return 0;
+	}
+
 	pm_runtime_disable(&pdev->dev);
 	if (!pm_runtime_status_suspended(&pdev->dev))
 		sun8i_codec_runtime_suspend(&pdev->dev);
@@ -1359,16 +1958,23 @@ static int sun8i_codec_remove(struct platform_device *pdev)
 }
 
 static const struct sun8i_codec_quirks sun8i_a33_quirks = {
+	.bus_clock	= true,
 	.legacy_widgets	= true,
 	.lrck_inversion	= true,
 };
 
 static const struct sun8i_codec_quirks sun50i_a64_quirks = {
+	.bus_clock	= true,
+	.jack_detection	= true,
+};
+
+static const struct sun8i_codec_quirks ac100_quirks = {
 };
 
 static const struct of_device_id sun8i_codec_of_match[] = {
 	{ .compatible = "allwinner,sun8i-a33-codec", .data = &sun8i_a33_quirks },
 	{ .compatible = "allwinner,sun50i-a64-codec", .data = &sun50i_a64_quirks },
+	{ .compatible = "x-powers,ac100-codec", .data = &ac100_quirks },
 	{}
 };
 MODULE_DEVICE_TABLE(of, sun8i_codec_of_match);
diff --git a/sound/soc/sunxi/sun9i-hdmi-audio.c b/sound/soc/sunxi/sun9i-hdmi-audio.c
new file mode 100644
index 000000000000..fc8f03d398c0
--- /dev/null
+++ b/sound/soc/sunxi/sun9i-hdmi-audio.c
@@ -0,0 +1,180 @@
+// SPDX-License-Identifier: GPL-2.0
+//
+// sun9i hdmi audio sound card
+//
+// Copyright (C) 2021 Jernej Skrabec <jernej.skrabec@gmail.com>
+
+#include <linux/module.h>
+#include <linux/of_platform.h>
+
+#include <sound/soc.h>
+#include <sound/soc-dai.h>
+
+static int sun9i_hdmi_audio_hw_params(struct snd_pcm_substream *substream,
+				      struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);
+	unsigned int mclk;
+
+	mclk = params_rate(params) * 128;
+
+	return snd_soc_dai_set_sysclk(asoc_rtd_to_cpu(rtd, 0), 0, mclk,
+				      SND_SOC_CLOCK_OUT);
+}
+
+static const struct snd_soc_ops sun9i_hdmi_audio_ops = {
+	.hw_params = sun9i_hdmi_audio_hw_params,
+};
+
+static int sun9i_hdmi_audio_dai_init(struct snd_soc_pcm_runtime *rtd)
+{
+	int ret;
+
+	/* TODO: switch to custom api once it's implemented in sun4i-i2s */
+	ret = snd_soc_dai_set_tdm_slot(asoc_rtd_to_cpu(rtd, 0), 0, 0, 2, 32);
+	if (ret) {
+		dev_err(asoc_rtd_to_cpu(rtd, 0)->dev,
+			"setting tdm link slots failed\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int sun9i_hdmi_audio_parse_dai(struct device_node *node,
+				      struct snd_soc_dai_link_component *dlc)
+{
+	struct of_phandle_args args;
+	int ret;
+
+	if (!node)
+		return 0;
+
+	ret = of_parse_phandle_with_args(node, "sound-dai",
+					 "#sound-dai-cells", 0, &args);
+	if (ret)
+		return ret;
+
+	ret = snd_soc_get_dai_name(&args, &dlc->dai_name);
+	if (ret < 0) {
+		of_node_put(args.np);
+
+		return ret;
+	}
+
+	dlc->of_node = args.np;
+
+	return 0;
+}
+
+static int sun9i_hdmi_audio_probe(struct platform_device *pdev)
+{
+	struct snd_soc_dai_link_component *dlc;
+	struct device *dev = &pdev->dev;
+	struct snd_soc_dai_link *link;
+	struct snd_soc_card *card;
+	struct device_node *child;
+	int ret;
+
+	card = devm_kzalloc(dev, sizeof(*card), GFP_KERNEL);
+	if (!card)
+		return -ENOMEM;
+
+	link = devm_kzalloc(dev, sizeof(*link), GFP_KERNEL);
+	if (!link)
+		return -ENOMEM;
+
+	dlc = devm_kzalloc(dev, sizeof(*dlc) * 3, GFP_KERNEL);
+	if (!dlc)
+		return -ENOMEM;
+
+	child = of_get_child_by_name(dev->of_node, "codec");
+	if (!child)
+		return -ENODEV;
+
+	ret = sun9i_hdmi_audio_parse_dai(child, &dlc[1]);
+	of_node_put(child);
+	if (ret)
+		return ret;
+
+	child = of_get_child_by_name(dev->of_node, "cpu");
+	if (!child) {
+		ret = -ENODEV;
+		goto out_err;
+	}
+
+	ret = sun9i_hdmi_audio_parse_dai(child, &dlc[0]);
+	of_node_put(child);
+	if (ret)
+		goto out_err;
+
+	dlc[2].of_node = dlc[0].of_node;
+
+	platform_set_drvdata(pdev, card);
+
+	link->cpus = &dlc[0];
+	link->codecs = &dlc[1];
+	link->platforms = &dlc[2];
+
+	link->num_cpus = 1;
+	link->num_codecs = 1;
+	link->num_platforms = 1;
+
+	link->playback_only = 1;
+
+	link->name = "SUN9I-HDMI";
+	link->stream_name = "SUN9I-HDMI PCM";
+
+	link->dai_fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_IF | SND_SOC_DAIFMT_CBS_CFS;
+
+	link->ops = &sun9i_hdmi_audio_ops;
+	link->init = sun9i_hdmi_audio_dai_init;
+
+	card->dai_link = link;
+	card->num_links = 1;
+	card->owner = THIS_MODULE;
+	card->dev = dev;
+	card->name = "sun9i-hdmi";
+
+	ret = devm_snd_soc_register_card(dev, card);
+	if (ret)
+		goto out_err;
+
+	return 0;
+
+out_err:
+	of_node_put(dlc[0].of_node);
+	of_node_put(dlc[1].of_node);
+
+	return ret;
+}
+
+static int sun9i_hdmi_audio_remove(struct platform_device *pdev)
+{
+	struct snd_soc_card *card = platform_get_drvdata(pdev);
+
+	of_node_put(card->dai_link->cpus->of_node);
+	of_node_put(card->dai_link->codecs->of_node);
+
+	return 0;
+}
+
+static const struct of_device_id sun9i_hdmi_audio_match[] = {
+	{ .compatible = "allwinner,sun9i-a80-hdmi-audio" },
+	{}
+};
+MODULE_DEVICE_TABLE(of, sun9i_hdmi_audio_match);
+
+static struct platform_driver sun9i_hdmi_audio_driver = {
+	.probe = sun9i_hdmi_audio_probe,
+	.remove = sun9i_hdmi_audio_remove,
+	.driver = {
+		.name = "sun9i-hdmi-audio",
+		.of_match_table = sun9i_hdmi_audio_match,
+	},
+};
+module_platform_driver(sun9i_hdmi_audio_driver);
+
+MODULE_DESCRIPTION("sun9i HDMI Audio Sound Card");
+MODULE_AUTHOR("Jernej Skrabec <jernej.skrabec@gmail.com>");
+MODULE_LICENSE("GPL v2");
-- 
2.39.2

