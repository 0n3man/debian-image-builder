diff -Naur a/drivers/gpu/drm/sun4i/sun8i_mixer.c b/drivers/gpu/drm/sun4i/sun8i_mixer.c
--- a/drivers/gpu/drm/sun4i/sun8i_mixer.c	2022-08-03 06:03:56.000000000 -0400
+++ b/drivers/gpu/drm/sun4i/sun8i_mixer.c	2022-08-04 04:02:59.523794490 -0400
@@ -560,6 +560,14 @@
 	.vi_num		= 1,
 };
 
+static const struct sun8i_mixer_cfg sun8i_h3_mixer1_cfg = {
+	.ccsc		= 1,
+	.mod_rate	= 432000000,
+	.scaler_mask	= 0xf,
+	.ui_num		= 3,
+	.vi_num		= 1,
+};
+
 static const struct sun8i_mixer_cfg sun8i_r40_mixer0_cfg = {
 	.ccsc		= 0,
 	.mod_rate	= 297000000,
@@ -629,6 +637,10 @@
 		.data = &sun8i_h3_mixer0_cfg,
 	},
 	{
+		.compatible = "allwinner,sun8i-h3-de2-mixer-1",
+		.data = &sun8i_h3_mixer1_cfg,
+	},
+	{
 		.compatible = "allwinner,sun8i-r40-de2-mixer-0",
 		.data = &sun8i_r40_mixer0_cfg,
 	},
diff -Naur a/sound/soc/sunxi/Kconfig b/sound/soc/sunxi/Kconfig
--- a/sound/soc/sunxi/Kconfig	2022-08-03 06:03:56.000000000 -0400
+++ b/sound/soc/sunxi/Kconfig	2022-08-04 04:03:33.281551468 -0400
@@ -56,6 +56,14 @@
 	  Say Y or M to add support for the S/PDIF audio block in the Allwinner
 	  A10 and affiliated SoCs.
 
+config SND_SUN9I_HDMI_AUDIO
+	tristate "Allwinner sun9i HDMI Audio Sound Card"
+	depends on OF
+	depends on SND_SUN4I_I2S
+	help
+	  Say Y or M to add support for the HDMI Audio sound card for Allwinner
+	  SoCs with DW-HDMI core.
+
 config SND_SUN8I_ADDA_PR_REGMAP
 	tristate
 	select REGMAP
diff -Naur a/sound/soc/sunxi/Makefile b/sound/soc/sunxi/Makefile
--- a/sound/soc/sunxi/Makefile	2022-08-03 06:03:56.000000000 -0400
+++ b/sound/soc/sunxi/Makefile	2022-08-04 04:03:33.281551468 -0400
@@ -1,8 +1,9 @@
 # SPDX-License-Identifier: GPL-2.0
+obj-$(CONFIG_SND_SUN8I_CODEC_ANALOG) += sun8i-codec-analog.o
 obj-$(CONFIG_SND_SUN4I_CODEC) += sun4i-codec.o
 obj-$(CONFIG_SND_SUN4I_I2S) += sun4i-i2s.o
 obj-$(CONFIG_SND_SUN4I_SPDIF) += sun4i-spdif.o
-obj-$(CONFIG_SND_SUN8I_CODEC_ANALOG) += sun8i-codec-analog.o
 obj-$(CONFIG_SND_SUN50I_CODEC_ANALOG) += sun50i-codec-analog.o
 obj-$(CONFIG_SND_SUN8I_CODEC) += sun8i-codec.o
 obj-$(CONFIG_SND_SUN8I_ADDA_PR_REGMAP) += sun8i-adda-pr-regmap.o
+obj-$(CONFIG_SND_SUN9I_HDMI_AUDIO) += sun9i-hdmi-audio.o
diff -Naur a/sound/soc/sunxi/sun4i-codec.c b/sound/soc/sunxi/sun4i-codec.c
--- a/sound/soc/sunxi/sun4i-codec.c	2022-08-03 06:03:56.000000000 -0400
+++ b/sound/soc/sunxi/sun4i-codec.c	2022-08-04 04:03:16.624684498 -0400
@@ -5,6 +5,7 @@
  * Copyright 2015 Maxime Ripard <maxime.ripard@free-electrons.com>
  * Copyright 2015 Adam Sampson <ats@offog.org>
  * Copyright 2016 Chen-Yu Tsai <wens@csie.org>
+ * Copyright 2021 gryzun <gryzun_an@rambler.ru>
  *
  * Based on the Allwinner SDK driver, released under the GPL.
  */
@@ -676,6 +677,16 @@
 };
 
 /*** sun4i Codec ***/
+
+static const char *adcis_text[] = {"Line In", "FM In", "Mic1 Mono", "Mic2 Mono",
+			"Mic1,Mic2", "Mic1+2 Mono", "MIX Out", "Line,Mic1"};
+
+static SOC_ENUM_SINGLE_DECL(adcis_mixer, SUN4I_CODEC_ADC_ACTL,
+					SUN4I_CODEC_ADC_ACTL_ADCIS, adcis_text);
+
+static const struct snd_kcontrol_new sun4i_codec_mux_controls =
+	SOC_DAPM_ENUM("Capture Source Capture Route", adcis_mixer);
+
 static const struct snd_kcontrol_new sun4i_codec_pa_mute =
 	SOC_DAPM_SINGLE("Switch", SUN4I_CODEC_DAC_ACTL,
 			SUN4I_CODEC_DAC_ACTL_PA_MUTE, 1, 0);
@@ -689,6 +700,8 @@
 			    0);
 static DECLARE_TLV_DB_SCALE(sun4i_codec_micin_loopback_gain_scale, -450, 150,
 			    0);
+static DECLARE_TLV_DB_SCALE(sun4i_codec_capture_gain_scale, -450, 150,
+			    0);
 static DECLARE_TLV_DB_RANGE(sun4i_codec_micin_preamp_gain_scale,
 			    0, 0, TLV_DB_SCALE_ITEM(0, 0, 0),
 			    1, 7, TLV_DB_SCALE_ITEM(3500, 300, 0));
@@ -742,6 +755,9 @@
 	SOC_SINGLE_TLV("Mic2 Boost Volume", SUN7I_CODEC_AC_MIC_PHONE_CAL,
 		       SUN7I_CODEC_AC_MIC_PHONE_CAL_PREG2, 7, 0,
 		       sun7i_codec_micin_preamp_gain_scale),
+	SOC_SINGLE_TLV("Capture Boost Capture Volume", SUN4I_CODEC_ADC_ACTL,
+		       SUN4I_CODEC_ADC_ACTL_VADCG, 7, 0,
+		       sun4i_codec_capture_gain_scale),
 };
 
 static const struct snd_kcontrol_new sun4i_codec_mixer_controls[] = {
@@ -820,6 +836,13 @@
 	SND_SOC_DAPM_PGA("MIC2 Pre-Amplifier", SUN4I_CODEC_ADC_ACTL,
 			 SUN4I_CODEC_ADC_ACTL_PREG2EN, 0, NULL, 0),
 
+	/* ADC Mux */
+	SND_SOC_DAPM_MUX("Right Capture Source Capture Route", SND_SOC_NOPM, 0, 0,
+		&sun4i_codec_mux_controls),
+
+	SND_SOC_DAPM_MUX("Left Capture Source Capture Route", SND_SOC_NOPM, 0, 0,
+		&sun4i_codec_mux_controls),
+
 	/* Power Amplifier */
 	SND_SOC_DAPM_MIXER("Power Amplifier", SUN4I_CODEC_ADC_ACTL,
 			   SUN4I_CODEC_ADC_ACTL_PA_EN, 0,
@@ -848,6 +871,30 @@
 	{ "Right ADC", NULL, "ADC" },
 	{ "Right DAC", NULL, "DAC" },
 
+	/* Left Mux Capture Routes */
+	{ "Left Capture Source Capture Route", "Mic1 Mono", "MIC1 Pre-Amplifier" },
+	{ "Left Capture Source Capture Route", "Mic2 Mono", "MIC2 Pre-Amplifier" },
+	{ "Left Capture Source Capture Route", "Line In", "Line Left" },
+	{ "Left Capture Source Capture Route", "FM In", "FM Left" },
+	{ "Left Capture Source Capture Route", "MIX Out", "Left Mixer" },
+	{ "Left Capture Source Capture Route", "Mic1,Mic2", "MIC1 Pre-Amplifier" },
+	{ "Left Capture Source Capture Route", "Mic1+2 Mono", "MIC1 Pre-Amplifier" },
+	{ "Left Capture Source Capture Route", "Mic1+2 Mono", "MIC2 Pre-Amplifier" },
+	{ "Left Capture Source Capture Route", "Line,Mic1", "Line Left" },
+	{ "Left ADC", NULL, "Left Capture Source Capture Route" },
+
+	/* Right Mux Capture Routes */
+	{ "Right Capture Source Capture Route", "Mic1 Mono", "MIC1 Pre-Amplifier" },
+	{ "Right Capture Source Capture Route", "Mic2 Mono", "MIC2 Pre-Amplifier" },
+	{ "Right Capture Source Capture Route", "Line In", "Line Right" },
+	{ "Right Capture Source Capture Route", "FM In", "FM Right" },
+	{ "Right Capture Source Capture Route", "MIX Out", "Right Mixer" },
+	{ "Right Capture Source Capture Route", "Mic1,Mic2", "MIC2 Pre-Amplifier" },
+	{ "Right Capture Source Capture Route", "Mic1+2 Mono", "MIC1 Pre-Amplifier" },
+	{ "Right Capture Source Capture Route", "Mic1+2 Mono", "MIC2 Pre-Amplifier" },
+	{ "Right Capture Source Capture Route", "Line,Mic1", "MIC1 Pre-Amplifier" },
+	{ "Right ADC", NULL, "Right Capture Source Capture Route" },
+
 	/* Right Mixer Routes */
 	{ "Right Mixer", NULL, "Mixer Enable" },
 	{ "Right Mixer", "Right Mixer Left DAC Playback Switch", "Left DAC" },
@@ -877,14 +924,10 @@
 	{ "HP Left", NULL, "Power Amplifier Mute" },
 
 	/* Mic1 Routes */
-	{ "Left ADC", NULL, "MIC1 Pre-Amplifier" },
-	{ "Right ADC", NULL, "MIC1 Pre-Amplifier" },
 	{ "MIC1 Pre-Amplifier", NULL, "Mic1"},
 	{ "Mic1", NULL, "VMIC" },
 
 	/* Mic2 Routes */
-	{ "Left ADC", NULL, "MIC2 Pre-Amplifier" },
-	{ "Right ADC", NULL, "MIC2 Pre-Amplifier" },
 	{ "MIC2 Pre-Amplifier", NULL, "Mic2"},
 	{ "Mic2", NULL, "VMIC" },
 };
diff -Naur a/sound/soc/sunxi/sun4i-spdif.c b/sound/soc/sunxi/sun4i-spdif.c
--- a/sound/soc/sunxi/sun4i-spdif.c	2022-08-03 06:03:56.000000000 -0400
+++ b/sound/soc/sunxi/sun4i-spdif.c	2022-08-04 04:03:22.156972440 -0400
@@ -175,6 +175,7 @@
 	unsigned int reg_dac_txdata;
 	bool has_reset;
 	unsigned int val_fctl_ftx;
+	unsigned int mclk_multiplier;
 };
 
 struct sun4i_spdif_dev {
@@ -311,6 +312,7 @@
 	default:
 		return -EINVAL;
 	}
+	mclk *= host->quirks->mclk_multiplier;
 
 	ret = clk_set_rate(host->spdif_clk, mclk);
 	if (ret < 0) {
@@ -345,6 +347,7 @@
 	default:
 		return -EINVAL;
 	}
+	mclk_div *= host->quirks->mclk_multiplier;
 
 	reg_val = 0;
 	reg_val |= SUN4I_SPDIF_TXCFG_ASS;
@@ -427,24 +430,28 @@
 static const struct sun4i_spdif_quirks sun4i_a10_spdif_quirks = {
 	.reg_dac_txdata	= SUN4I_SPDIF_TXFIFO,
 	.val_fctl_ftx   = SUN4I_SPDIF_FCTL_FTX,
+	.mclk_multiplier = 1,
 };
 
 static const struct sun4i_spdif_quirks sun6i_a31_spdif_quirks = {
 	.reg_dac_txdata	= SUN4I_SPDIF_TXFIFO,
 	.val_fctl_ftx   = SUN4I_SPDIF_FCTL_FTX,
 	.has_reset	= true,
+	.mclk_multiplier = 1,
 };
 
 static const struct sun4i_spdif_quirks sun8i_h3_spdif_quirks = {
 	.reg_dac_txdata	= SUN8I_SPDIF_TXFIFO,
 	.val_fctl_ftx   = SUN4I_SPDIF_FCTL_FTX,
 	.has_reset	= true,
+	.mclk_multiplier = 4,
 };
 
 static const struct sun4i_spdif_quirks sun50i_h6_spdif_quirks = {
 	.reg_dac_txdata = SUN8I_SPDIF_TXFIFO,
 	.val_fctl_ftx   = SUN50I_H6_SPDIF_FCTL_FTX,
 	.has_reset      = true,
+	.mclk_multiplier = 1,
 };
 
 static const struct of_device_id sun4i_spdif_of_match[] = {
diff -Naur a/sound/soc/sunxi/sun8i-codec-analog.c b/sound/soc/sunxi/sun8i-codec-analog.c
--- a/sound/soc/sunxi/sun8i-codec-analog.c	2022-08-03 06:03:56.000000000 -0400
+++ b/sound/soc/sunxi/sun8i-codec-analog.c	2022-08-04 04:03:28.201287040 -0400
@@ -729,8 +729,12 @@
 }
 
 static const struct sun8i_codec_analog_quirks sun8i_v3s_quirks = {
-	.has_headphone	= true,
-	.has_hmic	= true,
+	.has_headphone  = true,
+	.has_hmic       = true,
+	.has_linein     = true,
+	.has_lineout    = true,
+	.has_mbias      = true,
+	.has_mic2       = true,
 };
 
 static int sun8i_codec_analog_cmpnt_probe(struct snd_soc_component *cmpnt)
diff -Naur a/sound/soc/sunxi/sun9i-hdmi-audio.c b/sound/soc/sunxi/sun9i-hdmi-audio.c
--- a/sound/soc/sunxi/sun9i-hdmi-audio.c	1969-12-31 19:00:00.000000000 -0500
+++ b/sound/soc/sunxi/sun9i-hdmi-audio.c	2022-08-04 04:03:33.281551468 -0400
@@ -0,0 +1,180 @@
+// SPDX-License-Identifier: GPL-2.0
+//
+// sun9i hdmi audio sound card
+//
+// Copyright (C) 2021 Jernej Skrabec <jernej.skrabec@gmail.com>
+
+#include <linux/module.h>
+#include <linux/of_platform.h>
+
+#include <sound/soc.h>
+#include <sound/soc-dai.h>
+
+static int sun9i_hdmi_audio_hw_params(struct snd_pcm_substream *substream,
+				      struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);
+	unsigned int mclk;
+
+	mclk = params_rate(params) * 128;
+
+	return snd_soc_dai_set_sysclk(asoc_rtd_to_cpu(rtd, 0), 0, mclk,
+				      SND_SOC_CLOCK_OUT);
+}
+
+static const struct snd_soc_ops sun9i_hdmi_audio_ops = {
+	.hw_params = sun9i_hdmi_audio_hw_params,
+};
+
+static int sun9i_hdmi_audio_dai_init(struct snd_soc_pcm_runtime *rtd)
+{
+	int ret;
+
+	/* TODO: switch to custom api once it's implemented in sun4i-i2s */
+	ret = snd_soc_dai_set_tdm_slot(asoc_rtd_to_cpu(rtd, 0), 0, 0, 2, 32);
+	if (ret) {
+		dev_err(asoc_rtd_to_cpu(rtd, 0)->dev,
+			"setting tdm link slots failed\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int sun9i_hdmi_audio_parse_dai(struct device_node *node,
+				      struct snd_soc_dai_link_component *dlc)
+{
+	struct of_phandle_args args;
+	int ret;
+
+	if (!node)
+		return 0;
+
+	ret = of_parse_phandle_with_args(node, "sound-dai",
+					 "#sound-dai-cells", 0, &args);
+	if (ret)
+		return ret;
+
+	ret = snd_soc_get_dai_name(&args, &dlc->dai_name);
+	if (ret < 0) {
+		of_node_put(args.np);
+
+		return ret;
+	}
+
+	dlc->of_node = args.np;
+
+	return 0;
+}
+
+static int sun9i_hdmi_audio_probe(struct platform_device *pdev)
+{
+	struct snd_soc_dai_link_component *dlc;
+	struct device *dev = &pdev->dev;
+	struct snd_soc_dai_link *link;
+	struct snd_soc_card *card;
+	struct device_node *child;
+	int ret;
+
+	card = devm_kzalloc(dev, sizeof(*card), GFP_KERNEL);
+	if (!card)
+		return -ENOMEM;
+
+	link = devm_kzalloc(dev, sizeof(*link), GFP_KERNEL);
+	if (!link)
+		return -ENOMEM;
+
+	dlc = devm_kzalloc(dev, sizeof(*dlc) * 3, GFP_KERNEL);
+	if (!dlc)
+		return -ENOMEM;
+
+	child = of_get_child_by_name(dev->of_node, "codec");
+	if (!child)
+		return -ENODEV;
+
+	ret = sun9i_hdmi_audio_parse_dai(child, &dlc[1]);
+	of_node_put(child);
+	if (ret)
+		return ret;
+
+	child = of_get_child_by_name(dev->of_node, "cpu");
+	if (!child) {
+		ret = -ENODEV;
+		goto out_err;
+	}
+
+	ret = sun9i_hdmi_audio_parse_dai(child, &dlc[0]);
+	of_node_put(child);
+	if (ret)
+		goto out_err;
+
+	dlc[2].of_node = dlc[0].of_node;
+
+	platform_set_drvdata(pdev, card);
+
+	link->cpus = &dlc[0];
+	link->codecs = &dlc[1];
+	link->platforms = &dlc[2];
+
+	link->num_cpus = 1;
+	link->num_codecs = 1;
+	link->num_platforms = 1;
+
+	link->playback_only = 1;
+
+	link->name = "SUN9I-HDMI";
+	link->stream_name = "SUN9I-HDMI PCM";
+
+	link->dai_fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_IF | SND_SOC_DAIFMT_CBS_CFS;
+
+	link->ops = &sun9i_hdmi_audio_ops;
+	link->init = sun9i_hdmi_audio_dai_init;
+
+	card->dai_link = link;
+	card->num_links = 1;
+	card->owner = THIS_MODULE;
+	card->dev = dev;
+	card->name = "sun9i-hdmi";
+
+	ret = devm_snd_soc_register_card(dev, card);
+	if (ret)
+		goto out_err;
+
+	return 0;
+
+out_err:
+	of_node_put(dlc[0].of_node);
+	of_node_put(dlc[1].of_node);
+
+	return ret;
+}
+
+static int sun9i_hdmi_audio_remove(struct platform_device *pdev)
+{
+	struct snd_soc_card *card = platform_get_drvdata(pdev);
+
+	of_node_put(card->dai_link->cpus->of_node);
+	of_node_put(card->dai_link->codecs->of_node);
+
+	return 0;
+}
+
+static const struct of_device_id sun9i_hdmi_audio_match[] = {
+	{ .compatible = "allwinner,sun9i-a80-hdmi-audio" },
+	{}
+};
+MODULE_DEVICE_TABLE(of, sun9i_hdmi_audio_match);
+
+static struct platform_driver sun9i_hdmi_audio_driver = {
+	.probe = sun9i_hdmi_audio_probe,
+	.remove = sun9i_hdmi_audio_remove,
+	.driver = {
+		.name = "sun9i-hdmi-audio",
+		.of_match_table = sun9i_hdmi_audio_match,
+	},
+};
+module_platform_driver(sun9i_hdmi_audio_driver);
+
+MODULE_DESCRIPTION("sun9i HDMI Audio Sound Card");
+MODULE_AUTHOR("Jernej Skrabec <jernej.skrabec@gmail.com>");
+MODULE_LICENSE("GPL v2");
