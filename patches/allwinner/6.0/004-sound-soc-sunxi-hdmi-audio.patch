diff -Naur a/drivers/clk/sunxi-ng/ccu-sun50i-a64.c b/drivers/clk/sunxi-ng/ccu-sun50i-a64.c
--- a/drivers/clk/sunxi-ng/ccu-sun50i-a64.c	2022-08-14 18:50:18.000000000 -0400
+++ b/drivers/clk/sunxi-ng/ccu-sun50i-a64.c	2022-08-17 20:39:43.000000000 -0400
@@ -47,15 +47,35 @@
  * With sigma-delta modulation for fractional-N on the audio PLL,
  * we have to use specific dividers. This means the variable divider
  * can no longer be used, as the audio codec requests the exact clock
- * rates we support through this mechanism. So we now hard code the
- * variable divider to 1. This means the clock rates will no longer
- * match the clock names.
+ * rates we support through this mechanism.
+ *
+ * For the audio codec to work correctly, pll-audio must be exactly
+ * 22579200 Hz or 24576000 Hz, and pll-audio-4x (1x the base) must be
+ * between 3x and 8x that frequency. For the SRC to work at 96 kHz,
+ * pll-audio-4x must be at least 6x pll-audio.
+ *
+ * For now, hard code the variable divider to 3.
  */
 #define SUN50I_A64_PLL_AUDIO_REG	0x008
+#define SUN50I_A64_PLL_AUDIO_BIAS_REG	0x224
 
 static struct ccu_sdm_setting pll_audio_sdm_table[] = {
-	{ .rate = 22579200, .pattern = 0xc0010d84, .m = 8, .n = 7 },
-	{ .rate = 24576000, .pattern = 0xc000ac02, .m = 14, .n = 14 },
+	/* 24000000 * (  7 + 0x10d84 / 131072 ) /  8 / 1 - 22579200 == -6.9Hz */
+	{ .rate =  22579200, .pattern = 0xc0010d84, .m =  8, .n =  7 },
+	/* 24000000 * ( 14 + 0x0ac02 / 131072 ) / 14 / 1 - 24576000 == -2.5Hz */
+	{ .rate =  24576000, .pattern = 0xc000ac08, .m = 14, .n = 14 },
+	/* 24000000 * (  8 + 0x0ef35 / 131072 ) /  3 / 3 - 22579200 ==  3.3Hz */
+	{ .rate =  67737600, .pattern = 0xc000ef35, .m =  3, .n =  8 },
+	/* 24000000 * ( 15 + 0x0b852 / 131072 ) /  5 / 3 - 24576000 ==  1.0Hz */
+	{ .rate =  73728000, .pattern = 0xc000b852, .m =  5, .n = 15 },
+	/* 24000000 * (  7 + 0x10d84 / 131072 ) /  2 / 4 - 22579200 == -6.9Hz */
+	{ .rate =  90316800, .pattern = 0xc0010d84, .m =  2, .n =  7 },
+	/* 24000000 * ( 16 + 0x0c49c / 131072 ) /  4 / 4 - 24576000 ==  4.0Hz */
+	{ .rate =  98304000, .pattern = 0xc000c49c, .m =  4, .n = 16 },
+	/* 24000000 * (  5 + 0x14a23 / 131072 ) /  1 / 6 - 22579200 == -6.9Hz */
+	{ .rate = 135475200, .pattern = 0xc0014a23, .m =  1, .n =  5 },
+	/* 24000000 * ( 12 + 0x09375 / 131072 ) /  2 / 6 - 24576000 ==  4.0Hz */
+	{ .rate = 147456000, .pattern = 0xc0009375, .m =  2, .n = 12 },
 };
 
 static SUNXI_CCU_NM_WITH_SDM_GATE_LOCK(pll_audio_base_clk, "pll-audio-base",
@@ -604,10 +624,10 @@
 	&pll_audio_base_clk.common.hw
 };
 
-/* We hardcode the divider to 1 for now */
+/* We hardcode the divider to 3 for now */
 static CLK_FIXED_FACTOR_HWS(pll_audio_clk, "pll-audio",
 			    clk_parent_pll_audio,
-			    1, 1, CLK_SET_RATE_PARENT);
+			    3, 1, CLK_SET_RATE_PARENT);
 static CLK_FIXED_FACTOR_HWS(pll_audio_2x_clk, "pll-audio-2x",
 			    clk_parent_pll_audio,
 			    2, 1, CLK_SET_RATE_PARENT);
@@ -946,10 +966,13 @@
 	if (IS_ERR(reg))
 		return PTR_ERR(reg);
 
-	/* Force the PLL-Audio-1x divider to 1 */
+	/* Force the pll-audio variable divider to 3 */
 	val = readl(reg + SUN50I_A64_PLL_AUDIO_REG);
 	val &= ~GENMASK(19, 16);
-	writel(val | (0 << 16), reg + SUN50I_A64_PLL_AUDIO_REG);
+	writel(val | (2 << 16), reg + SUN50I_A64_PLL_AUDIO_REG);
+
+	/* Decrease the PLL AUDIO bias current to reduce noise. */
+	writel(0x10040000, reg + SUN50I_A64_PLL_AUDIO_BIAS_REG);
 
 	writel(0x515, reg + SUN50I_A64_PLL_MIPI_REG);
 
diff -Naur a/drivers/mfd/ac100.c b/drivers/mfd/ac100.c
--- a/drivers/mfd/ac100.c	2022-08-14 18:50:18.000000000 -0400
+++ b/drivers/mfd/ac100.c	2022-08-17 20:39:43.000000000 -0400
@@ -80,6 +80,9 @@
 		.name		= "ac100-codec",
 		.of_compatible	= "x-powers,ac100-codec",
 	}, {
+		.name		= "ac100-codec-analog",
+		.of_compatible	= "x-powers,ac100-codec-analog",
+	}, {
 		.name		= "ac100-rtc",
 		.of_compatible	= "x-powers,ac100-rtc",
 	},
diff -Naur a/include/linux/mfd/ac100.h b/include/linux/mfd/ac100.h
--- a/include/linux/mfd/ac100.h	2022-08-14 18:50:18.000000000 -0400
+++ b/include/linux/mfd/ac100.h	2022-08-17 20:39:43.000000000 -0400
@@ -80,6 +80,7 @@
 #define AC100_ERPOUT_CTRL		0x57
 #define AC100_SPKOUT_CTRL		0x58
 #define AC100_LINEOUT_CTRL		0x59
+#define AC100_ADDA_TUNE1 		0x5a
 
 /* ADC digital audio processing (high pass filter & auto gain control */
 #define AC100_ADC_DAP_L_STA		0x80
diff -Naur a/sound/soc/codecs/ec25.c b/sound/soc/codecs/ec25.c
--- a/sound/soc/codecs/ec25.c	1969-12-31 19:00:00.000000000 -0500
+++ b/sound/soc/codecs/ec25.c	2022-08-17 20:39:43.000000000 -0400
@@ -0,0 +1,95 @@
+// SPDX-License-Identifier: GPL-2.0-only
+
+#include <linux/module.h>
+#include <sound/soc.h>
+
+static const struct snd_soc_dapm_widget ec25_dapm_widgets[] = {
+	SND_SOC_DAPM_OUTPUT("AOUT"),
+	SND_SOC_DAPM_INPUT("AIN"),
+};
+
+static const struct snd_soc_dapm_route ec25_dapm_routes[] = {
+	{ "AOUT", NULL, "Playback" },
+	{ "AOUT", NULL, "Wideband Playback" },
+	{ "Capture", NULL, "AIN" },
+	{ "Wideband Capture", NULL, "AIN" },
+};
+
+static const struct snd_soc_component_driver ec25_component_driver = {
+	.dapm_widgets		= ec25_dapm_widgets,
+	.num_dapm_widgets	= ARRAY_SIZE(ec25_dapm_widgets),
+	.dapm_routes		= ec25_dapm_routes,
+	.num_dapm_routes	= ARRAY_SIZE(ec25_dapm_routes),
+	.endianness		= 1,
+	.non_legacy_dai_naming	= 1,
+};
+
+static struct snd_soc_dai_driver ec25_dais[] = {
+	{
+		.name = "ec25",
+		.capture = {
+			.stream_name	= "Capture",
+			.channels_min	= 1,
+			.channels_max	= 1,
+			.rates		= SNDRV_PCM_RATE_8000,
+			.formats	= SNDRV_PCM_FMTBIT_S16_LE,
+		},
+		.playback = {
+			.stream_name	= "Playback",
+			.channels_min	= 1,
+			.channels_max	= 1,
+			.rates		= SNDRV_PCM_RATE_8000,
+			.formats	= SNDRV_PCM_FMTBIT_S16_LE,
+		},
+		.symmetric_rate = 1,
+		.symmetric_channels = 1,
+		.symmetric_sample_bits = 1,
+	},
+	{
+		.name = "ec25-wb",
+		.capture = {
+			.stream_name	= "Wideband Capture",
+			.channels_min	= 1,
+			.channels_max	= 1,
+			.rates		= SNDRV_PCM_RATE_16000,
+			.formats	= SNDRV_PCM_FMTBIT_S16_LE,
+		},
+		.playback = {
+			.stream_name	= "Wideband Playback",
+			.channels_min	= 1,
+			.channels_max	= 1,
+			.rates		= SNDRV_PCM_RATE_16000,
+			.formats	= SNDRV_PCM_FMTBIT_S16_LE,
+		},
+		.symmetric_rate = 1,
+		.symmetric_channels = 1,
+		.symmetric_sample_bits = 1,
+	},
+};
+
+static int ec25_codec_probe(struct platform_device *pdev)
+{
+	return devm_snd_soc_register_component(&pdev->dev, &ec25_component_driver,
+					       ec25_dais, ARRAY_SIZE(ec25_dais));
+}
+
+static const struct of_device_id ec25_codec_of_match[] = {
+	{ .compatible = "quectel,ec25", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, ec25_codec_of_match);
+
+static struct platform_driver ec25_codec_driver = {
+	.driver	= {
+		.name		= "ec25",
+		.of_match_table	= of_match_ptr(ec25_codec_of_match),
+	},
+	.probe	= ec25_codec_probe,
+};
+
+module_platform_driver(ec25_codec_driver);
+
+MODULE_DESCRIPTION("ASoC ec25 driver");
+MODULE_AUTHOR("Samuel Holland <samuel@sholland.org>");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:ec25");
diff -Naur a/sound/soc/codecs/Kconfig b/sound/soc/codecs/Kconfig
--- a/sound/soc/codecs/Kconfig	2022-08-14 18:50:18.000000000 -0400
+++ b/sound/soc/codecs/Kconfig	2022-08-17 20:39:43.000000000 -0400
@@ -903,6 +903,9 @@
 	select SND_PCM_IEC958
 	select HDMI
 
+config SND_SOC_EC25
+	tristate "EC25 LTE module CODEC"
+
 config SND_SOC_ES7134
 	tristate "Everest Semi ES7134 CODEC"
 
diff -Naur a/sound/soc/codecs/Makefile b/sound/soc/codecs/Makefile
--- a/sound/soc/codecs/Makefile	2022-08-14 18:50:18.000000000 -0400
+++ b/sound/soc/codecs/Makefile	2022-08-17 20:39:43.000000000 -0400
@@ -97,6 +97,7 @@
 snd-soc-da732x-objs := da732x.o
 snd-soc-da9055-objs := da9055.o
 snd-soc-dmic-objs := dmic.o
+snd-soc-ec25-objs := ec25.o
 snd-soc-es7134-objs := es7134.o
 snd-soc-es7241-objs := es7241.o
 snd-soc-es8316-objs := es8316.o
@@ -452,6 +453,7 @@
 obj-$(CONFIG_SND_SOC_DA732X)	+= snd-soc-da732x.o
 obj-$(CONFIG_SND_SOC_DA9055)	+= snd-soc-da9055.o
 obj-$(CONFIG_SND_SOC_DMIC)	+= snd-soc-dmic.o
+obj-$(CONFIG_SND_SOC_EC25)	+= snd-soc-ec25.o
 obj-$(CONFIG_SND_SOC_ES7134)	+= snd-soc-es7134.o
 obj-$(CONFIG_SND_SOC_ES7241)	+= snd-soc-es7241.o
 obj-$(CONFIG_SND_SOC_ES8316)    += snd-soc-es8316.o
diff -Naur a/sound/soc/sunxi/ac100-codec.c b/sound/soc/sunxi/ac100-codec.c
--- a/sound/soc/sunxi/ac100-codec.c	1969-12-31 19:00:00.000000000 -0500
+++ b/sound/soc/sunxi/ac100-codec.c	2022-08-17 20:39:43.000000000 -0400
@@ -0,0 +1,1002 @@
+/*
+ * This driver supports the controls for X-Powers (Allwinner)
+ * AC100 audio codec. This codec is co-packaged with AXP81x PMICs.
+ *
+ * (C) Copyright 2020 Ondrej Jirman <megi@xff.cz>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/pm_runtime.h>
+#include <linux/regmap.h>
+#include <linux/mfd/ac100.h>
+
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/tlv.h>
+#include <sound/soc-dapm.h>
+
+#define AC100_ADC_APC_CTRL_ADCR_EN_OFF                          15
+#define AC100_ADC_APC_CTRL_ADCR_EN_MASK                         BIT(15)
+#define AC100_ADC_APC_CTRL_ADCR_EN_DISABLED                     0
+#define AC100_ADC_APC_CTRL_ADCR_EN_ENABLED                      BIT(15)
+#define AC100_ADC_APC_CTRL_ADCR_GAIN_OFF                        12
+#define AC100_ADC_APC_CTRL_ADCR_GAIN(v)                         (((v) & 0x7) << 12)
+#define AC100_ADC_APC_CTRL_ADCL_EN_OFF                          11
+#define AC100_ADC_APC_CTRL_ADCL_EN_MASK                         BIT(11)
+#define AC100_ADC_APC_CTRL_ADCL_EN_DISABLED                     0
+#define AC100_ADC_APC_CTRL_ADCL_EN_ENABLED                      BIT(11)
+#define AC100_ADC_APC_CTRL_ADCL_GAIN_OFF                        8
+#define AC100_ADC_APC_CTRL_ADCL_GAIN(v)                         (((v) & 0x7) << 8)
+#define AC100_ADC_APC_CTRL_MBIAS_EN_OFF                         7
+#define AC100_ADC_APC_CTRL_MBIAS_EN_MASK                        BIT(7)
+#define AC100_ADC_APC_CTRL_MBIAS_EN_DISABLED                    0
+#define AC100_ADC_APC_CTRL_MBIAS_EN_ENABLED                     BIT(7)
+#define AC100_ADC_APC_CTRL_MMIC_BIAS_CHOPPER_EN_OFF             6
+#define AC100_ADC_APC_CTRL_MMIC_BIAS_CHOPPER_EN_MASK            BIT(6)
+#define AC100_ADC_APC_CTRL_MMIC_BIAS_CHOPPER_EN_DISABLED        0
+#define AC100_ADC_APC_CTRL_MMIC_BIAS_CHOPPER_EN_ENABLED         BIT(6)
+#define AC100_ADC_APC_CTRL_MMIC_BIAS_CHOPPER_CKS_OFF            4
+#define AC100_ADC_APC_CTRL_MMIC_BIAS_CHOPPER_CKS_MASK           GENMASK(5, 4)
+#define AC100_ADC_APC_CTRL_MMIC_BIAS_CHOPPER_CKS_250K           (0x0 << 4)
+#define AC100_ADC_APC_CTRL_MMIC_BIAS_CHOPPER_CKS_500K           (0x1 << 4)
+#define AC100_ADC_APC_CTRL_MMIC_BIAS_CHOPPER_CKS_1M             (0x2 << 4)
+#define AC100_ADC_APC_CTRL_MMIC_BIAS_CHOPPER_CKS_2M             (0x3 << 4)
+#define AC100_ADC_APC_CTRL_HBIAS_MODE_OFF                       2
+#define AC100_ADC_APC_CTRL_HBIAS_MODE_MASK                      BIT(2)
+#define AC100_ADC_APC_CTRL_HBIAS_MODE_LOAD                      0
+#define AC100_ADC_APC_CTRL_HBIAS_MODE_HBIAS_EN                  BIT(2)
+#define AC100_ADC_APC_CTRL_HBIAS_EN_OFF                         1
+#define AC100_ADC_APC_CTRL_HBIAS_EN_MASK                        BIT(1)
+#define AC100_ADC_APC_CTRL_HBIAS_EN_DISABLED                    0
+#define AC100_ADC_APC_CTRL_HBIAS_EN_ENABLED                     BIT(1)
+#define AC100_ADC_APC_CTRL_HBIAS_ADC_EN_OFF                     0
+#define AC100_ADC_APC_CTRL_HBIAS_ADC_EN_MASK                    BIT(0)
+#define AC100_ADC_APC_CTRL_HBIAS_ADC_EN_DISABLED                0
+#define AC100_ADC_APC_CTRL_HBIAS_ADC_EN_ENABLED                 BIT(0)
+
+#define AC100_ADC_SRC_ADCR_MIC1_BOOST_OFF                       13
+#define AC100_ADC_SRC_ADCR_MIC1_BOOST_MASK                      BIT(13)
+#define AC100_ADC_SRC_ADCR_MIC1_BOOST_DISABLED                  0
+#define AC100_ADC_SRC_ADCR_MIC1_BOOST_ENABLED                   BIT(13)
+#define AC100_ADC_SRC_ADCR_MIC2_BOOST_OFF                       12
+#define AC100_ADC_SRC_ADCR_MIC2_BOOST_MASK                      BIT(12)
+#define AC100_ADC_SRC_ADCR_MIC2_BOOST_DISABLED                  0
+#define AC100_ADC_SRC_ADCR_MIC2_BOOST_ENABLED                   BIT(12)
+#define AC100_ADC_SRC_ADCR_LINEINL_LINEINR_OFF                  11
+#define AC100_ADC_SRC_ADCR_LINEINL_LINEINR_MASK                 BIT(11)
+#define AC100_ADC_SRC_ADCR_LINEINL_LINEINR_DISABLED             0
+#define AC100_ADC_SRC_ADCR_LINEINL_LINEINR_ENABLED              BIT(11)
+#define AC100_ADC_SRC_ADCR_LINEINR_OFF                          10
+#define AC100_ADC_SRC_ADCR_LINEINR_MASK                         BIT(10)
+#define AC100_ADC_SRC_ADCR_LINEINR_DISABLED                     0
+#define AC100_ADC_SRC_ADCR_LINEINR_ENABLED                      BIT(10)
+#define AC100_ADC_SRC_ADCR_AUXINR_OFF                           9
+#define AC100_ADC_SRC_ADCR_AUXINR_MASK                          BIT(9)
+#define AC100_ADC_SRC_ADCR_AUXINR_DISABLED                      0
+#define AC100_ADC_SRC_ADCR_AUXINR_ENABLED                       BIT(9)
+#define AC100_ADC_SRC_ADCR_ROUTMIX_OFF                          8
+#define AC100_ADC_SRC_ADCR_ROUTMIX_MASK                         BIT(8)
+#define AC100_ADC_SRC_ADCR_ROUTMIX_DISABLED                     0
+#define AC100_ADC_SRC_ADCR_ROUTMIX_ENABLED                      BIT(8)
+#define AC100_ADC_SRC_ADCR_LOUTMIX_OFF                          7
+#define AC100_ADC_SRC_ADCR_LOUTMIX_MASK                         BIT(7)
+#define AC100_ADC_SRC_ADCR_LOUTMIX_DISABLED                     0
+#define AC100_ADC_SRC_ADCR_LOUTMIX_ENABLED                      BIT(7)
+#define AC100_ADC_SRC_ADCL_MIC1_BOOST_OFF                       6
+#define AC100_ADC_SRC_ADCL_MIC1_BOOST_MASK                      BIT(6)
+#define AC100_ADC_SRC_ADCL_MIC1_BOOST_DISABLED                  0
+#define AC100_ADC_SRC_ADCL_MIC1_BOOST_ENABLED                   BIT(6)
+#define AC100_ADC_SRC_ADCL_MIC2_BOOST_OFF                       5
+#define AC100_ADC_SRC_ADCL_MIC2_BOOST_MASK                      BIT(5)
+#define AC100_ADC_SRC_ADCL_MIC2_BOOST_DISABLED                  0
+#define AC100_ADC_SRC_ADCL_MIC2_BOOST_ENABLED                   BIT(5)
+#define AC100_ADC_SRC_ADCL_LINEINL_LINEINR_OFF                  4
+#define AC100_ADC_SRC_ADCL_LINEINL_LINEINR_MASK                 BIT(4)
+#define AC100_ADC_SRC_ADCL_LINEINL_LINEINR_DISABLED             0
+#define AC100_ADC_SRC_ADCL_LINEINL_LINEINR_ENABLED              BIT(4)
+#define AC100_ADC_SRC_ADCL_LINEINL_OFF                          3
+#define AC100_ADC_SRC_ADCL_LINEINL_MASK                         BIT(3)
+#define AC100_ADC_SRC_ADCL_LINEINL_DISABLED                     0
+#define AC100_ADC_SRC_ADCL_LINEINL_ENABLED                      BIT(3)
+#define AC100_ADC_SRC_ADCL_AUXINL_OFF                           2
+#define AC100_ADC_SRC_ADCL_AUXINL_MASK                          BIT(2)
+#define AC100_ADC_SRC_ADCL_AUXINL_DISABLED                      0
+#define AC100_ADC_SRC_ADCL_AUXINL_ENABLED                       BIT(2)
+#define AC100_ADC_SRC_ADCL_LOUTMIX_OFF                          1
+#define AC100_ADC_SRC_ADCL_LOUTMIX_MASK                         BIT(1)
+#define AC100_ADC_SRC_ADCL_LOUTMIX_DISABLED                     0
+#define AC100_ADC_SRC_ADCL_LOUTMIX_ENABLED                      BIT(1)
+#define AC100_ADC_SRC_ADCL_ROUTMIX_OFF                          0
+#define AC100_ADC_SRC_ADCL_ROUTMIX_MASK                         BIT(0)
+#define AC100_ADC_SRC_ADCL_ROUTMIX_DISABLED                     0
+#define AC100_ADC_SRC_ADCL_ROUTMIX_ENABLED                      BIT(0)
+
+#define AC100_ADC_SRC_BST_CTRL_MIC1AMPEN_OFF                    15
+#define AC100_ADC_SRC_BST_CTRL_MIC1AMPEN_MASK                   BIT(15)
+#define AC100_ADC_SRC_BST_CTRL_MIC1AMPEN_DISABLED               0
+#define AC100_ADC_SRC_BST_CTRL_MIC1AMPEN_ENABLED                BIT(15)
+#define AC100_ADC_SRC_BST_CTRL_MIC1BOOST_OFF                    12
+#define AC100_ADC_SRC_BST_CTRL_MIC1BOOST(v)                     (((v) & 0x7) << 12)
+#define AC100_ADC_SRC_BST_CTRL_MIC2AMPEN_OFF                    11
+#define AC100_ADC_SRC_BST_CTRL_MIC2AMPEN_MASK                   BIT(11)
+#define AC100_ADC_SRC_BST_CTRL_MIC2AMPEN_DISABLED               0
+#define AC100_ADC_SRC_BST_CTRL_MIC2AMPEN_ENABLED                BIT(11)
+#define AC100_ADC_SRC_BST_CTRL_MIC2BOOST_OFF                    8
+#define AC100_ADC_SRC_BST_CTRL_MIC2BOOST(v)                     (((v) & 0x7) << 8)
+#define AC100_ADC_SRC_BST_CTRL_MIC2SLT_OFF                      7
+#define AC100_ADC_SRC_BST_CTRL_MIC2SLT_MASK                     BIT(7)
+#define AC100_ADC_SRC_BST_CTRL_MIC2SLT_MIC2                     0
+#define AC100_ADC_SRC_BST_CTRL_MIC2SLT_MIC3                     BIT(7)
+#define AC100_ADC_SRC_BST_CTRL_LINEIN_DIFF_PREG_OFF             4
+#define AC100_ADC_SRC_BST_CTRL_LINEIN_DIFF_PREG(v)              (((v) & 0x7) << 4)
+#define AC100_ADC_SRC_BST_CTRL_AXI_PREG_OFF                     0
+#define AC100_ADC_SRC_BST_CTRL_AXI_PREG(v)                      ((v) & 0x7)
+
+#define AC100_OUT_MXR_DAC_A_CTRL_DAC_AR_EN_OFF                  15
+#define AC100_OUT_MXR_DAC_A_CTRL_DAC_AR_EN_MASK                 BIT(15)
+#define AC100_OUT_MXR_DAC_A_CTRL_DAC_AR_EN_DISABLED             0
+#define AC100_OUT_MXR_DAC_A_CTRL_DAC_AR_EN_ENABLED              BIT(15)
+#define AC100_OUT_MXR_DAC_A_CTRL_DAC_AL_EN_OFF                  14
+#define AC100_OUT_MXR_DAC_A_CTRL_DAC_AL_EN_MASK                 BIT(14)
+#define AC100_OUT_MXR_DAC_A_CTRL_DAC_AL_EN_DISABLED             0
+#define AC100_OUT_MXR_DAC_A_CTRL_DAC_AL_EN_ENABLED              BIT(14)
+#define AC100_OUT_MXR_DAC_A_CTRL_AR_MIX_EN_OFF                  13
+#define AC100_OUT_MXR_DAC_A_CTRL_AR_MIX_EN_MASK                 BIT(13)
+#define AC100_OUT_MXR_DAC_A_CTRL_AR_MIX_EN_DISABLED             0
+#define AC100_OUT_MXR_DAC_A_CTRL_AR_MIX_EN_ENABLED              BIT(13)
+#define AC100_OUT_MXR_DAC_A_CTRL_AL_MIX_EN_OFF                  12
+#define AC100_OUT_MXR_DAC_A_CTRL_AL_MIX_EN_MASK                 BIT(12)
+#define AC100_OUT_MXR_DAC_A_CTRL_AL_MIX_EN_DISABLED             0
+#define AC100_OUT_MXR_DAC_A_CTRL_AL_MIX_EN_ENABLED              BIT(12)
+#define AC100_OUT_MXR_DAC_A_CTRL_HP_DCRM_EN_OFF                 8
+#define AC100_OUT_MXR_DAC_A_CTRL_HP_DCRM_EN(v)                  (((v) & 0xf) << 8)
+
+#define AC100_OUT_MXR_SRC_RMIX_MIC1_BOOST_OFF                   13
+#define AC100_OUT_MXR_SRC_RMIX_MIC1_BOOST_MASK                  BIT(13)
+#define AC100_OUT_MXR_SRC_RMIX_MIC1_BOOST_DISABLED              0
+#define AC100_OUT_MXR_SRC_RMIX_MIC1_BOOST_ENABLED               BIT(13)
+#define AC100_OUT_MXR_SRC_RMIX_MIC2_BOOST_OFF                   12
+#define AC100_OUT_MXR_SRC_RMIX_MIC2_BOOST_MASK                  BIT(12)
+#define AC100_OUT_MXR_SRC_RMIX_MIC2_BOOST_DISABLED              0
+#define AC100_OUT_MXR_SRC_RMIX_MIC2_BOOST_ENABLED               BIT(12)
+#define AC100_OUT_MXR_SRC_RMIX_LINEINL_LINEINR_OFF              11
+#define AC100_OUT_MXR_SRC_RMIX_LINEINL_LINEINR_MASK             BIT(11)
+#define AC100_OUT_MXR_SRC_RMIX_LINEINL_LINEINR_DISABLED         0
+#define AC100_OUT_MXR_SRC_RMIX_LINEINL_LINEINR_ENABLED          BIT(11)
+#define AC100_OUT_MXR_SRC_RMIX_LINEINR_OFF                      10
+#define AC100_OUT_MXR_SRC_RMIX_LINEINR_MASK                     BIT(10)
+#define AC100_OUT_MXR_SRC_RMIX_LINEINR_DISABLED                 0
+#define AC100_OUT_MXR_SRC_RMIX_LINEINR_ENABLED                  BIT(10)
+#define AC100_OUT_MXR_SRC_RMIX_AUXINR_OFF                       9
+#define AC100_OUT_MXR_SRC_RMIX_AUXINR_MASK                      BIT(9)
+#define AC100_OUT_MXR_SRC_RMIX_AUXINR_DISABLED                  0
+#define AC100_OUT_MXR_SRC_RMIX_AUXINR_ENABLED                   BIT(9)
+#define AC100_OUT_MXR_SRC_RMIX_DACR_OFF                         8
+#define AC100_OUT_MXR_SRC_RMIX_DACR_MASK                        BIT(8)
+#define AC100_OUT_MXR_SRC_RMIX_DACR_DISABLED                    0
+#define AC100_OUT_MXR_SRC_RMIX_DACR_ENABLED                     BIT(8)
+#define AC100_OUT_MXR_SRC_RMIX_DACL_OFF                         7
+#define AC100_OUT_MXR_SRC_RMIX_DACL_MASK                        BIT(7)
+#define AC100_OUT_MXR_SRC_RMIX_DACL_DISABLED                    0
+#define AC100_OUT_MXR_SRC_RMIX_DACL_ENABLED                     BIT(7)
+#define AC100_OUT_MXR_SRC_LMIX_MIC1_BOOST_OFF                   6
+#define AC100_OUT_MXR_SRC_LMIX_MIC1_BOOST_MASK                  BIT(6)
+#define AC100_OUT_MXR_SRC_LMIX_MIC1_BOOST_DISABLED              0
+#define AC100_OUT_MXR_SRC_LMIX_MIC1_BOOST_ENABLED               BIT(6)
+#define AC100_OUT_MXR_SRC_LMIX_MIC2_BOOST_OFF                   5
+#define AC100_OUT_MXR_SRC_LMIX_MIC2_BOOST_MASK                  BIT(5)
+#define AC100_OUT_MXR_SRC_LMIX_MIC2_BOOST_DISABLED              0
+#define AC100_OUT_MXR_SRC_LMIX_MIC2_BOOST_ENABLED               BIT(5)
+#define AC100_OUT_MXR_SRC_LMIX_LINEINL_LINEINR_OFF              4
+#define AC100_OUT_MXR_SRC_LMIX_LINEINL_LINEINR_MASK             BIT(4)
+#define AC100_OUT_MXR_SRC_LMIX_LINEINL_LINEINR_DISABLED         0
+#define AC100_OUT_MXR_SRC_LMIX_LINEINL_LINEINR_ENABLED          BIT(4)
+#define AC100_OUT_MXR_SRC_LMIX_LINEINL_OFF                      3
+#define AC100_OUT_MXR_SRC_LMIX_LINEINL_MASK                     BIT(3)
+#define AC100_OUT_MXR_SRC_LMIX_LINEINL_DISABLED                 0
+#define AC100_OUT_MXR_SRC_LMIX_LINEINL_ENABLED                  BIT(3)
+#define AC100_OUT_MXR_SRC_LMIX_AUXINL_OFF                       2
+#define AC100_OUT_MXR_SRC_LMIX_AUXINL_MASK                      BIT(2)
+#define AC100_OUT_MXR_SRC_LMIX_AUXINL_DISABLED                  0
+#define AC100_OUT_MXR_SRC_LMIX_AUXINL_ENABLED                   BIT(2)
+#define AC100_OUT_MXR_SRC_LMIX_DACL_OFF                         1
+#define AC100_OUT_MXR_SRC_LMIX_DACL_MASK                        BIT(1)
+#define AC100_OUT_MXR_SRC_LMIX_DACL_DISABLED                    0
+#define AC100_OUT_MXR_SRC_LMIX_DACL_ENABLED                     BIT(1)
+#define AC100_OUT_MXR_SRC_LMIX_DACR_OFF                         0
+#define AC100_OUT_MXR_SRC_LMIX_DACR_MASK                        BIT(0)
+#define AC100_OUT_MXR_SRC_LMIX_DACR_DISABLED                    0
+#define AC100_OUT_MXR_SRC_LMIX_DACR_ENABLED                     BIT(0)
+
+#define AC100_OUT_MXR_SRC_BST_HMICBIAS_VOLTAGE_OFF              14
+#define AC100_OUT_MXR_SRC_BST_HMICBIAS_VOLTAGE_MASK             GENMASK(15, 14)
+#define AC100_OUT_MXR_SRC_BST_HMICBIAS_VOLTAGE_1_88V            (0x0 << 14)
+#define AC100_OUT_MXR_SRC_BST_HMICBIAS_VOLTAGE_2_09V            (0x1 << 14)
+#define AC100_OUT_MXR_SRC_BST_HMICBIAS_VOLTAGE_2_33V            (0x2 << 14)
+#define AC100_OUT_MXR_SRC_BST_HMICBIAS_VOLTAGE_2_50V            (0x3 << 14)
+#define AC100_OUT_MXR_SRC_BST_MMICBIAS_VOLTAGE_OFF              12
+#define AC100_OUT_MXR_SRC_BST_MMICBIAS_VOLTAGE_MASK             GENMASK(13, 12)
+#define AC100_OUT_MXR_SRC_BST_MMICBIAS_VOLTAGE_1_88V            (0x0 << 12)
+#define AC100_OUT_MXR_SRC_BST_MMICBIAS_VOLTAGE_2_09V            (0x1 << 12)
+#define AC100_OUT_MXR_SRC_BST_MMICBIAS_VOLTAGE_2_33V            (0x2 << 12)
+#define AC100_OUT_MXR_SRC_BST_MMICBIAS_VOLTAGE_2_50V            (0x3 << 12)
+#define AC100_OUT_MXR_SRC_BST_AX_GAIN_OFF                       9
+#define AC100_OUT_MXR_SRC_BST_AX_GAIN(v)                        (((v) & 0x7) << 9)
+#define AC100_OUT_MXR_SRC_BST_MIC1_GAIN_OFF                     6
+#define AC100_OUT_MXR_SRC_BST_MIC1_GAIN(v)                      (((v) & 0x7) << 6)
+#define AC100_OUT_MXR_SRC_BST_MIC2_GAIN_OFF                     3
+#define AC100_OUT_MXR_SRC_BST_MIC2_GAIN(v)                      (((v) & 0x7) << 3)
+#define AC100_OUT_MXR_SRC_BST_LINEIN_GAIN_OFF                   0
+#define AC100_OUT_MXR_SRC_BST_LINEIN_GAIN(v)                    ((v) & 0x7)
+
+#define AC100_HPOUT_CTRL_RIGHT_SRC_OFF                          15
+#define AC100_HPOUT_CTRL_RIGHT_SRC_MASK                         BIT(15)
+#define AC100_HPOUT_CTRL_RIGHT_SRC_DACR                         0
+#define AC100_HPOUT_CTRL_RIGHT_SRC_RAMIX                        BIT(15)
+#define AC100_HPOUT_CTRL_LEFT_SRC_OFF                           14
+#define AC100_HPOUT_CTRL_LEFT_SRC_MASK                          BIT(14)
+#define AC100_HPOUT_CTRL_LEFT_SRC_DACL                          0
+#define AC100_HPOUT_CTRL_LEFT_SRC_LAMIX                         BIT(14)
+#define AC100_HPOUT_CTRL_RIGHT_PA_MUTE_OFF                      13
+#define AC100_HPOUT_CTRL_RIGHT_PA_MUTE_MASK                     BIT(13)
+#define AC100_HPOUT_CTRL_RIGHT_PA_MUTE_MUTE                     0
+#define AC100_HPOUT_CTRL_RIGHT_PA_MUTE_NOT_MUTE                 BIT(13)
+#define AC100_HPOUT_CTRL_LEFT_PA_MUTE_OFF                       12
+#define AC100_HPOUT_CTRL_LEFT_PA_MUTE_MASK                      BIT(12)
+#define AC100_HPOUT_CTRL_LEFT_PA_MUTE_MUTE                      0
+#define AC100_HPOUT_CTRL_LEFT_PA_MUTE_NOT_MUTE                  BIT(12)
+#define AC100_HPOUT_CTRL_PA_EN_OFF                              11
+#define AC100_HPOUT_CTRL_PA_EN_MASK                             BIT(11)
+#define AC100_HPOUT_CTRL_PA_EN_DISABLED                         0
+#define AC100_HPOUT_CTRL_PA_EN_ENABLED                          BIT(11)
+#define AC100_HPOUT_CTRL_VOLUME_OFF                             4
+#define AC100_HPOUT_CTRL_VOLUME(v)                              (((v) & 0x3f) << 4)
+#define AC100_HPOUT_CTRL_STARTUP_DELAY_OFF                      2
+#define AC100_HPOUT_CTRL_STARTUP_DELAY_MASK                     GENMASK(3, 2)
+#define AC100_HPOUT_CTRL_STARTUP_DELAY_4ms                      (0x0 << 2)
+#define AC100_HPOUT_CTRL_STARTUP_DELAY_8ms                      (0x1 << 2)
+#define AC100_HPOUT_CTRL_STARTUP_DELAY_16ms                     (0x2 << 2)
+#define AC100_HPOUT_CTRL_STARTUP_DELAY_32ms                     (0x3 << 2)
+#define AC100_HPOUT_CTRL_OUTPUT_CURRENT_OFF                     0
+#define AC100_HPOUT_CTRL_OUTPUT_CURRENT(v)                      ((v) & 0x3)
+
+#define AC100_ERPOUT_CTRL_RAMP_TIME_OFF                         11
+#define AC100_ERPOUT_CTRL_RAMP_TIME_MASK                        GENMASK(12, 11)
+#define AC100_ERPOUT_CTRL_RAMP_TIME_256ms                       (0x0 << 11)
+#define AC100_ERPOUT_CTRL_RAMP_TIME_512ms                       (0x1 << 11)
+#define AC100_ERPOUT_CTRL_RAMP_TIME_640ms                       (0x2 << 11)
+#define AC100_ERPOUT_CTRL_RAMP_TIME_768ms                       (0x3 << 11)
+#define AC100_ERPOUT_CTRL_OUT_CURRENT_OFF                       9
+#define AC100_ERPOUT_CTRL_OUT_CURRENT(v)                        (((v) & 0x3) << 9)
+#define AC100_ERPOUT_CTRL_INPUT_SOURCE_OFF                      7
+#define AC100_ERPOUT_CTRL_INPUT_SOURCE_MASK                     GENMASK(8, 7)
+#define AC100_ERPOUT_CTRL_INPUT_SOURCE_DACR                     (0x0 << 7)
+#define AC100_ERPOUT_CTRL_INPUT_SOURCE_DACL                     (0x1 << 7)
+#define AC100_ERPOUT_CTRL_INPUT_SOURCE_RAMIX                    (0x2 << 7)
+#define AC100_ERPOUT_CTRL_INPUT_SOURCE_LAMIX                    (0x3 << 7)
+#define AC100_ERPOUT_CTRL_MUTE_OFF                              6
+#define AC100_ERPOUT_CTRL_MUTE_MASK                             BIT(6)
+#define AC100_ERPOUT_CTRL_MUTE_MUTE                             0
+#define AC100_ERPOUT_CTRL_MUTE_NOT_MUTE                         BIT(6)
+#define AC100_ERPOUT_CTRL_PA_EN_OFF                             5
+#define AC100_ERPOUT_CTRL_PA_EN_MASK                            BIT(5)
+#define AC100_ERPOUT_CTRL_PA_EN_DISABLED                        0
+#define AC100_ERPOUT_CTRL_PA_EN_ENABLED                         BIT(5)
+#define AC100_ERPOUT_CTRL_VOLUME_OFF                            0
+#define AC100_ERPOUT_CTRL_VOLUME(v)                             ((v) & 0x1f)
+
+#define AC100_SPKOUT_CTRL_RIGHT_SRC_OFF                         12
+#define AC100_SPKOUT_CTRL_RIGHT_SRC_MASK                        BIT(12)
+#define AC100_SPKOUT_CTRL_RIGHT_SRC_MIXR                        0
+#define AC100_SPKOUT_CTRL_RIGHT_SRC_MIXL_MIXR                   BIT(12)
+#define AC100_SPKOUT_CTRL_RIGHT_INV_EN_OFF                      11
+#define AC100_SPKOUT_CTRL_RIGHT_INV_EN_MASK                     BIT(11)
+#define AC100_SPKOUT_CTRL_RIGHT_INV_EN_DISABLED                 0
+#define AC100_SPKOUT_CTRL_RIGHT_INV_EN_ENABLED                  BIT(11)
+#define AC100_SPKOUT_CTRL_RIGHT_EN_OFF                          9
+#define AC100_SPKOUT_CTRL_RIGHT_EN_MASK                         BIT(9)
+#define AC100_SPKOUT_CTRL_RIGHT_EN_DISABLED                     0
+#define AC100_SPKOUT_CTRL_RIGHT_EN_ENABLED                      BIT(9)
+#define AC100_SPKOUT_CTRL_LEFT_SRC_OFF                          8
+#define AC100_SPKOUT_CTRL_LEFT_SRC_MASK                         BIT(8)
+#define AC100_SPKOUT_CTRL_LEFT_SRC_MIXL                         0
+#define AC100_SPKOUT_CTRL_LEFT_SRC_MIXL_MIXR                    BIT(8)
+#define AC100_SPKOUT_CTRL_LEFT_INV_EN_OFF                       7
+#define AC100_SPKOUT_CTRL_LEFT_INV_EN_MASK                      BIT(7)
+#define AC100_SPKOUT_CTRL_LEFT_INV_EN_DISABLED                  0
+#define AC100_SPKOUT_CTRL_LEFT_INV_EN_ENABLED                   BIT(7)
+#define AC100_SPKOUT_CTRL_LEFT_EN_OFF                           5
+#define AC100_SPKOUT_CTRL_LEFT_EN_MASK                          BIT(5)
+#define AC100_SPKOUT_CTRL_LEFT_EN_DISABLED                      0
+#define AC100_SPKOUT_CTRL_LEFT_EN_ENABLED                       BIT(5)
+#define AC100_SPKOUT_CTRL_VOLUME_OFF                            0
+#define AC100_SPKOUT_CTRL_VOLUME(v)                             ((v) & 0x1f)
+
+#define AC100_LINEOUT_CTRL_LINEOUT_GAIN_OFF                     5
+#define AC100_LINEOUT_CTRL_LINEOUT_GAIN(v)                      (((v) & 0x7) << 5)
+#define AC100_LINEOUT_CTRL_LINEOUT_EN_OFF                       4
+#define AC100_LINEOUT_CTRL_LINEOUT_EN_MASK                      BIT(4)
+#define AC100_LINEOUT_CTRL_LINEOUT_EN_DISABLED                  0
+#define AC100_LINEOUT_CTRL_LINEOUT_EN_ENABLED                   BIT(4)
+#define AC100_LINEOUT_CTRL_LINEOUT_S0_OFF                       3
+#define AC100_LINEOUT_CTRL_LINEOUT_S0_MASK                      BIT(3)
+#define AC100_LINEOUT_CTRL_LINEOUT_S0_MUTE                      0
+#define AC100_LINEOUT_CTRL_LINEOUT_S0_ON                        BIT(3)
+#define AC100_LINEOUT_CTRL_LINEOUT_S1_OFF                       2
+#define AC100_LINEOUT_CTRL_LINEOUT_S1_MASK                      BIT(2)
+#define AC100_LINEOUT_CTRL_LINEOUT_S1_MUTE                      0
+#define AC100_LINEOUT_CTRL_LINEOUT_S1_ON                        BIT(2)
+#define AC100_LINEOUT_CTRL_LINEOUT_S2_OFF                       1
+#define AC100_LINEOUT_CTRL_LINEOUT_S2_MASK                      BIT(1)
+#define AC100_LINEOUT_CTRL_LINEOUT_S2_MUTE                      0
+#define AC100_LINEOUT_CTRL_LINEOUT_S2_ON                        BIT(1)
+#define AC100_LINEOUT_CTRL_LINEOUT_S3_OFF                       0
+#define AC100_LINEOUT_CTRL_LINEOUT_S3_MASK                      BIT(0)
+#define AC100_LINEOUT_CTRL_LINEOUT_S3_MUTE                      0
+#define AC100_LINEOUT_CTRL_LINEOUT_S3_ON                        BIT(0)
+
+#define AC100_ADDA_TUNE1_ZERO_CROSSOVER_EN_OFF                  8
+#define AC100_ADDA_TUNE1_ZERO_CROSSOVER_EN_MASK                 BIT(8)
+#define AC100_ADDA_TUNE1_ZERO_CROSSOVER_EN_DIS                  0
+#define AC100_ADDA_TUNE1_ZERO_CROSSOVER_EN_EN                   BIT(8)
+#define AC100_ADDA_TUNE1_ZERO_CROSSOVER_TIME_OFF                7
+#define AC100_ADDA_TUNE1_ZERO_CROSSOVER_TIME                    BIT(7)
+
+struct ac100_codec {
+	struct device *dev;
+	struct snd_soc_component component;
+};
+
+/* ADC mixer controls */
+static const struct snd_kcontrol_new ac100_codec_adc_mixer_controls[] = {
+	SOC_DAPM_DOUBLE("Mic1 Capture Switch",
+			AC100_ADC_SRC,
+			AC100_ADC_SRC_ADCL_MIC1_BOOST_OFF,
+			AC100_ADC_SRC_ADCR_MIC1_BOOST_OFF, 1, 0),
+	SOC_DAPM_DOUBLE("Mic2 Capture Switch",
+			AC100_ADC_SRC,
+			AC100_ADC_SRC_ADCL_MIC2_BOOST_OFF,
+			AC100_ADC_SRC_ADCR_MIC2_BOOST_OFF, 1, 0),
+	SOC_DAPM_DOUBLE("Line In Differential Capture Switch",
+			AC100_ADC_SRC,
+			AC100_ADC_SRC_ADCL_LINEINL_LINEINR_OFF,
+			AC100_ADC_SRC_ADCR_LINEINL_LINEINR_OFF, 1, 0),
+	SOC_DAPM_DOUBLE("Line In Capture Switch",
+			AC100_ADC_SRC,
+			AC100_ADC_SRC_ADCL_LINEINL_OFF,
+			AC100_ADC_SRC_ADCR_LINEINR_OFF, 1, 0),
+	SOC_DAPM_DOUBLE("Aux In Capture Switch",
+			AC100_ADC_SRC,
+			AC100_ADC_SRC_ADCL_AUXINL_OFF,
+			AC100_ADC_SRC_ADCR_AUXINR_OFF, 1, 0),
+	SOC_DAPM_DOUBLE("Mixer Capture Switch",
+			AC100_ADC_SRC,
+			AC100_ADC_SRC_ADCL_LOUTMIX_OFF,
+			AC100_ADC_SRC_ADCR_ROUTMIX_OFF, 1, 0),
+	SOC_DAPM_DOUBLE("Mixer Reversed Capture Switch",
+			AC100_ADC_SRC,
+			AC100_ADC_SRC_ADCL_ROUTMIX_OFF,
+			AC100_ADC_SRC_ADCR_LOUTMIX_OFF, 1, 0),
+};
+
+/* Output mixer controls */
+static const struct snd_kcontrol_new ac100_codec_mixer_controls[] = {
+	SOC_DAPM_DOUBLE("Mic1 Playback Switch",
+			AC100_OUT_MXR_SRC,
+			AC100_OUT_MXR_SRC_LMIX_MIC1_BOOST_OFF,
+			AC100_OUT_MXR_SRC_RMIX_MIC1_BOOST_OFF, 1, 0),
+	SOC_DAPM_DOUBLE("Mic2 Playback Switch",
+			AC100_OUT_MXR_SRC,
+			AC100_OUT_MXR_SRC_LMIX_MIC2_BOOST_OFF,
+			AC100_OUT_MXR_SRC_RMIX_MIC2_BOOST_OFF, 1, 0),
+	SOC_DAPM_DOUBLE("Line In Differential Playback Switch",
+			AC100_OUT_MXR_SRC,
+			AC100_OUT_MXR_SRC_LMIX_LINEINL_LINEINR_OFF,
+			AC100_OUT_MXR_SRC_RMIX_LINEINL_LINEINR_OFF, 1, 0),
+	SOC_DAPM_DOUBLE("Line In Playback Switch",
+			AC100_OUT_MXR_SRC,
+			AC100_OUT_MXR_SRC_LMIX_LINEINL_OFF,
+			AC100_OUT_MXR_SRC_RMIX_LINEINR_OFF, 1, 0),
+	SOC_DAPM_DOUBLE("Aux In Playback Switch",
+			AC100_OUT_MXR_SRC,
+			AC100_OUT_MXR_SRC_LMIX_AUXINL_OFF,
+			AC100_OUT_MXR_SRC_RMIX_AUXINR_OFF, 1, 0),
+	SOC_DAPM_DOUBLE("DAC Playback Switch",
+			AC100_OUT_MXR_SRC,
+			AC100_OUT_MXR_SRC_LMIX_DACL_OFF,
+			AC100_OUT_MXR_SRC_RMIX_DACR_OFF, 1, 0),
+	SOC_DAPM_DOUBLE("DAC Reversed Playback Switch",
+			AC100_OUT_MXR_SRC,
+			AC100_OUT_MXR_SRC_LMIX_DACR_OFF,
+			AC100_OUT_MXR_SRC_RMIX_DACL_OFF, 1, 0),
+};
+
+static const DECLARE_TLV_DB_SCALE(ac100_codec_out_mixer_pregain_scale,
+				  -450, 150, 0);
+
+static const DECLARE_TLV_DB_RANGE(ac100_codec_mic_gain_scale,
+	0, 0, TLV_DB_SCALE_ITEM(0, 0, 0),
+	1, 7, TLV_DB_SCALE_ITEM(3000, 300, 0),
+);
+
+static const DECLARE_TLV_DB_SCALE(ac100_codec_pre_gain_scale,
+				  -1200, 300, 0);
+
+static const DECLARE_TLV_DB_RANGE(ac100_codec_earpiece_vol_scale,
+	0, 1, TLV_DB_SCALE_ITEM(TLV_DB_GAIN_MUTE, 0, 1),
+	2, 31, TLV_DB_SCALE_ITEM(-4350, 150, 0),
+);
+
+static const DECLARE_TLV_DB_SCALE(ac100_codec_lineout_vol_scale, -450, 150, 0);
+
+static const DECLARE_TLV_DB_SCALE(ac100_codec_hp_vol_scale, -6300, 100, 1);
+
+static const char *ac100_codec_hp_pa_delay_texts[] = {
+	"4ms", "8ms", "16ms", "32ms"
+};
+
+static SOC_ENUM_SINGLE_DECL(ac100_codec_hp_pa_delay_enum,
+			    AC100_HPOUT_CTRL,
+			    AC100_HPOUT_CTRL_STARTUP_DELAY_OFF,
+			    ac100_codec_hp_pa_delay_texts);
+
+static const char *ac100_codec_hp_pa_cur_texts[] = {
+	"low", "mid", "higher", "highest"
+};
+
+static SOC_ENUM_SINGLE_DECL(ac100_codec_hp_pa_cur_enum,
+			    AC100_HPOUT_CTRL,
+			    AC100_HPOUT_CTRL_OUTPUT_CURRENT_OFF,
+			    ac100_codec_hp_pa_cur_texts);
+
+static SOC_ENUM_SINGLE_DECL(ac100_codec_ep_pa_cur_enum,
+			    AC100_ERPOUT_CTRL,
+			    AC100_ERPOUT_CTRL_OUT_CURRENT_OFF,
+			    ac100_codec_hp_pa_cur_texts);
+
+static const char *ac100_codec_ep_pa_ramp_time_texts[] = {
+	"256ms", "512ms", "640ms", "768ms"
+};
+
+static SOC_ENUM_SINGLE_DECL(ac100_codec_ep_pa_ramp_time_enum,
+			    AC100_ERPOUT_CTRL,
+			    AC100_ERPOUT_CTRL_RAMP_TIME_OFF,
+			    ac100_codec_ep_pa_ramp_time_texts);
+
+static const char *ac100_codec_mic_bv_texts[] = {
+	"1.88V", "2.09V", "2.33V", "2.5V"
+};
+
+static SOC_ENUM_SINGLE_DECL(ac100_codec_mic1_bv_enum,
+			    AC100_OUT_MXR_SRC_BST,
+			    AC100_OUT_MXR_SRC_BST_MMICBIAS_VOLTAGE_OFF,
+			    ac100_codec_mic_bv_texts);
+
+static SOC_ENUM_SINGLE_DECL(ac100_codec_mic2_bv_enum,
+			    AC100_OUT_MXR_SRC_BST,
+			    AC100_OUT_MXR_SRC_BST_HMICBIAS_VOLTAGE_OFF,
+			    ac100_codec_mic_bv_texts);
+
+/* volume / mute controls */
+static const struct snd_kcontrol_new ac100_codec_controls[] = {
+	/* Microphone Amp boost gain */
+	SOC_SINGLE_TLV("Mic1 Boost Volume", AC100_ADC_SRC_BST_CTRL,
+		       AC100_ADC_SRC_BST_CTRL_MIC1BOOST_OFF, 0x7, 0,
+		       ac100_codec_mic_gain_scale),
+
+	SOC_SINGLE_TLV("Mic2 Boost Volume", AC100_ADC_SRC_BST_CTRL,
+		       AC100_ADC_SRC_BST_CTRL_MIC2BOOST_OFF, 0x7, 0,
+		       ac100_codec_mic_gain_scale),
+
+	SOC_SINGLE_TLV("Line In Pre-Gain Volume", AC100_ADC_SRC_BST_CTRL,
+		       AC100_ADC_SRC_BST_CTRL_LINEIN_DIFF_PREG_OFF, 0x7, 0,
+		       ac100_codec_pre_gain_scale),
+
+	SOC_SINGLE_TLV("Aux In Pre-Gain Volume", AC100_ADC_SRC_BST_CTRL,
+		       AC100_ADC_SRC_BST_CTRL_AXI_PREG_OFF, 0x7, 0,
+		       ac100_codec_pre_gain_scale),
+
+	/* ADC */
+	SOC_DOUBLE_TLV("ADC Gain Capture Volume", AC100_ADC_APC_CTRL,
+		       AC100_ADC_APC_CTRL_ADCL_GAIN_OFF,
+		       AC100_ADC_APC_CTRL_ADCR_GAIN_OFF, 0x7, 0,
+		       ac100_codec_out_mixer_pregain_scale),
+
+	/* Mixer pre-gain */
+	SOC_SINGLE_TLV("Mic1 Playback Volume", AC100_OUT_MXR_SRC_BST,
+		       AC100_OUT_MXR_SRC_BST_MIC1_GAIN_OFF,
+		       0x7, 0, ac100_codec_out_mixer_pregain_scale),
+
+	SOC_SINGLE_TLV("Mic2 Playback Volume", AC100_OUT_MXR_SRC_BST,
+		       AC100_OUT_MXR_SRC_BST_MIC2_GAIN_OFF,
+		       0x7, 0, ac100_codec_out_mixer_pregain_scale),
+
+	SOC_SINGLE_TLV("Line In Playback Volume", AC100_OUT_MXR_SRC_BST,
+		       AC100_OUT_MXR_SRC_BST_LINEIN_GAIN_OFF,
+		       0x7, 0, ac100_codec_out_mixer_pregain_scale),
+
+	SOC_SINGLE_TLV("Aux In Playback Volume", AC100_OUT_MXR_SRC_BST,
+		       AC100_OUT_MXR_SRC_BST_AX_GAIN_OFF,
+		       0x7, 0, ac100_codec_out_mixer_pregain_scale),
+
+	SOC_SINGLE_TLV("Headphone Playback Volume",
+		       AC100_HPOUT_CTRL,
+		       AC100_HPOUT_CTRL_VOLUME_OFF, 0x3f, 0,
+		       ac100_codec_hp_vol_scale),
+
+	SOC_SINGLE_TLV("Earpiece Playback Volume",
+		       AC100_ERPOUT_CTRL,
+		       AC100_ERPOUT_CTRL_VOLUME_OFF, 0x1f, 0,
+		       ac100_codec_earpiece_vol_scale),
+
+	SOC_SINGLE_TLV("Speaker Playback Volume",
+		       AC100_SPKOUT_CTRL,
+		       AC100_SPKOUT_CTRL_VOLUME_OFF, 0x1f, 0,
+		       ac100_codec_earpiece_vol_scale),
+
+	SOC_SINGLE_TLV("Line Out Playback Volume",
+		       AC100_LINEOUT_CTRL,
+		       AC100_LINEOUT_CTRL_LINEOUT_GAIN_OFF, 0x7, 0,
+		       ac100_codec_lineout_vol_scale),
+
+	SOC_ENUM("Headphone Amplifier Startup Delay",
+		 ac100_codec_hp_pa_delay_enum),
+	SOC_ENUM("Headphone Amplifier Current", ac100_codec_hp_pa_cur_enum),
+
+	SOC_ENUM("Earpiece Amplifier Ramp Time",
+		 ac100_codec_ep_pa_ramp_time_enum),
+	SOC_ENUM("Earpiece Amplifier Current", ac100_codec_ep_pa_cur_enum),
+
+	SOC_ENUM("Mic1 Bias Voltage", ac100_codec_mic1_bv_enum),
+	SOC_ENUM("Mic2 Bias Voltage", ac100_codec_mic2_bv_enum),
+};
+
+/* Headphone */
+
+static const char * const ac100_codec_hp_src_enum_text[] = {
+	"DAC", "Mixer",
+};
+
+static SOC_ENUM_DOUBLE_DECL(ac100_codec_hp_src_enum,
+			    AC100_HPOUT_CTRL,
+			    AC100_HPOUT_CTRL_LEFT_SRC_OFF,
+			    AC100_HPOUT_CTRL_RIGHT_SRC_OFF,
+			    ac100_codec_hp_src_enum_text);
+
+static const struct snd_kcontrol_new ac100_codec_hp_src[] = {
+	SOC_DAPM_ENUM("Headphone Source Playback Route",
+		      ac100_codec_hp_src_enum),
+};
+
+static const struct snd_kcontrol_new ac100_codec_hp_switch =
+	SOC_DAPM_DOUBLE("Headphone Playback Switch",
+			AC100_HPOUT_CTRL,
+			AC100_HPOUT_CTRL_LEFT_PA_MUTE_OFF,
+			AC100_HPOUT_CTRL_RIGHT_PA_MUTE_OFF, 1, 0);
+
+/* Earpiece */
+
+static const struct snd_kcontrol_new ac100_codec_earpiece_switch =
+	SOC_DAPM_SINGLE("Playback Switch",
+			AC100_ERPOUT_CTRL,
+			AC100_ERPOUT_CTRL_MUTE_OFF, 1, 0);
+
+static const char * const ac100_codec_earpiece_src_enum_text[] = {
+	"DACR", "DACL", "Right Mixer", "Left Mixer",
+};
+
+static SOC_ENUM_SINGLE_DECL(ac100_codec_earpiece_src_enum,
+			    AC100_ERPOUT_CTRL,
+			    AC100_ERPOUT_CTRL_INPUT_SOURCE_OFF,
+			    ac100_codec_earpiece_src_enum_text);
+
+static const struct snd_kcontrol_new ac100_codec_earpiece_src[] = {
+	SOC_DAPM_ENUM("Earpiece Source Playback Route",
+		      ac100_codec_earpiece_src_enum),
+};
+
+/* Speaker */
+
+static const char * const ac100_codec_spk_src_enum_text[] = {
+	"Stereo", "Mono",
+};
+
+static SOC_ENUM_DOUBLE_DECL(ac100_codec_spk_src_enum,
+			    AC100_SPKOUT_CTRL,
+			    AC100_SPKOUT_CTRL_LEFT_SRC_OFF,
+			    AC100_SPKOUT_CTRL_RIGHT_SRC_OFF,
+			    ac100_codec_spk_src_enum_text);
+
+static const struct snd_kcontrol_new ac100_codec_spk_src[] = {
+	SOC_DAPM_ENUM("Speaker Source Playback Route",
+		      ac100_codec_spk_src_enum),
+};
+
+static const struct snd_kcontrol_new ac100_codec_spk_switch =
+	SOC_DAPM_DOUBLE("Speaker Playback Switch",
+			AC100_SPKOUT_CTRL,
+			AC100_SPKOUT_CTRL_LEFT_EN_OFF,
+			AC100_SPKOUT_CTRL_RIGHT_EN_OFF, 1, 0);
+
+static const struct snd_kcontrol_new ac100_codec_spk_inv_switch =
+	SOC_DAPM_DOUBLE("Speaker Invert Switch",
+			AC100_SPKOUT_CTRL,
+			AC100_SPKOUT_CTRL_LEFT_INV_EN_OFF,
+			AC100_SPKOUT_CTRL_RIGHT_INV_EN_OFF, 1, 0);
+
+/* Line Out */
+
+static const struct snd_kcontrol_new ac100_codec_lineout_mixer_controls[] = {
+	SOC_DAPM_SINGLE("Mic1 Playback Switch",
+			AC100_LINEOUT_CTRL,
+			AC100_LINEOUT_CTRL_LINEOUT_S0_OFF, 1, 0),
+	SOC_DAPM_SINGLE("Mic2 Playback Switch",
+			AC100_LINEOUT_CTRL,
+			AC100_LINEOUT_CTRL_LINEOUT_S1_OFF, 1, 0),
+	SOC_DAPM_SINGLE("Right Mixer Playback Switch",
+			AC100_LINEOUT_CTRL,
+			AC100_LINEOUT_CTRL_LINEOUT_S2_OFF, 1, 0),
+	SOC_DAPM_SINGLE("Left Mixer Playback Switch",
+			AC100_LINEOUT_CTRL,
+			AC100_LINEOUT_CTRL_LINEOUT_S3_OFF, 1, 0),
+};
+
+static const struct snd_kcontrol_new ac100_codec_lineout_switch =
+	SOC_DAPM_SINGLE("Playback Switch",
+			AC100_LINEOUT_CTRL,
+			AC100_LINEOUT_CTRL_LINEOUT_EN_OFF, 1, 0);
+
+/* Mic2 Boost Source */
+
+static const char * const ac100_codec_mic2boost_src_enum_text[] = {
+	"Mic2", "Mic3",
+};
+
+static SOC_ENUM_SINGLE_DECL(ac100_codec_mic2boost_src_enum,
+			    AC100_ADC_SRC_BST_CTRL,
+			    AC100_ADC_SRC_BST_CTRL_MIC2SLT_OFF,
+			    ac100_codec_mic2boost_src_enum_text);
+
+static const struct snd_kcontrol_new ac100_codec_mic2boost_src[] = {
+	SOC_DAPM_ENUM("Mic2 Source Capture Route",
+		      ac100_codec_mic2boost_src_enum),
+};
+
+/* This is done to remove the headphone buffer DC offset. */
+static int ac100_codec_hp_power(struct snd_soc_dapm_widget *w,
+				struct snd_kcontrol *k, int event)
+{
+	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+	unsigned int val = SND_SOC_DAPM_EVENT_ON(event) ? 0xf : 0;
+
+	// zero cross detection
+	if (SND_SOC_DAPM_EVENT_OFF(event)) {
+		snd_soc_component_update_bits(component,
+					      AC100_ADDA_TUNE1,
+					      AC100_ADDA_TUNE1_ZERO_CROSSOVER_EN_MASK,
+					      AC100_ADDA_TUNE1_ZERO_CROSSOVER_EN_EN);
+	} else {
+		snd_soc_component_update_bits(component,
+					      AC100_ADDA_TUNE1,
+					      AC100_ADDA_TUNE1_ZERO_CROSSOVER_EN_MASK,
+					      AC100_ADDA_TUNE1_ZERO_CROSSOVER_EN_DIS);
+	}
+
+	snd_soc_component_update_bits(component, AC100_OUT_MXR_DAC_A_CTRL,
+				      AC100_OUT_MXR_DAC_A_CTRL_HP_DCRM_EN(0xf),
+				      AC100_OUT_MXR_DAC_A_CTRL_HP_DCRM_EN(val));
+	return 0;
+}
+
+static const struct snd_soc_dapm_widget ac100_codec_widgets[] = {
+	/* DAC */
+	SND_SOC_DAPM_DAC("Left DAC", NULL, AC100_OUT_MXR_DAC_A_CTRL,
+			 AC100_OUT_MXR_DAC_A_CTRL_DAC_AL_EN_OFF, 0),
+	SND_SOC_DAPM_DAC("Right DAC", NULL, AC100_OUT_MXR_DAC_A_CTRL,
+			 AC100_OUT_MXR_DAC_A_CTRL_DAC_AR_EN_OFF, 0),
+
+	/* ADC */
+	SND_SOC_DAPM_ADC("Left ADC", NULL, AC100_ADC_APC_CTRL,
+			 AC100_ADC_APC_CTRL_ADCL_EN_OFF, 0),
+	SND_SOC_DAPM_ADC("Right ADC", NULL, AC100_ADC_APC_CTRL,
+			 AC100_ADC_APC_CTRL_ADCR_EN_OFF, 0),
+
+	/*
+	 * Due to this component and the codec belonging to separate DAPM
+	 * contexts, we need to manually link the above widgets to their
+	 * stream widgets at the card level.
+	 */
+
+        /* Headphones */
+
+	SND_SOC_DAPM_REGULATOR_SUPPLY("cpvdd", 0, 0),
+	SND_SOC_DAPM_MUX("Left Headphone Source",
+			 SND_SOC_NOPM, 0, 0, ac100_codec_hp_src),
+	SND_SOC_DAPM_MUX("Right Headphone Source",
+			 SND_SOC_NOPM, 0, 0, ac100_codec_hp_src),
+	SND_SOC_DAPM_SWITCH("Left Headphone Switch",
+			    SND_SOC_NOPM, 0, 0, &ac100_codec_hp_switch),
+	SND_SOC_DAPM_SWITCH("Right Headphone Switch",
+			    SND_SOC_NOPM, 0, 0, &ac100_codec_hp_switch),
+	SND_SOC_DAPM_OUT_DRV("Left Headphone Amp",
+			     SND_SOC_NOPM, 0, 0, NULL, 0),
+	SND_SOC_DAPM_OUT_DRV("Right Headphone Amp",
+			     SND_SOC_NOPM, 0, 0, NULL, 0),
+	SND_SOC_DAPM_SUPPLY("Headphone Amp", AC100_HPOUT_CTRL,
+			    AC100_HPOUT_CTRL_PA_EN_OFF, 0,
+			    ac100_codec_hp_power,
+			    SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_PRE_PMD),
+	SND_SOC_DAPM_OUTPUT("HP"),
+
+        /* Earpiece */
+
+	SND_SOC_DAPM_MUX("Earpiece Source Playback Route",
+			 SND_SOC_NOPM, 0, 0, ac100_codec_earpiece_src),
+	SND_SOC_DAPM_SWITCH("Earpiece",
+			    SND_SOC_NOPM, 0, 0, &ac100_codec_earpiece_switch),
+	SND_SOC_DAPM_OUT_DRV("Earpiece Amp", AC100_ERPOUT_CTRL,
+			     AC100_ERPOUT_CTRL_PA_EN_OFF, 0, NULL, 0),
+	SND_SOC_DAPM_OUTPUT("EARPIECE"),
+
+	/* Speaker */
+
+	SND_SOC_DAPM_MUX("Left Speaker Source",
+			 SND_SOC_NOPM, 0, 0, ac100_codec_spk_src),
+	SND_SOC_DAPM_MUX("Right Speaker Source",
+			 SND_SOC_NOPM, 0, 0, ac100_codec_spk_src),
+	SND_SOC_DAPM_SWITCH("Left Speaker Switch",
+			    SND_SOC_NOPM, 0, 0, &ac100_codec_spk_switch),
+	SND_SOC_DAPM_SWITCH("Right Speaker Switch",
+			    SND_SOC_NOPM, 0, 0, &ac100_codec_spk_switch),
+	SND_SOC_DAPM_SWITCH("Left Speaker Invert Switch",
+			    SND_SOC_NOPM, 0, 0, &ac100_codec_spk_inv_switch),
+	SND_SOC_DAPM_SWITCH("Right Speaker Invert Switch",
+			    SND_SOC_NOPM, 0, 0, &ac100_codec_spk_inv_switch),
+	SND_SOC_DAPM_OUTPUT("SPKOUTL"),
+	SND_SOC_DAPM_OUTPUT("SPKOUTR"),
+
+	/* Line Out */
+
+	SND_SOC_DAPM_MIXER("Line Out Mixer", SND_SOC_NOPM, 0, 0,
+			   ac100_codec_lineout_mixer_controls,
+			   ARRAY_SIZE(ac100_codec_lineout_mixer_controls)),
+	SND_SOC_DAPM_SWITCH("Line Out",
+			    SND_SOC_NOPM, 0, 0, &ac100_codec_lineout_switch),
+	SND_SOC_DAPM_OUTPUT("LINEOUT"),
+
+	/* Microphone 1 */
+
+	SND_SOC_DAPM_INPUT("MIC1"),
+	SND_SOC_DAPM_SUPPLY("MBIAS", AC100_ADC_APC_CTRL,
+			    AC100_ADC_APC_CTRL_MBIAS_EN_OFF,
+			    0, NULL, 0),
+	SND_SOC_DAPM_PGA("Mic1 Amplifier", AC100_ADC_SRC_BST_CTRL,
+			 AC100_ADC_SRC_BST_CTRL_MIC1AMPEN_OFF, 0, NULL, 0),
+
+        /* Microphone 2 and 3 */
+
+	SND_SOC_DAPM_INPUT("MIC2"),
+	SND_SOC_DAPM_INPUT("MIC3"),
+	SND_SOC_DAPM_MUX("Mic2 Amplifier Source",
+			 SND_SOC_NOPM, 0, 0, ac100_codec_mic2boost_src),
+	SND_SOC_DAPM_SUPPLY("HBIAS", AC100_ADC_APC_CTRL,
+			    AC100_ADC_APC_CTRL_HBIAS_EN_OFF,
+			    0, NULL, 0),
+	SND_SOC_DAPM_PGA("Mic2 Amplifier", AC100_ADC_SRC_BST_CTRL,
+			 AC100_ADC_SRC_BST_CTRL_MIC2AMPEN_OFF, 0, NULL, 0),
+
+	/* Line input */
+
+	SND_SOC_DAPM_INPUT("LINEIN"),
+
+	/* Aux input */
+
+	SND_SOC_DAPM_INPUT("AUXIN"),
+
+	/* Output mixers */
+	SND_SOC_DAPM_MIXER("Left Mixer", AC100_OUT_MXR_DAC_A_CTRL,
+			   AC100_OUT_MXR_DAC_A_CTRL_AL_MIX_EN_OFF, 0,
+			   ac100_codec_mixer_controls,
+			   ARRAY_SIZE(ac100_codec_mixer_controls)),
+	SND_SOC_DAPM_MIXER("Right Mixer", AC100_OUT_MXR_DAC_A_CTRL,
+			   AC100_OUT_MXR_DAC_A_CTRL_AR_MIX_EN_OFF, 0,
+			   ac100_codec_mixer_controls,
+			   ARRAY_SIZE(ac100_codec_mixer_controls)),
+
+	/* Input mixers */
+	SND_SOC_DAPM_MIXER("Left ADC Mixer", SND_SOC_NOPM, 0, 0,
+			   ac100_codec_adc_mixer_controls,
+			   ARRAY_SIZE(ac100_codec_adc_mixer_controls)),
+	SND_SOC_DAPM_MIXER("Right ADC Mixer", SND_SOC_NOPM, 0, 0,
+			   ac100_codec_adc_mixer_controls,
+			   ARRAY_SIZE(ac100_codec_adc_mixer_controls)),
+};
+
+static const struct snd_soc_dapm_route ac100_codec_routes[] = {
+	/* Microphone Routes */
+	{ "Mic1 Amplifier", NULL, "MIC1"},
+	{ "Mic2 Amplifier", NULL, "Mic2 Amplifier Source"},
+	{ "Mic2 Amplifier Source", "Mic2", "MIC2" },
+	{ "Mic2 Amplifier Source", "Mic3", "MIC3" },
+
+	/* Mixer Routes */
+	{ "Left Mixer", "Mic1 Playback Switch", "Mic1 Amplifier" },
+	{ "Left Mixer", "Mic2 Playback Switch", "Mic2 Amplifier" },
+	{ "Left Mixer", "Line In Differential Playback Switch", "LINEIN" },
+	{ "Left Mixer", "Line In Playback Switch", "LINEIN" },
+	{ "Left Mixer", "Aux In Playback Switch", "AUXIN" },
+	{ "Left Mixer", "DAC Playback Switch", "Left DAC" },
+	{ "Left Mixer", "DAC Reversed Playback Switch", "Right DAC" },
+
+	{ "Right Mixer", "Mic1 Playback Switch", "Mic1 Amplifier" },
+	{ "Right Mixer", "Mic2 Playback Switch", "Mic2 Amplifier" },
+	{ "Right Mixer", "Line In Differential Playback Switch", "LINEIN" },
+	{ "Right Mixer", "Line In Playback Switch", "LINEIN" },
+	{ "Right Mixer", "Aux In Playback Switch", "AUXIN" },
+	{ "Right Mixer", "DAC Playback Switch", "Right DAC" },
+	{ "Right Mixer", "DAC Reversed Playback Switch", "Left DAC" },
+
+	/* ADC Mixer Routes */
+	{ "Left ADC Mixer", "Mic1 Capture Switch", "Mic1 Amplifier" },
+	{ "Left ADC Mixer", "Mic2 Capture Switch", "Mic2 Amplifier" },
+	{ "Left ADC Mixer", "Line In Differential Capture Switch", "LINEIN" },
+	{ "Left ADC Mixer", "Line In Capture Switch", "LINEIN" },
+	{ "Left ADC Mixer", "Aux In Capture Switch", "AUXIN" },
+	{ "Left ADC Mixer", "Mixer Capture Switch", "Left Mixer" },
+	{ "Left ADC Mixer", "Mixer Reversed Capture Switch", "Right Mixer" },
+
+	{ "Right ADC Mixer", "Mic1 Capture Switch", "Mic1 Amplifier" },
+	{ "Right ADC Mixer", "Mic2 Capture Switch", "Mic2 Amplifier" },
+	{ "Right ADC Mixer", "Line In Differential Capture Switch", "LINEIN" },
+	{ "Right ADC Mixer", "Line In Capture Switch", "LINEIN" },
+	{ "Right ADC Mixer", "Aux In Capture Switch", "AUXIN" },
+	{ "Right ADC Mixer", "Mixer Capture Switch", "Right Mixer" },
+	{ "Right ADC Mixer", "Mixer Reversed Capture Switch", "Left Mixer" },
+
+	/* ADC Routes */
+	{ "Left ADC", NULL, "Left ADC Mixer" },
+	{ "Right ADC", NULL, "Right ADC Mixer" },
+
+	/* Headphone Routes */
+	{ "Left Headphone Source", "DAC", "Left DAC" },
+	{ "Left Headphone Source", "Mixer", "Left Mixer" },
+	{ "Left Headphone Switch", "Headphone Playback Switch", "Left Headphone Source" },
+	{ "Left Headphone Amp", NULL, "Left Headphone Switch" },
+	{ "Left Headphone Amp", NULL, "Headphone Amp" },
+	{ "HP", NULL, "Left Headphone Amp" },
+
+	{ "Right Headphone Source", "DAC", "Right DAC" },
+	{ "Right Headphone Source", "Mixer", "Right Mixer" },
+	{ "Right Headphone Switch", "Headphone Playback Switch", "Right Headphone Source" },
+	{ "Right Headphone Amp", NULL, "Right Headphone Switch" },
+	{ "Right Headphone Amp", NULL, "Headphone Amp" },
+	{ "HP", NULL, "Right Headphone Amp" },
+
+	{ "Headphone Amp", NULL, "cpvdd" },
+
+	/* Speaker Routes */
+	{ "Left Speaker Source", "Stereo", "Left Mixer" },
+	{ "Left Speaker Source", "Mono", "Right Mixer" },
+	{ "Left Speaker Source", "Mono", "Left Mixer" },
+	{ "Left Speaker Switch", "Speaker Playback Switch", "Left Speaker Source" },
+	{ "SPKOUTL", NULL, "Left Speaker Switch" },
+
+	{ "Right Speaker Source", "Stereo", "Right Mixer" },
+	{ "Right Speaker Source", "Mono", "Right Mixer" },
+	{ "Right Speaker Source", "Mono", "Left Mixer" },
+	{ "Right Speaker Switch", "Speaker Playback Switch", "Right Speaker Source" },
+	{ "SPKOUTR", NULL, "Right Speaker Switch" },
+
+	/* Earpiece Routes */
+	{ "Earpiece Source Playback Route", "DACR", "Right DAC" },
+	{ "Earpiece Source Playback Route", "DACL", "Left DAC" },
+	{ "Earpiece Source Playback Route", "Right Mixer", "Right Mixer" },
+	{ "Earpiece Source Playback Route", "Left Mixer", "Left Mixer" },
+	{ "Earpiece", "Playback Switch", "Earpiece Source Playback Route" },
+	{ "Earpiece Amp", NULL, "Earpiece" },
+	{ "EARPIECE", NULL, "Earpiece Amp" },
+
+	/* Line-out Routes */
+	{ "Line Out", "Playback Switch", "Line Out Mixer" },
+	{ "Line Out Mixer", "Mic1 Playback Switch", "Mic1 Amplifier" },
+	{ "Line Out Mixer", "Mic2 Playback Switch", "Mic2 Amplifier" },
+	{ "Line Out Mixer", "Right Mixer Playback Switch", "Right Mixer" },
+	{ "Line Out Mixer", "Left Mixer Playback Switch", "Left Mixer" },
+	{ "LINEOUT", NULL, "Line Out" },
+};
+
+static int ac100_codec_set_bias_level(struct snd_soc_component *component,
+				      enum snd_soc_bias_level level)
+{
+	if (level == SND_SOC_BIAS_OFF) {
+		pr_err("XX: idle bias off\n");
+	}
+
+	return 0;
+}
+
+static const struct snd_soc_component_driver ac100_codec_analog_cmpnt_drv = {
+	.controls		= ac100_codec_controls,
+	.num_controls		= ARRAY_SIZE(ac100_codec_controls),
+	.dapm_widgets		= ac100_codec_widgets,
+	.num_dapm_widgets	= ARRAY_SIZE(ac100_codec_widgets),
+	.dapm_routes		= ac100_codec_routes,
+	.num_dapm_routes	= ARRAY_SIZE(ac100_codec_routes),
+	.set_bias_level		= ac100_codec_set_bias_level,
+};
+
+static int ac100_codec_probe(struct platform_device *pdev)
+{
+	struct ac100_dev *ac100 = dev_get_drvdata(pdev->dev.parent);
+	struct ac100_codec *codec;
+	int ret = 0;
+
+	codec = devm_kzalloc(&pdev->dev, sizeof(*codec), GFP_KERNEL);
+	if (!codec)
+		return -ENOMEM;
+
+	codec->dev = &pdev->dev;
+	platform_set_drvdata(pdev, codec);
+
+	snd_soc_component_init_regmap(&codec->component, ac100->regmap);
+
+	ret = snd_soc_component_initialize(&codec->component,
+					   &ac100_codec_analog_cmpnt_drv,
+					   &pdev->dev);
+	if (ret < 0)
+		return ret;
+
+	ret = snd_soc_add_component(&codec->component, NULL, 0);
+	if (ret) {
+		dev_err(&pdev->dev,
+			"Failed to register codec component (%d)\n", ret);
+		return ret;
+	}
+
+	return ret;
+}
+
+static int ac100_codec_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_component(&pdev->dev);
+
+	/*
+	 * We do not call snd_soc_component_exit_regmap, because regmap
+	 * is still owned by the mfd device.
+	 */
+	return 0;
+}
+
+static const struct of_device_id ac100_codec_of_match[] = {
+	{ .compatible = "x-powers,ac100-codec-analog" },
+	{}
+};
+MODULE_DEVICE_TABLE(of, ac100_codec_of_match);
+
+static struct platform_driver ac100_codec_driver = {
+	.driver = {
+		.name = "ac100-codec-analog",
+		.of_match_table = ac100_codec_of_match,
+	},
+	.probe = ac100_codec_probe,
+	.remove = ac100_codec_remove,
+};
+module_platform_driver(ac100_codec_driver);
+
+MODULE_DESCRIPTION("X-Powers AC100 codec driver");
+MODULE_AUTHOR("Ondrej Jirman <megi@xff.cz>");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:ac100-codec");
diff -Naur a/sound/soc/sunxi/Kconfig b/sound/soc/sunxi/Kconfig
--- a/sound/soc/sunxi/Kconfig	2022-08-14 18:50:18.000000000 -0400
+++ b/sound/soc/sunxi/Kconfig	2022-08-17 20:39:43.000000000 -0400
@@ -16,12 +16,25 @@
 	depends on MACH_SUN8I || (ARM64 && ARCH_SUNXI) || COMPILE_TEST
 	depends on COMMON_CLK
 	select REGMAP_MMIO
+	select MFD_AC100
 	help
 	  This option enables the digital part of the internal audio codec for
-	  Allwinner sun8i SoC (and particularly A33).
+	  Allwinner sun8i SoC (and particularly A33). It also supports digital
+	  part of X-Powers AC100.
 
 	  Say Y or M if you want to add sun8i digital audio codec support.
 
+config SND_AC100_CODEC
+	tristate "Allwinner (X-Powers) AC100 audio codec (analog part)"
+	depends on OF
+	depends on MACH_SUN8I || COMPILE_TEST
+	select MFD_AC100
+	help
+	  This option enables the audio codec support for Allwinner (X-Powers)
+	  AC100 chip.
+
+	  Say Y or M if you want to add AC100 audio codec support.
+
 config SND_SUN8I_CODEC_ANALOG
 	tristate "Allwinner sun8i Codec Analog Controls Support"
 	depends on MACH_SUN8I || (ARM64 && ARCH_SUNXI) || COMPILE_TEST
@@ -56,6 +69,14 @@
 	  Say Y or M to add support for the S/PDIF audio block in the Allwinner
 	  A10 and affiliated SoCs.
 
+config SND_SUN9I_HDMI_AUDIO
+	tristate "Allwinner sun9i HDMI Audio Sound Card"
+	depends on OF
+	depends on SND_SUN4I_I2S
+	help
+	  Say Y or M to add support for the HDMI Audio sound card for Allwinner
+	  SoCs with DW-HDMI core.
+
 config SND_SUN8I_ADDA_PR_REGMAP
 	tristate
 	select REGMAP
diff -Naur a/sound/soc/sunxi/Makefile b/sound/soc/sunxi/Makefile
--- a/sound/soc/sunxi/Makefile	2022-08-14 18:50:18.000000000 -0400
+++ b/sound/soc/sunxi/Makefile	2022-08-17 20:39:43.000000000 -0400
@@ -6,3 +6,5 @@
 obj-$(CONFIG_SND_SUN50I_CODEC_ANALOG) += sun50i-codec-analog.o
 obj-$(CONFIG_SND_SUN8I_CODEC) += sun8i-codec.o
 obj-$(CONFIG_SND_SUN8I_ADDA_PR_REGMAP) += sun8i-adda-pr-regmap.o
+obj-$(CONFIG_SND_SUN9I_HDMI_AUDIO) += sun9i-hdmi-audio.o
+obj-$(CONFIG_SND_AC100_CODEC) += ac100-codec.o
diff -Naur a/sound/soc/sunxi/sun50i-codec-analog.c b/sound/soc/sunxi/sun50i-codec-analog.c
--- a/sound/soc/sunxi/sun50i-codec-analog.c	2022-08-14 18:50:18.000000000 -0400
+++ b/sound/soc/sunxi/sun50i-codec-analog.c	2022-08-17 20:39:43.000000000 -0400
@@ -116,9 +116,20 @@
 #define SUN50I_ADDA_HS_MBIAS_CTRL	0x0e
 #define SUN50I_ADDA_HS_MBIAS_CTRL_MMICBIASEN	7
 
+#define SUN50I_ADDA_MDET_CTRL		0x1c
+#define SUN50I_ADDA_MDET_CTRL_SELDETADC_FS	4
+#define SUN50I_ADDA_MDET_CTRL_SELDETADC_DB	2
+#define SUN50I_ADDA_MDET_CTRL_SELDETADC_BF	0
+
 #define SUN50I_ADDA_JACK_MIC_CTRL	0x1d
+#define SUN50I_ADDA_JACK_MIC_CTRL_JACKDETEN	7
 #define SUN50I_ADDA_JACK_MIC_CTRL_INNERRESEN	6
 #define SUN50I_ADDA_JACK_MIC_CTRL_HMICBIASEN	5
+#define SUN50I_ADDA_JACK_MIC_CTRL_MICADCEN	4
+
+struct sun50i_codec_analog {
+	bool	internal_bias_resistor;
+};
 
 /* mixer controls */
 static const struct snd_kcontrol_new sun50i_a64_codec_mixer_controls[] = {
@@ -297,6 +308,19 @@
 			SUN50I_ADDA_EARPIECE_CTRL1_ESPPA_MUTE, 1, 0),
 };
 
+static int sun50i_codec_hbias_event(struct snd_soc_dapm_widget *w,
+				    struct snd_kcontrol *kcontrol, int event)
+{
+	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+	u32 value = !!SND_SOC_DAPM_EVENT_ON(event);
+
+	regmap_update_bits(component->regmap, SUN50I_ADDA_JACK_MIC_CTRL,
+			   BIT(SUN50I_ADDA_JACK_MIC_CTRL_MICADCEN),
+			   value << SUN50I_ADDA_JACK_MIC_CTRL_MICADCEN);
+
+	return 0;
+}
+
 static const struct snd_soc_dapm_widget sun50i_a64_codec_widgets[] = {
 	/* DAC */
 	SND_SOC_DAPM_DAC("Left DAC", NULL, SUN50I_ADDA_MIX_DAC_CTRL,
@@ -368,7 +392,8 @@
 	/* Microphone Bias */
 	SND_SOC_DAPM_SUPPLY("HBIAS", SUN50I_ADDA_JACK_MIC_CTRL,
 			    SUN50I_ADDA_JACK_MIC_CTRL_HMICBIASEN,
-			    0, NULL, 0),
+			    0, sun50i_codec_hbias_event,
+			    SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),
 
 	/* Mic input path */
 	SND_SOC_DAPM_PGA("Mic2 Amplifier", SUN50I_ADDA_MIC2_CTRL,
@@ -472,17 +497,57 @@
 	{ "EARPIECE", NULL, "Earpiece Amp" },
 };
 
-static int sun50i_a64_codec_suspend(struct snd_soc_component *component)
+static int sun50i_a64_codec_probe(struct snd_soc_component *component)
 {
-	return regmap_update_bits(component->regmap, SUN50I_ADDA_HP_CTRL,
-				  BIT(SUN50I_ADDA_HP_CTRL_PA_CLK_GATE),
-				  BIT(SUN50I_ADDA_HP_CTRL_PA_CLK_GATE));
+	struct sun50i_codec_analog *codec = snd_soc_component_get_drvdata(component);
+
+	regmap_update_bits(component->regmap, SUN50I_ADDA_JACK_MIC_CTRL,
+			   BIT(SUN50I_ADDA_JACK_MIC_CTRL_INNERRESEN),
+			   codec->internal_bias_resistor <<
+				SUN50I_ADDA_JACK_MIC_CTRL_INNERRESEN);
+
+	/* Select sample interval of the ADC sample to 32ms */
+	regmap_update_bits(component->regmap, SUN50I_ADDA_MDET_CTRL,
+			   0x7 << SUN50I_ADDA_MDET_CTRL_SELDETADC_FS |
+			   0x3 << SUN50I_ADDA_MDET_CTRL_SELDETADC_BF,
+			   0x3 << SUN50I_ADDA_MDET_CTRL_SELDETADC_FS |
+			   0x3 << SUN50I_ADDA_MDET_CTRL_SELDETADC_BF);
+
+	return 0;
 }
 
-static int sun50i_a64_codec_resume(struct snd_soc_component *component)
+static int sun50i_a64_codec_set_bias_level(struct snd_soc_component *component,
+					   enum snd_soc_bias_level level)
 {
-	return regmap_update_bits(component->regmap, SUN50I_ADDA_HP_CTRL,
-				  BIT(SUN50I_ADDA_HP_CTRL_PA_CLK_GATE), 0);
+	struct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);
+	int hbias;
+
+	switch (level) {
+	case SND_SOC_BIAS_OFF:
+		regmap_update_bits(component->regmap, SUN50I_ADDA_JACK_MIC_CTRL,
+				   BIT(SUN50I_ADDA_JACK_MIC_CTRL_JACKDETEN) |
+				   BIT(SUN50I_ADDA_JACK_MIC_CTRL_MICADCEN), 0);
+
+		regmap_update_bits(component->regmap, SUN50I_ADDA_HP_CTRL,
+				   BIT(SUN50I_ADDA_HP_CTRL_PA_CLK_GATE),
+				   BIT(SUN50I_ADDA_HP_CTRL_PA_CLK_GATE));
+		break;
+	case SND_SOC_BIAS_STANDBY:
+		regmap_update_bits(component->regmap, SUN50I_ADDA_HP_CTRL,
+				   BIT(SUN50I_ADDA_HP_CTRL_PA_CLK_GATE), 0);
+
+		hbias = snd_soc_dapm_get_pin_status(dapm, "HBIAS");
+		regmap_update_bits(component->regmap, SUN50I_ADDA_JACK_MIC_CTRL,
+				   BIT(SUN50I_ADDA_JACK_MIC_CTRL_JACKDETEN) |
+				   BIT(SUN50I_ADDA_JACK_MIC_CTRL_MICADCEN),
+				   BIT(SUN50I_ADDA_JACK_MIC_CTRL_JACKDETEN) |
+				   hbias << SUN50I_ADDA_JACK_MIC_CTRL_MICADCEN);
+		break;
+	default:
+		break;
+	}
+
+	return 0;
 }
 
 static const struct snd_soc_component_driver sun50i_codec_analog_cmpnt_drv = {
@@ -492,8 +557,10 @@
 	.num_dapm_widgets	= ARRAY_SIZE(sun50i_a64_codec_widgets),
 	.dapm_routes		= sun50i_a64_codec_routes,
 	.num_dapm_routes	= ARRAY_SIZE(sun50i_a64_codec_routes),
-	.suspend		= sun50i_a64_codec_suspend,
-	.resume			= sun50i_a64_codec_resume,
+	.probe			= sun50i_a64_codec_probe,
+	.set_bias_level		= sun50i_a64_codec_set_bias_level,
+	.idle_bias_on		= true,
+	.suspend_bias_off	= true,
 };
 
 static const struct of_device_id sun50i_codec_analog_of_match[] = {
@@ -506,10 +573,20 @@
 
 static int sun50i_codec_analog_probe(struct platform_device *pdev)
 {
+	struct sun50i_codec_analog *codec;
 	struct regmap *regmap;
 	void __iomem *base;
 	bool enable;
 
+	codec = devm_kzalloc(&pdev->dev, sizeof(*codec), GFP_KERNEL);
+	if (!codec)
+		return -ENOMEM;
+
+	codec->internal_bias_resistor = of_property_read_bool(pdev->dev.of_node,
+					"allwinner,internal-bias-resistor");
+
+	platform_set_drvdata(pdev, codec);
+
 	base = devm_platform_ioremap_resource(pdev, 0);
 	if (IS_ERR(base)) {
 		dev_err(&pdev->dev, "Failed to map the registers\n");
diff -Naur a/sound/soc/sunxi/sun8i-codec.c b/sound/soc/sunxi/sun8i-codec.c
--- a/sound/soc/sunxi/sun8i-codec.c	2022-08-14 18:50:18.000000000 -0400
+++ b/sound/soc/sunxi/sun8i-codec.c	2022-08-17 20:39:43.000000000 -0400
@@ -12,12 +12,18 @@
 #include <linux/module.h>
 #include <linux/delay.h>
 #include <linux/clk.h>
+#include <linux/input.h>
 #include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/mutex.h>
 #include <linux/of_device.h>
 #include <linux/pm_runtime.h>
 #include <linux/regmap.h>
+#include <linux/regulator/consumer.h>
 #include <linux/log2.h>
+#include <linux/mfd/ac100.h>
 
+#include <sound/jack.h>
 #include <sound/pcm_params.h>
 #include <sound/soc.h>
 #include <sound/soc-dapm.h>
@@ -118,6 +124,23 @@
 #define SUN8I_ADC_VOL_CTRL				0x104
 #define SUN8I_ADC_VOL_CTRL_ADCL_VOL			8
 #define SUN8I_ADC_VOL_CTRL_ADCR_VOL			0
+#define SUN8I_HMIC_CTRL1				0x110
+#define SUN8I_HMIC_CTRL1_HMIC_M				12
+#define SUN8I_HMIC_CTRL1_HMIC_N				8
+#define SUN8I_HMIC_CTRL1_MDATA_THRESHOLD_DB		5
+#define SUN8I_HMIC_CTRL1_JACK_OUT_IRQ_EN		4
+#define SUN8I_HMIC_CTRL1_JACK_IN_IRQ_EN			3
+#define SUN8I_HMIC_CTRL1_HMIC_DATA_IRQ_EN		0
+#define SUN8I_HMIC_CTRL2				0x114
+#define SUN8I_HMIC_CTRL2_HMIC_SAMPLE			14
+#define SUN8I_HMIC_CTRL2_HMIC_MDATA_THRESHOLD		8
+#define SUN8I_HMIC_CTRL2_HMIC_SF			6
+#define SUN8I_HMIC_STS					0x118
+#define SUN8I_HMIC_STS_MDATA_DISCARD			13
+#define SUN8I_HMIC_STS_HMIC_DATA			8
+#define SUN8I_HMIC_STS_JACK_OUT_IRQ_ST			4
+#define SUN8I_HMIC_STS_JACK_IN_IRQ_ST			3
+#define SUN8I_HMIC_STS_HMIC_DATA_IRQ_ST			0
 #define SUN8I_DAC_DIG_CTRL				0x120
 #define SUN8I_DAC_DIG_CTRL_ENDA				15
 #define SUN8I_DAC_VOL_CTRL				0x124
@@ -143,6 +166,16 @@
 #define SUN8I_AIF_CLK_CTRL_WORD_SIZ_MASK	GENMASK(5, 4)
 #define SUN8I_AIF_CLK_CTRL_DATA_FMT_MASK	GENMASK(3, 2)
 #define SUN8I_AIF3_CLK_CTRL_AIF3_CLK_SRC_MASK	GENMASK(1, 0)
+#define SUN8I_HMIC_CTRL1_HMIC_M_MASK		GENMASK(15, 12)
+#define SUN8I_HMIC_CTRL1_HMIC_N_MASK		GENMASK(11, 8)
+#define SUN8I_HMIC_CTRL1_MDATA_THRESHOLD_DB_MASK GENMASK(6, 5)
+#define SUN8I_HMIC_CTRL2_HMIC_SAMPLE_MASK	GENMASK(15, 14)
+#define SUN8I_HMIC_CTRL2_HMIC_SF_MASK		GENMASK(7, 6)
+#define SUN8I_HMIC_STS_HMIC_DATA_MASK		GENMASK(12, 8)
+
+#define SUN8I_CODEC_BUTTONS	(SND_JACK_BTN_0|\
+				 SND_JACK_BTN_1|\
+				 SND_JACK_BTN_2)
 
 #define SUN8I_CODEC_PASSTHROUGH_SAMPLE_RATE 48000
 
@@ -177,17 +210,42 @@
 };
 
 struct sun8i_codec_quirks {
-	bool legacy_widgets	: 1;
-	bool lrck_inversion	: 1;
+	bool	bus_clock	: 1;
+	bool	jack_detection	: 1;
+	bool	legacy_widgets	: 1;
+	bool	lrck_inversion	: 1;
 };
 
+enum {
+	SUN8I_JACK_STATUS_DISCONNECTED,
+	SUN8I_JACK_STATUS_WAITING_HBIAS,
+	SUN8I_JACK_STATUS_CONNECTED,
+};
+
+#define AC100_NUM_SUPPLIES 4
+
 struct sun8i_codec {
 	struct regmap			*regmap;
+	struct snd_soc_card		*card;
+	struct clk			*clk_bus;
 	struct clk			*clk_module;
 	const struct sun8i_codec_quirks	*quirks;
 	struct sun8i_codec_aif		aifs[SUN8I_CODEC_NAIFS];
+	struct snd_soc_jack		jack;
+	struct delayed_work		jack_work;
+	int				jack_irq;
+	int				jack_status;
+	int				jack_last_sample;
+	int				jack_last_btn;
+	ktime_t				jack_hbias_ready;
+	int				jack_type;
+	int				last_hmic_irq;
+	struct mutex			jack_mutex;
 	unsigned int			sysclk_rate;
 	int				sysclk_refcnt;
+
+	struct regmap			*ac100_regmap;
+	struct regulator_bulk_data	supplies[AC100_NUM_SUPPLIES];
 };
 
 static struct snd_soc_dai_driver sun8i_codec_dais[];
@@ -197,6 +255,14 @@
 	struct sun8i_codec *scodec = dev_get_drvdata(dev);
 	int ret;
 
+	if (scodec->clk_bus) {
+		ret = clk_prepare_enable(scodec->clk_bus);
+		if (ret) {
+			dev_err(dev, "Failed to enable the bus clock\n");
+			return ret;
+		}
+	}
+
 	regcache_cache_only(scodec->regmap, false);
 
 	ret = regcache_sync(scodec->regmap);
@@ -215,6 +281,9 @@
 	regcache_cache_only(scodec->regmap, true);
 	regcache_mark_dirty(scodec->regmap);
 
+	if (scodec->clk_bus)
+		clk_disable_unprepare(scodec->clk_bus);
+
 	return 0;
 }
 
@@ -580,6 +649,7 @@
 			   SUN8I_AIF_CLK_CTRL_BCLK_DIV_MASK,
 			   bclk_div << SUN8I_AIF_CLK_CTRL_BCLK_DIV);
 
+	if (!scodec->ac100_regmap) {
 	/*
 	 * SYSCLK rate
 	 *
@@ -601,6 +671,7 @@
 	if (!aif->open_streams)
 		scodec->sysclk_refcnt++;
 	scodec->sysclk_rate = sysclk_rate;
+	}
 
 	aif->lrck_div_order = lrck_div_order;
 	aif->sample_rate = sample_rate;
@@ -619,8 +690,11 @@
 	if (aif->open_streams != BIT(substream->stream))
 		goto done;
 
-	clk_rate_exclusive_put(scodec->clk_module);
-	scodec->sysclk_refcnt--;
+	if (!scodec->ac100_regmap) {
+		clk_rate_exclusive_put(scodec->clk_module);
+		scodec->sysclk_refcnt--;
+	}
+
 	aif->lrck_div_order = 0;
 	aif->sample_rate = 0;
 
@@ -893,8 +967,6 @@
 
 static const struct snd_soc_dapm_widget sun8i_codec_dapm_widgets[] = {
 	/* System Clocks */
-	SND_SOC_DAPM_CLOCK_SUPPLY("mod"),
-
 	SND_SOC_DAPM_SUPPLY("AIF1CLK",
 			    SUN8I_SYSCLK_CTL,
 			    SUN8I_SYSCLK_CTL_AIF1CLK_ENA, 0, NULL, 0),
@@ -1055,8 +1127,6 @@
 
 static const struct snd_soc_dapm_route sun8i_codec_dapm_routes[] = {
 	/* Clock Routes */
-	{ "AIF1CLK", NULL, "mod" },
-
 	{ "SYSCLK", NULL, "AIF1CLK" },
 
 	{ "CLK AIF1", NULL, "AIF1CLK" },
@@ -1226,12 +1296,103 @@
 	{ "AIF1 Slot 0 Right", NULL, "DACR" },
 };
 
+static const struct snd_soc_dapm_widget sun8i_codec_dapm_widgets_sun8i[] = {
+	SND_SOC_DAPM_CLOCK_SUPPLY("mod"),
+};
+
+static const struct snd_soc_dapm_route sun8i_codec_dapm_routes_sun8i[] = {
+	{ "AIF1CLK", NULL, "mod" },
+};
+
+static struct snd_soc_jack_pin sun8i_codec_jack_pins[] = {
+	{
+		.pin	= "Headphone Jack",
+		.mask	= SND_JACK_HEADPHONE,
+	},
+	{
+		.pin	= "Headset Microphone",
+		.mask	= SND_JACK_MICROPHONE,
+	},
+};
+
+static int sun8i_codec_jack_init(struct sun8i_codec *scodec)
+{
+	int pins = 0;
+	int type = 0;
+	int i, ret;
+
+	for (i = 0; i < ARRAY_SIZE(sun8i_codec_jack_pins); ++i) {
+		struct snd_soc_jack_pin *pin = &sun8i_codec_jack_pins[i];
+		struct snd_soc_dapm_widget *w;
+
+		for_each_card_widgets(scodec->card, w) {
+			if (!strcmp(pin->pin, w->name)) {
+				pins |= BIT(i);
+				type |= pin->mask;
+				break;
+			}
+		}
+	}
+
+	if (!type)
+		return 0;
+
+	if (type & SND_JACK_MICROPHONE)
+		type |= SUN8I_CODEC_BUTTONS;
+
+	ret = snd_soc_card_jack_new(scodec->card, "Headset Jack", type,
+				    &scodec->jack);
+	if (ret)
+		return ret;
+
+	for (i = 0; i < ARRAY_SIZE(sun8i_codec_jack_pins); ++i) {
+		struct snd_soc_jack_pin *pin = &sun8i_codec_jack_pins[i];
+
+		if (pins & BIT(i)) {
+			ret = snd_soc_jack_add_pins(&scodec->jack, 1, pin);
+			if (ret)
+				return ret;
+		}
+	}
+
+	if (type & SND_JACK_MICROPHONE) {
+		struct snd_jack *jack = scodec->jack.jack;
+
+		snd_jack_set_key(jack, SND_JACK_BTN_0, KEY_PLAYPAUSE);
+		snd_jack_set_key(jack, SND_JACK_BTN_1, KEY_VOLUMEUP);
+		snd_jack_set_key(jack, SND_JACK_BTN_2, KEY_VOLUMEDOWN);
+	}
+
+	scodec->jack_type = type;
+
+	return 0;
+}
+
+static int ac100_codec_component_probe(struct snd_soc_component *component);
+
 static int sun8i_codec_component_probe(struct snd_soc_component *component)
 {
 	struct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);
 	struct sun8i_codec *scodec = snd_soc_component_get_drvdata(component);
 	int ret;
 
+	if (scodec->ac100_regmap)
+                return ac100_codec_component_probe(component);
+
+	ret = snd_soc_dapm_new_controls(dapm,
+					sun8i_codec_dapm_widgets_sun8i,
+					ARRAY_SIZE(sun8i_codec_dapm_widgets_sun8i));
+	if (ret)
+		return ret;
+
+	ret = snd_soc_dapm_add_routes(dapm,
+				      sun8i_codec_dapm_routes_sun8i,
+				      ARRAY_SIZE(sun8i_codec_dapm_routes_sun8i));
+	if (ret)
+		return ret;
+
+	scodec->card = component->card;
+
 	/* Add widgets for backward compatibility with old device trees. */
 	if (scodec->quirks->legacy_widgets) {
 		ret = snd_soc_dapm_new_controls(dapm, sun8i_codec_legacy_widgets,
@@ -1265,9 +1426,57 @@
 	/* Program the default sample rate. */
 	sun8i_codec_update_sample_rate(scodec);
 
+	if (scodec->quirks->jack_detection) {
+		ret = sun8i_codec_jack_init(scodec);
+		if (ret)
+			return ret;
+	}
+
+	if (scodec->jack_type) {
+		int irq_mask = BIT(SUN8I_HMIC_CTRL1_JACK_OUT_IRQ_EN) |
+			       BIT(SUN8I_HMIC_CTRL1_JACK_IN_IRQ_EN);
+
+		/* Reserved value required for jack IRQs to trigger. */
+		regmap_write(scodec->regmap, SUN8I_HMIC_CTRL1,
+				   0xf << SUN8I_HMIC_CTRL1_HMIC_N |
+				   0x0 << SUN8I_HMIC_CTRL1_MDATA_THRESHOLD_DB |
+				   0x4 << SUN8I_HMIC_CTRL1_HMIC_M);
+
+		/* Sample the ADC at 128 Hz; bypass smooth filter. */
+		regmap_write(scodec->regmap, SUN8I_HMIC_CTRL2,
+				   0x0 << SUN8I_HMIC_CTRL2_HMIC_SAMPLE |
+				   0x17 << SUN8I_HMIC_CTRL2_HMIC_MDATA_THRESHOLD |
+				   0x0 << SUN8I_HMIC_CTRL2_HMIC_SF);
+
+		/* Do not discard any MDATA, enable user written MDATA threshold. */
+		regmap_write(scodec->regmap, SUN8I_HMIC_STS, 0);
+
+		regmap_update_bits(scodec->regmap, SUN8I_HMIC_CTRL1,
+				   irq_mask, irq_mask);
+
+		enable_irq(scodec->jack_irq);
+	}
+
 	return 0;
 }
 
+static void sun8i_codec_component_remove(struct snd_soc_component *component)
+{
+	struct sun8i_codec *scodec = snd_soc_component_get_drvdata(component);
+
+	if (scodec->jack_type) {
+		int irq_mask = BIT(SUN8I_HMIC_CTRL1_JACK_OUT_IRQ_EN) |
+			       BIT(SUN8I_HMIC_CTRL1_JACK_IN_IRQ_EN)  |
+			       BIT(SUN8I_HMIC_CTRL1_HMIC_DATA_IRQ_EN);
+
+		disable_irq(scodec->jack_irq);
+		cancel_delayed_work_sync(&scodec->jack_work);
+
+		regmap_update_bits(scodec->regmap, SUN8I_HMIC_CTRL1,
+				   irq_mask, 0);
+	}
+}
+
 static const struct snd_soc_component_driver sun8i_soc_component = {
 	.controls		= sun8i_codec_controls,
 	.num_controls		= ARRAY_SIZE(sun8i_codec_controls),
@@ -1276,29 +1485,397 @@
 	.dapm_routes		= sun8i_codec_dapm_routes,
 	.num_dapm_routes	= ARRAY_SIZE(sun8i_codec_dapm_routes),
 	.probe			= sun8i_codec_component_probe,
+	.remove			= sun8i_codec_component_remove,
 	.idle_bias_on		= 1,
+	.suspend_bias_off	= 1,
 	.endianness		= 1,
 };
 
-static const struct regmap_config sun8i_codec_regmap_config = {
+static bool sun8i_codec_volatile_reg(struct device *dev, unsigned int reg)
+{
+	return reg == SUN8I_HMIC_STS;
+}
+
+static struct regmap_config sun8i_codec_regmap_config = {
 	.reg_bits	= 32,
 	.reg_stride	= 4,
 	.val_bits	= 32,
+	.volatile_reg	= sun8i_codec_volatile_reg,
 	.max_register	= SUN8I_DAC_MXR_SRC,
 
 	.cache_type	= REGCACHE_FLAT,
 };
 
+static void sun8i_codec_set_hmic_bias(struct sun8i_codec *scodec, bool enable)
+{
+	struct snd_soc_dapm_context *dapm = &scodec->card->dapm;
+	int irq_mask = BIT(SUN8I_HMIC_CTRL1_HMIC_DATA_IRQ_EN);
+
+	if (enable)
+		snd_soc_dapm_force_enable_pin(dapm, "HBIAS");
+	else
+		snd_soc_dapm_disable_pin(dapm, "HBIAS");
+	snd_soc_dapm_sync(dapm);
+
+	dev_dbg(scodec->card->dev, "HMIC bias %s\n", enable ? "on" : "off");
+
+	regmap_update_bits(scodec->regmap, SUN8I_HMIC_CTRL1,
+			   irq_mask, enable ? irq_mask : 0);
+}
+
+static void sun8i_codec_jack_work(struct work_struct *work)
+{
+	struct sun8i_codec *scodec = container_of(work, struct sun8i_codec,
+						  jack_work.work);
+	unsigned int mdata;
+	int type;
+
+	mutex_lock(&scodec->jack_mutex);
+
+	if (scodec->jack_status == SUN8I_JACK_STATUS_DISCONNECTED) {
+		if (scodec->last_hmic_irq != SUN8I_HMIC_STS_JACK_IN_IRQ_ST)
+			goto out_unlock;
+
+		scodec->jack_last_sample = -1;
+		scodec->jack_last_btn = 0;
+
+		if (scodec->jack_type & SND_JACK_MICROPHONE) {
+			/*
+			 * If we were in disconnected state, we just enable HBIAS and
+			 * wait 500ms before reading initial HDATA value.
+			 */
+			scodec->jack_hbias_ready = ktime_add_ms(ktime_get(), 600);
+			scodec->jack_status = SUN8I_JACK_STATUS_WAITING_HBIAS;
+			sun8i_codec_set_hmic_bias(scodec, true);
+			queue_delayed_work(system_power_efficient_wq,
+					   &scodec->jack_work,
+					   msecs_to_jiffies(610));
+		} else {
+			type = SND_JACK_HEADPHONE;
+			snd_soc_jack_report(&scodec->jack, 0, scodec->jack_type);
+			scodec->jack_status = SUN8I_JACK_STATUS_CONNECTED;
+		}
+	} else if (scodec->jack_status == SUN8I_JACK_STATUS_WAITING_HBIAS) {
+		/*
+		 * If we're waiting for HBIAS to stabilize, and we get plug-out
+		 * interrupt and nothing more for > 100ms, just cancel the
+		 * initialization.
+		 */
+		if (scodec->last_hmic_irq == SUN8I_HMIC_STS_JACK_OUT_IRQ_ST) {
+			scodec->jack_status = SUN8I_JACK_STATUS_DISCONNECTED;
+			sun8i_codec_set_hmic_bias(scodec, false);
+			goto out_unlock;
+		}
+
+		/*
+		 * If we're not done waiting for things to stabilize, wait more.
+		 */
+		if (!ktime_after(ktime_get(), scodec->jack_hbias_ready)) {
+			s64 msecs = ktime_ms_delta(scodec->jack_hbias_ready, ktime_get());
+
+			queue_delayed_work(system_power_efficient_wq,
+					   &scodec->jack_work,
+					   msecs_to_jiffies(msecs + 10));
+			goto out_unlock;
+		}
+
+		/*
+		 * Everything is stabilized, determine jack type and report it.
+		 */
+		regmap_read(scodec->regmap, SUN8I_HMIC_STS, &mdata);
+		mdata &= SUN8I_HMIC_STS_HMIC_DATA_MASK;
+		mdata >>= SUN8I_HMIC_STS_HMIC_DATA;
+
+		regmap_write(scodec->regmap, SUN8I_HMIC_STS, 0);
+
+		if (mdata < 0x10) {
+			type = SND_JACK_HEADPHONE;
+
+			sun8i_codec_set_hmic_bias(scodec, false);
+		} else {
+			type = SND_JACK_HEADSET;
+
+			/* Set MDATA threshold for triggering DATA interrupts
+			 * slightly bellow the initial value read at connection
+			 * time. This assumes that user is not pressing a button
+			 * when connecting the jack cable. It's an unlinkely
+			 * situation, unless the person has 3 hands or more.
+			 */
+			/*
+			pr_err("jack: new mdata threshold: %#x\n", mdata);
+			regmap_write(scodec->regmap, SUN8I_HMIC_CTRL2,
+					   0x0 << SUN8I_HMIC_CTRL2_HMIC_SAMPLE |
+					   (mdata - 3) << SUN8I_HMIC_CTRL2_HMIC_MDATA_THRESHOLD |
+					   0x0 << SUN8I_HMIC_CTRL2_HMIC_SF);
+			   */
+		}
+
+		snd_soc_jack_report(&scodec->jack, type, scodec->jack_type);
+		scodec->jack_status = SUN8I_JACK_STATUS_CONNECTED;
+
+		pr_err("jack: plug-in reported\n");
+	} else if (scodec->jack_status == SUN8I_JACK_STATUS_CONNECTED) {
+		if (scodec->last_hmic_irq == SUN8I_HMIC_STS_JACK_OUT_IRQ_ST) {
+			scodec->jack_status = SUN8I_JACK_STATUS_DISCONNECTED;
+			if (scodec->jack_type & SND_JACK_MICROPHONE)
+				sun8i_codec_set_hmic_bias(scodec, false);
+
+			snd_soc_jack_report(&scodec->jack, 0, scodec->jack_type);
+			pr_err("jack: plug-out reported\n");
+		}
+	}
+
+out_unlock:
+	mutex_unlock(&scodec->jack_mutex);
+}
+
+static irqreturn_t sun8i_codec_jack_irq(int irq, void *dev_id)
+{
+	struct sun8i_codec *scodec = dev_id;
+	unsigned int status;
+
+	mutex_lock(&scodec->jack_mutex);
+
+	regmap_read(scodec->regmap, SUN8I_HMIC_STS, &status);
+	regmap_write(scodec->regmap, SUN8I_HMIC_STS, status);
+
+	if (status & BIT(SUN8I_HMIC_STS_JACK_OUT_IRQ_ST)) {
+		pr_err("jack: irq plug-out\n");
+
+		scodec->last_hmic_irq = SUN8I_HMIC_STS_JACK_OUT_IRQ_ST;
+		queue_delayed_work(system_power_efficient_wq,
+				   &scodec->jack_work,
+				   msecs_to_jiffies(100));
+	} else if (status & BIT(SUN8I_HMIC_STS_JACK_IN_IRQ_ST)) {
+		pr_err("jack: irq plug-in\n");
+
+		scodec->last_hmic_irq = SUN8I_HMIC_STS_JACK_IN_IRQ_ST;
+		queue_delayed_work(system_power_efficient_wq,
+				   &scodec->jack_work,
+				   msecs_to_jiffies(100));
+	} else if (status & BIT(SUN8I_HMIC_STS_HMIC_DATA_IRQ_ST)) {
+		if (scodec->jack_status == SUN8I_JACK_STATUS_CONNECTED) {
+			unsigned int value;
+			int type = SND_JACK_HEADSET;
+			int btn_chg = 0;
+
+			regmap_read(scodec->regmap, SUN8I_HMIC_STS, &value);
+			value  &= SUN8I_HMIC_STS_HMIC_DATA_MASK;
+			value >>= SUN8I_HMIC_STS_HMIC_DATA;
+
+			if (value < 0x2)
+				type |= SND_JACK_BTN_0;
+			else if (value < 0x7)
+				type |= SND_JACK_BTN_1;
+			else if (value < 0x10)
+				type |= SND_JACK_BTN_2;
+
+			if (scodec->jack_last_sample >= 0 && scodec->jack_last_sample == value) {
+				btn_chg = (scodec->jack_last_btn ^ type) & 0x7000;
+				scodec->jack_last_btn = type;
+
+				//XXX: temporary for debugging
+				if (btn_chg) {
+					if (btn_chg & SND_JACK_BTN_0)
+						pr_err("jack: key_%spress BTN_0 (%#x)\n", type & SND_JACK_BTN_0 ? "" : "de", value);
+					if (btn_chg & SND_JACK_BTN_1)
+						pr_err("jack: key_%spress BTN_1 (%#x)\n", type & SND_JACK_BTN_1 ? "" : "de", value);
+					if (btn_chg & SND_JACK_BTN_2)
+						pr_err("jack: key_%spress BTN_2 (%#x)\n", type & SND_JACK_BTN_2 ? "" : "de", value);
+				}
+
+				snd_soc_jack_report(&scodec->jack, type, scodec->jack_type);
+			}
+
+			scodec->jack_last_sample = value;
+		}
+	} else {
+		mutex_unlock(&scodec->jack_mutex);
+		return IRQ_NONE;
+	}
+
+	mutex_unlock(&scodec->jack_mutex);
+	return IRQ_HANDLED;
+}
+
+/* AC100 Codec Support (digital parts) */
+
+static int sun8i_codec_ac100_regmap_read(void *context, unsigned int reg, unsigned int *val)
+{
+	struct sun8i_codec *scodec = context;
+
+	return regmap_read(scodec->ac100_regmap, reg / 4, val);
+}
+
+static int sun8i_codec_ac100_regmap_write(void *context, unsigned int reg, unsigned int val)
+{
+	struct sun8i_codec *scodec = context;
+
+	return regmap_write(scodec->ac100_regmap, reg / 4, val);
+}
+
+static struct regmap_bus sun8i_codec_ac100_regmap_bus = {
+	.reg_write = sun8i_codec_ac100_regmap_write,
+	.reg_read = sun8i_codec_ac100_regmap_read,
+};
+
+static const char *const ac100_supply_names[AC100_NUM_SUPPLIES] = {
+	"LDOIN",
+	"AVCC",
+	"VDDIO1",
+	"VDDIO2",
+};
+
+#define AC100_SYSCLK_CTRL_PLLCLK_ENA_OFF                        15
+#define AC100_SYSCLK_CTRL_PLLCLK_ENA_MASK                       BIT(15)
+#define AC100_SYSCLK_CTRL_PLLCLK_ENA_DISABLED                   0
+#define AC100_SYSCLK_CTRL_PLLCLK_ENA_ENABLED                    BIT(15)
+#define AC100_SYSCLK_CTRL_PLLCLK_SRC_OFF                        12
+#define AC100_SYSCLK_CTRL_PLLCLK_SRC_MASK                       GENMASK(13, 12)
+#define AC100_SYSCLK_CTRL_PLLCLK_SRC_MCLK1                      (0x0 << 12)
+#define AC100_SYSCLK_CTRL_PLLCLK_SRC_MCLK2                      (0x1 << 12)
+#define AC100_SYSCLK_CTRL_PLLCLK_SRC_BCLK1                      (0x2 << 12)
+#define AC100_SYSCLK_CTRL_PLLCLK_SRC_BCLK2                      (0x3 << 12)
+#define AC100_SYSCLK_CTRL_I2S1CLK_ENA_OFF                       11
+#define AC100_SYSCLK_CTRL_I2S1CLK_ENA_MASK                      BIT(11)
+#define AC100_SYSCLK_CTRL_I2S1CLK_ENA_DISABLED                  0
+#define AC100_SYSCLK_CTRL_I2S1CLK_ENA_ENABLED                   BIT(11)
+#define AC100_SYSCLK_CTRL_I2S1CLK_SRC_OFF                       8
+#define AC100_SYSCLK_CTRL_I2S1CLK_SRC_MASK                      GENMASK(9, 8)
+#define AC100_SYSCLK_CTRL_I2S1CLK_SRC_MCLK1                     (0x0 << 8)
+#define AC100_SYSCLK_CTRL_I2S1CLK_SRC_MCLK2                     (0x1 << 8)
+#define AC100_SYSCLK_CTRL_I2S1CLK_SRC_PLL                       (0x2 << 8)
+#define AC100_SYSCLK_CTRL_I2S2CLK_ENA_OFF                       7
+#define AC100_SYSCLK_CTRL_I2S2CLK_ENA_MASK                      BIT(7)
+#define AC100_SYSCLK_CTRL_I2S2CLK_ENA_DISABLED                  0
+#define AC100_SYSCLK_CTRL_I2S2CLK_ENA_ENABLED                   BIT(7)
+#define AC100_SYSCLK_CTRL_I2S2CLK_SRC_OFF                       4
+#define AC100_SYSCLK_CTRL_I2S2CLK_SRC_MASK                      GENMASK(5, 4)
+#define AC100_SYSCLK_CTRL_I2S2CLK_SRC_MCLK1                     (0x0 << 4)
+#define AC100_SYSCLK_CTRL_I2S2CLK_SRC_MCLK2                     (0x1 << 4)
+#define AC100_SYSCLK_CTRL_I2S2CLK_SRC_PLL                       (0x2 << 4)
+#define AC100_SYSCLK_CTRL_SYSCLK_ENA_OFF                        3
+#define AC100_SYSCLK_CTRL_SYSCLK_ENA_MASK                       BIT(3)
+#define AC100_SYSCLK_CTRL_SYSCLK_ENA_DISABLED                   0
+#define AC100_SYSCLK_CTRL_SYSCLK_ENA_ENABLED                    BIT(3)
+#define AC100_SYSCLK_CTRL_SYSCLK_SRC_OFF                        0
+#define AC100_SYSCLK_CTRL_SYSCLK_SRC_MASK                       BIT(0)
+#define AC100_SYSCLK_CTRL_SYSCLK_SRC_I2S1CLK                    0
+#define AC100_SYSCLK_CTRL_SYSCLK_SRC_I2S2CLK                    BIT(0)
+
+
+static int ac100_codec_component_probe(struct snd_soc_component *component)
+{
+	struct sun8i_codec *scodec = snd_soc_component_get_drvdata(component);
+
+        // The system clock(SYSCLK) of AC100 must be 512*fs(fs=48KHz or 44.1KHz)
+
+        // Source clocks from the SoC
+
+        regmap_update_bits(scodec->ac100_regmap, AC100_SYSCLK_CTRL,
+                            AC100_SYSCLK_CTRL_I2S1CLK_SRC_MASK,
+                            AC100_SYSCLK_CTRL_I2S1CLK_SRC_MCLK1);
+        regmap_update_bits(scodec->ac100_regmap, AC100_SYSCLK_CTRL,
+                            AC100_SYSCLK_CTRL_I2S2CLK_SRC_MASK,
+                            AC100_SYSCLK_CTRL_I2S2CLK_SRC_MCLK1);
+        regmap_update_bits(scodec->ac100_regmap, AC100_SYSCLK_CTRL,
+                            AC100_SYSCLK_CTRL_SYSCLK_SRC_MASK,
+                            AC100_SYSCLK_CTRL_SYSCLK_SRC_I2S1CLK);
+
+	/* Program the default sample rate. */
+	sun8i_codec_update_sample_rate(scodec);
+
+        return 0;
+}
+
+static int sun8i_codec_probe_ac100(struct platform_device *pdev)
+{
+	struct ac100_dev *ac100 = dev_get_drvdata(pdev->dev.parent);
+	struct device* dev = &pdev->dev;
+	struct sun8i_codec *scodec;
+	int ret, i;
+
+	scodec = devm_kzalloc(dev, sizeof(*scodec), GFP_KERNEL);
+	if (!scodec)
+		return -ENOMEM;
+
+	scodec->quirks = of_device_get_match_data(&pdev->dev);
+	scodec->ac100_regmap = ac100->regmap;
+
+	platform_set_drvdata(pdev, scodec);
+
+	// caching is done by the MFD regmap
+	sun8i_codec_regmap_config.cache_type = REGCACHE_NONE;
+
+	// we need to create a custom regmap_bus that will map reads/writes to the MFD regmap
+	scodec->regmap = __regmap_lockdep_wrapper(__devm_regmap_init,
+		 "ac100-regmap-codec", dev,
+		  &sun8i_codec_ac100_regmap_bus, scodec,
+		  &sun8i_codec_regmap_config);
+	if (IS_ERR(scodec->regmap)) {
+		dev_err(dev, "Failed to create our regmap\n");
+		return PTR_ERR(scodec->regmap);
+	}
+
+	for (i = 0; i < ARRAY_SIZE(scodec->supplies); i++)
+		scodec->supplies[i].supply = ac100_supply_names[i];
+
+        ret = devm_regulator_bulk_get(dev, ARRAY_SIZE(scodec->supplies),
+                                      scodec->supplies);
+        if (ret != 0) {
+              if (ret != -EPROBE_DEFER)
+                       dev_err(dev, "Failed to request supplies: %d\n", ret);
+                return ret;
+        }
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(scodec->supplies),
+				    scodec->supplies);
+	if (ret != 0) {
+		dev_err(dev, "Failed to enable supplies: %d\n", ret);
+		return ret;
+	}
+
+	ret = devm_snd_soc_register_component(dev, &sun8i_soc_component,
+					      sun8i_codec_dais,
+					      ARRAY_SIZE(sun8i_codec_dais));
+	if (ret) {
+		dev_err(dev, "Failed to register codec\n");
+		goto err_disable_reg;
+	}
+
+	return ret;
+
+err_disable_reg:
+	regulator_bulk_disable(ARRAY_SIZE(scodec->supplies),
+			       scodec->supplies);
+	return ret;
+}
+
 static int sun8i_codec_probe(struct platform_device *pdev)
 {
 	struct sun8i_codec *scodec;
 	void __iomem *base;
 	int ret;
 
+	if (of_device_is_compatible(pdev->dev.of_node, "x-powers,ac100-codec"))
+		return sun8i_codec_probe_ac100(pdev);
+
 	scodec = devm_kzalloc(&pdev->dev, sizeof(*scodec), GFP_KERNEL);
 	if (!scodec)
 		return -ENOMEM;
 
+	scodec->quirks = of_device_get_match_data(&pdev->dev);
+
+	platform_set_drvdata(pdev, scodec);
+
+	if (scodec->quirks->bus_clock) {
+		scodec->clk_bus = devm_clk_get(&pdev->dev, "bus");
+		if (IS_ERR(scodec->clk_bus)) {
+			dev_err(&pdev->dev, "Failed to get the bus clock\n");
+			return PTR_ERR(scodec->clk_bus);
+		}
+	}
+
 	scodec->clk_module = devm_clk_get(&pdev->dev, "mod");
 	if (IS_ERR(scodec->clk_module)) {
 		dev_err(&pdev->dev, "Failed to get the module clock\n");
@@ -1311,17 +1888,31 @@
 		return PTR_ERR(base);
 	}
 
-	scodec->regmap = devm_regmap_init_mmio_clk(&pdev->dev, "bus", base,
-						   &sun8i_codec_regmap_config);
+	scodec->regmap = devm_regmap_init_mmio(&pdev->dev, base,
+					       &sun8i_codec_regmap_config);
 	if (IS_ERR(scodec->regmap)) {
 		dev_err(&pdev->dev, "Failed to create our regmap\n");
 		return PTR_ERR(scodec->regmap);
 	}
 
-	scodec->quirks = of_device_get_match_data(&pdev->dev);
+	if (scodec->quirks->jack_detection) {
+		scodec->jack_irq = platform_get_irq(pdev, 0);
+		if (scodec->jack_irq < 0)
+			return scodec->jack_irq;
+
+		irq_set_status_flags(scodec->jack_irq, IRQ_NOAUTOEN);
+		ret = devm_request_threaded_irq(&pdev->dev, scodec->jack_irq,
+						NULL, sun8i_codec_jack_irq,
+						IRQF_ONESHOT,
+						dev_name(&pdev->dev), scodec);
+		if (ret)
+			return ret;
 
-	platform_set_drvdata(pdev, scodec);
+		INIT_DELAYED_WORK(&scodec->jack_work, sun8i_codec_jack_work);
+		mutex_init(&scodec->jack_mutex);
+	}
 
+	regcache_cache_only(scodec->regmap, true);
 	pm_runtime_enable(&pdev->dev);
 	if (!pm_runtime_enabled(&pdev->dev)) {
 		ret = sun8i_codec_runtime_resume(&pdev->dev);
@@ -1351,6 +1942,14 @@
 
 static int sun8i_codec_remove(struct platform_device *pdev)
 {
+	struct sun8i_codec *scodec = dev_get_drvdata(&pdev->dev);
+
+	if (scodec->ac100_regmap) {
+		regulator_bulk_disable(ARRAY_SIZE(scodec->supplies),
+				       scodec->supplies);
+		return 0;
+	}
+
 	pm_runtime_disable(&pdev->dev);
 	if (!pm_runtime_status_suspended(&pdev->dev))
 		sun8i_codec_runtime_suspend(&pdev->dev);
@@ -1359,16 +1958,23 @@
 }
 
 static const struct sun8i_codec_quirks sun8i_a33_quirks = {
+	.bus_clock	= true,
 	.legacy_widgets	= true,
 	.lrck_inversion	= true,
 };
 
 static const struct sun8i_codec_quirks sun50i_a64_quirks = {
+	.bus_clock	= true,
+	.jack_detection	= true,
+};
+
+static const struct sun8i_codec_quirks ac100_quirks = {
 };
 
 static const struct of_device_id sun8i_codec_of_match[] = {
 	{ .compatible = "allwinner,sun8i-a33-codec", .data = &sun8i_a33_quirks },
 	{ .compatible = "allwinner,sun50i-a64-codec", .data = &sun50i_a64_quirks },
+	{ .compatible = "x-powers,ac100-codec", .data = &ac100_quirks },
 	{}
 };
 MODULE_DEVICE_TABLE(of, sun8i_codec_of_match);
diff -Naur a/sound/soc/sunxi/sun9i-hdmi-audio.c b/sound/soc/sunxi/sun9i-hdmi-audio.c
--- a/sound/soc/sunxi/sun9i-hdmi-audio.c	1969-12-31 19:00:00.000000000 -0500
+++ b/sound/soc/sunxi/sun9i-hdmi-audio.c	2022-08-17 20:39:43.000000000 -0400
@@ -0,0 +1,180 @@
+// SPDX-License-Identifier: GPL-2.0
+//
+// sun9i hdmi audio sound card
+//
+// Copyright (C) 2021 Jernej Skrabec <jernej.skrabec@gmail.com>
+
+#include <linux/module.h>
+#include <linux/of_platform.h>
+
+#include <sound/soc.h>
+#include <sound/soc-dai.h>
+
+static int sun9i_hdmi_audio_hw_params(struct snd_pcm_substream *substream,
+				      struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);
+	unsigned int mclk;
+
+	mclk = params_rate(params) * 128;
+
+	return snd_soc_dai_set_sysclk(asoc_rtd_to_cpu(rtd, 0), 0, mclk,
+				      SND_SOC_CLOCK_OUT);
+}
+
+static const struct snd_soc_ops sun9i_hdmi_audio_ops = {
+	.hw_params = sun9i_hdmi_audio_hw_params,
+};
+
+static int sun9i_hdmi_audio_dai_init(struct snd_soc_pcm_runtime *rtd)
+{
+	int ret;
+
+	/* TODO: switch to custom api once it's implemented in sun4i-i2s */
+	ret = snd_soc_dai_set_tdm_slot(asoc_rtd_to_cpu(rtd, 0), 0, 0, 2, 32);
+	if (ret) {
+		dev_err(asoc_rtd_to_cpu(rtd, 0)->dev,
+			"setting tdm link slots failed\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int sun9i_hdmi_audio_parse_dai(struct device_node *node,
+				      struct snd_soc_dai_link_component *dlc)
+{
+	struct of_phandle_args args;
+	int ret;
+
+	if (!node)
+		return 0;
+
+	ret = of_parse_phandle_with_args(node, "sound-dai",
+					 "#sound-dai-cells", 0, &args);
+	if (ret)
+		return ret;
+
+	ret = snd_soc_get_dai_name(&args, &dlc->dai_name);
+	if (ret < 0) {
+		of_node_put(args.np);
+
+		return ret;
+	}
+
+	dlc->of_node = args.np;
+
+	return 0;
+}
+
+static int sun9i_hdmi_audio_probe(struct platform_device *pdev)
+{
+	struct snd_soc_dai_link_component *dlc;
+	struct device *dev = &pdev->dev;
+	struct snd_soc_dai_link *link;
+	struct snd_soc_card *card;
+	struct device_node *child;
+	int ret;
+
+	card = devm_kzalloc(dev, sizeof(*card), GFP_KERNEL);
+	if (!card)
+		return -ENOMEM;
+
+	link = devm_kzalloc(dev, sizeof(*link), GFP_KERNEL);
+	if (!link)
+		return -ENOMEM;
+
+	dlc = devm_kzalloc(dev, sizeof(*dlc) * 3, GFP_KERNEL);
+	if (!dlc)
+		return -ENOMEM;
+
+	child = of_get_child_by_name(dev->of_node, "codec");
+	if (!child)
+		return -ENODEV;
+
+	ret = sun9i_hdmi_audio_parse_dai(child, &dlc[1]);
+	of_node_put(child);
+	if (ret)
+		return ret;
+
+	child = of_get_child_by_name(dev->of_node, "cpu");
+	if (!child) {
+		ret = -ENODEV;
+		goto out_err;
+	}
+
+	ret = sun9i_hdmi_audio_parse_dai(child, &dlc[0]);
+	of_node_put(child);
+	if (ret)
+		goto out_err;
+
+	dlc[2].of_node = dlc[0].of_node;
+
+	platform_set_drvdata(pdev, card);
+
+	link->cpus = &dlc[0];
+	link->codecs = &dlc[1];
+	link->platforms = &dlc[2];
+
+	link->num_cpus = 1;
+	link->num_codecs = 1;
+	link->num_platforms = 1;
+
+	link->playback_only = 1;
+
+	link->name = "SUN9I-HDMI";
+	link->stream_name = "SUN9I-HDMI PCM";
+
+	link->dai_fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_IF | SND_SOC_DAIFMT_CBS_CFS;
+
+	link->ops = &sun9i_hdmi_audio_ops;
+	link->init = sun9i_hdmi_audio_dai_init;
+
+	card->dai_link = link;
+	card->num_links = 1;
+	card->owner = THIS_MODULE;
+	card->dev = dev;
+	card->name = "sun9i-hdmi";
+
+	ret = devm_snd_soc_register_card(dev, card);
+	if (ret)
+		goto out_err;
+
+	return 0;
+
+out_err:
+	of_node_put(dlc[0].of_node);
+	of_node_put(dlc[1].of_node);
+
+	return ret;
+}
+
+static int sun9i_hdmi_audio_remove(struct platform_device *pdev)
+{
+	struct snd_soc_card *card = platform_get_drvdata(pdev);
+
+	of_node_put(card->dai_link->cpus->of_node);
+	of_node_put(card->dai_link->codecs->of_node);
+
+	return 0;
+}
+
+static const struct of_device_id sun9i_hdmi_audio_match[] = {
+	{ .compatible = "allwinner,sun9i-a80-hdmi-audio" },
+	{}
+};
+MODULE_DEVICE_TABLE(of, sun9i_hdmi_audio_match);
+
+static struct platform_driver sun9i_hdmi_audio_driver = {
+	.probe = sun9i_hdmi_audio_probe,
+	.remove = sun9i_hdmi_audio_remove,
+	.driver = {
+		.name = "sun9i-hdmi-audio",
+		.of_match_table = sun9i_hdmi_audio_match,
+	},
+};
+module_platform_driver(sun9i_hdmi_audio_driver);
+
+MODULE_DESCRIPTION("sun9i HDMI Audio Sound Card");
+MODULE_AUTHOR("Jernej Skrabec <jernej.skrabec@gmail.com>");
+MODULE_LICENSE("GPL v2");
