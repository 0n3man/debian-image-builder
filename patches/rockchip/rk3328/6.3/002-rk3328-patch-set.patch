--- /dev/null	2023-04-29 08:31:15.023562380 -0400
+++ b/Documentation/devicetree/bindings/phy/phy-rockchip-inno-usb3.yaml	2023-05-06 08:46:30.709660232 -0400
@@ -0,0 +1,157 @@
+# SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: "http://devicetree.org/schemas/phy/phy-rockchip-inno-usb3.yaml#"
+$schema: "http://devicetree.org/meta-schemas/core.yaml#"
+
+title: ROCKCHIP USB 3.0 PHY WITH INNO IP BLOCK
+
+maintainers:
+
+properties:
+  compatible:
+    enum:
+      - rockchip,rk3328-u3phy
+
+  reg:
+    - description: the base address of the USB 3.0 PHY
+
+  interrupts:
+    maxItems: 1
+
+  interrupt-names:
+    items:
+      - const: linestate
+        description: host/otg linestate interrupt
+
+  clocks:
+    maxItems: 2
+
+  clock-names:
+    items:
+      - const: u3phy-otg
+        description: USB 3.0 PHY UTMI
+      - const: u3phy-pipe
+        description: USB 3.0 PHY Pipe
+
+  resets:
+    maxItems: 6
+
+  reset-names:
+    items:
+      - const: u3phy-u2-por
+      description: USB 2.0 logic of USB 3.0 PHY
+      - const: u3phy-u3-por
+      description: USB 3.0 logic of USB 3.0 PHY
+      - const: u3phy-pipe-mac
+      description: USB 3.0 PHY pipe MAC
+      - const: u3phy-utmi-mac
+      description: USB 3.0 PHY utmi MAC
+      - const: u3phy-utmi-apb
+      description: USB 3.0 PHY utmi apb
+      - const: u3phy-pipe-apb
+      description: USB 3.0 PHY pipe apb
+
+  "#phy-cells":
+    const: 1
+
+  rockchip,u3phygrf:
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    type: array
+    - description: phandle to the syscon managing the
+                   "USB 3.0 PHY general register files".
+
+  vbus-drv-gpios:
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    type: array
+    - description: phandle for gpio vbus supply
+
+required:
+  - compatible
+  - reg
+  - interrupts
+  - interrupt-names
+  - clocks
+  - clock-names
+  - resets
+  - reset-names
+  - "#phy-cells"
+  - rockchip,u3phygrf
+
+patternProperties:
+  "^u3phy_utmi@[0-9a-f]+$":
+    type: object
+
+    properties:
+      - description: USB 2.0 utmi phy.
+
+      rockchip,odt-val-tuning:
+        type: boolean
+        - description: specify 45ohm ODT tuning value.
+
+      "phy-cells":
+        const: 0
+
+    required:
+      - reg
+      - "#phy-cells"
+
+patternProperties:
+  "^u3phy_pipe@[0-9a-f]+$":
+    type: object
+
+    properties:
+      - description: USB 3.0 pipe phy.
+
+      rockchip,refclk-25m-quirk :
+
+        - description: phy reference clock changed to 25m quirk.
+
+      "phy-cells":
+        const: 0
+
+    required:
+      - reg
+      - "#phy-cells"
+
+examples:
+
+usb3phy_grf: syscon@ff460000 {
+	compatible = "rockchip,usb3phy-grf", "syscon";
+	reg = <0x0 0xff460000 0x0 0x1000>;
+};
+
+...
+
+u3phy: usb3-phy@ff470000 {
+	compatible = "rockchip,rk3328-u3phy";
+	reg = <0x0 0xff470000 0x0 0x0>;
+	rockchip,u3phygrf = <&usb3phy_grf>;
+	interrupts = <GIC_SPI 77 IRQ_TYPE_LEVEL_HIGH>;
+	interrupt-names = "linestate";
+	clocks = <&cru PCLK_USB3PHY_OTG>, <&cru PCLK_USB3PHY_PIPE>;
+	clock-names = "u3phy-otg", "u3phy-pipe";
+	resets = <&cru SRST_USB3PHY_U2>,
+		 <&cru SRST_USB3PHY_U3>,
+		 <&cru SRST_USB3PHY_PIPE>,
+		 <&cru SRST_USB3OTG_UTMI>,
+		 <&cru SRST_USB3PHY_OTG_P>,
+		 <&cru SRST_USB3PHY_PIPE_P>;
+	reset-names = "u3phy-u2-por", "u3phy-u3-por",
+		      "u3phy-pipe-mac", "u3phy-utmi-mac",
+		      "u3phy-utmi-apb", "u3phy-pipe-apb";
+	vbus-drv-gpios = <&gpio0 0 GPIO_ACTIVE_HIGH>;
+	#address-cells = <2>;
+	#size-cells = <2>;
+	ranges;
+
+	u3phy_utmi: utmi@ff470000 {
+		reg = <0x0 0xff470000 0x0 0x8000>;
+		#phy-cells = <0>;
+	};
+
+	u3phy_pipe: pipe@ff478000 {
+		reg = <0x0 0xff478000 0x0 0x8000>;
+		#phy-cells = <0>;
+	};
+};
diff -Naur a/Documentation/devicetree/bindings/soc/rockchip/grf.yaml b/Documentation/devicetree/bindings/soc/rockchip/grf.yaml
--- a/Documentation/devicetree/bindings/soc/rockchip/grf.yaml	2023-04-30 19:32:26.000000000 -0400
+++ b/Documentation/devicetree/bindings/soc/rockchip/grf.yaml	2023-05-06 08:46:30.709660232 -0400
@@ -46,6 +46,7 @@
               - rockchip,rk3308-usb2phy-grf
               - rockchip,rk3328-grf
               - rockchip,rk3328-usb2phy-grf
+              - rockchip,rk3328-u3phy-grf
               - rockchip,rk3368-grf
               - rockchip,rk3368-pmugrf
               - rockchip,rk3399-grf
diff -Naur a/drivers/clk/rockchip/clk-ddr.c b/drivers/clk/rockchip/clk-ddr.c
--- a/drivers/clk/rockchip/clk-ddr.c	2023-04-30 19:32:26.000000000 -0400
+++ b/drivers/clk/rockchip/clk-ddr.c	2023-05-06 08:46:30.738659947 -0400
@@ -87,6 +87,133 @@
 	.get_parent = rockchip_ddrclk_get_parent,
 };
 
+/* See v4.4/include/dt-bindings/display/rk_fb.h */
+#define SCREEN_NULL			0
+#define SCREEN_HDMI			6
+
+static inline int rk_drm_get_lcdc_type(void)
+{
+	return SCREEN_NULL;
+}
+
+struct share_params {
+	u32 hz;
+	u32 lcdc_type;
+	u32 vop;
+	u32 vop_dclk_mode;
+	u32 sr_idle_en;
+	u32 addr_mcu_el3;
+	/*
+	 * 1: need to wait flag1
+	 * 0: never wait flag1
+	 */
+	u32 wait_flag1;
+	/*
+	 * 1: need to wait flag1
+	 * 0: never wait flag1
+	 */
+	u32 wait_flag0;
+	u32 complt_hwirq;
+	 /* if need, add parameter after */
+};
+
+struct rockchip_ddrclk_data {
+	u32 inited_flag;
+	void __iomem *share_memory;
+};
+
+static struct rockchip_ddrclk_data ddr_data;
+
+static void rockchip_ddrclk_data_init(void)
+{
+	struct arm_smccc_res res;
+
+	arm_smccc_smc(ROCKCHIP_SIP_SHARE_MEM,
+		      1, SHARE_PAGE_TYPE_DDR, 0,
+		      0, 0, 0, 0, &res);
+
+	if (!res.a0) {
+		ddr_data.share_memory = (void __iomem *)ioremap(res.a1, 1<<12);
+		ddr_data.inited_flag = 1;
+	}
+}
+
+static int rockchip_ddrclk_sip_set_rate_v2(struct clk_hw *hw,
+					   unsigned long drate,
+					   unsigned long prate)
+{
+	struct share_params *p;
+	struct arm_smccc_res res;
+
+	if (!ddr_data.inited_flag)
+		rockchip_ddrclk_data_init();
+
+	p = (struct share_params *)ddr_data.share_memory;
+
+	p->hz = drate;
+	p->lcdc_type = rk_drm_get_lcdc_type();
+	p->wait_flag1 = 1;
+	p->wait_flag0 = 1;
+
+	arm_smccc_smc(ROCKCHIP_SIP_DRAM_FREQ,
+		      SHARE_PAGE_TYPE_DDR, 0,
+		      ROCKCHIP_SIP_CONFIG_DRAM_SET_RATE,
+		      0, 0, 0, 0, &res);
+
+	if ((int)res.a1 == -6) {
+		pr_err("%s: timeout, drate = %lumhz\n", __func__, drate/1000000);
+		/* TODO: rockchip_dmcfreq_wait_complete(); */
+	}
+
+	return res.a0;
+}
+
+static unsigned long rockchip_ddrclk_sip_recalc_rate_v2
+			(struct clk_hw *hw, unsigned long parent_rate)
+{
+	struct arm_smccc_res res;
+
+	arm_smccc_smc(ROCKCHIP_SIP_DRAM_FREQ,
+		      SHARE_PAGE_TYPE_DDR, 0,
+		      ROCKCHIP_SIP_CONFIG_DRAM_GET_RATE,
+		      0, 0, 0, 0, &res);
+	if (!res.a0)
+		return res.a1;
+	else
+		return 0;
+}
+
+static long rockchip_ddrclk_sip_round_rate_v2(struct clk_hw *hw,
+					      unsigned long rate,
+					      unsigned long *prate)
+{
+	struct share_params *p;
+	struct arm_smccc_res res;
+
+	if (!ddr_data.inited_flag)
+		rockchip_ddrclk_data_init();
+
+	p = (struct share_params *)ddr_data.share_memory;
+
+	p->hz = rate;
+
+	arm_smccc_smc(ROCKCHIP_SIP_DRAM_FREQ,
+		      SHARE_PAGE_TYPE_DDR, 0,
+		      ROCKCHIP_SIP_CONFIG_DRAM_ROUND_RATE,
+		      0, 0, 0, 0, &res);
+	if (!res.a0)
+		return res.a1;
+	else
+		return 0;
+}
+
+static const struct clk_ops rockchip_ddrclk_sip_ops_v2 = {
+	.recalc_rate = rockchip_ddrclk_sip_recalc_rate_v2,
+	.set_rate = rockchip_ddrclk_sip_set_rate_v2,
+	.round_rate = rockchip_ddrclk_sip_round_rate_v2,
+	.get_parent = rockchip_ddrclk_get_parent,
+};
+
 struct clk *rockchip_clk_register_ddrclk(const char *name, int flags,
 					 const char *const *parent_names,
 					 u8 num_parents, int mux_offset,
@@ -114,6 +241,9 @@
 	case ROCKCHIP_DDRCLK_SIP:
 		init.ops = &rockchip_ddrclk_sip_ops;
 		break;
+	case ROCKCHIP_DDRCLK_SIP_V2:
+		init.ops = &rockchip_ddrclk_sip_ops_v2;
+		break;
 	default:
 		pr_err("%s: unsupported ddrclk type %d\n", __func__, ddr_flag);
 		kfree(ddrclk);
diff -Naur a/drivers/clk/rockchip/clk.h b/drivers/clk/rockchip/clk.h
--- a/drivers/clk/rockchip/clk.h	2023-04-30 19:32:26.000000000 -0400
+++ b/drivers/clk/rockchip/clk.h	2023-05-06 08:46:30.739659938 -0400
@@ -486,7 +486,8 @@
  * DDRCLK flags, including method of setting the rate
  * ROCKCHIP_DDRCLK_SIP: use SIP call to bl31 to change ddrclk rate.
  */
-#define ROCKCHIP_DDRCLK_SIP		BIT(0)
+#define ROCKCHIP_DDRCLK_SIP		0x01
+#define ROCKCHIP_DDRCLK_SIP_V2		0x03
 
 struct clk *rockchip_clk_register_ddrclk(const char *name, int flags,
 					 const char *const *parent_names,
diff -Naur a/drivers/clk/rockchip/clk-rk3328.c b/drivers/clk/rockchip/clk-rk3328.c
--- a/drivers/clk/rockchip/clk-rk3328.c	2023-04-30 19:32:26.000000000 -0400
+++ b/drivers/clk/rockchip/clk-rk3328.c	2023-05-06 08:46:30.739659938 -0400
@@ -315,9 +315,10 @@
 			RK3328_CLKGATE_CON(14), 1, GFLAGS),
 
 	/* PD_DDR */
-	COMPOSITE(0, "clk_ddr", mux_ddrphy_p, CLK_IGNORE_UNUSED,
-			RK3328_CLKSEL_CON(3), 8, 2, MFLAGS, 0, 3, DFLAGS | CLK_DIVIDER_POWER_OF_TWO,
-			RK3328_CLKGATE_CON(0), 4, GFLAGS),
+	COMPOSITE_DDRCLK(SCLK_DDRCLK, "sclk_ddrc", mux_ddrphy_p, 0,
+			RK3328_CLKSEL_CON(3), 8, 2, 0, 3,
+			ROCKCHIP_DDRCLK_SIP_V2),
+
 	GATE(0, "clk_ddrmsch", "clk_ddr", CLK_IGNORE_UNUSED,
 			RK3328_CLKGATE_CON(18), 6, GFLAGS),
 	GATE(0, "clk_ddrupctl", "clk_ddr", CLK_IGNORE_UNUSED,
diff -Naur a/drivers/devfreq/event/rockchip-dfi.c b/drivers/devfreq/event/rockchip-dfi.c
--- a/drivers/devfreq/event/rockchip-dfi.c	2023-04-30 19:32:26.000000000 -0400
+++ b/drivers/devfreq/event/rockchip-dfi.c	2023-05-06 08:46:30.735659977 -0400
@@ -18,25 +18,66 @@
 #include <linux/list.h>
 #include <linux/of.h>
 
-#include <soc/rockchip/rk3399_grf.h>
-
-#define RK3399_DMC_NUM_CH	2
+#define PX30_PMUGRF_OS_REG2		0x208
 
+#define RK3128_GRF_SOC_CON0		0x140
+#define RK3128_GRF_OS_REG1		0x1cc
+#define RK3128_GRF_DFI_WRNUM		0x220
+#define RK3128_GRF_DFI_RDNUM		0x224
+#define RK3128_GRF_DFI_TIMERVAL		0x22c
+#define RK3128_DDR_MONITOR_EN		((1 << (16 + 6)) + (1 << 6))
+#define RK3128_DDR_MONITOR_DISB		((1 << (16 + 6)) + (0 << 6))
+
+#define RK3288_PMU_SYS_REG2		0x9c
+#define RK3288_GRF_SOC_CON4		0x254
+#define RK3288_GRF_SOC_STATUS(n)	(0x280 + (n) * 4)
+#define RK3288_DFI_EN			(0x30003 << 14)
+#define RK3288_DFI_DIS			(0x30000 << 14)
+#define RK3288_LPDDR_SEL		(0x10001 << 13)
+#define RK3288_DDR3_SEL			(0x10000 << 13)
+
+#define RK3328_GRF_OS_REG2		0x5d0
+
+#define RK3368_GRF_DDRC0_CON0		0x600
+#define RK3368_GRF_SOC_STATUS5		0x494
+#define RK3368_GRF_SOC_STATUS6		0x498
+#define RK3368_GRF_SOC_STATUS8		0x4a0
+#define RK3368_GRF_SOC_STATUS9		0x4a4
+#define RK3368_GRF_SOC_STATUS10		0x4a8
+#define RK3368_DFI_EN			(0x30003 << 5)
+#define RK3368_DFI_DIS			(0x30000 << 5)
+
+#define MAX_DMC_NUM_CH			2
+#define READ_DRAMTYPE_INFO(n)		(((n) >> 13) & 0x7)
+#define READ_CH_INFO(n)			(((n) >> 28) & 0x3)
 /* DDRMON_CTRL */
-#define DDRMON_CTRL	0x04
-#define CLR_DDRMON_CTRL	(0x1f0000 << 0)
-#define LPDDR4_EN	(0x10001 << 4)
-#define HARDWARE_EN	(0x10001 << 3)
-#define LPDDR3_EN	(0x10001 << 2)
-#define SOFTWARE_EN	(0x10001 << 1)
-#define SOFTWARE_DIS	(0x10000 << 1)
-#define TIME_CNT_EN	(0x10001 << 0)
+#define DDRMON_CTRL			0x04
+#define CLR_DDRMON_CTRL			(0x3f0000 << 0)
+#define DDR4_EN				(0x10001 << 5)
+#define LPDDR4_EN			(0x10001 << 4)
+#define HARDWARE_EN			(0x10001 << 3)
+#define LPDDR2_3_EN			(0x10001 << 2)
+#define SOFTWARE_EN			(0x10001 << 1)
+#define SOFTWARE_DIS			(0x10000 << 1)
+#define TIME_CNT_EN			(0x10001 << 0)
 
 #define DDRMON_CH0_COUNT_NUM		0x28
 #define DDRMON_CH0_DFI_ACCESS_NUM	0x2c
 #define DDRMON_CH1_COUNT_NUM		0x3c
 #define DDRMON_CH1_DFI_ACCESS_NUM	0x40
 
+/* pmu grf */
+#define PMUGRF_OS_REG2			0x308
+
+enum {
+	DDR4 = 0,
+	DDR3 = 3,
+	LPDDR2 = 5,
+	LPDDR3 = 6,
+	LPDDR4 = 7,
+	UNUSED = 0xFF
+};
+
 struct dmc_usage {
 	u32 access;
 	u32 total;
@@ -50,33 +91,261 @@
 struct rockchip_dfi {
 	struct devfreq_event_dev *edev;
 	struct devfreq_event_desc *desc;
-	struct dmc_usage ch_usage[RK3399_DMC_NUM_CH];
+	struct dmc_usage ch_usage[MAX_DMC_NUM_CH];
 	struct device *dev;
 	void __iomem *regs;
 	struct regmap *regmap_pmu;
+	struct regmap *regmap_grf;
+	struct regmap *regmap_pmugrf;
 	struct clk *clk;
+	u32 dram_type;
+	/*
+	 * available mask, 1: available, 0: not available
+	 * each bit represent a channel
+	 */
+	u32 ch_msk;
+};
+
+static void rk3128_dfi_start_hardware_counter(struct devfreq_event_dev *edev)
+{
+	struct rockchip_dfi *info = devfreq_event_get_drvdata(edev);
+
+	regmap_write(info->regmap_grf,
+		     RK3128_GRF_SOC_CON0,
+		     RK3128_DDR_MONITOR_EN);
+}
+
+static void rk3128_dfi_stop_hardware_counter(struct devfreq_event_dev *edev)
+{
+	struct rockchip_dfi *info = devfreq_event_get_drvdata(edev);
+
+	regmap_write(info->regmap_grf,
+		     RK3128_GRF_SOC_CON0,
+		     RK3128_DDR_MONITOR_DISB);
+}
+
+static int rk3128_dfi_disable(struct devfreq_event_dev *edev)
+{
+	rk3128_dfi_stop_hardware_counter(edev);
+
+	return 0;
+}
+
+static int rk3128_dfi_enable(struct devfreq_event_dev *edev)
+{
+	rk3128_dfi_start_hardware_counter(edev);
+
+	return 0;
+}
+
+static int rk3128_dfi_set_event(struct devfreq_event_dev *edev)
+{
+	return 0;
+}
+
+static int rk3128_dfi_get_event(struct devfreq_event_dev *edev,
+				struct devfreq_event_data *edata)
+{
+	struct rockchip_dfi *info = devfreq_event_get_drvdata(edev);
+	unsigned long flags;
+	u32 dfi_wr, dfi_rd, dfi_timer;
+
+	local_irq_save(flags);
+
+	rk3128_dfi_stop_hardware_counter(edev);
+
+	regmap_read(info->regmap_grf, RK3128_GRF_DFI_WRNUM, &dfi_wr);
+	regmap_read(info->regmap_grf, RK3128_GRF_DFI_RDNUM, &dfi_rd);
+	regmap_read(info->regmap_grf, RK3128_GRF_DFI_TIMERVAL, &dfi_timer);
+
+	edata->load_count = (dfi_wr + dfi_rd) * 4;
+	edata->total_count = dfi_timer;
+
+	rk3128_dfi_start_hardware_counter(edev);
+
+	local_irq_restore(flags);
+
+	return 0;
+}
+
+static const struct devfreq_event_ops rk3128_dfi_ops = {
+	.disable = rk3128_dfi_disable,
+	.enable = rk3128_dfi_enable,
+	.get_event = rk3128_dfi_get_event,
+	.set_event = rk3128_dfi_set_event,
+};
+
+static void rk3288_dfi_start_hardware_counter(struct devfreq_event_dev *edev)
+{
+	struct rockchip_dfi *info = devfreq_event_get_drvdata(edev);
+
+	regmap_write(info->regmap_grf, RK3288_GRF_SOC_CON4, RK3288_DFI_EN);
+}
+
+static void rk3288_dfi_stop_hardware_counter(struct devfreq_event_dev *edev)
+{
+	struct rockchip_dfi *info = devfreq_event_get_drvdata(edev);
+
+	regmap_write(info->regmap_grf, RK3288_GRF_SOC_CON4, RK3288_DFI_DIS);
+}
+
+static int rk3288_dfi_disable(struct devfreq_event_dev *edev)
+{
+	rk3288_dfi_stop_hardware_counter(edev);
+
+	return 0;
+}
+
+static int rk3288_dfi_enable(struct devfreq_event_dev *edev)
+{
+	rk3288_dfi_start_hardware_counter(edev);
+
+	return 0;
+}
+
+static int rk3288_dfi_set_event(struct devfreq_event_dev *edev)
+{
+	return 0;
+}
+
+static int rk3288_dfi_get_busier_ch(struct devfreq_event_dev *edev)
+{
+	struct rockchip_dfi *info = devfreq_event_get_drvdata(edev);
+	u32 tmp, max = 0;
+	u32 i, busier_ch = 0;
+	u32 rd_count, wr_count, total_count;
+
+	rk3288_dfi_stop_hardware_counter(edev);
+
+	/* Find out which channel is busier */
+	for (i = 0; i < MAX_DMC_NUM_CH; i++) {
+		if (!(info->ch_msk & BIT(i)))
+			continue;
+		regmap_read(info->regmap_grf,
+			    RK3288_GRF_SOC_STATUS(11 + i * 4), &wr_count);
+		regmap_read(info->regmap_grf,
+			    RK3288_GRF_SOC_STATUS(12 + i * 4), &rd_count);
+		regmap_read(info->regmap_grf,
+			    RK3288_GRF_SOC_STATUS(14 + i * 4), &total_count);
+		info->ch_usage[i].access = (wr_count + rd_count) * 4;
+		info->ch_usage[i].total = total_count;
+		tmp = info->ch_usage[i].access;
+		if (tmp > max) {
+			busier_ch = i;
+			max = tmp;
+		}
+	}
+	rk3288_dfi_start_hardware_counter(edev);
+
+	return busier_ch;
+}
+
+static int rk3288_dfi_get_event(struct devfreq_event_dev *edev,
+				struct devfreq_event_data *edata)
+{
+	struct rockchip_dfi *info = devfreq_event_get_drvdata(edev);
+	int busier_ch;
+	unsigned long flags;
+
+	local_irq_save(flags);
+	busier_ch = rk3288_dfi_get_busier_ch(edev);
+	local_irq_restore(flags);
+
+	edata->load_count = info->ch_usage[busier_ch].access;
+	edata->total_count = info->ch_usage[busier_ch].total;
+
+	return 0;
+}
+
+static const struct devfreq_event_ops rk3288_dfi_ops = {
+	.disable = rk3288_dfi_disable,
+	.enable = rk3288_dfi_enable,
+	.get_event = rk3288_dfi_get_event,
+	.set_event = rk3288_dfi_set_event,
+};
+
+static void rk3368_dfi_start_hardware_counter(struct devfreq_event_dev *edev)
+{
+	struct rockchip_dfi *info = devfreq_event_get_drvdata(edev);
+
+	regmap_write(info->regmap_grf, RK3368_GRF_DDRC0_CON0, RK3368_DFI_EN);
+}
+
+static void rk3368_dfi_stop_hardware_counter(struct devfreq_event_dev *edev)
+{
+	struct rockchip_dfi *info = devfreq_event_get_drvdata(edev);
+
+	regmap_write(info->regmap_grf, RK3368_GRF_DDRC0_CON0, RK3368_DFI_DIS);
+}
+
+static int rk3368_dfi_disable(struct devfreq_event_dev *edev)
+{
+	rk3368_dfi_stop_hardware_counter(edev);
+
+	return 0;
+}
+
+static int rk3368_dfi_enable(struct devfreq_event_dev *edev)
+{
+	rk3368_dfi_start_hardware_counter(edev);
+
+	return 0;
+}
+
+static int rk3368_dfi_set_event(struct devfreq_event_dev *edev)
+{
+	return 0;
+}
+
+static int rk3368_dfi_get_event(struct devfreq_event_dev *edev,
+				struct devfreq_event_data *edata)
+{
+	struct rockchip_dfi *info = devfreq_event_get_drvdata(edev);
+	unsigned long flags;
+	u32 dfi0_wr, dfi0_rd, dfi1_wr, dfi1_rd, dfi_timer;
+
+	local_irq_save(flags);
+
+	rk3368_dfi_stop_hardware_counter(edev);
+
+	regmap_read(info->regmap_grf, RK3368_GRF_SOC_STATUS5, &dfi0_wr);
+	regmap_read(info->regmap_grf, RK3368_GRF_SOC_STATUS6, &dfi0_rd);
+	regmap_read(info->regmap_grf, RK3368_GRF_SOC_STATUS9, &dfi1_wr);
+	regmap_read(info->regmap_grf, RK3368_GRF_SOC_STATUS10, &dfi1_rd);
+	regmap_read(info->regmap_grf, RK3368_GRF_SOC_STATUS8, &dfi_timer);
+
+	edata->load_count = (dfi0_wr + dfi0_rd + dfi1_wr + dfi1_rd) * 2;
+	edata->total_count = dfi_timer;
+
+	rk3368_dfi_start_hardware_counter(edev);
+
+	local_irq_restore(flags);
+
+	return 0;
+}
+
+static const struct devfreq_event_ops rk3368_dfi_ops = {
+	.disable = rk3368_dfi_disable,
+	.enable = rk3368_dfi_enable,
+	.get_event = rk3368_dfi_get_event,
+	.set_event = rk3368_dfi_set_event,
 };
 
 static void rockchip_dfi_start_hardware_counter(struct devfreq_event_dev *edev)
 {
 	struct rockchip_dfi *info = devfreq_event_get_drvdata(edev);
 	void __iomem *dfi_regs = info->regs;
-	u32 val;
-	u32 ddr_type;
-
-	/* get ddr type */
-	regmap_read(info->regmap_pmu, RK3399_PMUGRF_OS_REG2, &val);
-	ddr_type = (val >> RK3399_PMUGRF_DDRTYPE_SHIFT) &
-		    RK3399_PMUGRF_DDRTYPE_MASK;
 
 	/* clear DDRMON_CTRL setting */
 	writel_relaxed(CLR_DDRMON_CTRL, dfi_regs + DDRMON_CTRL);
 
 	/* set ddr type to dfi */
-	if (ddr_type == RK3399_PMUGRF_DDRTYPE_LPDDR3)
-		writel_relaxed(LPDDR3_EN, dfi_regs + DDRMON_CTRL);
-	else if (ddr_type == RK3399_PMUGRF_DDRTYPE_LPDDR4)
+	if (info->dram_type == LPDDR3 || info->dram_type == LPDDR2)
+		writel_relaxed(LPDDR2_3_EN, dfi_regs + DDRMON_CTRL);
+	else if (info->dram_type == LPDDR4)
 		writel_relaxed(LPDDR4_EN, dfi_regs + DDRMON_CTRL);
+	else if (info->dram_type == DDR4)
+		writel_relaxed(DDR4_EN, dfi_regs + DDRMON_CTRL);
 
 	/* enable count, use software mode */
 	writel_relaxed(SOFTWARE_EN, dfi_regs + DDRMON_CTRL);
@@ -100,12 +369,22 @@
 	rockchip_dfi_stop_hardware_counter(edev);
 
 	/* Find out which channel is busier */
-	for (i = 0; i < RK3399_DMC_NUM_CH; i++) {
-		info->ch_usage[i].access = readl_relaxed(dfi_regs +
-				DDRMON_CH0_DFI_ACCESS_NUM + i * 20) * 4;
+	for (i = 0; i < MAX_DMC_NUM_CH; i++) {
+		if (!(info->ch_msk & BIT(i)))
+			continue;
+
 		info->ch_usage[i].total = readl_relaxed(dfi_regs +
 				DDRMON_CH0_COUNT_NUM + i * 20);
-		tmp = info->ch_usage[i].access;
+
+		/* LPDDR4 BL = 16,other DDR type BL = 8 */
+		tmp = readl_relaxed(dfi_regs +
+				DDRMON_CH0_DFI_ACCESS_NUM + i * 20);
+		if (info->dram_type == LPDDR4)
+			tmp *= 8;
+		else
+			tmp *= 4;
+		info->ch_usage[i].access = tmp;
+
 		if (tmp > max) {
 			busier_ch = i;
 			max = tmp;
@@ -121,7 +400,8 @@
 	struct rockchip_dfi *info = devfreq_event_get_drvdata(edev);
 
 	rockchip_dfi_stop_hardware_counter(edev);
-	clk_disable_unprepare(info->clk);
+	if (info->clk)
+		clk_disable_unprepare(info->clk);
 
 	return 0;
 }
@@ -131,10 +411,13 @@
 	struct rockchip_dfi *info = devfreq_event_get_drvdata(edev);
 	int ret;
 
-	ret = clk_prepare_enable(info->clk);
-	if (ret) {
-		dev_err(&edev->dev, "failed to enable dfi clk: %d\n", ret);
-		return ret;
+	if (info->clk) {
+		ret = clk_prepare_enable(info->clk);
+		if (ret) {
+			dev_err(&edev->dev, "failed to enable dfi clk: %d\n",
+				ret);
+			return ret;
+		}
 	}
 
 	rockchip_dfi_start_hardware_counter(edev);
@@ -151,8 +434,11 @@
 {
 	struct rockchip_dfi *info = devfreq_event_get_drvdata(edev);
 	int busier_ch;
+	unsigned long flags;
 
+	local_irq_save(flags);
 	busier_ch = rockchip_dfi_get_busier_ch(edev);
+	local_irq_restore(flags);
 
 	edata->load_count = info->ch_usage[busier_ch].access;
 	edata->total_count = info->ch_usage[busier_ch].total;
@@ -167,22 +453,116 @@
 	.set_event = rockchip_dfi_set_event,
 };
 
-static const struct of_device_id rockchip_dfi_id_match[] = {
-	{ .compatible = "rockchip,rk3399-dfi" },
-	{ },
-};
-MODULE_DEVICE_TABLE(of, rockchip_dfi_id_match);
+static __init int px30_dfi_init(struct platform_device *pdev,
+				  struct rockchip_dfi *data,
+				  struct devfreq_event_desc *desc)
+{
+	struct device_node *np = pdev->dev.of_node, *node;
+	struct resource *res;
+	u32 val;
 
-static int rockchip_dfi_probe(struct platform_device *pdev)
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	data->regs = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(data->regs))
+		return PTR_ERR(data->regs);
+
+	node = of_parse_phandle(np, "rockchip,pmugrf", 0);
+	if (node) {
+		data->regmap_pmugrf = syscon_node_to_regmap(node);
+		if (IS_ERR(data->regmap_pmugrf))
+			return PTR_ERR(data->regmap_pmugrf);
+	}
+
+	regmap_read(data->regmap_pmugrf, PX30_PMUGRF_OS_REG2, &val);
+	data->dram_type = READ_DRAMTYPE_INFO(val);
+	data->ch_msk = 1;
+	data->clk = NULL;
+
+	desc->ops = &rockchip_dfi_ops;
+
+	return 0;
+}
+
+static __init int rk3128_dfi_init(struct platform_device *pdev,
+				  struct rockchip_dfi *data,
+				  struct devfreq_event_desc *desc)
 {
-	struct device *dev = &pdev->dev;
-	struct rockchip_dfi *data;
-	struct devfreq_event_desc *desc;
 	struct device_node *np = pdev->dev.of_node, *node;
 
-	data = devm_kzalloc(dev, sizeof(struct rockchip_dfi), GFP_KERNEL);
-	if (!data)
-		return -ENOMEM;
+	node = of_parse_phandle(np, "rockchip,grf", 0);
+	if (node) {
+		data->regmap_grf = syscon_node_to_regmap(node);
+		if (IS_ERR(data->regmap_grf))
+			return PTR_ERR(data->regmap_grf);
+	}
+
+	desc->ops = &rk3128_dfi_ops;
+
+	return 0;
+}
+
+static __init int rk3288_dfi_init(struct platform_device *pdev,
+				  struct rockchip_dfi *data,
+				  struct devfreq_event_desc *desc)
+{
+	struct device_node *np = pdev->dev.of_node, *node;
+	u32 val;
+
+	node = of_parse_phandle(np, "rockchip,pmu", 0);
+	if (node) {
+		data->regmap_pmu = syscon_node_to_regmap(node);
+		if (IS_ERR(data->regmap_pmu))
+			return PTR_ERR(data->regmap_pmu);
+	}
+
+	node = of_parse_phandle(np, "rockchip,grf", 0);
+	if (node) {
+		data->regmap_grf = syscon_node_to_regmap(node);
+		if (IS_ERR(data->regmap_grf))
+			return PTR_ERR(data->regmap_grf);
+	}
+
+	regmap_read(data->regmap_pmu, RK3288_PMU_SYS_REG2, &val);
+	data->dram_type = READ_DRAMTYPE_INFO(val);
+	data->ch_msk = READ_CH_INFO(val);
+
+	if (data->dram_type == DDR3)
+		regmap_write(data->regmap_grf, RK3288_GRF_SOC_CON4,
+			     RK3288_DDR3_SEL);
+	else
+		regmap_write(data->regmap_grf, RK3288_GRF_SOC_CON4,
+			     RK3288_LPDDR_SEL);
+
+	desc->ops = &rk3288_dfi_ops;
+
+	return 0;
+}
+
+static __init int rk3368_dfi_init(struct platform_device *pdev,
+				  struct rockchip_dfi *data,
+				  struct devfreq_event_desc *desc)
+{
+	struct device *dev = &pdev->dev;
+
+	if (!dev->parent || !dev->parent->of_node)
+		return -EINVAL;
+
+	data->regmap_grf = syscon_node_to_regmap(dev->parent->of_node);
+	if (IS_ERR(data->regmap_grf))
+		return PTR_ERR(data->regmap_grf);
+
+	desc->ops = &rk3368_dfi_ops;
+
+	return 0;
+}
+
+static __init int rockchip_dfi_init(struct platform_device *pdev,
+				    struct rockchip_dfi *data,
+				    struct devfreq_event_desc *desc)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *np = pdev->dev.of_node, *node;
+	u32 val;
 
 	data->regs = devm_platform_ioremap_resource(pdev, 0);
 	if (IS_ERR(data->regs))
@@ -201,21 +581,97 @@
 		if (IS_ERR(data->regmap_pmu))
 			return PTR_ERR(data->regmap_pmu);
 	}
-	data->dev = dev;
+
+	regmap_read(data->regmap_pmu, PMUGRF_OS_REG2, &val);
+	data->dram_type = READ_DRAMTYPE_INFO(val);
+	data->ch_msk = READ_CH_INFO(val);
+
+	desc->ops = &rockchip_dfi_ops;
+
+	return 0;
+}
+
+static __init int rk3328_dfi_init(struct platform_device *pdev,
+				  struct rockchip_dfi *data,
+				  struct devfreq_event_desc *desc)
+{
+	struct device_node *np = pdev->dev.of_node, *node;
+	struct resource *res;
+	u32 val;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	data->regs = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(data->regs))
+		return PTR_ERR(data->regs);
+
+	node = of_parse_phandle(np, "rockchip,grf", 0);
+	if (node) {
+		data->regmap_grf = syscon_node_to_regmap(node);
+		if (IS_ERR(data->regmap_grf))
+			return PTR_ERR(data->regmap_grf);
+	}
+
+	regmap_read(data->regmap_grf, RK3328_GRF_OS_REG2, &val);
+	data->dram_type = READ_DRAMTYPE_INFO(val);
+	data->ch_msk = 1;
+	data->clk = NULL;
+
+	desc->ops = &rockchip_dfi_ops;
+
+	return 0;
+}
+
+static const struct of_device_id rockchip_dfi_id_match[] = {
+	{ .compatible = "rockchip,px30-dfi", .data = px30_dfi_init },
+	{ .compatible = "rockchip,rk1808-dfi", .data = px30_dfi_init },
+	{ .compatible = "rockchip,rk3128-dfi", .data = rk3128_dfi_init },
+	{ .compatible = "rockchip,rk3288-dfi", .data = rk3288_dfi_init },
+	{ .compatible = "rockchip,rk3328-dfi", .data = rk3328_dfi_init },
+	{ .compatible = "rockchip,rk3368-dfi", .data = rk3368_dfi_init },
+	{ .compatible = "rockchip,rk3399-dfi", .data = rockchip_dfi_init },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, rockchip_dfi_id_match);
+
+static int rockchip_dfi_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct rockchip_dfi *data;
+	struct devfreq_event_desc *desc;
+	struct device_node *np = pdev->dev.of_node;
+	const struct of_device_id *match;
+	int (*init)(struct platform_device *pdev, struct rockchip_dfi *data,
+		    struct devfreq_event_desc *desc);
+
+	data = devm_kzalloc(dev, sizeof(struct rockchip_dfi), GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
 
 	desc = devm_kzalloc(dev, sizeof(*desc), GFP_KERNEL);
 	if (!desc)
 		return -ENOMEM;
 
-	desc->ops = &rockchip_dfi_ops;
+	match = of_match_node(rockchip_dfi_id_match, pdev->dev.of_node);
+	if (match) {
+		init = match->data;
+		if (init) {
+			if (init(pdev, data, desc))
+				return -EINVAL;
+		} else {
+			return 0;
+		}
+	} else {
+		return 0;
+	}
+
 	desc->driver_data = data;
 	desc->name = np->name;
 	data->desc = desc;
+	data->dev = dev;
 
-	data->edev = devm_devfreq_event_add_edev(&pdev->dev, desc);
+	data->edev = devm_devfreq_event_add_edev(dev, desc);
 	if (IS_ERR(data->edev)) {
-		dev_err(&pdev->dev,
-			"failed to add devfreq-event device\n");
+		dev_err(dev, "failed to add devfreq-event device\n");
 		return PTR_ERR(data->edev);
 	}
 
diff -Naur a/drivers/devfreq/Kconfig b/drivers/devfreq/Kconfig
--- a/drivers/devfreq/Kconfig	2023-04-30 19:32:26.000000000 -0400
+++ b/drivers/devfreq/Kconfig	2023-05-06 08:46:30.735659977 -0400
@@ -130,6 +130,18 @@
 	  buck voltages and update a proper CCI frequency. Use the notification
 	  to get the regulator status.
 
+config ARM_RK3328_DMC_DEVFREQ
+	tristate "ARM RK3328 DMC DEVFREQ Driver"
+	depends on ARCH_ROCKCHIP
+	select DEVFREQ_EVENT_ROCKCHIP_DFI
+	select DEVFREQ_GOV_SIMPLE_ONDEMAND
+	select PM_DEVFREQ_EVENT
+	select PM_OPP
+	help
+	  This adds the DEVFREQ driver for the RK3328 DMC(Dynamic Memory Controller).
+	  It sets the frequency for the memory controller and reads the usage counts
+	  from hardware.
+
 config ARM_RK3399_DMC_DEVFREQ
 	tristate "ARM RK3399 DMC DEVFREQ Driver"
 	depends on (ARCH_ROCKCHIP && HAVE_ARM_SMCCC) || \
diff -Naur a/drivers/devfreq/Makefile b/drivers/devfreq/Makefile
--- a/drivers/devfreq/Makefile	2023-04-30 19:32:26.000000000 -0400
+++ b/drivers/devfreq/Makefile	2023-05-06 08:46:30.735659977 -0400
@@ -13,6 +13,7 @@
 obj-$(CONFIG_ARM_IMX8M_DDRC_DEVFREQ)	+= imx8m-ddrc.o
 obj-$(CONFIG_ARM_MEDIATEK_CCI_DEVFREQ)	+= mtk-cci-devfreq.o
 obj-$(CONFIG_ARM_RK3399_DMC_DEVFREQ)	+= rk3399_dmc.o
+obj-$(CONFIG_ARM_RK3328_DMC_DEVFREQ)	+= rk3328_dmc.o
 obj-$(CONFIG_ARM_SUN8I_A33_MBUS_DEVFREQ)	+= sun8i-a33-mbus.o
 obj-$(CONFIG_ARM_TEGRA_DEVFREQ)		+= tegra30-devfreq.o
 
--- /dev/null	2023-04-29 08:31:15.023562380 -0400
+++ b/drivers/devfreq/rk3328_dmc.c	2023-05-06 08:46:30.736659967 -0400
@@ -0,0 +1,846 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (c) 2016, Fuzhou Rockchip Electronics Co., Ltd.
+ * Author: Lin Huang <hl@rock-chips.com>
+ */
+
+#include <linux/arm-smccc.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/devfreq.h>
+#include <linux/devfreq-event.h>
+#include <linux/interrupt.h>
+#include <linux/mfd/syscon.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/pm_opp.h>
+#include <linux/regmap.h>
+#include <linux/regulator/consumer.h>
+#include <linux/rwsem.h>
+#include <linux/suspend.h>
+
+#include <soc/rockchip/rockchip_sip.h>
+
+#define DTS_PAR_OFFSET		(4096)
+
+struct share_params {
+	u32 hz;
+	u32 lcdc_type;
+	u32 vop;
+	u32 vop_dclk_mode;
+	u32 sr_idle_en;
+	u32 addr_mcu_el3;
+	/*
+	 * 1: need to wait flag1
+	 * 0: never wait flag1
+	 */
+	u32 wait_flag1;
+	/*
+	 * 1: need to wait flag1
+	 * 0: never wait flag1
+	 */
+	u32 wait_flag0;
+	u32 complt_hwirq;
+	/* if need, add parameter after */
+};
+
+static struct share_params *ddr_psci_param;
+
+/* hope this define can adapt all future platform */
+static const char * const rk3328_dts_timing[] = {
+	"ddr3_speed_bin",
+	"ddr4_speed_bin",
+	"pd_idle",
+	"sr_idle",
+	"sr_mc_gate_idle",
+	"srpd_lite_idle",
+	"standby_idle",
+
+	"auto_pd_dis_freq",
+	"auto_sr_dis_freq",
+	"ddr3_dll_dis_freq",
+	"ddr4_dll_dis_freq",
+	"phy_dll_dis_freq",
+
+	"ddr3_odt_dis_freq",
+	"phy_ddr3_odt_dis_freq",
+	"ddr3_drv",
+	"ddr3_odt",
+	"phy_ddr3_ca_drv",
+	"phy_ddr3_ck_drv",
+	"phy_ddr3_dq_drv",
+	"phy_ddr3_odt",
+
+	"lpddr3_odt_dis_freq",
+	"phy_lpddr3_odt_dis_freq",
+	"lpddr3_drv",
+	"lpddr3_odt",
+	"phy_lpddr3_ca_drv",
+	"phy_lpddr3_ck_drv",
+	"phy_lpddr3_dq_drv",
+	"phy_lpddr3_odt",
+
+	"lpddr4_odt_dis_freq",
+	"phy_lpddr4_odt_dis_freq",
+	"lpddr4_drv",
+	"lpddr4_dq_odt",
+	"lpddr4_ca_odt",
+	"phy_lpddr4_ca_drv",
+	"phy_lpddr4_ck_cs_drv",
+	"phy_lpddr4_dq_drv",
+	"phy_lpddr4_odt",
+
+	"ddr4_odt_dis_freq",
+	"phy_ddr4_odt_dis_freq",
+	"ddr4_drv",
+	"ddr4_odt",
+	"phy_ddr4_ca_drv",
+	"phy_ddr4_ck_drv",
+	"phy_ddr4_dq_drv",
+	"phy_ddr4_odt",
+};
+
+static const char * const rk3328_dts_ca_timing[] = {
+	"ddr3a1_ddr4a9_de-skew",
+	"ddr3a0_ddr4a10_de-skew",
+	"ddr3a3_ddr4a6_de-skew",
+	"ddr3a2_ddr4a4_de-skew",
+	"ddr3a5_ddr4a8_de-skew",
+	"ddr3a4_ddr4a5_de-skew",
+	"ddr3a7_ddr4a11_de-skew",
+	"ddr3a6_ddr4a7_de-skew",
+	"ddr3a9_ddr4a0_de-skew",
+	"ddr3a8_ddr4a13_de-skew",
+	"ddr3a11_ddr4a3_de-skew",
+	"ddr3a10_ddr4cs0_de-skew",
+	"ddr3a13_ddr4a2_de-skew",
+	"ddr3a12_ddr4ba1_de-skew",
+	"ddr3a15_ddr4odt0_de-skew",
+	"ddr3a14_ddr4a1_de-skew",
+	"ddr3ba1_ddr4a15_de-skew",
+	"ddr3ba0_ddr4bg0_de-skew",
+	"ddr3ras_ddr4cke_de-skew",
+	"ddr3ba2_ddr4ba0_de-skew",
+	"ddr3we_ddr4bg1_de-skew",
+	"ddr3cas_ddr4a12_de-skew",
+	"ddr3ckn_ddr4ckn_de-skew",
+	"ddr3ckp_ddr4ckp_de-skew",
+	"ddr3cke_ddr4a16_de-skew",
+	"ddr3odt0_ddr4a14_de-skew",
+	"ddr3cs0_ddr4act_de-skew",
+	"ddr3reset_ddr4reset_de-skew",
+	"ddr3cs1_ddr4cs1_de-skew",
+	"ddr3odt1_ddr4odt1_de-skew",
+};
+
+static const char * const rk3328_dts_cs0_timing[] = {
+	"cs0_dm0_rx_de-skew",
+	"cs0_dm0_tx_de-skew",
+	"cs0_dq0_rx_de-skew",
+	"cs0_dq0_tx_de-skew",
+	"cs0_dq1_rx_de-skew",
+	"cs0_dq1_tx_de-skew",
+	"cs0_dq2_rx_de-skew",
+	"cs0_dq2_tx_de-skew",
+	"cs0_dq3_rx_de-skew",
+	"cs0_dq3_tx_de-skew",
+	"cs0_dq4_rx_de-skew",
+	"cs0_dq4_tx_de-skew",
+	"cs0_dq5_rx_de-skew",
+	"cs0_dq5_tx_de-skew",
+	"cs0_dq6_rx_de-skew",
+	"cs0_dq6_tx_de-skew",
+	"cs0_dq7_rx_de-skew",
+	"cs0_dq7_tx_de-skew",
+	"cs0_dqs0_rx_de-skew",
+	"cs0_dqs0p_tx_de-skew",
+	"cs0_dqs0n_tx_de-skew",
+
+	"cs0_dm1_rx_de-skew",
+	"cs0_dm1_tx_de-skew",
+	"cs0_dq8_rx_de-skew",
+	"cs0_dq8_tx_de-skew",
+	"cs0_dq9_rx_de-skew",
+	"cs0_dq9_tx_de-skew",
+	"cs0_dq10_rx_de-skew",
+	"cs0_dq10_tx_de-skew",
+	"cs0_dq11_rx_de-skew",
+	"cs0_dq11_tx_de-skew",
+	"cs0_dq12_rx_de-skew",
+	"cs0_dq12_tx_de-skew",
+	"cs0_dq13_rx_de-skew",
+	"cs0_dq13_tx_de-skew",
+	"cs0_dq14_rx_de-skew",
+	"cs0_dq14_tx_de-skew",
+	"cs0_dq15_rx_de-skew",
+	"cs0_dq15_tx_de-skew",
+	"cs0_dqs1_rx_de-skew",
+	"cs0_dqs1p_tx_de-skew",
+	"cs0_dqs1n_tx_de-skew",
+
+	"cs0_dm2_rx_de-skew",
+	"cs0_dm2_tx_de-skew",
+	"cs0_dq16_rx_de-skew",
+	"cs0_dq16_tx_de-skew",
+	"cs0_dq17_rx_de-skew",
+	"cs0_dq17_tx_de-skew",
+	"cs0_dq18_rx_de-skew",
+	"cs0_dq18_tx_de-skew",
+	"cs0_dq19_rx_de-skew",
+	"cs0_dq19_tx_de-skew",
+	"cs0_dq20_rx_de-skew",
+	"cs0_dq20_tx_de-skew",
+	"cs0_dq21_rx_de-skew",
+	"cs0_dq21_tx_de-skew",
+	"cs0_dq22_rx_de-skew",
+	"cs0_dq22_tx_de-skew",
+	"cs0_dq23_rx_de-skew",
+	"cs0_dq23_tx_de-skew",
+	"cs0_dqs2_rx_de-skew",
+	"cs0_dqs2p_tx_de-skew",
+	"cs0_dqs2n_tx_de-skew",
+
+	"cs0_dm3_rx_de-skew",
+	"cs0_dm3_tx_de-skew",
+	"cs0_dq24_rx_de-skew",
+	"cs0_dq24_tx_de-skew",
+	"cs0_dq25_rx_de-skew",
+	"cs0_dq25_tx_de-skew",
+	"cs0_dq26_rx_de-skew",
+	"cs0_dq26_tx_de-skew",
+	"cs0_dq27_rx_de-skew",
+	"cs0_dq27_tx_de-skew",
+	"cs0_dq28_rx_de-skew",
+	"cs0_dq28_tx_de-skew",
+	"cs0_dq29_rx_de-skew",
+	"cs0_dq29_tx_de-skew",
+	"cs0_dq30_rx_de-skew",
+	"cs0_dq30_tx_de-skew",
+	"cs0_dq31_rx_de-skew",
+	"cs0_dq31_tx_de-skew",
+	"cs0_dqs3_rx_de-skew",
+	"cs0_dqs3p_tx_de-skew",
+	"cs0_dqs3n_tx_de-skew",
+};
+
+static const char * const rk3328_dts_cs1_timing[] = {
+	"cs1_dm0_rx_de-skew",
+	"cs1_dm0_tx_de-skew",
+	"cs1_dq0_rx_de-skew",
+	"cs1_dq0_tx_de-skew",
+	"cs1_dq1_rx_de-skew",
+	"cs1_dq1_tx_de-skew",
+	"cs1_dq2_rx_de-skew",
+	"cs1_dq2_tx_de-skew",
+	"cs1_dq3_rx_de-skew",
+	"cs1_dq3_tx_de-skew",
+	"cs1_dq4_rx_de-skew",
+	"cs1_dq4_tx_de-skew",
+	"cs1_dq5_rx_de-skew",
+	"cs1_dq5_tx_de-skew",
+	"cs1_dq6_rx_de-skew",
+	"cs1_dq6_tx_de-skew",
+	"cs1_dq7_rx_de-skew",
+	"cs1_dq7_tx_de-skew",
+	"cs1_dqs0_rx_de-skew",
+	"cs1_dqs0p_tx_de-skew",
+	"cs1_dqs0n_tx_de-skew",
+
+	"cs1_dm1_rx_de-skew",
+	"cs1_dm1_tx_de-skew",
+	"cs1_dq8_rx_de-skew",
+	"cs1_dq8_tx_de-skew",
+	"cs1_dq9_rx_de-skew",
+	"cs1_dq9_tx_de-skew",
+	"cs1_dq10_rx_de-skew",
+	"cs1_dq10_tx_de-skew",
+	"cs1_dq11_rx_de-skew",
+	"cs1_dq11_tx_de-skew",
+	"cs1_dq12_rx_de-skew",
+	"cs1_dq12_tx_de-skew",
+	"cs1_dq13_rx_de-skew",
+	"cs1_dq13_tx_de-skew",
+	"cs1_dq14_rx_de-skew",
+	"cs1_dq14_tx_de-skew",
+	"cs1_dq15_rx_de-skew",
+	"cs1_dq15_tx_de-skew",
+	"cs1_dqs1_rx_de-skew",
+	"cs1_dqs1p_tx_de-skew",
+	"cs1_dqs1n_tx_de-skew",
+
+	"cs1_dm2_rx_de-skew",
+	"cs1_dm2_tx_de-skew",
+	"cs1_dq16_rx_de-skew",
+	"cs1_dq16_tx_de-skew",
+	"cs1_dq17_rx_de-skew",
+	"cs1_dq17_tx_de-skew",
+	"cs1_dq18_rx_de-skew",
+	"cs1_dq18_tx_de-skew",
+	"cs1_dq19_rx_de-skew",
+	"cs1_dq19_tx_de-skew",
+	"cs1_dq20_rx_de-skew",
+	"cs1_dq20_tx_de-skew",
+	"cs1_dq21_rx_de-skew",
+	"cs1_dq21_tx_de-skew",
+	"cs1_dq22_rx_de-skew",
+	"cs1_dq22_tx_de-skew",
+	"cs1_dq23_rx_de-skew",
+	"cs1_dq23_tx_de-skew",
+	"cs1_dqs2_rx_de-skew",
+	"cs1_dqs2p_tx_de-skew",
+	"cs1_dqs2n_tx_de-skew",
+
+	"cs1_dm3_rx_de-skew",
+	"cs1_dm3_tx_de-skew",
+	"cs1_dq24_rx_de-skew",
+	"cs1_dq24_tx_de-skew",
+	"cs1_dq25_rx_de-skew",
+	"cs1_dq25_tx_de-skew",
+	"cs1_dq26_rx_de-skew",
+	"cs1_dq26_tx_de-skew",
+	"cs1_dq27_rx_de-skew",
+	"cs1_dq27_tx_de-skew",
+	"cs1_dq28_rx_de-skew",
+	"cs1_dq28_tx_de-skew",
+	"cs1_dq29_rx_de-skew",
+	"cs1_dq29_tx_de-skew",
+	"cs1_dq30_rx_de-skew",
+	"cs1_dq30_tx_de-skew",
+	"cs1_dq31_rx_de-skew",
+	"cs1_dq31_tx_de-skew",
+	"cs1_dqs3_rx_de-skew",
+	"cs1_dqs3p_tx_de-skew",
+	"cs1_dqs3n_tx_de-skew",
+};
+
+struct rk3328_ddr_dts_config_timing {
+	unsigned int ddr3_speed_bin;
+	unsigned int ddr4_speed_bin;
+	unsigned int pd_idle;
+	unsigned int sr_idle;
+	unsigned int sr_mc_gate_idle;
+	unsigned int srpd_lite_idle;
+	unsigned int standby_idle;
+
+	unsigned int auto_pd_dis_freq;
+	unsigned int auto_sr_dis_freq;
+	/* for ddr3 only */
+	unsigned int ddr3_dll_dis_freq;
+	/* for ddr4 only */
+	unsigned int ddr4_dll_dis_freq;
+	unsigned int phy_dll_dis_freq;
+
+	unsigned int ddr3_odt_dis_freq;
+	unsigned int phy_ddr3_odt_dis_freq;
+	unsigned int ddr3_drv;
+	unsigned int ddr3_odt;
+	unsigned int phy_ddr3_ca_drv;
+	unsigned int phy_ddr3_ck_drv;
+	unsigned int phy_ddr3_dq_drv;
+	unsigned int phy_ddr3_odt;
+
+	unsigned int lpddr3_odt_dis_freq;
+	unsigned int phy_lpddr3_odt_dis_freq;
+	unsigned int lpddr3_drv;
+	unsigned int lpddr3_odt;
+	unsigned int phy_lpddr3_ca_drv;
+	unsigned int phy_lpddr3_ck_drv;
+	unsigned int phy_lpddr3_dq_drv;
+	unsigned int phy_lpddr3_odt;
+
+	unsigned int lpddr4_odt_dis_freq;
+	unsigned int phy_lpddr4_odt_dis_freq;
+	unsigned int lpddr4_drv;
+	unsigned int lpddr4_dq_odt;
+	unsigned int lpddr4_ca_odt;
+	unsigned int phy_lpddr4_ca_drv;
+	unsigned int phy_lpddr4_ck_cs_drv;
+	unsigned int phy_lpddr4_dq_drv;
+	unsigned int phy_lpddr4_odt;
+
+	unsigned int ddr4_odt_dis_freq;
+	unsigned int phy_ddr4_odt_dis_freq;
+	unsigned int ddr4_drv;
+	unsigned int ddr4_odt;
+	unsigned int phy_ddr4_ca_drv;
+	unsigned int phy_ddr4_ck_drv;
+	unsigned int phy_ddr4_dq_drv;
+	unsigned int phy_ddr4_odt;
+
+	unsigned int ca_skew[15];
+	unsigned int cs0_skew[44];
+	unsigned int cs1_skew[44];
+
+	unsigned int available;
+};
+
+struct rk3328_ddr_de_skew_setting {
+	unsigned int ca_de_skew[30];
+	unsigned int cs0_de_skew[84];
+	unsigned int cs1_de_skew[84];
+};
+
+struct rk3328_dmcfreq {
+	struct device *dev;
+	struct devfreq *devfreq;
+	struct devfreq_simple_ondemand_data ondemand_data;
+	struct clk *dmc_clk;
+	struct devfreq_event_dev *edev;
+	struct mutex lock;
+	struct regulator *vdd_center;
+	unsigned long rate, target_rate;
+	unsigned long volt, target_volt;
+
+	int (*set_auto_self_refresh)(u32 en);
+};
+
+static void
+rk3328_de_skew_setting_2_register(struct rk3328_ddr_de_skew_setting *de_skew,
+				  struct rk3328_ddr_dts_config_timing *tim)
+{
+	u32 n;
+	u32 offset;
+	u32 shift;
+
+	memset_io(tim->ca_skew, 0, sizeof(tim->ca_skew));
+	memset_io(tim->cs0_skew, 0, sizeof(tim->cs0_skew));
+	memset_io(tim->cs1_skew, 0, sizeof(tim->cs1_skew));
+
+	/* CA de-skew */
+	for (n = 0; n < ARRAY_SIZE(de_skew->ca_de_skew); n++) {
+		offset = n / 2;
+		shift = n % 2;
+		/* 0 => 4; 1 => 0 */
+		shift = (shift == 0) ? 4 : 0;
+		tim->ca_skew[offset] &= ~(0xf << shift);
+		tim->ca_skew[offset] |= (de_skew->ca_de_skew[n] << shift);
+	}
+
+	/* CS0 data de-skew */
+	for (n = 0; n < ARRAY_SIZE(de_skew->cs0_de_skew); n++) {
+		offset = ((n / 21) * 11) + ((n % 21) / 2);
+		shift = ((n % 21) % 2);
+		if ((n % 21) == 20)
+			shift = 0;
+		else
+			/* 0 => 4; 1 => 0 */
+			shift = (shift == 0) ? 4 : 0;
+		tim->cs0_skew[offset] &= ~(0xf << shift);
+		tim->cs0_skew[offset] |= (de_skew->cs0_de_skew[n] << shift);
+	}
+
+	/* CS1 data de-skew */
+	for (n = 0; n < ARRAY_SIZE(de_skew->cs1_de_skew); n++) {
+		offset = ((n / 21) * 11) + ((n % 21) / 2);
+		shift = ((n % 21) % 2);
+		if ((n % 21) == 20)
+			shift = 0;
+		else
+			/* 0 => 4; 1 => 0 */
+			shift = (shift == 0) ? 4 : 0;
+		tim->cs1_skew[offset] &= ~(0xf << shift);
+		tim->cs1_skew[offset] |= (de_skew->cs1_de_skew[n] << shift);
+	}
+}
+
+static void of_get_rk3328_timings(struct device *dev,
+				  struct device_node *np, uint32_t *timing)
+{
+	struct device_node *np_tim;
+	u32 *p;
+	struct rk3328_ddr_dts_config_timing *dts_timing;
+	struct rk3328_ddr_de_skew_setting *de_skew;
+	int ret = 0;
+	u32 i;
+
+	dts_timing =
+		(struct rk3328_ddr_dts_config_timing *)(timing +
+							DTS_PAR_OFFSET / 4);
+
+	np_tim = of_parse_phandle(np, "ddr_timing", 0);
+	if (!np_tim) {
+		ret = -EINVAL;
+		goto end;
+	}
+	de_skew = kmalloc(sizeof(*de_skew), GFP_KERNEL);
+	if (!de_skew) {
+		ret = -ENOMEM;
+		goto end;
+	}
+
+	p = (u32 *)dts_timing;
+	for (i = 0; i < ARRAY_SIZE(rk3328_dts_timing); i++) {
+		ret |= of_property_read_u32(np_tim, rk3328_dts_timing[i],
+					p + i);
+	}
+	p = (u32 *)de_skew->ca_de_skew;
+	for (i = 0; i < ARRAY_SIZE(rk3328_dts_ca_timing); i++) {
+		ret |= of_property_read_u32(np_tim, rk3328_dts_ca_timing[i],
+					p + i);
+	}
+	p = (u32 *)de_skew->cs0_de_skew;
+	for (i = 0; i < ARRAY_SIZE(rk3328_dts_cs0_timing); i++) {
+		ret |= of_property_read_u32(np_tim, rk3328_dts_cs0_timing[i],
+					p + i);
+	}
+	p = (u32 *)de_skew->cs1_de_skew;
+	for (i = 0; i < ARRAY_SIZE(rk3328_dts_cs1_timing); i++) {
+		ret |= of_property_read_u32(np_tim, rk3328_dts_cs1_timing[i],
+					p + i);
+	}
+	if (!ret)
+		rk3328_de_skew_setting_2_register(de_skew, dts_timing);
+
+	kfree(de_skew);
+end:
+	if (!ret) {
+		dts_timing->available = 1;
+	} else {
+		dts_timing->available = 0;
+		dev_err(dev, "of_get_ddr_timings: fail\n");
+	}
+
+	of_node_put(np_tim);
+}
+
+static int rockchip_ddr_set_auto_self_refresh(uint32_t en)
+{
+	struct arm_smccc_res res;
+
+	ddr_psci_param->sr_idle_en = en;
+
+	arm_smccc_smc(ROCKCHIP_SIP_DRAM_FREQ,
+		      SHARE_PAGE_TYPE_DDR, 0, ROCKCHIP_SIP_CONFIG_DRAM_SET_AT_SR,
+		      0, 0, 0, 0, &res);
+
+	return res.a0;
+}
+
+static int rk3328_dmc_init(struct platform_device *pdev,
+			   struct rk3328_dmcfreq *dmcfreq)
+{
+	struct arm_smccc_res res;
+	u32 size, page_num;
+
+	arm_smccc_smc(ROCKCHIP_SIP_DRAM_FREQ,
+		      0, 0, ROCKCHIP_SIP_CONFIG_DRAM_GET_VERSION,
+		      0, 0, 0, 0, &res);
+	if (res.a0 || (res.a1 < 0x101)) {
+		dev_err(&pdev->dev,
+			"trusted firmware need to update or is invalid\n");
+		return -ENXIO;
+	}
+
+	dev_notice(&pdev->dev, "current ATF version 0x%lx\n", res.a1);
+
+	/*
+	 * first 4KB is used for interface parameters
+	 * after 4KB * N is dts parameters
+	 */
+	size = sizeof(struct rk3328_ddr_dts_config_timing);
+	page_num = DIV_ROUND_UP(size, 4096) + 1;
+
+	arm_smccc_smc(ROCKCHIP_SIP_SHARE_MEM,
+		      page_num, SHARE_PAGE_TYPE_DDR, 0,
+		      0, 0, 0, 0, &res);
+	if (res.a0 != 0) {
+		dev_err(&pdev->dev, "no ATF memory for init\n");
+		return -ENOMEM;
+	}
+
+	ddr_psci_param = ioremap(res.a1, page_num << 12);
+	of_get_rk3328_timings(&pdev->dev, pdev->dev.of_node,
+			      (uint32_t *)ddr_psci_param);
+
+	arm_smccc_smc(ROCKCHIP_SIP_DRAM_FREQ,
+		      SHARE_PAGE_TYPE_DDR, 0, ROCKCHIP_SIP_CONFIG_DRAM_INIT,
+		      0, 0, 0, 0, &res);
+	if (res.a0) {
+		dev_err(&pdev->dev, "Rockchip dram init error %lx\n", res.a0);
+		return -ENOMEM;
+	}
+
+	dmcfreq->set_auto_self_refresh = rockchip_ddr_set_auto_self_refresh;
+
+	return 0;
+}
+
+static int rk3328_dmcfreq_target(struct device *dev, unsigned long *freq,
+				 u32 flags)
+{
+	struct rk3328_dmcfreq *dmcfreq = dev_get_drvdata(dev);
+	struct dev_pm_opp *opp;
+	unsigned long old_clk_rate = dmcfreq->rate;
+	unsigned long target_volt, target_rate;
+	int err;
+
+	opp = devfreq_recommended_opp(dev, freq, flags);
+	if (IS_ERR(opp))
+		return PTR_ERR(opp);
+
+	target_rate = dev_pm_opp_get_freq(opp);
+	target_volt = dev_pm_opp_get_voltage(opp);
+	dev_pm_opp_put(opp);
+
+	if (dmcfreq->rate == target_rate)
+		return 0;
+
+	mutex_lock(&dmcfreq->lock);
+
+	/*
+	 * If frequency scaling from low to high, adjust voltage first.
+	 * If frequency scaling from high to low, adjust frequency first.
+	 */
+	if (old_clk_rate < target_rate) {
+		err = regulator_set_voltage(dmcfreq->vdd_center, target_volt,
+					    target_volt);
+		if (err) {
+			dev_err(dev, "Cannot set voltage %lu uV\n",
+				target_volt);
+			goto out;
+		}
+	}
+
+	err = clk_set_rate(dmcfreq->dmc_clk, target_rate);
+	if (err) {
+		dev_err(dev, "Cannot set frequency %lu (%d)\n", target_rate,
+			err);
+		regulator_set_voltage(dmcfreq->vdd_center, dmcfreq->volt,
+				      dmcfreq->volt);
+		goto out;
+	}
+
+	/*
+	 * Check the dpll rate,
+	 * There only two result we will get,
+	 * 1. Ddr frequency scaling fail, we still get the old rate.
+	 * 2. Ddr frequency scaling sucessful, we get the rate we set.
+	 */
+	dmcfreq->rate = clk_get_rate(dmcfreq->dmc_clk);
+
+	/* If get the incorrect rate, set voltage to old value. */
+	if (dmcfreq->rate != target_rate) {
+		dev_err(dev, "Got wrong frequency, Request %lu, Current %lu\n",
+			target_rate, dmcfreq->rate);
+		regulator_set_voltage(dmcfreq->vdd_center, dmcfreq->volt,
+				      dmcfreq->volt);
+		goto out;
+	} else if (old_clk_rate > target_rate)
+		err = regulator_set_voltage(dmcfreq->vdd_center, target_volt,
+					    target_volt);
+	if (err)
+		dev_err(dev, "Cannot set voltage %lu uV\n", target_volt);
+
+	dmcfreq->rate = target_rate;
+	dmcfreq->volt = target_volt;
+
+out:
+	mutex_unlock(&dmcfreq->lock);
+	return err;
+}
+
+static int rk3328_dmcfreq_get_dev_status(struct device *dev,
+					 struct devfreq_dev_status *stat)
+{
+	struct rk3328_dmcfreq *dmcfreq = dev_get_drvdata(dev);
+	struct devfreq_event_data edata;
+	int ret = 0;
+
+	ret = devfreq_event_get_event(dmcfreq->edev, &edata);
+	if (ret < 0)
+		return ret;
+
+	stat->current_frequency = dmcfreq->rate;
+	stat->busy_time = edata.load_count;
+	stat->total_time = edata.total_count;
+
+	return ret;
+}
+
+static int rk3328_dmcfreq_get_cur_freq(struct device *dev, unsigned long *freq)
+{
+	struct rk3328_dmcfreq *dmcfreq = dev_get_drvdata(dev);
+
+	*freq = dmcfreq->rate;
+
+	return 0;
+}
+
+static struct devfreq_dev_profile rk3328_devfreq_dmc_profile = {
+	.polling_ms	= 200,
+	.target		= rk3328_dmcfreq_target,
+	.get_dev_status	= rk3328_dmcfreq_get_dev_status,
+	.get_cur_freq	= rk3328_dmcfreq_get_cur_freq,
+};
+
+static __maybe_unused int rk3328_dmcfreq_suspend(struct device *dev)
+{
+	struct rk3328_dmcfreq *dmcfreq = dev_get_drvdata(dev);
+	int ret = 0;
+
+	ret = devfreq_event_disable_edev(dmcfreq->edev);
+	if (ret < 0) {
+		dev_err(dev, "failed to disable the devfreq-event devices\n");
+		return ret;
+	}
+
+	ret = devfreq_suspend_device(dmcfreq->devfreq);
+	if (ret < 0) {
+		dev_err(dev, "failed to suspend the devfreq devices\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static __maybe_unused int rk3328_dmcfreq_resume(struct device *dev)
+{
+	struct rk3328_dmcfreq *dmcfreq = dev_get_drvdata(dev);
+	int ret = 0;
+
+	ret = devfreq_event_enable_edev(dmcfreq->edev);
+	if (ret < 0) {
+		dev_err(dev, "failed to enable the devfreq-event devices\n");
+		return ret;
+	}
+
+	ret = devfreq_resume_device(dmcfreq->devfreq);
+	if (ret < 0) {
+		dev_err(dev, "failed to resume the devfreq devices\n");
+		return ret;
+	}
+	return ret;
+}
+
+static SIMPLE_DEV_PM_OPS(rk3328_dmcfreq_pm, rk3328_dmcfreq_suspend,
+			 rk3328_dmcfreq_resume);
+
+static int rk3328_dmcfreq_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *np = pdev->dev.of_node;
+	struct rk3328_dmcfreq *data;
+	struct dev_pm_opp *opp;
+	int ret;
+
+	data = devm_kzalloc(dev, sizeof(struct rk3328_dmcfreq), GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	mutex_init(&data->lock);
+
+	data->vdd_center = devm_regulator_get(dev, "center");
+	if (IS_ERR(data->vdd_center)) {
+		if (PTR_ERR(data->vdd_center) == -EPROBE_DEFER)
+			return -EPROBE_DEFER;
+
+		dev_err(dev, "Cannot get the regulator \"center\"\n");
+		return PTR_ERR(data->vdd_center);
+	}
+
+	data->dmc_clk = devm_clk_get(dev, "dmc_clk");
+	if (IS_ERR(data->dmc_clk)) {
+		if (PTR_ERR(data->dmc_clk) == -EPROBE_DEFER)
+			return -EPROBE_DEFER;
+
+		dev_err(dev, "Cannot get the clk dmc_clk\n");
+		return PTR_ERR(data->dmc_clk);
+	}
+
+	data->edev = devfreq_event_get_edev_by_phandle(dev, "devfreq-events", 0);
+	if (IS_ERR(data->edev))
+		return -EPROBE_DEFER;
+
+	ret = devfreq_event_enable_edev(data->edev);
+	if (ret < 0) {
+		dev_err(dev, "failed to enable devfreq-event devices\n");
+		return ret;
+	}
+
+	ret = rk3328_dmc_init(pdev, data);
+	if (ret)
+		return ret;
+
+	/*
+	 * We add a devfreq driver to our parent since it has a device tree node
+	 * with operating points.
+	 */
+	if (dev_pm_opp_of_add_table(dev)) {
+		dev_err(dev, "Invalid operating-points in device tree.\n");
+		return -EINVAL;
+	}
+
+	of_property_read_u32(np, "upthreshold",
+			     &data->ondemand_data.upthreshold);
+	of_property_read_u32(np, "downdifferential",
+			     &data->ondemand_data.downdifferential);
+
+	data->rate = clk_get_rate(data->dmc_clk);
+
+	opp = devfreq_recommended_opp(dev, &data->rate, 0);
+	if (IS_ERR(opp)) {
+		ret = PTR_ERR(opp);
+		goto err_free_opp;
+	}
+
+	data->rate = dev_pm_opp_get_freq(opp);
+	data->volt = dev_pm_opp_get_voltage(opp);
+	dev_pm_opp_put(opp);
+
+	rk3328_devfreq_dmc_profile.initial_freq = data->rate;
+
+	data->devfreq = devm_devfreq_add_device(dev,
+					   &rk3328_devfreq_dmc_profile,
+					   DEVFREQ_GOV_SIMPLE_ONDEMAND,
+					   &data->ondemand_data);
+	if (IS_ERR(data->devfreq)) {
+		ret = PTR_ERR(data->devfreq);
+		goto err_free_opp;
+	}
+
+	devm_devfreq_register_opp_notifier(dev, data->devfreq);
+
+	data->dev = dev;
+	platform_set_drvdata(pdev, data);
+
+	return 0;
+
+err_free_opp:
+	dev_pm_opp_of_remove_table(&pdev->dev);
+	return ret;
+}
+
+static int rk3328_dmcfreq_remove(struct platform_device *pdev)
+{
+	struct rk3328_dmcfreq *dmcfreq = dev_get_drvdata(&pdev->dev);
+
+	/*
+	 * Before remove the opp table we need to unregister the opp notifier.
+	 */
+	devm_devfreq_unregister_opp_notifier(dmcfreq->dev, dmcfreq->devfreq);
+	dev_pm_opp_of_remove_table(dmcfreq->dev);
+
+	return 0;
+}
+
+static const struct of_device_id rk3328dmc_devfreq_of_match[] = {
+	{ .compatible = "rockchip,rk3328-dmc" },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, rk3328dmc_devfreq_of_match);
+
+static struct platform_driver rk3328_dmcfreq_driver = {
+	.probe	= rk3328_dmcfreq_probe,
+	.remove = rk3328_dmcfreq_remove,
+	.driver = {
+		.name	= "rk3328-dmc-freq",
+		.pm	= &rk3328_dmcfreq_pm,
+		.of_match_table = rk3328dmc_devfreq_of_match,
+	},
+};
+module_platform_driver(rk3328_dmcfreq_driver);
+
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Lin Huang <hl@rock-chips.com>");
+MODULE_DESCRIPTION("RK3328 dmcfreq driver with devfreq framework");
diff -Naur a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c	2023-04-30 19:32:26.000000000 -0400
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c	2023-05-06 08:46:30.722660105 -0400
@@ -5575,27 +5575,15 @@
 static int stmmac_change_mtu(struct net_device *dev, int new_mtu)
 {
 	struct stmmac_priv *priv = netdev_priv(dev);
-	int txfifosz = priv->plat->tx_fifo_size;
 	struct stmmac_dma_conf *dma_conf;
 	const int mtu = new_mtu;
 	int ret;
 
-	if (txfifosz == 0)
-		txfifosz = priv->dma_cap.tx_fifo_size;
-
-	txfifosz /= priv->plat->tx_queues_to_use;
-
 	if (stmmac_xdp_is_enabled(priv) && new_mtu > ETH_DATA_LEN) {
 		netdev_dbg(priv->dev, "Jumbo frames not supported for XDP\n");
 		return -EINVAL;
 	}
 
-	new_mtu = STMMAC_ALIGN(new_mtu);
-
-	/* If condition true, FIFO is too small or MTU too large */
-	if ((txfifosz < new_mtu) || (new_mtu > BUF_SIZE_16KiB))
-		return -EINVAL;
-
 	if (netif_running(dev)) {
 		netdev_dbg(priv->dev, "restarting interface to change its MTU\n");
 		/* Try to allocate the new DMA conf with the new mtu */
diff -Naur a/drivers/phy/rockchip/Kconfig b/drivers/phy/rockchip/Kconfig
--- a/drivers/phy/rockchip/Kconfig	2023-04-30 19:32:26.000000000 -0400
+++ b/drivers/phy/rockchip/Kconfig	2023-05-06 08:46:30.706660262 -0400
@@ -74,6 +74,15 @@
 	  Enable this to support the Rockchip PCIe/USB3.0/SATA/QSGMII
 	  combo PHY with NaNeng IP block.
 
+config PHY_ROCKCHIP_INNO_USB3
+	tristate "Rockchip INNO USB 3.0 PHY Driver"
+	depends on (ARCH_ROCKCHIP || COMPILE_TEST) && OF
+	depends on USB_SUPPORT
+	select GENERIC_PHY
+	select USB_PHY
+	help
+	  Support for Rockchip USB 3.0 PHY with Innosilicon IP block.
+
 config PHY_ROCKCHIP_PCIE
 	tristate "Rockchip PCIe PHY Driver"
 	depends on (ARCH_ROCKCHIP && OF) || COMPILE_TEST
diff -Naur a/drivers/phy/rockchip/Makefile b/drivers/phy/rockchip/Makefile
--- a/drivers/phy/rockchip/Makefile	2023-04-30 19:32:26.000000000 -0400
+++ b/drivers/phy/rockchip/Makefile	2023-05-06 08:46:30.706660262 -0400
@@ -6,6 +6,7 @@
 obj-$(CONFIG_PHY_ROCKCHIP_INNO_DSIDPHY)	+= phy-rockchip-inno-dsidphy.o
 obj-$(CONFIG_PHY_ROCKCHIP_INNO_HDMI)	+= phy-rockchip-inno-hdmi.o
 obj-$(CONFIG_PHY_ROCKCHIP_INNO_USB2)	+= phy-rockchip-inno-usb2.o
+obj-$(CONFIG_PHY_ROCKCHIP_INNO_USB3)	+= phy-rockchip-inno-usb3.o
 obj-$(CONFIG_PHY_ROCKCHIP_NANENG_COMBO_PHY)	+= phy-rockchip-naneng-combphy.o
 obj-$(CONFIG_PHY_ROCKCHIP_PCIE)		+= phy-rockchip-pcie.o
 obj-$(CONFIG_PHY_ROCKCHIP_SNPS_PCIE3)	+= phy-rockchip-snps-pcie3.o
--- /dev/null	2023-04-29 08:31:15.023562380 -0400
+++ b/drivers/phy/rockchip/phy-rockchip-inno-usb3.c	2023-05-06 08:46:30.707660252 -0400
@@ -0,0 +1,1107 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Rockchip USB 3.0 PHY with Innosilicon IP block driver
+ *
+ * Copyright (C) 2016 Fuzhou Rockchip Electronics Co., Ltd
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/debugfs.h>
+#include <linux/gpio/consumer.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/mfd/syscon.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_clk.h>
+#include <linux/of_irq.h>
+#include <linux/of_platform.h>
+#include <linux/phy/phy.h>
+#include <linux/platform_device.h>
+#include <linux/regmap.h>
+#include <linux/reset.h>
+#include <linux/usb/phy.h>
+#include <linux/uaccess.h>
+
+#define U3PHY_PORT_NUM	2
+#define BIT_WRITEABLE_SHIFT	16
+#define SCHEDULE_DELAY	(60 * HZ)
+
+#define U3PHY_APB_RST	BIT(0)
+#define U3PHY_POR_RST	BIT(1)
+#define U3PHY_MAC_RST	BIT(2)
+
+struct rockchip_u3phy;
+struct rockchip_u3phy_port;
+
+enum rockchip_u3phy_type {
+	U3PHY_TYPE_PIPE,
+	U3PHY_TYPE_UTMI,
+};
+
+enum rockchip_u3phy_pipe_pwr {
+	PIPE_PWR_P0	= 0,
+	PIPE_PWR_P1	= 1,
+	PIPE_PWR_P2	= 2,
+	PIPE_PWR_P3	= 3,
+	PIPE_PWR_MAX	= 4,
+};
+
+enum rockchip_u3phy_rest_req {
+	U3_POR_RSTN	= 0,
+	U2_POR_RSTN	= 1,
+	PIPE_MAC_RSTN	= 2,
+	UTMI_MAC_RSTN	= 3,
+	PIPE_APB_RSTN	= 4,
+	UTMI_APB_RSTN	= 5,
+	U3PHY_RESET_MAX	= 6,
+};
+
+enum rockchip_u3phy_utmi_state {
+	PHY_UTMI_HS_ONLINE	= 0,
+	PHY_UTMI_DISCONNECT	= 1,
+	PHY_UTMI_CONNECT	= 2,
+	PHY_UTMI_FS_LS_ONLINE	= 4,
+};
+
+/*
+ * @rvalue: reset value
+ * @dvalue: desired value
+ */
+struct u3phy_reg {
+	unsigned int	offset;
+	unsigned int	bitend;
+	unsigned int	bitstart;
+	unsigned int	rvalue;
+	unsigned int	dvalue;
+};
+
+struct rockchip_u3phy_grfcfg {
+	struct u3phy_reg	um_suspend;
+	struct u3phy_reg	ls_det_en;
+	struct u3phy_reg	ls_det_st;
+	struct u3phy_reg	um_ls;
+	struct u3phy_reg	um_hstdct;
+	struct u3phy_reg	u2_only_ctrl;
+	struct u3phy_reg	u3_disable;
+	struct u3phy_reg	pp_pwr_st;
+	struct u3phy_reg	pp_pwr_en[PIPE_PWR_MAX];
+};
+
+/**
+ * struct rockchip_u3phy_apbcfg: usb3-phy apb configuration.
+ * @u2_pre_emp: usb2-phy pre-emphasis tuning.
+ * @u2_pre_emp_sth: usb2-phy pre-emphasis strength tuning.
+ * @u2_odt_tuning: usb2-phy odt 45ohm tuning.
+ */
+struct rockchip_u3phy_apbcfg {
+	unsigned int	u2_pre_emp;
+	unsigned int	u2_pre_emp_sth;
+	unsigned int	u2_odt_tuning;
+};
+
+struct rockchip_u3phy_cfg {
+	unsigned int reg;
+	const struct rockchip_u3phy_grfcfg grfcfg;
+
+	int (*phy_pipe_power)(struct rockchip_u3phy *u3phy,
+			      struct rockchip_u3phy_port *u3phy_port,
+			      bool on);
+	int (*phy_tuning)(struct rockchip_u3phy *u3phy,
+			  struct rockchip_u3phy_port *u3phy_port,
+			  struct device_node *child_np);
+};
+
+struct rockchip_u3phy_port {
+	struct phy	*phy;
+	void __iomem	*base;
+	unsigned int	index;
+	unsigned char	type;
+	bool		suspended;
+	bool		refclk_25m_quirk;
+	struct mutex	mutex; /* mutex for updating register */
+	struct delayed_work	um_sm_work;
+};
+
+struct rockchip_u3phy {
+	struct device *dev;
+	struct regmap *u3phy_grf;
+	struct regmap *grf;
+	int um_ls_irq;
+	struct clk **clks;
+	int num_clocks;
+	struct dentry *root;
+	struct gpio_desc *vbus_drv_gpio;
+	struct reset_control *rsts[U3PHY_RESET_MAX];
+	struct rockchip_u3phy_apbcfg apbcfg;
+	const struct rockchip_u3phy_cfg *cfgs;
+	struct rockchip_u3phy_port ports[U3PHY_PORT_NUM];
+	struct usb_phy usb_phy;
+};
+
+static inline int param_write(void __iomem *base,
+			      const struct u3phy_reg *reg, bool desired)
+{
+	unsigned int val, mask;
+	unsigned int tmp = desired ? reg->dvalue : reg->rvalue;
+	int ret = 0;
+
+	mask = GENMASK(reg->bitend, reg->bitstart);
+	val = (tmp << reg->bitstart) | (mask << BIT_WRITEABLE_SHIFT);
+	ret = regmap_write(base, reg->offset, val);
+
+	return ret;
+}
+
+static inline bool param_exped(void __iomem *base,
+			       const struct u3phy_reg *reg,
+			       unsigned int value)
+{
+	int ret;
+	unsigned int tmp, orig;
+	unsigned int mask = GENMASK(reg->bitend, reg->bitstart);
+
+	ret = regmap_read(base, reg->offset, &orig);
+	if (ret)
+		return false;
+
+	tmp = (orig & mask) >> reg->bitstart;
+	return tmp == value;
+}
+
+static int rockchip_u3phy_usb2_only_show(struct seq_file *s, void *unused)
+{
+	struct rockchip_u3phy	*u3phy = s->private;
+
+	if (param_exped(u3phy->u3phy_grf, &u3phy->cfgs->grfcfg.u2_only_ctrl, 1))
+		dev_info(u3phy->dev, "u2\n");
+	else
+		dev_info(u3phy->dev, "u3\n");
+
+	return 0;
+}
+
+static int rockchip_u3phy_usb2_only_open(struct inode *inode,
+					 struct file *file)
+{
+	return single_open(file, rockchip_u3phy_usb2_only_show,
+			   inode->i_private);
+}
+
+static ssize_t rockchip_u3phy_usb2_only_write(struct file *file,
+					      const char __user *ubuf,
+					      size_t count, loff_t *ppos)
+{
+	struct seq_file			*s = file->private_data;
+	struct rockchip_u3phy		*u3phy = s->private;
+	struct rockchip_u3phy_port	*u3phy_port;
+	char				buf[32];
+	u8				index;
+
+	if (copy_from_user(&buf, ubuf, min_t(size_t, sizeof(buf) - 1, count)))
+		return -EFAULT;
+
+	if (!strncmp(buf, "u3", 2) &&
+	    param_exped(u3phy->u3phy_grf,
+			&u3phy->cfgs->grfcfg.u2_only_ctrl, 1)) {
+		dev_info(u3phy->dev, "Set usb3.0 and usb2.0 mode successfully\n");
+
+		gpiod_set_value_cansleep(u3phy->vbus_drv_gpio, 0);
+
+		param_write(u3phy->grf,
+			    &u3phy->cfgs->grfcfg.u3_disable, false);
+		param_write(u3phy->u3phy_grf,
+			    &u3phy->cfgs->grfcfg.u2_only_ctrl, false);
+
+		for (index = 0; index < U3PHY_PORT_NUM; index++) {
+			u3phy_port = &u3phy->ports[index];
+			/* enable u3 rx termimation */
+			if (u3phy_port->type == U3PHY_TYPE_PIPE)
+				writel(0x30, u3phy_port->base + 0xd8);
+		}
+
+		atomic_notifier_call_chain(&u3phy->usb_phy.notifier, 0, NULL);
+
+		gpiod_set_value_cansleep(u3phy->vbus_drv_gpio, 1);
+	} else if (!strncmp(buf, "u2", 2) &&
+		   param_exped(u3phy->u3phy_grf,
+			       &u3phy->cfgs->grfcfg.u2_only_ctrl, 0)) {
+		dev_info(u3phy->dev, "Set usb2.0 only mode successfully\n");
+
+		gpiod_set_value_cansleep(u3phy->vbus_drv_gpio, 0);
+
+		param_write(u3phy->grf,
+			    &u3phy->cfgs->grfcfg.u3_disable, true);
+		param_write(u3phy->u3phy_grf,
+			    &u3phy->cfgs->grfcfg.u2_only_ctrl, true);
+
+		for (index = 0; index < U3PHY_PORT_NUM; index++) {
+			u3phy_port = &u3phy->ports[index];
+			/* disable u3 rx termimation */
+			if (u3phy_port->type == U3PHY_TYPE_PIPE)
+				writel(0x20, u3phy_port->base + 0xd8);
+		}
+
+		atomic_notifier_call_chain(&u3phy->usb_phy.notifier, 0, NULL);
+
+		gpiod_set_value_cansleep(u3phy->vbus_drv_gpio, 1);
+	} else {
+		dev_info(u3phy->dev, "Same or illegal mode\n");
+	}
+
+	return count;
+}
+
+static const struct file_operations rockchip_u3phy_usb2_only_fops = {
+	.open			= rockchip_u3phy_usb2_only_open,
+	.write			= rockchip_u3phy_usb2_only_write,
+	.read			= seq_read,
+	.llseek			= seq_lseek,
+	.release		= single_release,
+};
+
+int rockchip_u3phy_debugfs_init(struct rockchip_u3phy *u3phy)
+{
+	struct dentry		*root;
+	struct dentry		*file;
+	int			ret;
+
+	root = debugfs_create_dir(dev_name(u3phy->dev), NULL);
+	if (!root) {
+		ret = -ENOMEM;
+		goto err0;
+	}
+
+	u3phy->root = root;
+
+	file = debugfs_create_file("u3phy_mode", 0644, root,
+				   u3phy, &rockchip_u3phy_usb2_only_fops);
+	if (!file) {
+		ret = -ENOMEM;
+		goto err1;
+	}
+	return 0;
+
+err1:
+	debugfs_remove_recursive(root);
+err0:
+	return ret;
+}
+
+static const char *get_rest_name(enum rockchip_u3phy_rest_req rst)
+{
+	switch (rst) {
+	case U2_POR_RSTN:
+		return "u3phy-u2-por";
+	case U3_POR_RSTN:
+		return "u3phy-u3-por";
+	case PIPE_MAC_RSTN:
+		return "u3phy-pipe-mac";
+	case UTMI_MAC_RSTN:
+		return "u3phy-utmi-mac";
+	case UTMI_APB_RSTN:
+		return "u3phy-utmi-apb";
+	case PIPE_APB_RSTN:
+		return "u3phy-pipe-apb";
+	default:
+		return "invalid";
+	}
+}
+
+static void rockchip_u3phy_rest_deassert(struct rockchip_u3phy *u3phy,
+					 unsigned int flag)
+{
+	int rst;
+
+	if (flag & U3PHY_APB_RST) {
+		dev_dbg(u3phy->dev, "deassert APB bus interface reset\n");
+		for (rst = PIPE_APB_RSTN; rst <= UTMI_APB_RSTN; rst++) {
+			if (u3phy->rsts[rst])
+				reset_control_deassert(u3phy->rsts[rst]);
+		}
+	}
+
+	if (flag & U3PHY_POR_RST) {
+		usleep_range(12, 15);
+		dev_dbg(u3phy->dev, "deassert u2 and u3 phy power on reset\n");
+		for (rst = U3_POR_RSTN; rst <= U2_POR_RSTN; rst++) {
+			if (u3phy->rsts[rst])
+				reset_control_deassert(u3phy->rsts[rst]);
+		}
+	}
+
+	if (flag & U3PHY_MAC_RST) {
+		usleep_range(1200, 1500);
+		dev_dbg(u3phy->dev, "deassert pipe and utmi MAC reset\n");
+		for (rst = PIPE_MAC_RSTN; rst <= UTMI_MAC_RSTN; rst++)
+			if (u3phy->rsts[rst])
+				reset_control_deassert(u3phy->rsts[rst]);
+	}
+}
+
+static void rockchip_u3phy_rest_assert(struct rockchip_u3phy *u3phy)
+{
+	int rst;
+
+	dev_dbg(u3phy->dev, "assert u3phy reset\n");
+	for (rst = 0; rst < U3PHY_RESET_MAX; rst++)
+		if (u3phy->rsts[rst])
+			reset_control_assert(u3phy->rsts[rst]);
+}
+
+static int rockchip_u3phy_clk_enable(struct rockchip_u3phy *u3phy)
+{
+	int ret, clk;
+
+	for (clk = 0; clk < u3phy->num_clocks && u3phy->clks[clk]; clk++) {
+		ret = clk_prepare_enable(u3phy->clks[clk]);
+		if (ret)
+			goto err_disable_clks;
+	}
+	return 0;
+
+err_disable_clks:
+	while (--clk >= 0)
+		clk_disable_unprepare(u3phy->clks[clk]);
+	return ret;
+}
+
+static void rockchip_u3phy_clk_disable(struct rockchip_u3phy *u3phy)
+{
+	int clk;
+
+	for (clk = u3phy->num_clocks - 1; clk >= 0; clk--)
+		if (u3phy->clks[clk])
+			clk_disable_unprepare(u3phy->clks[clk]);
+}
+
+static int rockchip_u3phy_init(struct phy *phy)
+{
+	return 0;
+}
+
+static int rockchip_u3phy_exit(struct phy *phy)
+{
+	return 0;
+}
+
+static int rockchip_u3phy_power_on(struct phy *phy)
+{
+	struct rockchip_u3phy_port *u3phy_port = phy_get_drvdata(phy);
+	struct rockchip_u3phy *u3phy = dev_get_drvdata(phy->dev.parent);
+	int ret;
+
+	dev_info(&u3phy_port->phy->dev, "u3phy %s power on\n",
+		 (u3phy_port->type == U3PHY_TYPE_UTMI) ? "u2" : "u3");
+
+	if (!u3phy_port->suspended)
+		return 0;
+
+	ret = rockchip_u3phy_clk_enable(u3phy);
+	if (ret)
+		return ret;
+
+	if (u3phy_port->type == U3PHY_TYPE_UTMI) {
+		param_write(u3phy->u3phy_grf,
+			    &u3phy->cfgs->grfcfg.um_suspend, false);
+	} else {
+		/* current in p2 ? */
+		if (param_exped(u3phy->u3phy_grf,
+				&u3phy->cfgs->grfcfg.pp_pwr_st, PIPE_PWR_P2))
+			goto done;
+
+		if (u3phy->cfgs->phy_pipe_power) {
+			dev_dbg(u3phy->dev, "do pipe power up\n");
+			u3phy->cfgs->phy_pipe_power(u3phy, u3phy_port, true);
+		}
+
+		/* exit to p0 */
+		param_write(u3phy->u3phy_grf,
+			    &u3phy->cfgs->grfcfg.pp_pwr_en[PIPE_PWR_P0], true);
+		usleep_range(90, 100);
+
+		/* enter to p2 from p0 */
+		param_write(u3phy->u3phy_grf,
+			    &u3phy->cfgs->grfcfg.pp_pwr_en[PIPE_PWR_P2],
+			    false);
+		udelay(3);
+	}
+
+done:
+	u3phy_port->suspended = false;
+	return 0;
+}
+
+static int rockchip_u3phy_power_off(struct phy *phy)
+{
+	struct rockchip_u3phy_port *u3phy_port = phy_get_drvdata(phy);
+	struct rockchip_u3phy *u3phy = dev_get_drvdata(phy->dev.parent);
+
+	dev_info(&u3phy_port->phy->dev, "u3phy %s power off\n",
+		 (u3phy_port->type == U3PHY_TYPE_UTMI) ? "u2" : "u3");
+
+	if (u3phy_port->suspended)
+		return 0;
+
+	if (u3phy_port->type == U3PHY_TYPE_UTMI) {
+		param_write(u3phy->u3phy_grf,
+			    &u3phy->cfgs->grfcfg.um_suspend, true);
+	} else {
+		/* current in p3 ? */
+		if (param_exped(u3phy->u3phy_grf,
+				&u3phy->cfgs->grfcfg.pp_pwr_st, PIPE_PWR_P3))
+			goto done;
+
+		/* exit to p0 */
+		param_write(u3phy->u3phy_grf,
+			    &u3phy->cfgs->grfcfg.pp_pwr_en[PIPE_PWR_P0], true);
+		udelay(2);
+
+		/* enter to p3 from p0 */
+		param_write(u3phy->u3phy_grf,
+			    &u3phy->cfgs->grfcfg.pp_pwr_en[PIPE_PWR_P3], true);
+		udelay(6);
+
+		if (u3phy->cfgs->phy_pipe_power) {
+			dev_dbg(u3phy->dev, "do pipe power down\n");
+			u3phy->cfgs->phy_pipe_power(u3phy, u3phy_port, false);
+		}
+	}
+
+done:
+	rockchip_u3phy_clk_disable(u3phy);
+	u3phy_port->suspended = true;
+	return 0;
+}
+
+static __maybe_unused
+struct phy *rockchip_u3phy_xlate(struct device *dev,
+				 struct of_phandle_args *args)
+{
+	struct rockchip_u3phy *u3phy = dev_get_drvdata(dev);
+	struct rockchip_u3phy_port *u3phy_port = NULL;
+	struct device_node *phy_np = args->np;
+	int index;
+
+	if (args->args_count != 1) {
+		dev_err(dev, "invalid number of cells in 'phy' property\n");
+		return ERR_PTR(-EINVAL);
+	}
+
+	for (index = 0; index < U3PHY_PORT_NUM; index++) {
+		if (phy_np == u3phy->ports[index].phy->dev.of_node) {
+			u3phy_port = &u3phy->ports[index];
+			break;
+		}
+	}
+
+	if (!u3phy_port) {
+		dev_err(dev, "failed to find appropriate phy\n");
+		return ERR_PTR(-EINVAL);
+	}
+
+	return u3phy_port->phy;
+}
+
+static struct phy_ops rockchip_u3phy_ops = {
+	.init		= rockchip_u3phy_init,
+	.exit		= rockchip_u3phy_exit,
+	.power_on	= rockchip_u3phy_power_on,
+	.power_off	= rockchip_u3phy_power_off,
+	.owner		= THIS_MODULE,
+};
+
+/*
+ * The function manage host-phy port state and suspend/resume phy port
+ * to save power automatically.
+ *
+ * we rely on utmi_linestate and utmi_hostdisconnect to identify whether
+ * devices is disconnect or not. Besides, we do not need care it is FS/LS
+ * disconnected or HS disconnected, actually, we just only need get the
+ * device is disconnected at last through rearm the delayed work,
+ * to suspend the phy port in _PHY_STATE_DISCONNECT_ case.
+ */
+static void rockchip_u3phy_um_sm_work(struct work_struct *work)
+{
+	struct rockchip_u3phy_port *u3phy_port =
+		container_of(work, struct rockchip_u3phy_port, um_sm_work.work);
+	struct rockchip_u3phy *u3phy =
+		dev_get_drvdata(u3phy_port->phy->dev.parent);
+	unsigned int sh = u3phy->cfgs->grfcfg.um_hstdct.bitend -
+			u3phy->cfgs->grfcfg.um_hstdct.bitstart + 1;
+	unsigned int ul, uhd, state;
+	unsigned int ul_mask, uhd_mask;
+	int ret;
+
+	mutex_lock(&u3phy_port->mutex);
+
+	ret = regmap_read(u3phy->u3phy_grf,
+			  u3phy->cfgs->grfcfg.um_ls.offset, &ul);
+	if (ret < 0)
+		goto next_schedule;
+
+	ret = regmap_read(u3phy->u3phy_grf,
+			  u3phy->cfgs->grfcfg.um_hstdct.offset, &uhd);
+	if (ret < 0)
+		goto next_schedule;
+
+	uhd_mask = GENMASK(u3phy->cfgs->grfcfg.um_hstdct.bitend,
+			   u3phy->cfgs->grfcfg.um_hstdct.bitstart);
+	ul_mask = GENMASK(u3phy->cfgs->grfcfg.um_ls.bitend,
+			  u3phy->cfgs->grfcfg.um_ls.bitstart);
+
+	/* stitch on um_ls and um_hstdct as phy state */
+	state = ((uhd & uhd_mask) >> u3phy->cfgs->grfcfg.um_hstdct.bitstart) |
+		(((ul & ul_mask) >> u3phy->cfgs->grfcfg.um_ls.bitstart) << sh);
+
+	switch (state) {
+	case PHY_UTMI_HS_ONLINE:
+		dev_dbg(&u3phy_port->phy->dev, "HS online\n");
+		break;
+	case PHY_UTMI_FS_LS_ONLINE:
+		/*
+		 * For FS/LS device, the online state share with connect state
+		 * from um_ls and um_hstdct register, so we distinguish
+		 * them via suspended flag.
+		 *
+		 * Plus, there are two cases, one is D- Line pull-up, and D+
+		 * line pull-down, the state is 4; another is D+ line pull-up,
+		 * and D- line pull-down, the state is 2.
+		 */
+		if (!u3phy_port->suspended) {
+			/* D- line pull-up, D+ line pull-down */
+			dev_dbg(&u3phy_port->phy->dev, "FS/LS online\n");
+			break;
+		}
+		/* fall through */
+	case PHY_UTMI_CONNECT:
+		if (u3phy_port->suspended) {
+			dev_dbg(&u3phy_port->phy->dev, "Connected\n");
+			rockchip_u3phy_power_on(u3phy_port->phy);
+			u3phy_port->suspended = false;
+		} else {
+			/* D+ line pull-up, D- line pull-down */
+			dev_dbg(&u3phy_port->phy->dev, "FS/LS online\n");
+		}
+		break;
+	case PHY_UTMI_DISCONNECT:
+		if (!u3phy_port->suspended) {
+			dev_dbg(&u3phy_port->phy->dev, "Disconnected\n");
+			rockchip_u3phy_power_off(u3phy_port->phy);
+			u3phy_port->suspended = true;
+		}
+
+		/*
+		 * activate the linestate detection to get the next device
+		 * plug-in irq.
+		 */
+		param_write(u3phy->u3phy_grf,
+			    &u3phy->cfgs->grfcfg.ls_det_st, true);
+		param_write(u3phy->u3phy_grf,
+			    &u3phy->cfgs->grfcfg.ls_det_en, true);
+
+		/*
+		 * we don't need to rearm the delayed work when the phy port
+		 * is suspended.
+		 */
+		mutex_unlock(&u3phy_port->mutex);
+		return;
+	default:
+		dev_dbg(&u3phy_port->phy->dev, "unknown phy state\n");
+		break;
+	}
+
+next_schedule:
+	mutex_unlock(&u3phy_port->mutex);
+	schedule_delayed_work(&u3phy_port->um_sm_work, SCHEDULE_DELAY);
+}
+
+static irqreturn_t rockchip_u3phy_um_ls_irq(int irq, void *data)
+{
+	struct rockchip_u3phy_port *u3phy_port = data;
+	struct rockchip_u3phy *u3phy =
+		dev_get_drvdata(u3phy_port->phy->dev.parent);
+
+	if (!param_exped(u3phy->u3phy_grf,
+			 &u3phy->cfgs->grfcfg.ls_det_st,
+			 u3phy->cfgs->grfcfg.ls_det_st.dvalue))
+		return IRQ_NONE;
+
+	dev_dbg(u3phy->dev, "utmi linestate interrupt\n");
+	mutex_lock(&u3phy_port->mutex);
+
+	/* disable linestate detect irq and clear its status */
+	param_write(u3phy->u3phy_grf, &u3phy->cfgs->grfcfg.ls_det_en, false);
+	param_write(u3phy->u3phy_grf, &u3phy->cfgs->grfcfg.ls_det_st, true);
+
+	mutex_unlock(&u3phy_port->mutex);
+
+	/*
+	 * In this case for host phy, a new device is plugged in, meanwhile,
+	 * if the phy port is suspended, we need rearm the work to resume it
+	 * and mange its states; otherwise, we just return irq handled.
+	 */
+	if (u3phy_port->suspended) {
+		dev_dbg(u3phy->dev, "schedule utmi sm work\n");
+		rockchip_u3phy_um_sm_work(&u3phy_port->um_sm_work.work);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int rockchip_u3phy_parse_dt(struct rockchip_u3phy *u3phy,
+				   struct platform_device *pdev)
+
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node;
+	int ret, i, clk;
+
+	u3phy->um_ls_irq = platform_get_irq_byname(pdev, "linestate");
+	if (u3phy->um_ls_irq < 0) {
+		dev_err(dev, "get utmi linestate irq failed\n");
+		return -ENXIO;
+	}
+
+	u3phy->vbus_drv_gpio = devm_gpiod_get_optional(dev, "vbus-drv",
+						       GPIOD_OUT_HIGH);
+
+	if (!u3phy->vbus_drv_gpio) {
+		dev_warn(&pdev->dev, "vbus_drv is not assigned\n");
+	} else if (IS_ERR(u3phy->vbus_drv_gpio)) {
+		dev_err(&pdev->dev, "failed to get vbus_drv\n");
+		return PTR_ERR(u3phy->vbus_drv_gpio);
+	}
+
+	u3phy->num_clocks = of_clk_get_parent_count(np);
+	if (u3phy->num_clocks == 0)
+		dev_warn(&pdev->dev, "no clks found in dt\n");
+
+	u3phy->clks = devm_kcalloc(dev, u3phy->num_clocks,
+				  sizeof(struct clk *), GFP_KERNEL);
+
+	for (clk = 0; clk < u3phy->num_clocks; clk++) {
+		u3phy->clks[clk] = of_clk_get(np, clk);
+		if (IS_ERR(u3phy->clks[clk])) {
+			ret = PTR_ERR(u3phy->clks[clk]);
+			if (ret == -EPROBE_DEFER)
+				goto err_put_clks;
+			dev_err(&pdev->dev, "failed to get clks, %i\n",
+				ret);
+			u3phy->clks[clk] = NULL;
+			break;
+		}
+	}
+
+	for (i = 0; i < U3PHY_RESET_MAX; i++) {
+		u3phy->rsts[i] = devm_reset_control_get(dev, get_rest_name(i));
+		if (IS_ERR(u3phy->rsts[i])) {
+			dev_info(dev, "no %s reset control specified\n",
+				 get_rest_name(i));
+			u3phy->rsts[i] = NULL;
+		}
+	}
+
+	return 0;
+
+err_put_clks:
+	while (--clk >= 0)
+		clk_put(u3phy->clks[clk]);
+	return ret;
+}
+
+static int rockchip_u3phy_port_init(struct rockchip_u3phy *u3phy,
+				    struct rockchip_u3phy_port *u3phy_port,
+				    struct device_node *child_np)
+{
+	struct resource res;
+	struct phy *phy;
+	int ret;
+
+	dev_dbg(u3phy->dev, "u3phy port initialize\n");
+
+	mutex_init(&u3phy_port->mutex);
+	u3phy_port->suspended = true; /* initial status */
+
+	phy = devm_phy_create(u3phy->dev, child_np, &rockchip_u3phy_ops);
+	if (IS_ERR(phy)) {
+		dev_err(u3phy->dev, "failed to create phy\n");
+		return PTR_ERR(phy);
+	}
+
+	u3phy_port->phy = phy;
+
+	ret = of_address_to_resource(child_np, 0, &res);
+	if (ret) {
+		dev_err(u3phy->dev, "failed to get address resource(np-%s)\n",
+			child_np->name);
+		return ret;
+	}
+
+	u3phy_port->base = devm_ioremap_resource(&u3phy_port->phy->dev, &res);
+	if (IS_ERR(u3phy_port->base)) {
+		dev_err(u3phy->dev, "failed to remap phy regs\n");
+		return PTR_ERR(u3phy_port->base);
+	}
+
+	if (!of_node_cmp(child_np->name, "pipe")) {
+		u3phy_port->type = U3PHY_TYPE_PIPE;
+		u3phy_port->refclk_25m_quirk =
+			of_property_read_bool(child_np,
+					      "rockchip,refclk-25m-quirk");
+	} else {
+		u3phy_port->type = U3PHY_TYPE_UTMI;
+		INIT_DELAYED_WORK(&u3phy_port->um_sm_work,
+				  rockchip_u3phy_um_sm_work);
+
+		ret = devm_request_threaded_irq(u3phy->dev, u3phy->um_ls_irq,
+						NULL, rockchip_u3phy_um_ls_irq,
+						IRQF_ONESHOT, "rockchip_u3phy",
+						u3phy_port);
+		if (ret) {
+			dev_err(u3phy->dev, "failed to request utmi linestate irq handle\n");
+			return ret;
+		}
+	}
+
+	if (u3phy->cfgs->phy_tuning) {
+		dev_dbg(u3phy->dev, "do u3phy tuning\n");
+		ret = u3phy->cfgs->phy_tuning(u3phy, u3phy_port, child_np);
+		if (ret)
+			return ret;
+	}
+
+	phy_set_drvdata(u3phy_port->phy, u3phy_port);
+	return 0;
+}
+
+static int rockchip_u3phy_on_init(struct usb_phy *usb_phy)
+{
+	struct rockchip_u3phy *u3phy =
+		container_of(usb_phy, struct rockchip_u3phy, usb_phy);
+
+	rockchip_u3phy_rest_deassert(u3phy, U3PHY_POR_RST | U3PHY_MAC_RST);
+	return 0;
+}
+
+static void rockchip_u3phy_on_shutdown(struct usb_phy *usb_phy)
+{
+	struct rockchip_u3phy *u3phy =
+		container_of(usb_phy, struct rockchip_u3phy, usb_phy);
+	int rst;
+
+	for (rst = 0; rst < U3PHY_RESET_MAX; rst++)
+		if (u3phy->rsts[rst] && rst != UTMI_APB_RSTN &&
+		    rst != PIPE_APB_RSTN)
+			reset_control_assert(u3phy->rsts[rst]);
+	udelay(1);
+}
+
+static int rockchip_u3phy_on_disconnect(struct usb_phy *usb_phy,
+					enum usb_device_speed speed)
+{
+	struct rockchip_u3phy *u3phy =
+		container_of(usb_phy, struct rockchip_u3phy, usb_phy);
+
+	dev_info(u3phy->dev, "%s device has disconnected\n",
+		 (speed == USB_SPEED_SUPER) ? "U3" : "UW/U2/U1.1/U1");
+
+	if (speed == USB_SPEED_SUPER)
+		atomic_notifier_call_chain(&usb_phy->notifier, 0, NULL);
+
+	return 0;
+}
+
+static int rockchip_u3phy_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node;
+	struct device_node *child_np;
+	struct phy_provider *provider;
+	struct rockchip_u3phy *u3phy;
+	const struct rockchip_u3phy_cfg *phy_cfgs;
+	const struct of_device_id *match;
+	unsigned int reg[2];
+	int index, ret;
+
+	match = of_match_device(dev->driver->of_match_table, dev);
+	if (!match || !match->data) {
+		dev_err(dev, "phy-cfgs are not assigned!\n");
+		return -EINVAL;
+	}
+
+	u3phy = devm_kzalloc(dev, sizeof(*u3phy), GFP_KERNEL);
+	if (!u3phy)
+		return -ENOMEM;
+
+	u3phy->u3phy_grf =
+		syscon_regmap_lookup_by_phandle(np, "rockchip,u3phygrf");
+	if (IS_ERR(u3phy->u3phy_grf))
+		return PTR_ERR(u3phy->u3phy_grf);
+
+	u3phy->grf =
+		syscon_regmap_lookup_by_phandle(np, "rockchip,grf");
+	if (IS_ERR(u3phy->grf)) {
+		dev_err(dev, "Missing rockchip,grf property\n");
+		return PTR_ERR(u3phy->grf);
+	}
+
+	if (of_property_read_u32_array(np, "reg", reg, 2)) {
+		dev_err(dev, "the reg property is not assigned in %s node\n",
+			np->name);
+		return -EINVAL;
+	}
+
+	u3phy->dev = dev;
+	phy_cfgs = match->data;
+	platform_set_drvdata(pdev, u3phy);
+
+	/* find out a proper config which can be matched with dt. */
+	index = 0;
+	while (phy_cfgs[index].reg) {
+		if (phy_cfgs[index].reg == reg[1]) {
+			u3phy->cfgs = &phy_cfgs[index];
+			break;
+		}
+
+		++index;
+	}
+
+	if (!u3phy->cfgs) {
+		dev_err(dev, "no phy-cfgs can be matched with %s node\n",
+			np->name);
+		return -EINVAL;
+	}
+
+	ret = rockchip_u3phy_parse_dt(u3phy, pdev);
+	if (ret) {
+		dev_err(dev, "parse dt failed, ret(%d)\n", ret);
+		return ret;
+	}
+
+	ret = rockchip_u3phy_clk_enable(u3phy);
+	if (ret) {
+		dev_err(dev, "clk enable failed, ret(%d)\n", ret);
+		return ret;
+	}
+
+	rockchip_u3phy_rest_assert(u3phy);
+	rockchip_u3phy_rest_deassert(u3phy, U3PHY_APB_RST | U3PHY_POR_RST);
+
+	index = 0;
+	for_each_available_child_of_node(np, child_np) {
+		struct rockchip_u3phy_port *u3phy_port = &u3phy->ports[index];
+
+		u3phy_port->index = index;
+		ret = rockchip_u3phy_port_init(u3phy, u3phy_port, child_np);
+		if (ret) {
+			dev_err(dev, "u3phy port init failed,ret(%d)\n", ret);
+			goto put_child;
+		}
+
+		/* to prevent out of boundary */
+		if (++index >= U3PHY_PORT_NUM)
+			break;
+	}
+
+	provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);
+	if (IS_ERR_OR_NULL(provider))
+		goto put_child;
+
+	rockchip_u3phy_rest_deassert(u3phy, U3PHY_MAC_RST);
+	rockchip_u3phy_clk_disable(u3phy);
+
+	u3phy->usb_phy.dev = dev;
+	u3phy->usb_phy.init = rockchip_u3phy_on_init;
+	u3phy->usb_phy.shutdown = rockchip_u3phy_on_shutdown;
+	u3phy->usb_phy.notify_disconnect = rockchip_u3phy_on_disconnect;
+	usb_add_phy(&u3phy->usb_phy, USB_PHY_TYPE_USB3);
+	ATOMIC_INIT_NOTIFIER_HEAD(&u3phy->usb_phy.notifier);
+
+	rockchip_u3phy_debugfs_init(u3phy);
+
+	dev_info(dev, "Rockchip u3phy initialized successfully\n");
+	return 0;
+
+put_child:
+	of_node_put(child_np);
+	return ret;
+}
+
+static int rk3328_u3phy_pipe_power(struct rockchip_u3phy *u3phy,
+				   struct rockchip_u3phy_port *u3phy_port,
+				   bool on)
+{
+	unsigned int reg;
+
+	if (on) {
+		reg = readl(u3phy_port->base + 0x1a8);
+		reg &= ~BIT(4); /* ldo power up */
+		writel(reg, u3phy_port->base + 0x1a8);
+
+		reg = readl(u3phy_port->base + 0x044);
+		reg &= ~BIT(4); /* bg power on */
+		writel(reg, u3phy_port->base + 0x044);
+
+		reg = readl(u3phy_port->base + 0x150);
+		reg |= BIT(6); /* tx bias enable */
+		writel(reg, u3phy_port->base + 0x150);
+
+		reg = readl(u3phy_port->base + 0x080);
+		reg &= ~BIT(2); /* tx cm power up */
+		writel(reg, u3phy_port->base + 0x080);
+
+		reg = readl(u3phy_port->base + 0x0c0);
+		/* tx obs enable and rx cm enable */
+		reg |= (BIT(3) | BIT(4));
+		writel(reg, u3phy_port->base + 0x0c0);
+
+		udelay(1);
+	} else {
+		reg = readl(u3phy_port->base + 0x1a8);
+		reg |= BIT(4); /* ldo power down */
+		writel(reg, u3phy_port->base + 0x1a8);
+
+		reg = readl(u3phy_port->base + 0x044);
+		reg |= BIT(4); /* bg power down */
+		writel(reg, u3phy_port->base + 0x044);
+
+		reg = readl(u3phy_port->base + 0x150);
+		reg &= ~BIT(6); /* tx bias disable */
+		writel(reg, u3phy_port->base + 0x150);
+
+		reg = readl(u3phy_port->base + 0x080);
+		reg |= BIT(2); /* tx cm power down */
+		writel(reg, u3phy_port->base + 0x080);
+
+		reg = readl(u3phy_port->base + 0x0c0);
+		/* tx obs disable and rx cm disable */
+		reg &= ~(BIT(3) | BIT(4));
+		writel(reg, u3phy_port->base + 0x0c0);
+	}
+
+	return 0;
+}
+
+static int rk3328_u3phy_tuning(struct rockchip_u3phy *u3phy,
+			       struct rockchip_u3phy_port *u3phy_port,
+			       struct device_node *child_np)
+{
+	if (u3phy_port->type == U3PHY_TYPE_UTMI) {
+		/*
+		 * For rk3328 SoC, pre-emphasis and pre-emphasis strength must
+		 * be written as one fixed value as below.
+		 *
+		 * Dissimilarly, the odt 45ohm value should be flexibly tuninged
+		 * for the different boards to adjust HS eye height, so its
+		 * value can be assigned in DT in code design.
+		 */
+
+		/* {bits[2:0]=111}: always enable pre-emphasis */
+		u3phy->apbcfg.u2_pre_emp = 0x0f;
+
+		/* {bits[5:3]=000}: pre-emphasis strength as the weakest */
+		u3phy->apbcfg.u2_pre_emp_sth = 0x41;
+
+		/* {bits[4:0]=10101}: odt 45ohm tuning */
+		u3phy->apbcfg.u2_odt_tuning = 0xb5;
+		/* optional override of the odt 45ohm tuning */
+		of_property_read_u32(child_np, "rockchip,odt-val-tuning",
+				     &u3phy->apbcfg.u2_odt_tuning);
+
+		writel(u3phy->apbcfg.u2_pre_emp, u3phy_port->base + 0x030);
+		writel(u3phy->apbcfg.u2_pre_emp_sth, u3phy_port->base + 0x040);
+		writel(u3phy->apbcfg.u2_odt_tuning, u3phy_port->base + 0x11c);
+	} else if (u3phy_port->type == U3PHY_TYPE_PIPE) {
+		if (u3phy_port->refclk_25m_quirk) {
+			dev_dbg(u3phy->dev, "switch to 25m refclk\n");
+			/* ref clk switch to 25M */
+			writel(0x64, u3phy_port->base + 0x11c);
+			writel(0x64, u3phy_port->base + 0x028);
+			writel(0x01, u3phy_port->base + 0x020);
+			writel(0x21, u3phy_port->base + 0x030);
+			writel(0x06, u3phy_port->base + 0x108);
+			writel(0x00, u3phy_port->base + 0x118);
+		} else {
+			/* configure for 24M ref clk */
+			writel(0x80, u3phy_port->base + 0x10c);
+			writel(0x01, u3phy_port->base + 0x118);
+			writel(0x38, u3phy_port->base + 0x11c);
+			writel(0x83, u3phy_port->base + 0x020);
+			writel(0x02, u3phy_port->base + 0x108);
+		}
+
+		/* Enable SSC */
+		udelay(3);
+		writel(0x08, u3phy_port->base + 0x000);
+		writel(0x0c, u3phy_port->base + 0x120);
+
+		/* Tuning Rx for compliance RJTL test */
+		writel(0x70, u3phy_port->base + 0x150);
+		writel(0x12, u3phy_port->base + 0x0c8);
+		writel(0x05, u3phy_port->base + 0x148);
+		writel(0x08, u3phy_port->base + 0x068);
+		writel(0xf0, u3phy_port->base + 0x1c4);
+		writel(0xff, u3phy_port->base + 0x070);
+		writel(0x0f, u3phy_port->base + 0x06c);
+		writel(0xe0, u3phy_port->base + 0x060);
+
+		/*
+		 * Tuning Tx to increase the bias current
+		 * used in TX driver and RX EQ, it can
+		 * also increase the voltage of LFPS.
+		 */
+		writel(0x08, u3phy_port->base + 0x180);
+	} else {
+		dev_err(u3phy->dev, "invalid u3phy port type\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static const struct rockchip_u3phy_cfg rk3328_u3phy_cfgs[] = {
+	{
+		.reg		= 0xff470000,
+		.grfcfg		= {
+			.um_suspend	= { 0x0004, 15, 0, 0x1452, 0x15d1 },
+			.u2_only_ctrl	= { 0x0020, 15, 15, 0, 1 },
+			.um_ls		= { 0x0030, 5, 4, 0, 1 },
+			.um_hstdct	= { 0x0030, 7, 7, 0, 1 },
+			.ls_det_en	= { 0x0040, 0, 0, 0, 1 },
+			.ls_det_st	= { 0x0044, 0, 0, 0, 1 },
+			.pp_pwr_st	= { 0x0034, 14, 13, 0, 0},
+			.pp_pwr_en	= { {0x0020, 14, 0, 0x0014, 0x0005},
+					    {0x0020, 14, 0, 0x0014, 0x000d},
+					    {0x0020, 14, 0, 0x0014, 0x0015},
+					    {0x0020, 14, 0, 0x0014, 0x001d} },
+			.u3_disable	= { 0x04c4, 15, 0, 0x1100, 0x101},
+		},
+		.phy_pipe_power	= rk3328_u3phy_pipe_power,
+		.phy_tuning	= rk3328_u3phy_tuning,
+	},
+	{ /* sentinel */ }
+};
+
+static const struct of_device_id rockchip_u3phy_dt_match[] = {
+	{ .compatible = "rockchip,rk3328-u3phy", .data = &rk3328_u3phy_cfgs },
+	{}
+};
+MODULE_DEVICE_TABLE(of, rockchip_u3phy_dt_match);
+
+static struct platform_driver rockchip_u3phy_driver = {
+	.probe		= rockchip_u3phy_probe,
+	.driver		= {
+		.name	= "rockchip-u3phy",
+		.of_match_table = rockchip_u3phy_dt_match,
+	},
+};
+module_platform_driver(rockchip_u3phy_driver);
+
+MODULE_AUTHOR("Frank Wang <frank.wang@rock-chips.com>");
+MODULE_AUTHOR("William Wu <william.wu@rock-chips.com>");
+MODULE_DESCRIPTION("Rockchip USB 3.0 PHY driver");
+MODULE_LICENSE("GPL v2");
--- /dev/null	2023-04-29 08:31:15.023562380 -0400
+++ b/drivers/staging/fusb30x/fusb30x.c	2023-05-06 08:46:30.702660301 -0400
@@ -0,0 +1,3434 @@
+/*
+ * Copyright (c) 2016, Fuzhou Rockchip Electronics Co., Ltd
+ * Author: Zain Wang <zain.wang@rock-chips.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * Some ideas are from chrome ec and fairchild GPL fusb302 driver.
+ */
+
+#include <linux/delay.h>
+#include <linux/extcon.h>
+#include <linux/extcon-provider.h>
+#include <linux/gpio.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/of_gpio.h>
+#include <linux/regmap.h>
+#include <linux/power_supply.h>
+
+#include "fusb30x.h"
+
+#define FUSB302_MAX_REG		(FUSB_REG_FIFO + 50)
+#define FUSB_MS_TO_NS(x)	((s64)x * 1000 * 1000)
+
+#define TYPEC_CC_VOLT_OPEN	0
+#define TYPEC_CC_VOLT_RA	1
+#define TYPEC_CC_VOLT_RD	2
+#define TYPEC_CC_VOLT_RP	3
+
+#define EVENT_CC		BIT(0)
+#define EVENT_RX		BIT(1)
+#define EVENT_TX		BIT(2)
+#define EVENT_REC_RESET		BIT(3)
+#define EVENT_WORK_CONTINUE	BIT(5)
+#define EVENT_TIMER_MUX		BIT(6)
+#define EVENT_TIMER_STATE	BIT(7)
+#define EVENT_DELAY_CC		BIT(8)
+#define FLAG_EVENT		(EVENT_RX | EVENT_TIMER_MUX | \
+				 EVENT_TIMER_STATE)
+
+#define PACKET_IS_CONTROL_MSG(header, type) \
+		(PD_HEADER_CNT(header) == 0 && \
+		 PD_HEADER_TYPE(header) == type)
+
+#define PACKET_IS_DATA_MSG(header, type) \
+		(PD_HEADER_CNT(header) != 0 && \
+		 PD_HEADER_TYPE(header) == type)
+
+/*
+ * DisplayPort modes capabilities
+ * -------------------------------
+ * <31:24> : Reserved (always 0).
+ * <23:16> : UFP_D pin assignment supported
+ * <15:8>  : DFP_D pin assignment supported
+ * <7>     : USB 2.0 signaling (0b=yes, 1b=no)
+ * <6>     : Plug | Receptacle (0b == plug, 1b == receptacle)
+ * <5:2>   : xxx1: Supports DPv1.3, xx1x Supports USB Gen 2 signaling
+ *	     Other bits are reserved.
+ * <1:0>   : signal direction ( 00b=rsv, 01b=sink, 10b=src 11b=both )
+ */
+#define PD_DP_PIN_CAPS(x)	((((x) >> 6) & 0x1) ? (((x) >> 16) & 0x3f) \
+				 : (((x) >> 8) & 0x3f))
+#define PD_DP_SIGNAL_GEN2(x)	(((x) >> 3) & 0x1)
+
+#define MODE_DP_PIN_A		BIT(0)
+#define MODE_DP_PIN_B		BIT(1)
+#define MODE_DP_PIN_C		BIT(2)
+#define MODE_DP_PIN_D		BIT(3)
+#define MODE_DP_PIN_E		BIT(4)
+#define MODE_DP_PIN_F		BIT(5)
+
+/* Pin configs B/D/F support multi-function */
+#define MODE_DP_PIN_MF_MASK	(MODE_DP_PIN_B | MODE_DP_PIN_D | MODE_DP_PIN_F)
+/* Pin configs A/B support BR2 signaling levels */
+#define MODE_DP_PIN_BR2_MASK	(MODE_DP_PIN_A | MODE_DP_PIN_B)
+/* Pin configs C/D/E/F support DP signaling levels */
+#define MODE_DP_PIN_DP_MASK	(MODE_DP_PIN_C | MODE_DP_PIN_D | \
+				 MODE_DP_PIN_E | MODE_DP_PIN_F)
+
+/*
+ * DisplayPort Status VDO
+ * ----------------------
+ * <31:9> : Reserved (always 0).
+ * <8>    : IRQ_HPD : 1 == irq arrived since last message otherwise 0.
+ * <7>    : HPD state : 0 = HPD_LOW, 1 == HPD_HIGH
+ * <6>    : Exit DP Alt mode: 0 == maintain, 1 == exit
+ * <5>    : USB config : 0 == maintain current, 1 == switch to USB from DP
+ * <4>    : Multi-function preference : 0 == no pref, 1 == MF preferred.
+ * <3>    : enabled : is DPout on/off.
+ * <2>    : power low : 0 == normal or LPM disabled, 1 == DP disabled for LPM
+ * <1:0>  : connect status : 00b ==  no (DFP|UFP)_D is connected or disabled.
+ *	    01b == DFP_D connected, 10b == UFP_D connected, 11b == both.
+ */
+#define PD_VDO_DPSTS_HPD_IRQ(x)	(((x) >> 8) & 0x1)
+#define PD_VDO_DPSTS_HPD_LVL(x)	(((x) >> 7) & 0x1)
+#define PD_VDO_DPSTS_MF_PREF(x)	(((x) >> 4) & 0x1)
+
+static u8 fusb30x_port_used;
+static struct fusb30x_chip *fusb30x_port_info[256];
+
+static bool is_write_reg(struct device *dev, unsigned int reg)
+{
+	if (reg >= FUSB_REG_FIFO)
+		return true;
+	else
+		return ((reg < (FUSB_REG_CONTROL4 + 1)) && (reg > 0x01)) ?
+			true : false;
+}
+
+static bool is_volatile_reg(struct device *dev, unsigned int reg)
+{
+	if (reg > FUSB_REG_CONTROL4)
+		return true;
+
+	switch (reg) {
+	case FUSB_REG_CONTROL0:
+	case FUSB_REG_CONTROL1:
+	case FUSB_REG_CONTROL3:
+	case FUSB_REG_RESET:
+		return true;
+	}
+	return false;
+}
+
+struct regmap_config fusb302_regmap_config = {
+	.reg_bits = 8,
+	.val_bits = 8,
+	.writeable_reg = is_write_reg,
+	.volatile_reg = is_volatile_reg,
+	.max_register = FUSB302_MAX_REG,
+	.cache_type = REGCACHE_RBTREE,
+};
+
+static void dump_notify_info(struct fusb30x_chip *chip)
+{
+	dev_dbg(chip->dev, "port        %d\n", chip->port_num);
+	dev_dbg(chip->dev, "orientation %d\n", chip->notify.orientation);
+	dev_dbg(chip->dev, "power_role  %d\n", chip->notify.power_role);
+	dev_dbg(chip->dev, "data_role   %d\n", chip->notify.data_role);
+	dev_dbg(chip->dev, "cc          %d\n", chip->notify.is_cc_connected);
+	dev_dbg(chip->dev, "pd          %d\n", chip->notify.is_pd_connected);
+	dev_dbg(chip->dev, "enter_mode  %d\n", chip->notify.is_enter_mode);
+	dev_dbg(chip->dev, "pin support %d\n",
+		chip->notify.pin_assignment_support);
+	dev_dbg(chip->dev, "pin def     %d\n", chip->notify.pin_assignment_def);
+	dev_dbg(chip->dev, "attention   %d\n", chip->notify.attention);
+}
+
+static const unsigned int fusb302_cable[] = {
+	EXTCON_USB,
+	EXTCON_USB_HOST,
+	EXTCON_CHG_USB_SDP,
+	EXTCON_CHG_USB_CDP,
+	EXTCON_CHG_USB_DCP,
+	EXTCON_CHG_USB_SLOW,
+	EXTCON_CHG_USB_FAST,
+	EXTCON_DISP_DP,
+	EXTCON_NONE,
+};
+
+static void fusb_set_pos_power(struct fusb30x_chip *chip, int max_vol,
+			       int max_cur)
+{
+	int i;
+	int pos_find;
+	int tmp;
+
+	pos_find = 0;
+	for (i = PD_HEADER_CNT(chip->rec_head) - 1; i >= 0; i--) {
+		switch (CAP_POWER_TYPE(chip->rec_load[i])) {
+		case 0:
+			/* Fixed Supply */
+			if ((CAP_FPDO_VOLTAGE(chip->rec_load[i]) * 50) <=
+			    max_vol &&
+			    (CAP_FPDO_CURRENT(chip->rec_load[i]) * 10) <=
+			    max_cur) {
+				chip->pos_power = i + 1;
+				tmp = CAP_FPDO_VOLTAGE(chip->rec_load[i]);
+				chip->pd_output_vol = tmp * 50;
+				tmp = CAP_FPDO_CURRENT(chip->rec_load[i]);
+				chip->pd_output_cur = tmp * 10;
+				pos_find = 1;
+			}
+			break;
+		case 1:
+			/* Battery */
+			if ((CAP_VPDO_VOLTAGE(chip->rec_load[i]) * 50) <=
+			    max_vol &&
+			    (CAP_VPDO_CURRENT(chip->rec_load[i]) * 10) <=
+			    max_cur) {
+				chip->pos_power = i + 1;
+				tmp = CAP_VPDO_VOLTAGE(chip->rec_load[i]);
+				chip->pd_output_vol = tmp * 50;
+				tmp = CAP_VPDO_CURRENT(chip->rec_load[i]);
+				chip->pd_output_cur = tmp * 10;
+				pos_find = 1;
+			}
+			break;
+		default:
+			/* not meet battery caps */
+			break;
+		}
+		if (pos_find)
+			break;
+	}
+}
+
+static int fusb302_set_pos_power_by_charge_ic(struct fusb30x_chip *chip)
+{
+	struct power_supply *psy = NULL;
+	union power_supply_propval val;
+	enum power_supply_property psp;
+	int max_vol, max_cur;
+
+	max_vol = 0;
+	max_cur = 0;
+	psy = power_supply_get_by_phandle(chip->dev->of_node, "charge-dev");
+	if (!psy || IS_ERR(psy))
+		return -1;
+
+	psp = POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT_MAX;
+	if (power_supply_get_property(psy, psp, &val) == 0)
+		max_vol = val.intval / 1000;
+
+	psp = POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT;
+	if (power_supply_get_property(psy, psp, &val) == 0)
+		max_cur = val.intval / 1000;
+
+	if (max_vol > 0 && max_cur > 0)
+		fusb_set_pos_power(chip, max_vol, max_cur);
+
+	return 0;
+}
+
+void fusb_irq_disable(struct fusb30x_chip *chip)
+{
+	unsigned long irqflags = 0;
+
+	spin_lock_irqsave(&chip->irq_lock, irqflags);
+	if (chip->enable_irq) {
+		disable_irq_nosync(chip->gpio_int_irq);
+		chip->enable_irq = 0;
+	} else {
+		dev_warn(chip->dev, "irq have already disabled\n");
+	}
+	spin_unlock_irqrestore(&chip->irq_lock, irqflags);
+}
+
+void fusb_irq_enable(struct fusb30x_chip *chip)
+{
+	unsigned long irqflags = 0;
+
+	spin_lock_irqsave(&chip->irq_lock, irqflags);
+	if (!chip->enable_irq) {
+		enable_irq(chip->gpio_int_irq);
+		chip->enable_irq = 1;
+	}
+	spin_unlock_irqrestore(&chip->irq_lock, irqflags);
+}
+
+static void platform_fusb_notify(struct fusb30x_chip *chip)
+{
+	bool plugged = false, flip = false, dfp = false, ufp = false,
+	     dp = false, usb_ss = false, hpd = false;
+	union extcon_property_value property;
+
+	if (chip->notify.is_cc_connected)
+		chip->notify.orientation =
+			(chip->cc_polarity == TYPEC_POLARITY_CC1) ?
+			CC1 : CC2;
+
+	/* avoid notify repeated */
+	if (memcmp(&chip->notify, &chip->notify_cmp,
+		   sizeof(struct notify_info))) {
+		dump_notify_info(chip);
+		chip->notify.attention = false;
+		memcpy(&chip->notify_cmp, &chip->notify,
+		       sizeof(struct notify_info));
+
+		plugged = chip->notify.is_cc_connected ||
+			  chip->notify.is_pd_connected;
+		if (chip->notify.orientation != NONE)
+			flip = (chip->notify.orientation == CC1) ? false : true;
+		dp = chip->notify.is_enter_mode;
+
+		if (dp) {
+			dfp = true;
+			usb_ss = (chip->notify.pin_assignment_def &
+				  MODE_DP_PIN_MF_MASK) ? true : false;
+			hpd = GET_DP_STATUS_HPD(chip->notify.dp_status);
+		} else if (chip->notify.data_role) {
+			dfp = true;
+			usb_ss = true;
+		} else if (plugged) {
+			ufp = true;
+			usb_ss = true;
+		}
+
+		property.intval = flip;
+		extcon_set_property(chip->extcon, EXTCON_USB,
+				    EXTCON_PROP_USB_TYPEC_POLARITY, property);
+		extcon_set_property(chip->extcon, EXTCON_USB_HOST,
+				    EXTCON_PROP_USB_TYPEC_POLARITY, property);
+		extcon_set_property(chip->extcon, EXTCON_DISP_DP,
+				    EXTCON_PROP_USB_TYPEC_POLARITY, property);
+
+		property.intval = usb_ss;
+		extcon_set_property(chip->extcon, EXTCON_USB,
+				    EXTCON_PROP_USB_SS, property);
+		extcon_set_property(chip->extcon, EXTCON_USB_HOST,
+				    EXTCON_PROP_USB_SS, property);
+		extcon_set_property(chip->extcon, EXTCON_DISP_DP,
+				    EXTCON_PROP_USB_SS, property);
+		extcon_set_state(chip->extcon, EXTCON_USB, ufp);
+		extcon_set_state(chip->extcon, EXTCON_USB_HOST, dfp);
+		extcon_set_state(chip->extcon, EXTCON_DISP_DP, dp && hpd);
+		extcon_sync(chip->extcon, EXTCON_USB);
+		extcon_sync(chip->extcon, EXTCON_USB_HOST);
+		extcon_sync(chip->extcon, EXTCON_DISP_DP);
+		if (chip->notify.power_role == POWER_ROLE_SINK &&
+		    chip->notify.is_pd_connected &&
+		    chip->pd_output_vol > 0 && chip->pd_output_cur > 0) {
+			extcon_set_state(chip->extcon, EXTCON_CHG_USB_FAST, true);
+			property.intval =
+				(chip->pd_output_cur << 15 |
+				 chip->pd_output_vol);
+			extcon_set_property(chip->extcon, EXTCON_CHG_USB_FAST,
+					    EXTCON_PROP_USB_TYPEC_POLARITY,
+					    property);
+			extcon_sync(chip->extcon, EXTCON_CHG_USB_FAST);
+		}
+	}
+}
+
+static bool platform_get_device_irq_state(struct fusb30x_chip *chip)
+{
+	return !gpiod_get_value(chip->gpio_int);
+}
+
+static void fusb_timer_start(struct hrtimer *timer, int ms)
+{
+	ktime_t ktime;
+
+	ktime = ktime_set(0, FUSB_MS_TO_NS(ms));
+	hrtimer_start(timer, ktime, HRTIMER_MODE_REL);
+}
+
+static void platform_set_vbus_lvl_enable(struct fusb30x_chip *chip, int vbus_5v,
+					 int vbus_other)
+{
+	bool gpio_vbus_value = false;
+
+	gpio_vbus_value = gpiod_get_value(chip->gpio_vbus_5v);
+	if (chip->gpio_vbus_5v) {
+		gpiod_set_raw_value(chip->gpio_vbus_5v, vbus_5v);
+	}
+
+	if (chip->gpio_vbus_other)
+		gpiod_set_raw_value(chip->gpio_vbus_5v, vbus_other);
+
+	if (chip->gpio_discharge && !vbus_5v && gpio_vbus_value) {
+		gpiod_set_value(chip->gpio_discharge, 1);
+		msleep(20);
+		gpiod_set_value(chip->gpio_discharge, 0);
+	}
+}
+
+static void set_state(struct fusb30x_chip *chip, enum connection_state state)
+{
+	dev_dbg(chip->dev, "port %d, state %d\n", chip->port_num, state);
+	if (!state)
+		dev_info(chip->dev, "PD disabled\n");
+	chip->conn_state = state;
+	chip->sub_state = 0;
+	chip->val_tmp = 0;
+	chip->work_continue |= EVENT_WORK_CONTINUE;
+}
+
+static int tcpm_get_message(struct fusb30x_chip *chip)
+{
+	u8 buf[32];
+	int len;
+
+	do {
+		regmap_raw_read(chip->regmap, FUSB_REG_FIFO, buf, 3);
+		chip->rec_head = (buf[1] & 0xff) | ((buf[2] << 8) & 0xff00);
+
+		len = PD_HEADER_CNT(chip->rec_head) << 2;
+		regmap_raw_read(chip->regmap, FUSB_REG_FIFO, buf, len + 4);
+	/* ignore good_crc message */
+	} while (PACKET_IS_CONTROL_MSG(chip->rec_head, CMT_GOODCRC));
+
+	memcpy(chip->rec_load, buf, len);
+
+	return 0;
+}
+
+static void fusb302_flush_rx_fifo(struct fusb30x_chip *chip)
+{
+	regmap_write(chip->regmap, FUSB_REG_CONTROL1, CONTROL1_RX_FLUSH);
+}
+
+static int tcpm_get_cc(struct fusb30x_chip *chip, int *CC1, int *CC2)
+{
+	u32 val;
+	int *CC_MEASURE;
+	u32 store;
+
+	*CC1 = TYPEC_CC_VOLT_OPEN;
+	*CC2 = TYPEC_CC_VOLT_OPEN;
+
+	if (chip->cc_state & CC_STATE_TOGSS_CC1)
+		CC_MEASURE = CC1;
+	else
+		CC_MEASURE = CC2;
+
+	if (chip->cc_state & CC_STATE_TOGSS_IS_UFP) {
+		regmap_read(chip->regmap, FUSB_REG_SWITCHES0, &store);
+		/* measure cc1 first */
+		regmap_update_bits(chip->regmap, FUSB_REG_SWITCHES0,
+				   SWITCHES0_MEAS_CC1 | SWITCHES0_MEAS_CC2 |
+				   SWITCHES0_PU_EN1 | SWITCHES0_PU_EN2 |
+				   SWITCHES0_PDWN1 | SWITCHES0_PDWN2,
+				   SWITCHES0_PDWN1 | SWITCHES0_PDWN2 |
+				   SWITCHES0_MEAS_CC1);
+		usleep_range(250, 300);
+
+		regmap_read(chip->regmap, FUSB_REG_STATUS0, &val);
+		val &= STATUS0_BC_LVL;
+		*CC1 = val ? TYPEC_CC_VOLT_RP : TYPEC_CC_VOLT_OPEN;
+
+		regmap_update_bits(chip->regmap, FUSB_REG_SWITCHES0,
+				   SWITCHES0_MEAS_CC1 | SWITCHES0_MEAS_CC2 |
+				   SWITCHES0_PU_EN1 | SWITCHES0_PU_EN2 |
+				   SWITCHES0_PDWN1 | SWITCHES0_PDWN2,
+				   SWITCHES0_PDWN1 | SWITCHES0_PDWN2 |
+				   SWITCHES0_MEAS_CC2);
+		usleep_range(250, 300);
+
+		regmap_read(chip->regmap, FUSB_REG_STATUS0, &val);
+		val &= STATUS0_BC_LVL;
+		*CC2 = val ? TYPEC_CC_VOLT_RP : TYPEC_CC_VOLT_OPEN;
+
+		regmap_update_bits(chip->regmap, FUSB_REG_SWITCHES0,
+				   SWITCHES0_MEAS_CC1 | SWITCHES0_MEAS_CC2,
+				   store);
+	} else {
+		regmap_read(chip->regmap, FUSB_REG_SWITCHES0, &store);
+		val = store;
+		val &= ~(SWITCHES0_MEAS_CC1 | SWITCHES0_MEAS_CC2 |
+				SWITCHES0_PU_EN1 | SWITCHES0_PU_EN2);
+		if (chip->cc_state & CC_STATE_TOGSS_CC1) {
+			val |= SWITCHES0_MEAS_CC1 | SWITCHES0_PU_EN1;
+		} else {
+			val |= SWITCHES0_MEAS_CC2 | SWITCHES0_PU_EN2;
+		}
+		regmap_write(chip->regmap, FUSB_REG_SWITCHES0, val);
+
+		regmap_write(chip->regmap, FUSB_REG_MEASURE, chip->cc_meas_high);
+		usleep_range(250, 300);
+
+		regmap_read(chip->regmap, FUSB_REG_STATUS0, &val);
+		if (val & STATUS0_COMP) {
+			int retry = 3;
+			int comp_times = 0;
+
+			while (retry--) {
+				regmap_write(chip->regmap, FUSB_REG_MEASURE, chip->cc_meas_high);
+				usleep_range(250, 300);
+				regmap_read(chip->regmap, FUSB_REG_STATUS0, &val);
+				if (val & STATUS0_COMP) {
+					comp_times++;
+					if (comp_times == 3) {
+						*CC_MEASURE = TYPEC_CC_VOLT_OPEN;
+						regmap_write(chip->regmap, FUSB_REG_SWITCHES0, store);
+					}
+				}
+			}
+		} else {
+			regmap_write(chip->regmap, FUSB_REG_MEASURE, chip->cc_meas_low);
+			regmap_read(chip->regmap, FUSB_REG_MEASURE, &val);
+			usleep_range(250, 300);
+
+			regmap_read(chip->regmap, FUSB_REG_STATUS0, &val);
+
+			if (val & STATUS0_COMP)
+				*CC_MEASURE = TYPEC_CC_VOLT_RD;
+			else
+				*CC_MEASURE = TYPEC_CC_VOLT_RA;
+		}
+		regmap_write(chip->regmap, FUSB_REG_SWITCHES0, store);
+		regmap_write(chip->regmap, FUSB_REG_MEASURE,
+			     chip->cc_meas_high);
+	}
+
+	return 0;
+}
+
+static void tcpm_set_cc_pull_mode(struct fusb30x_chip *chip, enum CC_MODE mode)
+{
+	u8 val;
+
+	switch (mode) {
+	case CC_PULL_UP:
+		if (chip->cc_polarity == TYPEC_POLARITY_CC1)
+			val = SWITCHES0_PU_EN1;
+		else
+			val = SWITCHES0_PU_EN2;
+		break;
+	case CC_PULL_DOWN:
+		val = SWITCHES0_PDWN1 | SWITCHES0_PDWN2;
+		break;
+	default:
+		val = 0;
+		break;
+	}
+
+	regmap_update_bits(chip->regmap, FUSB_REG_SWITCHES0,
+			   SWITCHES0_PU_EN1 | SWITCHES0_PU_EN2 |
+			   SWITCHES0_PDWN1 | SWITCHES0_PDWN2,
+			   val);
+
+	if (chip->cc_meas_high && mode == CC_PULL_UP)
+		regmap_write(chip->regmap, FUSB_REG_MEASURE,
+			     chip->cc_meas_high);
+}
+
+static int tcpm_set_cc(struct fusb30x_chip *chip, enum role_mode mode)
+{
+	switch (mode) {
+	case ROLE_MODE_DFP:
+		tcpm_set_cc_pull_mode(chip, CC_PULL_UP);
+		regmap_update_bits(chip->regmap, FUSB_REG_CONTROL2,
+				   CONTROL2_MODE | CONTROL2_TOG_RD_ONLY,
+				   CONTROL2_MODE_DFP | CONTROL2_TOG_RD_ONLY);
+		break;
+	case ROLE_MODE_UFP:
+		tcpm_set_cc_pull_mode(chip, CC_PULL_UP);
+		regmap_update_bits(chip->regmap, FUSB_REG_CONTROL2,
+				   CONTROL2_MODE | CONTROL2_TOG_RD_ONLY,
+				   CONTROL2_MODE_UFP);
+		break;
+	case ROLE_MODE_DRP:
+		tcpm_set_cc_pull_mode(chip, CC_PULL_NONE);
+		regmap_update_bits(chip->regmap, FUSB_REG_CONTROL2,
+				   CONTROL2_MODE | CONTROL2_TOG_RD_ONLY,
+				   CONTROL2_MODE_DRP | CONTROL2_TOG_RD_ONLY);
+		break;
+	default:
+		dev_err(chip->dev, "%s: Unsupport cc mode %d\n",
+			__func__, mode);
+		return -EINVAL;
+		break;
+	}
+
+	regmap_update_bits(chip->regmap, FUSB_REG_CONTROL2, CONTROL2_TOGGLE,
+			   CONTROL2_TOGGLE);
+
+	return 0;
+}
+
+static int tcpm_set_rx_enable(struct fusb30x_chip *chip, int enable)
+{
+	u8 val = 0;
+
+	if (enable) {
+		if (chip->cc_polarity == TYPEC_POLARITY_CC1)
+			val |= SWITCHES0_MEAS_CC1;
+		else
+			val |= SWITCHES0_MEAS_CC2;
+		regmap_update_bits(chip->regmap, FUSB_REG_SWITCHES0,
+				   SWITCHES0_MEAS_CC1 | SWITCHES0_MEAS_CC2,
+				   val);
+		fusb302_flush_rx_fifo(chip);
+		regmap_update_bits(chip->regmap, FUSB_REG_SWITCHES1,
+				   SWITCHES1_AUTO_CRC, SWITCHES1_AUTO_CRC);
+	} else {
+		regmap_update_bits(chip->regmap, FUSB_REG_SWITCHES0,
+				   SWITCHES0_MEAS_CC1 | SWITCHES0_MEAS_CC2,
+				   0);
+		regmap_update_bits(chip->regmap,
+				   FUSB_REG_SWITCHES1, SWITCHES1_AUTO_CRC, 0);
+	}
+
+	return 0;
+}
+
+static int tcpm_set_msg_header(struct fusb30x_chip *chip)
+{
+	regmap_update_bits(chip->regmap, FUSB_REG_SWITCHES1,
+			   SWITCHES1_POWERROLE | SWITCHES1_DATAROLE,
+			   (chip->notify.power_role << 7) |
+			   (chip->notify.data_role << 4));
+	regmap_update_bits(chip->regmap, FUSB_REG_SWITCHES1,
+			   SWITCHES1_SPECREV, 2 << 5);
+	return 0;
+}
+
+static int tcpm_set_polarity(struct fusb30x_chip *chip,
+			     enum typec_cc_polarity polarity)
+{
+	u8 val = 0;
+
+	if (chip->vconn_enabled) {
+		if (polarity)
+			val |= SWITCHES0_VCONN_CC1;
+		else
+			val |= SWITCHES0_VCONN_CC2;
+	}
+
+	if (chip->cc_state & CC_STATE_TOGSS_IS_UFP) {
+		if (polarity == TYPEC_POLARITY_CC1)
+			val |= SWITCHES0_MEAS_CC1;
+		else
+			val |= SWITCHES0_MEAS_CC2;
+	} else {
+		if (polarity == TYPEC_POLARITY_CC1)
+			val |= SWITCHES0_MEAS_CC1 | SWITCHES0_PU_EN1;
+		else
+			val |= SWITCHES0_MEAS_CC2 | SWITCHES0_PU_EN2;
+	}
+
+	regmap_update_bits(chip->regmap, FUSB_REG_SWITCHES0,
+			   SWITCHES0_VCONN_CC1 | SWITCHES0_VCONN_CC2 |
+			   SWITCHES0_MEAS_CC1 | SWITCHES0_MEAS_CC2 |
+			   SWITCHES0_PU_EN1 | SWITCHES0_PU_EN2,
+			   val);
+
+	val = 0;
+	if (polarity == TYPEC_POLARITY_CC1)
+		val |= SWITCHES1_TXCC1;
+	else
+		val |= SWITCHES1_TXCC2;
+	regmap_update_bits(chip->regmap, FUSB_REG_SWITCHES1,
+			   SWITCHES1_TXCC1 | SWITCHES1_TXCC2,
+			   val);
+
+	chip->cc_polarity = polarity;
+
+	return 0;
+}
+
+static int tcpm_set_vconn(struct fusb30x_chip *chip, int enable)
+{
+	u8 val = 0;
+
+	if (enable) {
+		if (chip->cc_polarity == TYPEC_POLARITY_CC1)
+			val = SWITCHES0_VCONN_CC2;
+		else
+			val = SWITCHES0_VCONN_CC1;
+	}
+	regmap_update_bits(chip->regmap, FUSB_REG_SWITCHES0,
+			   SWITCHES0_VCONN_CC1 | SWITCHES0_VCONN_CC2,
+			   val);
+	chip->vconn_enabled = (bool)enable;
+	return 0;
+}
+
+static void fusb302_pd_reset(struct fusb30x_chip *chip)
+{
+	regmap_write(chip->regmap, FUSB_REG_RESET, RESET_PD_RESET);
+	regmap_reinit_cache(chip->regmap, &fusb302_regmap_config);
+}
+
+static void tcpm_select_rp_value(struct fusb30x_chip *chip, u32 rp)
+{
+	u32 control0_reg;
+
+	regmap_read(chip->regmap, FUSB_REG_CONTROL0, &control0_reg);
+
+	control0_reg &= ~CONTROL0_HOST_CUR;
+	/*
+	 * according to the host current, the compare value is different
+	 * Fusb302 datasheet Table 3
+	 */
+	switch (rp) {
+	/*
+	 * host pull up current is 80ua , high voltage is 1.596v,
+	 * low is 0.21v
+	 */
+	case TYPEC_RP_USB:
+		chip->cc_meas_high = 0x26;
+		chip->cc_meas_low = 0x5;
+		control0_reg |= CONTROL0_HOST_CUR_USB;
+		break;
+	/*
+	 * host pull up current is 330ua , high voltage is 2.604v,
+	 * low is 0.798v
+	 */
+	case TYPEC_RP_3A0:
+		chip->cc_meas_high = 0x3e;
+		chip->cc_meas_low = 0x13;
+		control0_reg |= CONTROL0_HOST_CUR_3A0;
+		break;
+	/*
+	 * host pull up current is 180ua , high voltage is 1.596v,
+	 * low is 0.42v
+	 */
+	case TYPEC_RP_1A5:
+	default:
+		chip->cc_meas_high = 0x26;
+		chip->cc_meas_low = 0xa;
+		control0_reg |= CONTROL0_HOST_CUR_1A5;
+		break;
+	}
+
+	regmap_write(chip->regmap, FUSB_REG_CONTROL0, control0_reg);
+}
+
+static int tcpm_check_vbus(struct fusb30x_chip *chip)
+{
+	u32 val;
+
+	/* Read status register */
+	regmap_read(chip->regmap, FUSB_REG_STATUS0, &val);
+
+	return (val & STATUS0_VBUSOK) ? 1 : 0;
+}
+
+static void tcpm_init(struct fusb30x_chip *chip)
+{
+	u8 val;
+	u32 tmp;
+
+	regmap_read(chip->regmap, FUSB_REG_DEVICEID, &tmp);
+	chip->chip_id = (u8)tmp;
+	platform_set_vbus_lvl_enable(chip, 0, 0);
+	chip->notify.is_cc_connected = false;
+	chip->cc_state = 0;
+
+	/* restore default settings */
+	regmap_update_bits(chip->regmap, FUSB_REG_RESET, RESET_SW_RESET,
+			   RESET_SW_RESET);
+	fusb302_pd_reset(chip);
+	/* set auto_retry and number of retries */
+	regmap_update_bits(chip->regmap, FUSB_REG_CONTROL3,
+			   CONTROL3_AUTO_RETRY | CONTROL3_N_RETRIES,
+			   CONTROL3_AUTO_RETRY | CONTROL3_N_RETRIES),
+
+	/* set interrupts */
+	val = 0xff;
+	val &= ~(MASK_M_COLLISION | MASK_M_ALERT | MASK_M_VBUSOK);
+	regmap_write(chip->regmap, FUSB_REG_MASK, val);
+
+	val = 0xff;
+	val &= ~(MASKA_M_RETRYFAIL | MASKA_M_HARDSENT | MASKA_M_TXSENT |
+		 MASKA_M_HARDRST | MASKA_M_TOGDONE);
+	regmap_write(chip->regmap, FUSB_REG_MASKA, val);
+
+	val = ~MASKB_M_GCRCSEND;
+	regmap_write(chip->regmap, FUSB_REG_MASKB, val);
+
+	tcpm_select_rp_value(chip, TYPEC_RP_1A5);
+	/* Interrupts Enable */
+	regmap_update_bits(chip->regmap, FUSB_REG_CONTROL0, CONTROL0_INT_MASK,
+			   ~CONTROL0_INT_MASK);
+
+	tcpm_set_vconn(chip, 0);
+
+	regmap_write(chip->regmap, FUSB_REG_POWER, 0xf);
+}
+
+static void pd_execute_hard_reset(struct fusb30x_chip *chip)
+{
+	chip->msg_id = 0;
+	chip->vdm_state = VDM_STATE_DISCOVERY_ID;
+	if (chip->notify.power_role)
+		set_state(chip, policy_src_transition_default);
+	else
+		set_state(chip, policy_snk_transition_default);
+}
+
+static void tcpc_alert(struct fusb30x_chip *chip, u32 *evt)
+{
+	int interrupt, interrupta, interruptb;
+	u32 val;
+	static int retry;
+
+	regmap_read(chip->regmap, FUSB_REG_INTERRUPT, &interrupt);
+	regmap_read(chip->regmap, FUSB_REG_INTERRUPTA, &interrupta);
+	regmap_read(chip->regmap, FUSB_REG_INTERRUPTB, &interruptb);
+
+	if ((interrupt & INTERRUPT_COMP_CHNG) &&
+	    (!(chip->cc_state & CC_STATE_TOGSS_IS_UFP))) {
+		regmap_read(chip->regmap, FUSB_REG_STATUS0, &val);
+		if (val & STATUS0_COMP)
+			*evt |= EVENT_CC;
+	}
+
+	if (interrupt & INTERRUPT_VBUSOK) {
+		if (chip->notify.is_cc_connected)
+			*evt |= EVENT_CC;
+	}
+
+	if (interrupta & INTERRUPTA_TOGDONE) {
+		*evt |= EVENT_CC;
+		regmap_read(chip->regmap, FUSB_REG_STATUS1A, &val);
+		chip->cc_state = ((u8)val >> 3) & 0x07;
+
+		regmap_update_bits(chip->regmap, FUSB_REG_CONTROL2,
+				   CONTROL2_TOGGLE,
+				   0);
+	}
+
+	if (interrupta & INTERRUPTA_TXSENT) {
+		*evt |= EVENT_TX;
+		chip->tx_state = tx_success;
+	}
+
+	if (interruptb & INTERRUPTB_GCRCSENT)
+		*evt |= EVENT_RX;
+
+	if (interrupta & INTERRUPTA_HARDRST) {
+		fusb302_pd_reset(chip);
+		pd_execute_hard_reset(chip);
+		*evt |= EVENT_REC_RESET;
+	}
+
+	if (interrupta & INTERRUPTA_RETRYFAIL) {
+		*evt |= EVENT_TX;
+		chip->tx_state = tx_failed;
+	}
+
+	if (interrupta & INTERRUPTA_HARDSENT) {
+		/*
+		 * The fusb PD should be reset once to sync adapter PD
+		 * signal after fusb sent hard reset cmd.This is not PD
+		 * device if reset failed.
+		 */
+		if (!retry) {
+			retry = 1;
+			fusb302_pd_reset(chip);
+			pd_execute_hard_reset(chip);
+		} else {
+			retry = 0;
+			chip->tx_state = tx_success;
+			chip->timer_state = T_DISABLED;
+			*evt |= EVENT_TX;
+		}
+	}
+}
+
+static void mux_alert(struct fusb30x_chip *chip, u32 *evt)
+{
+	if (!chip->timer_mux) {
+		*evt |= EVENT_TIMER_MUX;
+		chip->timer_mux = T_DISABLED;
+	}
+
+	if (!chip->timer_state) {
+		*evt |= EVENT_TIMER_STATE;
+		chip->timer_state = T_DISABLED;
+	}
+
+	if (chip->work_continue) {
+		*evt |= chip->work_continue;
+		chip->work_continue = 0;
+	}
+}
+
+static void set_state_unattached(struct fusb30x_chip *chip)
+{
+	dev_info(chip->dev, "connection has disconnected\n");
+	tcpm_init(chip);
+	tcpm_set_rx_enable(chip, 0);
+	set_state(chip, unattached);
+	tcpm_set_cc(chip, chip->role);
+
+	/* claer notify_info */
+	memset(&chip->notify, 0, sizeof(struct notify_info));
+	platform_fusb_notify(chip);
+
+	if (chip->gpio_discharge)
+		gpiod_set_value(chip->gpio_discharge, 1);
+	msleep(100);
+	if (chip->gpio_discharge)
+		gpiod_set_value(chip->gpio_discharge, 0);
+
+	regmap_update_bits(chip->regmap, FUSB_REG_MASK,
+			   MASK_M_COMP_CHNG, MASK_M_COMP_CHNG);
+	chip->try_role_complete = false;
+}
+
+static void set_mesg(struct fusb30x_chip *chip, int cmd, int is_DMT)
+{
+	int i;
+	struct PD_CAP_INFO *pd_cap_info = &chip->pd_cap_info;
+
+	chip->send_head = ((chip->msg_id & 0x7) << 9) |
+			 ((chip->notify.power_role & 0x1) << 8) |
+			 (1 << 6) |
+			 ((chip->notify.data_role & 0x1) << 5);
+
+	if (is_DMT) {
+		switch (cmd) {
+		case DMT_SOURCECAPABILITIES:
+			chip->send_head |= ((chip->n_caps_used & 0x3) << 12) | (cmd & 0xf);
+
+			for (i = 0; i < chip->n_caps_used; i++) {
+				chip->send_load[i] = (pd_cap_info->supply_type << 30) |
+						    (pd_cap_info->dual_role_power << 29) |
+						    (pd_cap_info->usb_suspend_support << 28) |
+						    (pd_cap_info->externally_powered << 27) |
+						    (pd_cap_info->usb_communications_cap << 26) |
+						    (pd_cap_info->data_role_swap << 25) |
+						    (pd_cap_info->peak_current << 20) |
+						    (chip->source_power_supply[i] << 10) |
+						    (chip->source_max_current[i]);
+			}
+			break;
+		case DMT_REQUEST:
+			chip->send_head |= ((1 << 12) | (cmd & 0xf));
+			/* send request with FVRDO */
+			chip->send_load[0] = (chip->pos_power << 28) |
+					    (0 << 27) |
+					    (1 << 26) |
+					    (0 << 25) |
+					    (0 << 24);
+
+			switch (CAP_POWER_TYPE(chip->rec_load[chip->pos_power - 1])) {
+			case 0:
+				/* Fixed Supply */
+				chip->send_load[0] |= ((CAP_FPDO_VOLTAGE(chip->rec_load[chip->pos_power - 1]) << 10) & 0x3ff);
+				chip->send_load[0] |= (CAP_FPDO_CURRENT(chip->rec_load[chip->pos_power - 1]) & 0x3ff);
+				break;
+			case 1:
+				/* Battery */
+				chip->send_load[0] |= ((CAP_VPDO_VOLTAGE(chip->rec_load[chip->pos_power - 1]) << 10) & 0x3ff);
+				chip->send_load[0] |= (CAP_VPDO_CURRENT(chip->rec_load[chip->pos_power - 1]) & 0x3ff);
+				break;
+			default:
+				/* not meet battery caps */
+				break;
+			}
+			break;
+		case DMT_SINKCAPABILITIES:
+			break;
+		case DMT_VENDERDEFINED:
+			break;
+		default:
+			break;
+		}
+	} else {
+		chip->send_head |= (cmd & 0xf);
+	}
+}
+
+/*
+ * This algorithm defaults to choosing higher pin config over lower ones in
+ * order to prefer multi-function if desired.
+ *
+ *  NAME | SIGNALING | OUTPUT TYPE | MULTI-FUNCTION | PIN CONFIG
+ * -------------------------------------------------------------
+ *  A    |  USB G2   |  ?          | no             | 00_0001
+ *  B    |  USB G2   |  ?          | yes            | 00_0010
+ *  C    |  DP       |  CONVERTED  | no             | 00_0100
+ *  D    |  PD       |  CONVERTED  | yes            | 00_1000
+ *  E    |  DP       |  DP         | no             | 01_0000
+ *  F    |  PD       |  DP         | yes            | 10_0000
+ *
+ * if UFP has NOT asserted multi-function preferred code masks away B/D/F
+ * leaving only A/C/E.  For single-output dongles that should leave only one
+ * possible pin config depending on whether its a converter DP->(VGA|HDMI) or DP
+ * output.  If UFP is a USB-C receptacle it may assert C/D/E/F.  The DFP USB-C
+ * receptacle must always choose C/D in those cases.
+ */
+static int pd_dfp_dp_get_pin_assignment(struct fusb30x_chip *chip,
+					uint32_t caps, uint32_t status)
+{
+	uint32_t pin_caps;
+
+	/* revisit with DFP that can be a sink */
+	pin_caps = PD_DP_PIN_CAPS(caps);
+
+	/* if don't want multi-function then ignore those pin configs */
+	if (!PD_VDO_DPSTS_MF_PREF(status))
+		pin_caps &= ~MODE_DP_PIN_MF_MASK;
+
+	/* revisit if DFP drives USB Gen 2 signals */
+	if (PD_DP_SIGNAL_GEN2(caps))
+		pin_caps &= ~MODE_DP_PIN_DP_MASK;
+	else
+		pin_caps &= ~MODE_DP_PIN_BR2_MASK;
+
+	/* if C/D present they have precedence over E/F for USB-C->USB-C */
+	if (pin_caps & (MODE_DP_PIN_C | MODE_DP_PIN_D))
+		pin_caps &= ~(MODE_DP_PIN_E | MODE_DP_PIN_F);
+
+	/* returns undefined for zero */
+	if (!pin_caps)
+		return 0;
+
+	/* choosing higher pin config over lower ones */
+	return 1 << (31 - __builtin_clz(pin_caps));
+}
+
+static void set_vdm_mesg(struct fusb30x_chip *chip, int cmd, int type, int mode)
+{
+	chip->send_head = (chip->msg_id & 0x7) << 9;
+	chip->send_head |= (chip->notify.power_role & 0x1) << 8;
+
+	chip->send_head = ((chip->msg_id & 0x7) << 9) |
+			 ((chip->notify.power_role & 0x1) << 8) |
+			 (1 << 6) |
+			 ((chip->notify.data_role & 0x1) << 5) |
+			 (DMT_VENDERDEFINED & 0xf);
+
+	chip->send_load[0] = (1 << 15) |
+			    (0 << 13) |
+			    (type << 6) |
+			    (cmd);
+
+	switch (cmd) {
+	case VDM_DISCOVERY_ID:
+	case VDM_DISCOVERY_SVIDS:
+	case VDM_ATTENTION:
+		chip->send_load[0] |= (0xff00 << 16);
+		chip->send_head |= (1 << 12);
+		break;
+	case VDM_DISCOVERY_MODES:
+		chip->send_load[0] |=
+			(chip->vdm_svid[chip->val_tmp >> 1] << 16);
+		chip->send_head |= (1 << 12);
+		break;
+	case VDM_ENTER_MODE:
+		chip->send_head |= (1 << 12);
+		chip->send_load[0] |= (mode << 8) | (0xff01 << 16);
+		break;
+	case VDM_EXIT_MODE:
+		chip->send_head |= (1 << 12);
+		chip->send_load[0] |= (0x0f << 8) | (0xff01 << 16);
+		break;
+	case VDM_DP_STATUS_UPDATE:
+		chip->send_head |= (2 << 12);
+		chip->send_load[0] |= (1 << 8) | (0xff01 << 16);
+		chip->send_load[1] = 5;
+		break;
+	case VDM_DP_CONFIG:
+		chip->send_head |= (2 << 12);
+		chip->send_load[0] |= (1 << 8) | (0xff01 << 16);
+
+		chip->notify.pin_assignment_def =
+			pd_dfp_dp_get_pin_assignment(chip, chip->notify.dp_caps,
+						     chip->notify.dp_status);
+
+		chip->send_load[1] = (chip->notify.pin_assignment_def << 8) |
+				    (1 << 2) | 2;
+		dev_dbg(chip->dev, "DisplayPort Configurations: 0x%08x\n",
+			chip->send_load[1]);
+		break;
+	default:
+		break;
+	}
+}
+
+static enum tx_state policy_send_hardrst(struct fusb30x_chip *chip, u32 evt)
+{
+	switch (chip->tx_state) {
+	case 0:
+		regmap_update_bits(chip->regmap, FUSB_REG_CONTROL3,
+				   CONTROL3_SEND_HARDRESET,
+				   CONTROL3_SEND_HARDRESET);
+		chip->tx_state = tx_busy;
+		chip->timer_state = T_BMC_TIMEOUT;
+		fusb_timer_start(&chip->timer_state_machine,
+				 chip->timer_state);
+		break;
+	default:
+		if (evt & EVENT_TIMER_STATE)
+			chip->tx_state = tx_success;
+		break;
+	}
+	return chip->tx_state;
+}
+
+static enum tx_state policy_send_data(struct fusb30x_chip *chip)
+{
+	u8 senddata[40];
+	int pos = 0;
+	u8 len;
+
+	switch (chip->tx_state) {
+	case 0:
+		senddata[pos++] = FUSB_TKN_SYNC1;
+		senddata[pos++] = FUSB_TKN_SYNC1;
+		senddata[pos++] = FUSB_TKN_SYNC1;
+		senddata[pos++] = FUSB_TKN_SYNC2;
+
+		len = PD_HEADER_CNT(chip->send_head) << 2;
+		senddata[pos++] = FUSB_TKN_PACKSYM | ((len + 2) & 0x1f);
+
+		senddata[pos++] = chip->send_head & 0xff;
+		senddata[pos++] = (chip->send_head >> 8) & 0xff;
+
+		memcpy(&senddata[pos], chip->send_load, len);
+		pos += len;
+
+		senddata[pos++] = FUSB_TKN_JAMCRC;
+		senddata[pos++] = FUSB_TKN_EOP;
+		senddata[pos++] = FUSB_TKN_TXOFF;
+		senddata[pos++] = FUSB_TKN_TXON;
+
+		regmap_raw_write(chip->regmap, FUSB_REG_FIFO, senddata, pos);
+		chip->tx_state = tx_busy;
+		break;
+
+	default:
+		/* wait Tx result */
+		break;
+	}
+
+	return chip->tx_state;
+}
+
+static void process_vdm_msg(struct fusb30x_chip *chip)
+{
+	u32 vdm_header = chip->rec_load[0];
+	int i;
+	u32 tmp;
+
+	/* can't procee unstructed vdm msg */
+	if (!GET_VDMHEAD_STRUCT_TYPE(vdm_header)) {
+		dev_warn(chip->dev, "unknown unstructed vdm message\n");
+		return;
+	}
+
+	switch (GET_VDMHEAD_CMD_TYPE(vdm_header)) {
+	case VDM_TYPE_INIT:
+		switch (GET_VDMHEAD_CMD(vdm_header)) {
+		case VDM_ATTENTION:
+			chip->notify.dp_status = GET_DP_STATUS(chip->rec_load[1]);
+			dev_info(chip->dev, "attention, dp_status %x\n",
+				 chip->rec_load[1]);
+			chip->notify.attention = true;
+			platform_fusb_notify(chip);
+			break;
+		default:
+			dev_warn(chip->dev, "rec unknown init vdm msg\n");
+			break;
+		}
+		break;
+	case VDM_TYPE_ACK:
+		switch (GET_VDMHEAD_CMD(vdm_header)) {
+		case VDM_DISCOVERY_ID:
+			chip->vdm_id = chip->rec_load[1];
+			break;
+		case VDM_DISCOVERY_SVIDS:
+			for (i = 0; i < 6; i++) {
+				tmp = (chip->rec_load[i + 1] >> 16) &
+				      0x0000ffff;
+				if (tmp) {
+					chip->vdm_svid[i * 2] = tmp;
+					chip->vdm_svid_num++;
+				} else {
+					break;
+				}
+
+				tmp = (chip->rec_load[i + 1] & 0x0000ffff);
+				if (tmp) {
+					chip->vdm_svid[i * 2 + 1] = tmp;
+					chip->vdm_svid_num++;
+				} else {
+					break;
+				}
+			}
+			break;
+		case VDM_DISCOVERY_MODES:
+			/* indicate there are some vdo modes */
+			if (PD_HEADER_CNT(chip->rec_head) > 1) {
+				/*
+				 * store mode config,
+				 * enter first mode default
+				 */
+				tmp = chip->rec_load[1];
+
+				if ((!((tmp >> 8) & 0x3f)) &&
+				    (!((tmp >> 16) & 0x3f))) {
+					chip->val_tmp |= 1;
+					break;
+				}
+				chip->notify.dp_caps = chip->rec_load[1];
+				chip->notify.pin_assignment_def = 0;
+				chip->notify.pin_assignment_support =
+							PD_DP_PIN_CAPS(tmp);
+				chip->val_tmp |= 1;
+				dev_dbg(chip->dev,
+					"DisplayPort Capabilities: 0x%08x\n",
+					chip->rec_load[1]);
+			}
+			break;
+		case VDM_ENTER_MODE:
+			chip->val_tmp = 1;
+			break;
+		case VDM_DP_STATUS_UPDATE:
+			chip->notify.dp_status = GET_DP_STATUS(chip->rec_load[1]);
+			dev_dbg(chip->dev, "DisplayPort Status: 0x%08x\n",
+				chip->rec_load[1]);
+			chip->val_tmp = 1;
+			break;
+		case VDM_DP_CONFIG:
+			chip->val_tmp = 1;
+			dev_info(chip->dev,
+				 "DP config successful, pin_assignment 0x%x\n",
+				 chip->notify.pin_assignment_def);
+			chip->notify.is_enter_mode = true;
+			break;
+		default:
+			break;
+		}
+		break;
+	case VDM_TYPE_NACK:
+			dev_warn(chip->dev, "REC NACK for 0x%x\n",
+				 GET_VDMHEAD_CMD(vdm_header));
+			/* disable vdm */
+			chip->vdm_state = VDM_STATE_ERR;
+		break;
+	}
+}
+
+static int vdm_send_discoveryid(struct fusb30x_chip *chip, u32 evt)
+{
+	int tmp;
+
+	switch (chip->vdm_send_state) {
+	case 0:
+		set_vdm_mesg(chip, VDM_DISCOVERY_ID, VDM_TYPE_INIT, 0);
+		chip->vdm_id = 0;
+		chip->tx_state = 0;
+		chip->vdm_send_state++;
+	case 1:
+		tmp = policy_send_data(chip);
+		if (tmp == tx_success) {
+			chip->vdm_send_state++;
+			chip->timer_state = T_SENDER_RESPONSE;
+			fusb_timer_start(&chip->timer_state_machine,
+					 chip->timer_state);
+		} else if (tmp == tx_failed) {
+			dev_warn(chip->dev, "VDM_DISCOVERY_ID send failed\n");
+			/* disable auto_vdm_machine */
+			chip->vdm_state = VDM_STATE_ERR;
+			return -EPIPE;
+		}
+
+		if (chip->vdm_send_state != 2)
+			break;
+	default:
+		if (chip->vdm_id) {
+			chip->vdm_send_state = 0;
+			return 0;
+		} else if (evt & EVENT_TIMER_STATE) {
+			dev_warn(chip->dev, "VDM_DISCOVERY_ID time out\n");
+			chip->vdm_state = VDM_STATE_ERR;
+			chip->work_continue |= EVENT_WORK_CONTINUE;
+			return -ETIMEDOUT;
+		}
+		break;
+	}
+	return -EINPROGRESS;
+}
+
+static int vdm_send_discoverysvid(struct fusb30x_chip *chip, u32 evt)
+{
+	int tmp;
+
+	switch (chip->vdm_send_state) {
+	case 0:
+		set_vdm_mesg(chip, VDM_DISCOVERY_SVIDS, VDM_TYPE_INIT, 0);
+		memset(chip->vdm_svid, 0, sizeof(chip->vdm_svid));
+		chip->vdm_svid_num = 0;
+		chip->tx_state = 0;
+		chip->vdm_send_state++;
+	case 1:
+		tmp = policy_send_data(chip);
+		if (tmp == tx_success) {
+			chip->vdm_send_state++;
+			chip->timer_state = T_SENDER_RESPONSE;
+			fusb_timer_start(&chip->timer_state_machine,
+					 chip->timer_state);
+		} else if (tmp == tx_failed) {
+			dev_warn(chip->dev, "VDM_DISCOVERY_SVIDS send failed\n");
+			/* disable auto_vdm_machine */
+			chip->vdm_state = VDM_STATE_ERR;
+			return -EPIPE;
+		}
+
+		if (chip->vdm_send_state != 2)
+			break;
+	default:
+		if (chip->vdm_svid_num) {
+			chip->vdm_send_state = 0;
+			return 0;
+		} else if (evt & EVENT_TIMER_STATE) {
+			dev_warn(chip->dev, "VDM_DISCOVERY_SVIDS time out\n");
+			chip->vdm_state = VDM_STATE_ERR;
+			chip->work_continue |= EVENT_WORK_CONTINUE;
+			return -ETIMEDOUT;
+		}
+		break;
+	}
+	return -EINPROGRESS;
+}
+
+static int vdm_send_discoverymodes(struct fusb30x_chip *chip, u32 evt)
+{
+	int tmp;
+
+	if ((chip->val_tmp >> 1) != chip->vdm_svid_num) {
+		switch (chip->vdm_send_state) {
+		case 0:
+			set_vdm_mesg(chip, VDM_DISCOVERY_MODES,
+				     VDM_TYPE_INIT, 0);
+			chip->tx_state = 0;
+			chip->vdm_send_state++;
+		case 1:
+			tmp = policy_send_data(chip);
+			if (tmp == tx_success) {
+				chip->vdm_send_state++;
+				chip->timer_state = T_SENDER_RESPONSE;
+				fusb_timer_start(&chip->timer_state_machine,
+						 chip->timer_state);
+			} else if (tmp == tx_failed) {
+				dev_warn(chip->dev,
+					 "VDM_DISCOVERY_MODES send failed\n");
+				chip->vdm_state = VDM_STATE_ERR;
+				return -EPIPE;
+			}
+
+			if (chip->vdm_send_state != 2)
+				break;
+		default:
+			if (chip->val_tmp & 1) {
+				chip->val_tmp &= 0xfe;
+				chip->val_tmp += 2;
+				chip->vdm_send_state = 0;
+				chip->work_continue |= EVENT_WORK_CONTINUE;
+			} else if (evt & EVENT_TIMER_STATE) {
+				dev_warn(chip->dev,
+					 "VDM_DISCOVERY_MODES time out\n");
+				chip->vdm_state = VDM_STATE_ERR;
+				chip->work_continue |= EVENT_WORK_CONTINUE;
+				return -ETIMEDOUT;
+			}
+			break;
+		}
+	} else {
+		chip->val_tmp = 0;
+		return 0;
+	}
+
+	return -EINPROGRESS;
+}
+
+static int vdm_send_entermode(struct fusb30x_chip *chip, u32 evt)
+{
+	int tmp;
+
+	switch (chip->vdm_send_state) {
+	case 0:
+		set_vdm_mesg(chip, VDM_ENTER_MODE, VDM_TYPE_INIT, 1);
+		chip->tx_state = 0;
+		chip->vdm_send_state++;
+		chip->notify.is_enter_mode = false;
+	case 1:
+		tmp = policy_send_data(chip);
+		if (tmp == tx_success) {
+			chip->vdm_send_state++;
+			chip->timer_state = T_SENDER_RESPONSE;
+			fusb_timer_start(&chip->timer_state_machine,
+					 chip->timer_state);
+		} else if (tmp == tx_failed) {
+			dev_warn(chip->dev, "VDM_ENTER_MODE send failed\n");
+			/* disable auto_vdm_machine */
+			chip->vdm_state = VDM_STATE_ERR;
+			return -EPIPE;
+		}
+
+		if (chip->vdm_send_state != 2)
+			break;
+	default:
+		if (chip->val_tmp) {
+			chip->val_tmp = 0;
+			chip->vdm_send_state = 0;
+			return 0;
+		} else if (evt & EVENT_TIMER_STATE) {
+			dev_warn(chip->dev, "VDM_ENTER_MODE time out\n");
+			chip->vdm_state = VDM_STATE_ERR;
+			chip->work_continue |= EVENT_WORK_CONTINUE;
+			return -ETIMEDOUT;
+		}
+		break;
+	}
+	return -EINPROGRESS;
+}
+
+static int vdm_send_getdpstatus(struct fusb30x_chip *chip, u32 evt)
+{
+	int tmp;
+
+	switch (chip->vdm_send_state) {
+	case 0:
+		set_vdm_mesg(chip, VDM_DP_STATUS_UPDATE, VDM_TYPE_INIT, 1);
+		chip->tx_state = 0;
+		chip->vdm_send_state++;
+	case 1:
+		tmp = policy_send_data(chip);
+		if (tmp == tx_success) {
+			chip->vdm_send_state++;
+			chip->timer_state = T_SENDER_RESPONSE;
+			fusb_timer_start(&chip->timer_state_machine,
+					 chip->timer_state);
+		} else if (tmp == tx_failed) {
+			dev_warn(chip->dev,
+				 "VDM_DP_STATUS_UPDATE send failed\n");
+			/* disable auto_vdm_machine */
+			chip->vdm_state = VDM_STATE_ERR;
+			return -EPIPE;
+		}
+
+		if (chip->vdm_send_state != 2)
+			break;
+	default:
+		if (chip->val_tmp) {
+			chip->val_tmp = 0;
+			chip->vdm_send_state = 0;
+			return 0;
+		} else if (evt & EVENT_TIMER_STATE) {
+			dev_warn(chip->dev, "VDM_DP_STATUS_UPDATE time out\n");
+			chip->vdm_state = VDM_STATE_ERR;
+			chip->work_continue |= EVENT_WORK_CONTINUE;
+			return -ETIMEDOUT;
+		}
+		break;
+	}
+	return -EINPROGRESS;
+}
+
+static int vdm_send_dpconfig(struct fusb30x_chip *chip, u32 evt)
+{
+	int tmp;
+
+	switch (chip->vdm_send_state) {
+	case 0:
+		set_vdm_mesg(chip, VDM_DP_CONFIG, VDM_TYPE_INIT, 0);
+		chip->tx_state = 0;
+		chip->vdm_send_state++;
+	case 1:
+		tmp = policy_send_data(chip);
+		if (tmp == tx_success) {
+			chip->vdm_send_state++;
+			chip->timer_state = T_SENDER_RESPONSE;
+			fusb_timer_start(&chip->timer_state_machine,
+					 chip->timer_state);
+		} else if (tmp == tx_failed) {
+			dev_warn(chip->dev, "vdm_send_dpconfig send failed\n");
+			/* disable auto_vdm_machine */
+			chip->vdm_state = VDM_STATE_ERR;
+			return -EPIPE;
+		}
+
+		if (chip->vdm_send_state != 2)
+			break;
+	default:
+		if (chip->val_tmp) {
+			chip->val_tmp = 0;
+			chip->vdm_send_state = 0;
+			return 0;
+		} else if (evt & EVENT_TIMER_STATE) {
+			dev_warn(chip->dev, "vdm_send_dpconfig time out\n");
+			chip->vdm_state = VDM_STATE_ERR;
+			chip->work_continue |= EVENT_WORK_CONTINUE;
+			return -ETIMEDOUT;
+		}
+		break;
+	}
+	return -EINPROGRESS;
+}
+
+/* without break if success */
+#define AUTO_VDM_HANDLE(func, chip, evt, conditions) \
+do { \
+	conditions = func(chip, evt); \
+	if (!conditions) { \
+		chip->vdm_state++; \
+		chip->work_continue |= EVENT_WORK_CONTINUE; \
+	} else { \
+		if (conditions != -EINPROGRESS) \
+			chip->vdm_state = VDM_STATE_ERR; \
+	} \
+} while (0)
+
+static void auto_vdm_machine(struct fusb30x_chip *chip, u32 evt)
+{
+	int conditions;
+
+	switch (chip->vdm_state) {
+	case VDM_STATE_DISCOVERY_ID:
+		AUTO_VDM_HANDLE(vdm_send_discoveryid, chip, evt, conditions);
+		break;
+	case VDM_STATE_DISCOVERY_SVID:
+		AUTO_VDM_HANDLE(vdm_send_discoverysvid, chip, evt, conditions);
+		break;
+	case VDM_STATE_DISCOVERY_MODES:
+		AUTO_VDM_HANDLE(vdm_send_discoverymodes, chip, evt, conditions);
+		break;
+	case VDM_STATE_ENTER_MODE:
+		AUTO_VDM_HANDLE(vdm_send_entermode, chip, evt, conditions);
+		break;
+	case VDM_STATE_UPDATE_STATUS:
+		AUTO_VDM_HANDLE(vdm_send_getdpstatus, chip, evt, conditions);
+		break;
+	case VDM_STATE_DP_CONFIG:
+		AUTO_VDM_HANDLE(vdm_send_dpconfig, chip, evt, conditions);
+		break;
+	case VDM_STATE_NOTIFY:
+		platform_fusb_notify(chip);
+		chip->vdm_state = VDM_STATE_READY;
+		break;
+	default:
+		break;
+	}
+}
+
+static void fusb_state_disabled(struct fusb30x_chip *chip, u32 evt)
+{
+	/* Do nothing */
+}
+
+static void fusb_state_unattached(struct fusb30x_chip *chip, u32 evt)
+{
+	chip->notify.is_cc_connected = false;
+	chip->is_pd_support = false;
+
+	if ((evt & EVENT_CC) && chip->cc_state) {
+		if (chip->cc_state & CC_STATE_TOGSS_IS_UFP)
+			set_state(chip, attach_wait_sink);
+		else
+			set_state(chip, attach_wait_source);
+
+		chip->vbus_begin = tcpm_check_vbus(chip);
+
+		tcpm_set_polarity(chip, (chip->cc_state & CC_STATE_TOGSS_CC1) ?
+					TYPEC_POLARITY_CC1 :
+					TYPEC_POLARITY_CC2);
+		tcpm_get_cc(chip, &chip->cc1, &chip->cc2);
+		chip->debounce_cnt = 0;
+		chip->timer_mux = 2;
+		fusb_timer_start(&chip->timer_mux_machine, chip->timer_mux);
+	}
+}
+
+static void fusb_state_try_attach_set(struct fusb30x_chip *chip,
+				      enum role_mode mode)
+{
+	if (mode == ROLE_MODE_NONE || mode == ROLE_MODE_DRP ||
+	    mode == ROLE_MODE_ASS)
+		return;
+
+	tcpm_init(chip);
+	tcpm_set_cc(chip, (mode == ROLE_MODE_DFP) ?
+			  ROLE_MODE_DFP : ROLE_MODE_UFP);
+	chip->timer_mux = T_PD_TRY_DRP;
+	fusb_timer_start(&chip->timer_mux_machine, chip->timer_mux);
+	set_state(chip, (mode == ROLE_MODE_DFP) ?
+			attach_try_src : attach_try_snk);
+}
+
+static void fusb_state_attach_wait_sink(struct fusb30x_chip *chip, u32 evt)
+{
+	int cc1, cc2;
+
+	if (evt & EVENT_TIMER_MUX) {
+		if (tcpm_check_vbus(chip)) {
+			chip->timer_mux = T_DISABLED;
+			if (chip->role == ROLE_MODE_DRP &&
+			    chip->try_role == ROLE_MODE_DFP &&
+			    !chip->try_role_complete) {
+				fusb_state_try_attach_set(chip, ROLE_MODE_DFP);
+				return;
+			} else if (chip->try_role_complete) {
+				chip->timer_mux = T_PD_SOURCE_ON;
+				fusb_timer_start(&chip->timer_mux_machine,
+						 chip->timer_mux);
+				set_state(chip, attached_sink);
+				return;
+			}
+		}
+
+		tcpm_get_cc(chip, &cc1, &cc2);
+
+		if ((chip->cc1 == cc1) && (chip->cc2 == cc2)) {
+			chip->debounce_cnt++;
+		} else {
+			chip->cc1 = cc1;
+			chip->cc2 = cc2;
+			chip->debounce_cnt = 0;
+		}
+
+		if (chip->debounce_cnt > N_DEBOUNCE_CNT) {
+			chip->timer_mux = T_DISABLED;
+			if ((chip->cc1 == TYPEC_CC_VOLT_RP &&
+			     chip->cc2 == TYPEC_CC_VOLT_OPEN) ||
+			    (chip->cc2 == TYPEC_CC_VOLT_RP &&
+			     chip->cc1 == TYPEC_CC_VOLT_OPEN)) {
+				chip->timer_mux = T_PD_SOURCE_ON;
+				fusb_timer_start(&chip->timer_mux_machine,
+						 chip->timer_mux);
+				set_state(chip, attached_sink);
+			} else {
+				set_state_unattached(chip);
+			}
+			return;
+		}
+
+		chip->timer_mux = 2;
+		fusb_timer_start(&chip->timer_mux_machine,
+				 chip->timer_mux);
+	}
+}
+
+static void fusb_state_attach_wait_source(struct fusb30x_chip *chip, u32 evt)
+{
+	int cc1, cc2;
+
+	if (evt & EVENT_TIMER_MUX) {
+		tcpm_get_cc(chip, &cc1, &cc2);
+
+		if ((chip->cc1 == cc1) && (chip->cc2 == cc2)) {
+			chip->debounce_cnt++;
+		} else {
+			chip->cc1 = cc1;
+			chip->cc2 = cc2;
+			chip->debounce_cnt = 0;
+		}
+
+		if (chip->debounce_cnt > N_DEBOUNCE_CNT) {
+			if (((!chip->cc1) || (!chip->cc2)) &&
+			    ((chip->cc1 == TYPEC_CC_VOLT_RD) ||
+			     (chip->cc2 == TYPEC_CC_VOLT_RD))) {
+				if (chip->role == ROLE_MODE_DRP &&
+				    chip->try_role == ROLE_MODE_UFP &&
+				    !chip->try_role_complete)
+					fusb_state_try_attach_set(chip,
+							ROLE_MODE_UFP);
+				else
+					set_state(chip, attached_source);
+			} else {
+				set_state_unattached(chip);
+			}
+			return;
+		}
+
+		chip->timer_mux = 2;
+		fusb_timer_start(&chip->timer_mux_machine,
+				 chip->timer_mux);
+	}
+}
+
+static void fusb_state_attached_source(struct fusb30x_chip *chip, u32 evt)
+{
+	platform_set_vbus_lvl_enable(chip, 1, 0);
+	tcpm_set_polarity(chip, (chip->cc_state & CC_STATE_TOGSS_CC1) ?
+				TYPEC_POLARITY_CC1 : TYPEC_POLARITY_CC2);
+	tcpm_set_vconn(chip, 1);
+
+	chip->notify.is_cc_connected = true;
+
+	chip->notify.power_role = POWER_ROLE_SOURCE;
+	chip->notify.data_role = DATA_ROLE_DFP;
+	chip->hardrst_count = 0;
+	set_state(chip, policy_src_startup);
+	regmap_update_bits(chip->regmap, FUSB_REG_MASK, MASK_M_COMP_CHNG, 0);
+	dev_info(chip->dev, "CC connected in %s as DFP\n",
+		 chip->cc_polarity ? "CC1" : "CC2");
+}
+
+static void fusb_state_attached_sink(struct fusb30x_chip *chip, u32 evt)
+{
+	if (tcpm_check_vbus(chip)) {
+		chip->timer_mux = T_DISABLED;
+		chip->timer_state = T_DISABLED;
+		if (!chip->try_role_complete &&
+		    chip->try_role == ROLE_MODE_DFP &&
+		    chip->role == ROLE_MODE_DRP) {
+			fusb_state_try_attach_set(chip, ROLE_MODE_DFP);
+			return;
+		}
+
+		chip->try_role_complete = true;
+		chip->notify.is_cc_connected = true;
+		chip->notify.power_role = POWER_ROLE_SINK;
+		chip->notify.data_role = DATA_ROLE_UFP;
+		chip->hardrst_count = 0;
+		set_state(chip, policy_snk_startup);
+		dev_info(chip->dev, "CC connected in %s as UFP\n",
+			 chip->cc_polarity ? "CC1" : "CC2");
+		return;
+	} else if (evt & EVENT_TIMER_MUX) {
+		set_state_unattached(chip);
+		return;
+	}
+
+	chip->timer_state = 2;
+	fusb_timer_start(&chip->timer_state_machine,
+			 chip->timer_state);
+}
+
+static void fusb_state_try_attach(struct fusb30x_chip *chip, u32 evt,
+				  enum role_mode mode)
+{
+	if ((evt & EVENT_CC) && chip->cc_state) {
+		chip->try_role_complete = true;
+		if (chip->cc_state & CC_STATE_TOGSS_IS_UFP)
+			set_state(chip, (mode == ROLE_MODE_UFP) ?
+					attach_wait_sink : error_recovery);
+		else
+			set_state(chip, (mode == ROLE_MODE_DFP) ?
+					attach_wait_source : error_recovery);
+
+		tcpm_set_polarity(chip, (chip->cc_state & CC_STATE_TOGSS_CC1) ?
+					TYPEC_POLARITY_CC1 :
+					TYPEC_POLARITY_CC2);
+		tcpm_get_cc(chip, &chip->cc1, &chip->cc2);
+		chip->debounce_cnt = 0;
+		chip->timer_mux = 2;
+		fusb_timer_start(&chip->timer_mux_machine, chip->timer_mux);
+	} else if (evt & EVENT_TIMER_MUX) {
+		if (!chip->try_role_complete) {
+			chip->try_role_complete = true;
+			fusb_state_try_attach_set(chip,
+						  (mode == ROLE_MODE_DFP) ?
+						  ROLE_MODE_UFP :
+						  ROLE_MODE_DFP);
+		} else {
+			set_state(chip, error_recovery);
+		}
+	}
+}
+
+static void fusb_soft_reset_parameter(struct fusb30x_chip *chip)
+{
+	chip->caps_counter = 0;
+	chip->msg_id = 0;
+	chip->vdm_state = VDM_STATE_DISCOVERY_ID;
+	chip->vdm_substate = 0;
+	chip->vdm_send_state = 0;
+	chip->val_tmp = 0;
+	chip->pos_power = 0;
+}
+
+static void fusb_state_src_startup(struct fusb30x_chip *chip, u32 evt)
+{
+	chip->notify.is_pd_connected = false;
+	fusb_soft_reset_parameter(chip);
+
+	memset(chip->partner_cap, 0, sizeof(chip->partner_cap));
+
+	tcpm_set_msg_header(chip);
+	tcpm_set_polarity(chip, chip->cc_polarity);
+	tcpm_set_rx_enable(chip, 1);
+
+	set_state(chip, policy_src_send_caps);
+	platform_fusb_notify(chip);
+}
+
+static void fusb_state_src_discovery(struct fusb30x_chip *chip, u32 evt)
+{
+	switch (chip->sub_state) {
+	case 0:
+		chip->caps_counter++;
+
+		if (chip->caps_counter < N_CAPS_COUNT) {
+			chip->timer_state = T_TYPEC_SEND_SOURCECAP;
+			fusb_timer_start(&chip->timer_state_machine,
+					 chip->timer_state);
+			chip->sub_state = 1;
+		} else {
+			set_state(chip, disabled);
+		}
+		break;
+	default:
+		if (evt & EVENT_TIMER_STATE) {
+			set_state(chip, policy_src_send_caps);
+		} else if (evt & EVENT_TIMER_MUX) {
+			if (!chip->is_pd_support)
+				set_state(chip, disabled);
+			else if (chip->hardrst_count > N_HARDRESET_COUNT)
+				set_state(chip, error_recovery);
+			else
+				set_state(chip, policy_src_send_hardrst);
+		}
+		break;
+	}
+}
+
+static void fusb_state_src_send_caps(struct fusb30x_chip *chip, u32 evt)
+{
+	u32 tmp;
+
+	switch (chip->sub_state) {
+	case 0:
+		set_mesg(chip, DMT_SOURCECAPABILITIES, DATAMESSAGE);
+		chip->sub_state = 1;
+		chip->tx_state = tx_idle;
+		/* without break */
+	case 1:
+		tmp = policy_send_data(chip);
+
+		if (tmp == tx_success) {
+			chip->hardrst_count = 0;
+			chip->caps_counter = 0;
+			chip->timer_state = T_SENDER_RESPONSE;
+			fusb_timer_start(&chip->timer_state_machine,
+					 chip->timer_state);
+			chip->timer_mux = T_DISABLED;
+			chip->sub_state++;
+			chip->is_pd_support = true;
+		} else if (tmp == tx_failed) {
+			set_state(chip, policy_src_discovery);
+			break;
+		}
+
+		if (!(evt & FLAG_EVENT))
+			break;
+	default:
+		if (evt & EVENT_RX) {
+			if (PACKET_IS_DATA_MSG(chip->rec_head, DMT_REQUEST)) {
+				set_state(chip, policy_src_negotiate_cap);
+			} else {
+				set_state(chip, policy_src_send_softrst);
+			}
+		} else if (evt & EVENT_TIMER_STATE) {
+			if (chip->hardrst_count <= N_HARDRESET_COUNT)
+				set_state(chip, policy_src_send_hardrst);
+			else
+				set_state(chip, disabled);
+		} else if (evt & EVENT_TIMER_MUX) {
+			if (!chip->is_pd_support)
+				set_state(chip, disabled);
+			else if (chip->hardrst_count > N_HARDRESET_COUNT)
+				set_state(chip, error_recovery);
+			else
+				set_state(chip, policy_src_send_hardrst);
+		}
+		break;
+	}
+}
+
+static void fusb_state_src_negotiate_cap(struct fusb30x_chip *chip, u32 evt)
+{
+	u32 tmp;
+
+	/* base on evb1 */
+	tmp = (chip->rec_load[0] >> 28) & 0x07;
+	if (tmp > chip->n_caps_used)
+		set_state(chip, policy_src_cap_response);
+	else
+		set_state(chip, policy_src_transition_supply);
+}
+
+static void fusb_state_src_transition_supply(struct fusb30x_chip *chip,
+					     u32 evt)
+{
+	u32 tmp;
+
+	switch (chip->sub_state) {
+	case 0:
+		set_mesg(chip, CMT_ACCEPT, CONTROLMESSAGE);
+		chip->tx_state = tx_idle;
+		chip->sub_state++;
+		/* without break */
+	case 1:
+		tmp = policy_send_data(chip);
+		if (tmp == tx_success) {
+			chip->timer_state = T_SRC_TRANSITION;
+			chip->sub_state++;
+			fusb_timer_start(&chip->timer_state_machine,
+					 chip->timer_state);
+		} else if (tmp == tx_failed) {
+			set_state(chip, policy_src_send_softrst);
+		}
+		break;
+	case 2:
+		if (evt & EVENT_TIMER_STATE) {
+			chip->notify.is_pd_connected = true;
+			platform_set_vbus_lvl_enable(chip, 1, 0);
+			set_mesg(chip, CMT_PS_RDY, CONTROLMESSAGE);
+			chip->tx_state = tx_idle;
+			chip->sub_state++;
+			chip->work_continue |= EVENT_WORK_CONTINUE;
+		}
+		break;
+	default:
+		tmp = policy_send_data(chip);
+		if (tmp == tx_success) {
+			dev_info(chip->dev,
+				 "PD connected as DFP, supporting 5V\n");
+			set_state(chip, policy_src_ready);
+		} else if (tmp == tx_failed) {
+			set_state(chip, policy_src_send_softrst);
+		}
+		break;
+	}
+}
+
+static void fusb_state_src_cap_response(struct fusb30x_chip *chip, u32 evt)
+{
+	u32 tmp;
+
+	switch (chip->sub_state) {
+	case 0:
+		set_mesg(chip, CMT_REJECT, CONTROLMESSAGE);
+		chip->tx_state = tx_idle;
+		chip->sub_state++;
+		/* without break */
+	default:
+		tmp = policy_send_data(chip);
+		if (tmp == tx_success) {
+			if (chip->notify.is_pd_connected) {
+				dev_info(chip->dev,
+					 "PD connected as DFP, supporting 5V\n");
+				set_state(chip, policy_src_ready);
+			} else {
+				set_state(chip, policy_src_send_hardrst);
+			}
+		} else if (tmp == tx_failed) {
+			set_state(chip, policy_src_send_softrst);
+		}
+		break;
+	}
+}
+
+static void fusb_state_src_transition_default(struct fusb30x_chip *chip,
+					      u32 evt)
+{
+	switch (chip->sub_state) {
+	case 0:
+		chip->notify.is_pd_connected = false;
+		platform_set_vbus_lvl_enable(chip, 0, 0);
+		if (chip->notify.data_role)
+			regmap_update_bits(chip->regmap,
+					   FUSB_REG_SWITCHES1,
+					   SWITCHES1_DATAROLE,
+					   SWITCHES1_DATAROLE);
+		else
+			regmap_update_bits(chip->regmap,
+					   FUSB_REG_SWITCHES1,
+					   SWITCHES1_DATAROLE,
+					   0);
+
+		chip->timer_state = T_SRC_RECOVER;
+		fusb_timer_start(&chip->timer_state_machine,
+				 chip->timer_state);
+		chip->sub_state++;
+		break;
+	default:
+		if (evt & EVENT_TIMER_STATE) {
+			platform_set_vbus_lvl_enable(chip, 1, 0);
+			chip->timer_mux = T_NO_RESPONSE;
+			fusb_timer_start(&chip->timer_mux_machine,
+					 chip->timer_mux);
+			set_state(chip, policy_src_startup);
+			dev_dbg(chip->dev, "reset over-> src startup\n");
+		}
+		break;
+	}
+}
+
+static void fusb_state_vcs_ufp_evaluate_swap(struct fusb30x_chip *chip, u32 evt)
+{
+	if (chip->vconn_supported)
+		set_state(chip, policy_vcs_ufp_accept);
+	else
+		set_state(chip, policy_vcs_ufp_reject);
+}
+
+static void fusb_state_swap_msg_process(struct fusb30x_chip *chip, u32 evt)
+{
+	if (evt & EVENT_RX) {
+		if (PACKET_IS_CONTROL_MSG(chip->rec_head, CMT_PR_SWAP)) {
+			set_state(chip, policy_src_prs_evaluate);
+		} else if (PACKET_IS_CONTROL_MSG(chip->rec_head,
+						 CMT_VCONN_SWAP)) {
+			if (chip->notify.data_role)
+				set_state(chip, chip->conn_state);
+			else
+				set_state(chip, policy_vcs_ufp_evaluate_swap);
+		} else if (PACKET_IS_CONTROL_MSG(chip->rec_head,
+						 CMT_DR_SWAP)) {
+			if (chip->notify.data_role)
+				set_state(chip, policy_drs_dfp_evaluate);
+			else
+				set_state(chip, policy_drs_ufp_evaluate);
+		}
+	}
+}
+
+#define VDM_IS_ACTIVE(chip) \
+	(chip->notify.data_role && chip->vdm_state < VDM_STATE_READY)
+
+static void fusb_state_src_ready(struct fusb30x_chip *chip, u32 evt)
+{
+	if (evt & EVENT_RX) {
+		if (PACKET_IS_DATA_MSG(chip->rec_head, DMT_VENDERDEFINED)) {
+			process_vdm_msg(chip);
+			chip->work_continue |= EVENT_WORK_CONTINUE;
+			chip->timer_state = T_DISABLED;
+		} else if (!VDM_IS_ACTIVE(chip)) {
+			fusb_state_swap_msg_process(chip, evt);
+		}
+	}
+
+	if (!chip->partner_cap[0])
+		set_state(chip, policy_src_get_sink_caps);
+	else if (VDM_IS_ACTIVE(chip))
+		auto_vdm_machine(chip, evt);
+}
+
+static void fusb_state_prs_evaluate(struct fusb30x_chip *chip, u32 evt)
+{
+	if (chip->role == ROLE_MODE_DRP)
+		set_state(chip, policy_src_prs_accept);
+	else
+		set_state(chip, policy_src_prs_reject);
+}
+
+static void fusb_state_send_simple_msg(struct fusb30x_chip *chip, u32 evt,
+				       int cmd, int is_DMT,
+				       enum connection_state state_success,
+				       enum connection_state state_failed)
+{
+	u32 tmp;
+
+	switch (chip->sub_state) {
+	case 0:
+		set_mesg(chip, cmd, is_DMT);
+		chip->tx_state = tx_idle;
+		chip->sub_state++;
+		/* fallthrough */
+	case 1:
+		tmp = policy_send_data(chip);
+		if (tmp == tx_success)
+			set_state(chip, state_success);
+		else if (tmp == tx_failed)
+			set_state(chip, state_failed);
+	}
+}
+
+static void fusb_state_prs_reject(struct fusb30x_chip *chip, u32 evt)
+{
+	fusb_state_send_simple_msg(chip, evt, CMT_REJECT, CONTROLMESSAGE,
+				   (chip->notify.power_role) ?
+				   policy_src_ready : policy_snk_ready,
+				   (chip->notify.power_role) ?
+				   policy_src_send_softrst :
+				   policy_snk_send_softrst);
+}
+
+static void fusb_state_prs_accept(struct fusb30x_chip *chip, u32 evt)
+{
+	fusb_state_send_simple_msg(chip, evt, CMT_ACCEPT, CONTROLMESSAGE,
+				   (chip->notify.power_role) ?
+				   policy_src_prs_transition_to_off :
+				   policy_snk_prs_transition_to_off,
+				   (chip->notify.power_role) ?
+				   policy_src_send_softrst :
+				   policy_snk_send_softrst);
+}
+
+static void fusb_state_vcs_ufp_accept(struct fusb30x_chip *chip, u32 evt)
+{
+	fusb_state_send_simple_msg(chip, evt, CMT_ACCEPT, CONTROLMESSAGE,
+				   (chip->vconn_enabled) ?
+				   policy_vcs_ufp_wait_for_dfp_vconn :
+				   policy_vcs_ufp_turn_on_vconn,
+				   (chip->notify.power_role) ?
+				   policy_src_send_softrst :
+				   policy_snk_send_softrst);
+}
+
+static void fusb_state_vcs_set_vconn(struct fusb30x_chip *chip,
+				     u32 evt, bool on)
+{
+	if (on) {
+		tcpm_set_vconn(chip, 1);
+		set_state(chip, chip->notify.data_role ?
+				policy_vcs_dfp_send_ps_rdy :
+				policy_vcs_ufp_send_ps_rdy);
+	} else {
+		tcpm_set_vconn(chip, 0);
+		if (chip->notify.power_role)
+			set_state(chip, policy_src_ready);
+		else
+			set_state(chip, policy_snk_ready);
+	}
+}
+
+static void fusb_state_vcs_send_ps_rdy(struct fusb30x_chip *chip, u32 evt)
+{
+	fusb_state_send_simple_msg(chip, evt, CMT_PS_RDY, CONTROLMESSAGE,
+				   (chip->notify.power_role) ?
+				   policy_src_ready : policy_snk_ready,
+				   (chip->notify.power_role) ?
+				   policy_src_send_softrst :
+				   policy_snk_send_softrst);
+}
+
+static void fusb_state_vcs_wait_for_vconn(struct fusb30x_chip *chip,
+					  u32 evt)
+{
+	switch (chip->sub_state) {
+	case 0:
+		chip->timer_state = T_PD_VCONN_SRC_ON;
+		fusb_timer_start(&chip->timer_state_machine,
+				 chip->timer_state);
+		chip->sub_state++;
+		/* fallthrough */
+	case 1:
+		if (evt & EVENT_RX) {
+			if (PACKET_IS_CONTROL_MSG(chip->rec_head, CMT_PS_RDY))
+				set_state(chip, chip->notify.data_role ?
+						policy_vcs_dfp_turn_off_vconn :
+						policy_vcs_ufp_turn_off_vconn);
+		} else if (evt & EVENT_TIMER_STATE) {
+			if (chip->notify.power_role)
+				set_state(chip, policy_src_send_hardrst);
+			else
+				set_state(chip, policy_snk_send_hardrst);
+		}
+	}
+}
+
+static void fusb_state_src_prs_transition_to_off(struct fusb30x_chip *chip,
+						 u32 evt)
+{
+	switch (chip->sub_state) {
+	case 0:
+		chip->timer_state = T_SRC_TRANSITION;
+		fusb_timer_start(&chip->timer_state_machine,
+				 chip->timer_state);
+		chip->sub_state++;
+		break;
+	case 1:
+		if (evt & EVENT_TIMER_STATE) {
+			platform_set_vbus_lvl_enable(chip, 0, 0);
+			chip->notify.power_role = POWER_ROLE_SINK;
+			tcpm_set_msg_header(chip);
+			if (chip->role == ROLE_MODE_DRP)
+				set_state(chip, policy_src_prs_assert_rd);
+			else
+				set_state(chip, policy_src_prs_source_off);
+		}
+	}
+}
+
+static void fusb_state_src_prs_assert_rd(struct fusb30x_chip *chip, u32 evt)
+{
+	tcpm_set_cc_pull_mode(chip, CC_PULL_DOWN);
+	set_state(chip, policy_src_prs_source_off);
+}
+
+static void fusb_state_src_prs_source_off(struct fusb30x_chip *chip, u32 evt)
+{
+	u32 tmp;
+
+	switch (chip->sub_state) {
+	case 0:
+		set_mesg(chip, CMT_PS_RDY, CONTROLMESSAGE);
+		chip->tx_state = tx_idle;
+		chip->sub_state++;
+		/* fallthrough */
+	case 1:
+		tmp = policy_send_data(chip);
+		if (tmp == tx_success) {
+			chip->timer_state = T_PD_SOURCE_ON;
+			fusb_timer_start(&chip->timer_state_machine,
+					 chip->timer_state);
+			chip->sub_state++;
+		} else if (tmp == tx_failed) {
+			chip->notify.power_role = POWER_ROLE_SOURCE;
+			tcpm_set_msg_header(chip);
+			set_state(chip, policy_src_send_hardrst);
+		}
+		if (chip->sub_state != 3)
+			break;
+	case 2:
+		if (evt & EVENT_RX) {
+			if (PACKET_IS_CONTROL_MSG(chip->rec_head,
+						  CMT_PS_RDY)) {
+				chip->timer_state = T_DISABLED;
+				/* snk startup */
+				chip->notify.is_pd_connected = false;
+				chip->cc_state |= CC_STATE_TOGSS_IS_UFP;
+				tcpm_set_polarity(chip, chip->cc_polarity);
+				tcpm_set_rx_enable(chip, 1);
+				set_state(chip, policy_snk_discovery);
+			} else {
+				dev_dbg(chip->dev,
+					"rec careless msg: head %x\n",
+					chip->rec_head);
+			}
+		} else if (evt & EVENT_TIMER_STATE) {
+			chip->notify.power_role = POWER_ROLE_SOURCE;
+			tcpm_set_msg_header(chip);
+			set_state(chip, policy_src_send_hardrst);
+		}
+	}
+}
+
+static void fusb_state_drs_evaluate(struct fusb30x_chip *chip, u32 evt)
+{
+	if (chip->pd_cap_info.data_role_swap)
+		/*
+		 * TODO:
+		 * NOW REJECT swap when the port is DFP
+		 * since we should work together with USB part
+		 */
+		set_state(chip, chip->notify.data_role ?
+				policy_drs_dfp_reject : policy_drs_ufp_accept);
+	else
+		set_state(chip, chip->notify.data_role ?
+				policy_drs_dfp_reject : policy_drs_ufp_reject);
+}
+
+static void fusb_state_drs_send_accept(struct fusb30x_chip *chip, u32 evt)
+{
+	fusb_state_send_simple_msg(chip, evt, CMT_ACCEPT, CONTROLMESSAGE,
+				   chip->notify.power_role ?
+				   policy_drs_dfp_change :
+				   policy_drs_ufp_change,
+				   error_recovery);
+}
+
+static void fusb_state_drs_role_change(struct fusb30x_chip *chip, u32 evt)
+{
+	chip->notify.data_role = chip->notify.data_role ?
+				 DATA_ROLE_UFP : DATA_ROLE_DFP;
+	tcpm_set_msg_header(chip);
+	set_state(chip, chip->notify.power_role ? policy_src_ready :
+						  policy_snk_ready);
+}
+
+static void fusb_state_src_get_sink_cap(struct fusb30x_chip *chip, u32 evt)
+{
+	u32 tmp;
+
+	switch (chip->sub_state) {
+	case 0:
+		set_mesg(chip, CMT_GETSINKCAP, CONTROLMESSAGE);
+		chip->tx_state = tx_idle;
+		chip->sub_state++;
+		/* without break */
+	case 1:
+		tmp = policy_send_data(chip);
+		if (tmp == tx_success) {
+			chip->timer_state = T_SENDER_RESPONSE;
+			chip->sub_state++;
+			fusb_timer_start(&chip->timer_state_machine,
+					 chip->timer_state);
+		} else if (tmp == tx_failed) {
+			set_state(chip, policy_src_send_softrst);
+		}
+
+		if (!(evt & FLAG_EVENT))
+			break;
+	default:
+		if (evt & EVENT_RX) {
+			if (PACKET_IS_DATA_MSG(chip->rec_head,
+					       DMT_SINKCAPABILITIES)) {
+				for (tmp = 0;
+				     tmp < PD_HEADER_CNT(chip->rec_head);
+				     tmp++) {
+					chip->partner_cap[tmp] =
+						chip->rec_load[tmp];
+				}
+				set_state(chip, policy_src_ready);
+			} else {
+				chip->partner_cap[0] = 0xffffffff;
+				set_state(chip, policy_src_ready);
+			}
+		} else if (evt & EVENT_TIMER_STATE) {
+			dev_warn(chip->dev, "Get sink cap time out\n");
+			chip->partner_cap[0] = 0xffffffff;
+			set_state(chip, policy_src_ready);
+		}
+	}
+}
+
+static void fusb_state_src_send_hardreset(struct fusb30x_chip *chip, u32 evt)
+{
+	u32 tmp;
+
+	switch (chip->sub_state) {
+	case 0:
+		chip->tx_state = tx_idle;
+		chip->sub_state++;
+		/* without break */
+	default:
+		tmp = policy_send_hardrst(chip, evt);
+		if (tmp == tx_success) {
+			chip->hardrst_count++;
+			set_state(chip, policy_src_transition_default);
+		} else if (tmp == tx_failed) {
+			/* can't reach here */
+			set_state(chip, error_recovery);
+		}
+		break;
+	}
+}
+
+static void fusb_state_src_softreset(struct fusb30x_chip *chip)
+{
+	u32 tmp;
+
+	switch (chip->sub_state) {
+	case 0:
+		set_mesg(chip, CMT_ACCEPT, CONTROLMESSAGE);
+		chip->tx_state = tx_idle;
+		chip->sub_state++;
+		/* without break */
+	default:
+		tmp = policy_send_data(chip);
+		if (tmp == tx_success) {
+			fusb_soft_reset_parameter(chip);
+			set_state(chip, policy_src_send_caps);
+		} else if (tmp == tx_failed) {
+			set_state(chip, policy_src_send_hardrst);
+		}
+		break;
+	}
+}
+
+static void fusb_state_src_send_softreset(struct fusb30x_chip *chip, u32 evt)
+{
+	u32 tmp;
+
+	switch (chip->sub_state) {
+	case 0:
+		set_mesg(chip, CMT_SOFTRESET, CONTROLMESSAGE);
+		chip->tx_state = tx_idle;
+		chip->sub_state++;
+		/* without break */
+	case 1:
+		tmp = policy_send_data(chip);
+		if (tmp == tx_success) {
+			chip->timer_state = T_SENDER_RESPONSE;
+			chip->sub_state++;
+			fusb_timer_start(&chip->timer_state_machine,
+					 chip->timer_state);
+		} else if (tmp == tx_failed) {
+			set_state(chip, policy_src_send_hardrst);
+		}
+
+		if (!(evt & FLAG_EVENT))
+			break;
+	default:
+		if (evt & EVENT_RX) {
+			if (PACKET_IS_CONTROL_MSG(chip->rec_head, CMT_ACCEPT)) {
+				fusb_soft_reset_parameter(chip);
+				set_state(chip, policy_src_send_caps);
+			}
+		} else if (evt & EVENT_TIMER_STATE) {
+			set_state(chip, policy_src_send_hardrst);
+		}
+		break;
+	}
+}
+
+static void fusb_state_snk_startup(struct fusb30x_chip *chip, u32 evt)
+{
+	chip->notify.is_pd_connected = false;
+	fusb_soft_reset_parameter(chip);
+
+	memset(chip->partner_cap, 0, sizeof(chip->partner_cap));
+
+	tcpm_set_msg_header(chip);
+	tcpm_set_polarity(chip, chip->cc_polarity);
+	tcpm_set_rx_enable(chip, 1);
+	set_state(chip, policy_snk_discovery);
+	platform_fusb_notify(chip);
+}
+
+static void fusb_state_snk_discovery(struct fusb30x_chip *chip, u32 evt)
+{
+	set_state(chip, policy_snk_wait_caps);
+	chip->timer_state = T_TYPEC_SINK_WAIT_CAP;
+	fusb_timer_start(&chip->timer_state_machine,
+			 chip->timer_state);
+}
+
+static void fusb_state_snk_wait_caps(struct fusb30x_chip *chip, u32 evt)
+{
+	if (evt & EVENT_RX) {
+		if (PACKET_IS_DATA_MSG(chip->rec_head,
+				       DMT_SOURCECAPABILITIES)) {
+			chip->is_pd_support = true;
+			chip->timer_mux = T_DISABLED;
+			set_state(chip, policy_snk_evaluate_caps);
+		}
+	} else if (evt & EVENT_TIMER_STATE) {
+		if (chip->hardrst_count <= N_HARDRESET_COUNT) {
+			if (chip->vbus_begin) {
+				chip->vbus_begin = false;
+				set_state(chip, policy_snk_send_softrst);
+			} else {
+				set_state(chip, policy_snk_send_hardrst);
+			}
+		} else {
+			if (chip->is_pd_support)
+				set_state(chip, error_recovery);
+			else
+				set_state(chip, disabled);
+		}
+	} else if ((evt & EVENT_TIMER_MUX) &&
+		   (chip->hardrst_count > N_HARDRESET_COUNT)) {
+		if (chip->is_pd_support)
+			set_state(chip, error_recovery);
+		else
+			set_state(chip, disabled);
+	}
+}
+
+static void fusb_state_snk_evaluate_caps(struct fusb30x_chip *chip, u32 evt)
+{
+	u32 tmp;
+
+	chip->hardrst_count = 0;
+	chip->pos_power = 0;
+
+	for (tmp = 0; tmp < PD_HEADER_CNT(chip->rec_head); tmp++) {
+		switch (CAP_POWER_TYPE(chip->rec_load[tmp])) {
+		case 0:
+			/* Fixed Supply */
+			if (CAP_FPDO_VOLTAGE(chip->rec_load[tmp]) <= 100)
+				chip->pos_power = tmp + 1;
+			break;
+		case 1:
+			/* Battery */
+			if (CAP_VPDO_VOLTAGE(chip->rec_load[tmp]) <= 100)
+				chip->pos_power = tmp + 1;
+			break;
+		default:
+			/* not meet battery caps */
+			break;
+		}
+	}
+	fusb302_set_pos_power_by_charge_ic(chip);
+
+	if ((!chip->pos_power) || (chip->pos_power > 7)) {
+		chip->pos_power = 0;
+		set_state(chip, policy_snk_wait_caps);
+	} else {
+		set_state(chip, policy_snk_select_cap);
+	}
+}
+
+static void fusb_state_snk_select_cap(struct fusb30x_chip *chip, u32 evt)
+{
+	u32 tmp;
+
+	switch (chip->sub_state) {
+	case 0:
+		set_mesg(chip, DMT_REQUEST, DATAMESSAGE);
+		chip->sub_state = 1;
+		chip->tx_state = tx_idle;
+		/* without break */
+	case 1:
+		tmp = policy_send_data(chip);
+
+		if (tmp == tx_success) {
+			chip->timer_state = T_SENDER_RESPONSE;
+			fusb_timer_start(&chip->timer_state_machine,
+					 chip->timer_state);
+			chip->sub_state++;
+		} else if (tmp == tx_failed) {
+			set_state(chip, policy_snk_discovery);
+			break;
+		}
+
+		if (!(evt & FLAG_EVENT))
+			break;
+	default:
+		if (evt & EVENT_RX) {
+			if (!PD_HEADER_CNT(chip->rec_head)) {
+				switch (PD_HEADER_TYPE(chip->rec_head)) {
+				case CMT_ACCEPT:
+					set_state(chip,
+						  policy_snk_transition_sink);
+					chip->timer_state = T_PS_TRANSITION;
+					fusb_timer_start(&chip->timer_state_machine,
+							 chip->timer_state);
+					break;
+				case CMT_WAIT:
+				case CMT_REJECT:
+					if (chip->notify.is_pd_connected) {
+						dev_info(chip->dev,
+							 "PD connected as UFP, fetching 5V\n");
+						set_state(chip,
+							  policy_snk_ready);
+					} else {
+						set_state(chip,
+							  policy_snk_wait_caps);
+						/*
+						 * make sure don't send
+						 * hard reset to prevent
+						 * infinite loop
+						 */
+						chip->hardrst_count =
+							N_HARDRESET_COUNT + 1;
+					}
+					break;
+				default:
+					break;
+				}
+			}
+		} else if (evt & EVENT_TIMER_STATE) {
+			set_state(chip, policy_snk_send_hardrst);
+		}
+		break;
+	}
+}
+
+static void fusb_state_snk_transition_sink(struct fusb30x_chip *chip, u32 evt)
+{
+	if (evt & EVENT_RX) {
+		if (PACKET_IS_CONTROL_MSG(chip->rec_head, CMT_PS_RDY)) {
+			chip->notify.is_pd_connected = true;
+			dev_info(chip->dev,
+				 "PD connected as UFP, fetching 5V\n");
+			set_state(chip, policy_snk_ready);
+		} else if (PACKET_IS_DATA_MSG(chip->rec_head,
+					      DMT_SOURCECAPABILITIES)) {
+			set_state(chip, policy_snk_evaluate_caps);
+		}
+	} else if (evt & EVENT_TIMER_STATE) {
+		set_state(chip, policy_snk_send_hardrst);
+	}
+}
+
+static void fusb_state_snk_transition_default(struct fusb30x_chip *chip,
+					      u32 evt)
+{
+	switch (chip->sub_state) {
+	case 0:
+		chip->notify.is_pd_connected = false;
+		chip->timer_mux = T_NO_RESPONSE;
+		fusb_timer_start(&chip->timer_mux_machine,
+				 chip->timer_mux);
+		chip->timer_state = T_PS_HARD_RESET_MAX + T_SAFE_0V;
+		fusb_timer_start(&chip->timer_state_machine,
+				 chip->timer_state);
+		if (chip->notify.data_role)
+			tcpm_set_msg_header(chip);
+
+		chip->sub_state++;
+		/* fallthrough */
+	case 1:
+		if (!tcpm_check_vbus(chip)) {
+			chip->sub_state++;
+			chip->timer_state = T_SRC_RECOVER_MAX + T_SRC_TURN_ON;
+			fusb_timer_start(&chip->timer_state_machine,
+					 chip->timer_state);
+		} else if (evt & EVENT_TIMER_STATE) {
+			set_state(chip, policy_snk_startup);
+		}
+		break;
+	default:
+		if (tcpm_check_vbus(chip)) {
+			chip->timer_state = T_DISABLED;
+			set_state(chip, policy_snk_startup);
+		} else if (evt & EVENT_TIMER_STATE) {
+			set_state(chip, policy_snk_startup);
+		}
+		break;
+	}
+}
+
+static void fusb_state_snk_ready(struct fusb30x_chip *chip, u32 evt)
+{
+	if (evt & EVENT_RX) {
+		if (PACKET_IS_DATA_MSG(chip->rec_head, DMT_VENDERDEFINED)) {
+			process_vdm_msg(chip);
+			chip->work_continue |= EVENT_WORK_CONTINUE;
+			chip->timer_state = T_DISABLED;
+		} else if (!VDM_IS_ACTIVE(chip)) {
+			fusb_state_swap_msg_process(chip, evt);
+		}
+	}
+
+	if (VDM_IS_ACTIVE(chip))
+		auto_vdm_machine(chip, evt);
+
+	fusb_state_swap_msg_process(chip, evt);
+	platform_fusb_notify(chip);
+}
+
+static void fusb_state_snk_send_hardreset(struct fusb30x_chip *chip, u32 evt)
+{
+	u32 tmp;
+
+	switch (chip->sub_state) {
+	case 0:
+		chip->tx_state = tx_idle;
+		chip->sub_state++;
+	default:
+		tmp = policy_send_hardrst(chip, evt);
+		if (tmp == tx_success) {
+			chip->hardrst_count++;
+			set_state(chip, policy_snk_transition_default);
+		} else if (tmp == tx_failed) {
+			set_state(chip, error_recovery);
+		}
+		break;
+	}
+}
+
+static void fusb_state_send_swap(struct fusb30x_chip *chip, u32 evt, int cmd)
+{
+	u32 tmp;
+
+	switch (chip->sub_state) {
+	case 0:
+		set_mesg(chip, cmd, CONTROLMESSAGE);
+		chip->sub_state = 1;
+		chip->tx_state = tx_idle;
+		/* fallthrough */
+	case 1:
+		tmp = policy_send_data(chip);
+
+		if (tmp == tx_success) {
+			chip->timer_state = T_SENDER_RESPONSE;
+			fusb_timer_start(&chip->timer_state_machine,
+					 chip->timer_state);
+			chip->sub_state++;
+		} else if (tmp == tx_failed) {
+			if (cmd == CMT_DR_SWAP) {
+				set_state(chip, error_recovery);
+				return;
+			}
+
+			if (chip->notify.power_role)
+				set_state(chip, policy_src_send_softrst);
+			else
+				set_state(chip, policy_snk_send_softrst);
+		}
+		break;
+	case 2:
+		if (evt & EVENT_RX) {
+			if (PACKET_IS_CONTROL_MSG(chip->rec_head,
+						  CMT_ACCEPT)) {
+				chip->timer_state = T_DISABLED;
+				if (cmd == CMT_VCONN_SWAP) {
+					set_state(chip, chip->vconn_enabled ?
+							policy_vcs_dfp_wait_for_ufp_vconn :
+							policy_vcs_dfp_turn_on_vconn);
+				} else if (cmd == CMT_PR_SWAP) {
+					if (chip->notify.power_role)
+						set_state(chip, policy_src_prs_transition_to_off);
+					else
+						set_state(chip, policy_snk_prs_transition_to_off);
+					chip->notify.power_role = POWER_ROLE_SOURCE;
+					tcpm_set_msg_header(chip);
+				} else if (cmd == CMT_DR_SWAP) {
+					set_state(chip, chip->notify.data_role ?
+							policy_drs_dfp_change :
+							policy_drs_ufp_change);
+				}
+			} else if (PACKET_IS_CONTROL_MSG(chip->rec_head,
+							 CMT_REJECT) ||
+				   PACKET_IS_CONTROL_MSG(chip->rec_head,
+							 CMT_WAIT)) {
+				chip->timer_state = T_DISABLED;
+				if (chip->notify.power_role)
+					set_state(chip, policy_src_ready);
+				else
+					set_state(chip, policy_snk_ready);
+			}
+		} else if (evt & EVENT_TIMER_STATE) {
+			if (chip->notify.power_role)
+				set_state(chip, policy_src_ready);
+			else
+				set_state(chip, policy_snk_ready);
+		}
+	}
+}
+
+static void fusb_state_snk_prs_transition_to_off(struct fusb30x_chip *chip,
+						 u32 evt)
+{
+	switch (chip->sub_state) {
+	case 0:
+		chip->timer_state = T_PD_SOURCE_OFF;
+		fusb_timer_start(&chip->timer_state_machine,
+				 chip->timer_state);
+		chip->sub_state++;
+		/* fallthrough */
+	case 1:
+		if (evt & EVENT_RX) {
+			if (PACKET_IS_CONTROL_MSG(chip->rec_head,
+						  CMT_PS_RDY)) {
+				if (chip->role == ROLE_MODE_DRP)
+					set_state(chip,
+						  policy_snk_prs_assert_rp);
+				else
+					set_state(chip,
+						  policy_snk_prs_source_on);
+			} else {
+				dev_dbg(chip->dev,
+					"rec careless msg: head %x\n",
+					chip->rec_head);
+			}
+		} else if (evt & EVENT_TIMER_STATE) {
+			chip->notify.power_role = POWER_ROLE_SINK;
+			tcpm_set_msg_header(chip);
+			set_state(chip, policy_snk_send_hardrst);
+		}
+		break;
+	}
+}
+
+static void fusb_state_snk_prs_assert_rp(struct fusb30x_chip *chip, u32 evt)
+{
+	tcpm_set_cc_pull_mode(chip, CC_PULL_UP);
+	set_state(chip, policy_snk_prs_source_on);
+}
+
+static void fusb_state_snk_prs_source_on(struct fusb30x_chip *chip, u32 evt)
+{
+	u32 tmp;
+
+	switch (chip->sub_state) {
+	case 0:
+		/* supply power in 50ms */
+		platform_set_vbus_lvl_enable(chip, 1, 0);
+		chip->sub_state++;
+		chip->work_continue |= EVENT_WORK_CONTINUE;
+		break;
+	case 1:
+		set_mesg(chip, CMT_PS_RDY, CONTROLMESSAGE);
+		chip->tx_state = tx_idle;
+		chip->sub_state++;
+		/* fallthrough */
+	case 2:
+		tmp = policy_send_data(chip);
+		if (tmp == tx_success) {
+			/* PD spe 6.5.10.2 */
+			chip->timer_state = T_PD_SWAP_SOURCE_START;
+			fusb_timer_start(&chip->timer_state_machine,
+					 chip->timer_state);
+			chip->sub_state++;
+		} else if (tmp == tx_failed) {
+			chip->notify.power_role = POWER_ROLE_SINK;
+			tcpm_set_msg_header(chip);
+			set_state(chip, policy_snk_send_hardrst);
+		}
+		break;
+	case 3:
+		if (evt & EVENT_TIMER_STATE) {
+			chip->cc_state &= ~CC_STATE_TOGSS_IS_UFP;
+			regmap_update_bits(chip->regmap, FUSB_REG_MASK,
+					   MASK_M_COMP_CHNG, 0);
+			set_state(chip, policy_src_send_caps);
+		}
+		break;
+	}
+}
+
+static void fusb_state_snk_softreset(struct fusb30x_chip *chip)
+{
+	u32 tmp;
+
+	switch (chip->sub_state) {
+	case 0:
+		set_mesg(chip, CMT_ACCEPT, CONTROLMESSAGE);
+		chip->tx_state = tx_idle;
+		chip->sub_state++;
+		/* without break */
+	default:
+		tmp = policy_send_data(chip);
+		if (tmp == tx_success) {
+			fusb_soft_reset_parameter(chip);
+			chip->timer_state = T_TYPEC_SINK_WAIT_CAP;
+			fusb_timer_start(&chip->timer_state_machine,
+					 chip->timer_state);
+			set_state(chip, policy_snk_wait_caps);
+		} else if (tmp == tx_failed) {
+			set_state(chip, policy_snk_send_hardrst);
+		}
+		break;
+	}
+}
+
+static void fusb_state_snk_send_softreset(struct fusb30x_chip *chip, u32 evt)
+{
+	u32 tmp;
+
+	switch (chip->sub_state) {
+	case 0:
+		set_mesg(chip, CMT_SOFTRESET, CONTROLMESSAGE);
+		chip->tx_state = tx_idle;
+		chip->sub_state++;
+	case 1:
+		tmp = policy_send_data(chip);
+		if (tmp == tx_success) {
+			chip->timer_state = T_SENDER_RESPONSE;
+			chip->sub_state++;
+			fusb_timer_start(&chip->timer_state_machine,
+					 chip->timer_state);
+		} else if (tmp == tx_failed) {
+			/* can't reach here */
+			set_state(chip, policy_snk_send_hardrst);
+		}
+
+		if (!(evt & FLAG_EVENT))
+			break;
+	default:
+		if (evt & EVENT_RX) {
+			if ((!PD_HEADER_CNT(chip->rec_head)) &&
+			    (PD_HEADER_TYPE(chip->rec_head) == CMT_ACCEPT)) {
+				fusb_soft_reset_parameter(chip);
+				chip->timer_state = T_TYPEC_SINK_WAIT_CAP;
+				fusb_timer_start(&chip->timer_state_machine,
+						 chip->timer_state);
+				set_state(chip, policy_snk_wait_caps);
+			}
+		} else if (evt & EVENT_TIMER_STATE) {
+			set_state(chip, policy_snk_send_hardrst);
+		}
+		break;
+	}
+}
+
+static void fusb_try_detach(struct fusb30x_chip *chip)
+{
+	int cc1, cc2;
+
+	if ((chip->cc_state & CC_STATE_TOGSS_IS_UFP) &&
+	    (chip->conn_state !=
+	     policy_snk_transition_default) &&
+	    (chip->conn_state !=
+	     policy_src_prs_source_off) &&
+	    (chip->conn_state != policy_snk_prs_send_swap) &&
+	    (chip->conn_state != policy_snk_prs_assert_rp) &&
+	    (chip->conn_state != policy_snk_prs_source_on) &&
+	    (chip->conn_state != policy_snk_prs_transition_to_off)) {
+		if (!tcpm_check_vbus(chip))
+			set_state_unattached(chip);
+	} else if ((chip->conn_state !=
+		    policy_src_transition_default) &&
+		   (chip->conn_state !=
+		    policy_src_prs_source_off) &&
+		   (chip->conn_state != policy_snk_prs_source_on)) {
+		tcpm_get_cc(chip, &cc1, &cc2);
+		if (chip->cc_state & CC_STATE_TOGSS_CC2)
+			cc1 = cc2;
+		if (cc1 == TYPEC_CC_VOLT_OPEN)
+			set_state_unattached(chip);
+	} else {
+		/*
+		 * Detached may occurred at swap operations. So, DON'T ignore
+		 * the EVENT_CC during swapping at all, check the connection
+		 * after it.
+		 */
+		chip->work_continue |= EVENT_DELAY_CC;
+	}
+}
+
+static void state_machine_typec(struct fusb30x_chip *chip)
+{
+	u32 evt = 0;
+
+	tcpc_alert(chip, &evt);
+	mux_alert(chip, &evt);
+	if (!evt)
+		goto BACK;
+
+	if (chip->notify.is_cc_connected)
+		if (evt & (EVENT_CC | EVENT_DELAY_CC))
+			fusb_try_detach(chip);
+
+	if (evt & EVENT_RX) {
+		tcpm_get_message(chip);
+		if (PACKET_IS_CONTROL_MSG(chip->rec_head, CMT_SOFTRESET)) {
+			if (chip->notify.power_role)
+				set_state(chip, policy_src_softrst);
+			else
+				set_state(chip, policy_snk_softrst);
+		}
+	}
+
+	if (evt & EVENT_TX) {
+		if (chip->tx_state == tx_success)
+			chip->msg_id++;
+	}
+	switch (chip->conn_state) {
+	case disabled:
+		fusb_state_disabled(chip, evt);
+		break;
+	case error_recovery:
+		set_state_unattached(chip);
+		break;
+	case unattached:
+		fusb_state_unattached(chip, evt);
+		break;
+	case attach_wait_sink:
+		fusb_state_attach_wait_sink(chip, evt);
+		break;
+	case attach_wait_source:
+		fusb_state_attach_wait_source(chip, evt);
+		break;
+	case attached_source:
+		fusb_state_attached_source(chip, evt);
+		break;
+	case attached_sink:
+		fusb_state_attached_sink(chip, evt);
+		break;
+	case attach_try_src:
+		fusb_state_try_attach(chip, evt, ROLE_MODE_DFP);
+		break;
+	case attach_try_snk:
+		fusb_state_try_attach(chip, evt, ROLE_MODE_UFP);
+		break;
+
+	/* POWER DELIVERY */
+	case policy_src_startup:
+		fusb_state_src_startup(chip, evt);
+		break;
+	case policy_src_discovery:
+		fusb_state_src_discovery(chip, evt);
+		break;
+	case policy_src_send_caps:
+		fusb_state_src_send_caps(chip, evt);
+		if (chip->conn_state != policy_src_negotiate_cap)
+			break;
+	case policy_src_negotiate_cap:
+		fusb_state_src_negotiate_cap(chip, evt);
+
+	case policy_src_transition_supply:
+		fusb_state_src_transition_supply(chip, evt);
+		break;
+	case policy_src_cap_response:
+		fusb_state_src_cap_response(chip, evt);
+		break;
+	case policy_src_transition_default:
+		fusb_state_src_transition_default(chip, evt);
+		break;
+	case policy_src_ready:
+		fusb_state_src_ready(chip, evt);
+		break;
+	case policy_src_get_sink_caps:
+		fusb_state_src_get_sink_cap(chip, evt);
+		break;
+	case policy_src_send_hardrst:
+		fusb_state_src_send_hardreset(chip, evt);
+		break;
+	case policy_src_send_softrst:
+		fusb_state_src_send_softreset(chip, evt);
+		break;
+	case policy_src_softrst:
+		fusb_state_src_softreset(chip);
+		break;
+
+	/* UFP */
+	case policy_snk_startup:
+		fusb_state_snk_startup(chip, evt);
+		break;
+	case policy_snk_discovery:
+		fusb_state_snk_discovery(chip, evt);
+		break;
+	case policy_snk_wait_caps:
+		fusb_state_snk_wait_caps(chip, evt);
+		break;
+	case policy_snk_evaluate_caps:
+		fusb_state_snk_evaluate_caps(chip, evt);
+		/* without break */
+	case policy_snk_select_cap:
+		fusb_state_snk_select_cap(chip, evt);
+		break;
+	case policy_snk_transition_sink:
+		fusb_state_snk_transition_sink(chip, evt);
+		break;
+	case policy_snk_transition_default:
+		fusb_state_snk_transition_default(chip, evt);
+		break;
+	case policy_snk_ready:
+		fusb_state_snk_ready(chip, evt);
+		break;
+	case policy_snk_send_hardrst:
+		fusb_state_snk_send_hardreset(chip, evt);
+		break;
+	case policy_snk_send_softrst:
+		fusb_state_snk_send_softreset(chip, evt);
+		break;
+	case policy_snk_softrst:
+		fusb_state_snk_softreset(chip);
+		break;
+
+	/*
+	 * PD Spec 1.0: PR SWAP: chap 8.3.3.6.3.1/2
+	 *		VC SWAP: chap 8.3.3.7.1/2
+	 */
+	case policy_src_prs_evaluate:
+	case policy_snk_prs_evaluate:
+		fusb_state_prs_evaluate(chip, evt);
+		break;
+	case policy_snk_prs_accept:
+	case policy_src_prs_accept:
+		fusb_state_prs_accept(chip, evt);
+		break;
+	case policy_snk_prs_reject:
+	case policy_src_prs_reject:
+	case policy_vcs_ufp_reject:
+	case policy_drs_dfp_reject:
+	case policy_drs_ufp_reject:
+		fusb_state_prs_reject(chip, evt);
+		break;
+	case policy_src_prs_transition_to_off:
+		fusb_state_src_prs_transition_to_off(chip, evt);
+		break;
+	case policy_src_prs_assert_rd:
+		fusb_state_src_prs_assert_rd(chip, evt);
+		break;
+	case policy_src_prs_source_off:
+		fusb_state_src_prs_source_off(chip, evt);
+		break;
+	case policy_snk_prs_send_swap:
+	case policy_src_prs_send_swap:
+		fusb_state_send_swap(chip, evt, CMT_PR_SWAP);
+		break;
+	case policy_snk_prs_transition_to_off:
+		fusb_state_snk_prs_transition_to_off(chip, evt);
+		break;
+	case policy_snk_prs_assert_rp:
+		fusb_state_snk_prs_assert_rp(chip, evt);
+		break;
+	case policy_snk_prs_source_on:
+		fusb_state_snk_prs_source_on(chip, evt);
+		break;
+	case policy_vcs_ufp_evaluate_swap:
+		fusb_state_vcs_ufp_evaluate_swap(chip, evt);
+		break;
+	case policy_vcs_ufp_accept:
+		fusb_state_vcs_ufp_accept(chip, evt);
+		break;
+	case policy_vcs_ufp_wait_for_dfp_vconn:
+	case policy_vcs_dfp_wait_for_ufp_vconn:
+		fusb_state_vcs_wait_for_vconn(chip, evt);
+		break;
+	case policy_vcs_ufp_turn_off_vconn:
+	case policy_vcs_dfp_turn_off_vconn:
+		fusb_state_vcs_set_vconn(chip, evt, false);
+		break;
+	case policy_vcs_ufp_turn_on_vconn:
+	case policy_vcs_dfp_turn_on_vconn:
+		fusb_state_vcs_set_vconn(chip, evt, true);
+		break;
+	case policy_vcs_ufp_send_ps_rdy:
+	case policy_vcs_dfp_send_ps_rdy:
+		fusb_state_vcs_send_ps_rdy(chip, evt);
+		break;
+	case policy_vcs_dfp_send_swap:
+		fusb_state_send_swap(chip, evt, CMT_VCONN_SWAP);
+		break;
+	case policy_drs_ufp_evaluate:
+	case policy_drs_dfp_evaluate:
+		fusb_state_drs_evaluate(chip, evt);
+		break;
+	case policy_drs_dfp_accept:
+	case policy_drs_ufp_accept:
+		fusb_state_drs_send_accept(chip, evt);
+		break;
+	case policy_drs_dfp_change:
+	case policy_drs_ufp_change:
+		fusb_state_drs_role_change(chip, evt);
+		break;
+	case policy_drs_ufp_send_swap:
+	case policy_drs_dfp_send_swap:
+		fusb_state_send_swap(chip, evt, CMT_DR_SWAP);
+		break;
+
+	default:
+		break;
+	}
+
+BACK:
+	if (chip->work_continue) {
+		queue_work(chip->fusb30x_wq, &chip->work);
+		return;
+	}
+
+	if (!platform_get_device_irq_state(chip))
+		fusb_irq_enable(chip);
+	else
+		queue_work(chip->fusb30x_wq, &chip->work);
+}
+
+static irqreturn_t cc_interrupt_handler(int irq, void *dev_id)
+{
+	struct fusb30x_chip *chip = dev_id;
+
+	queue_work(chip->fusb30x_wq, &chip->work);
+	fusb_irq_disable(chip);
+	return IRQ_HANDLED;
+}
+
+static int fusb_initialize_gpio(struct fusb30x_chip *chip)
+{
+	chip->gpio_int = devm_gpiod_get_optional(chip->dev, "int-n", GPIOD_IN);
+	if (IS_ERR(chip->gpio_int))
+		return PTR_ERR(chip->gpio_int);
+
+	/* some board support vbus with other ways */
+	chip->gpio_vbus_5v = devm_gpiod_get_optional(chip->dev, "vbus-5v",
+						     GPIOD_OUT_LOW);
+	if (IS_ERR(chip->gpio_vbus_5v))
+		dev_warn(chip->dev,
+			 "Could not get named GPIO for VBus5V!\n");
+	else
+		gpiod_set_raw_value(chip->gpio_vbus_5v, 0);
+
+	chip->gpio_vbus_other = devm_gpiod_get_optional(chip->dev,
+							"vbus-other",
+							GPIOD_OUT_LOW);
+	if (IS_ERR(chip->gpio_vbus_other))
+		dev_warn(chip->dev,
+			 "Could not get named GPIO for VBusOther!\n");
+	else
+		gpiod_set_raw_value(chip->gpio_vbus_other, 0);
+
+	chip->gpio_discharge = devm_gpiod_get_optional(chip->dev, "discharge",
+						       GPIOD_OUT_LOW);
+	if (IS_ERR(chip->gpio_discharge)) {
+		dev_warn(chip->dev,
+			 "Could not get named GPIO for discharge!\n");
+		chip->gpio_discharge = NULL;
+	}
+
+	return 0;
+}
+
+static enum hrtimer_restart fusb_timer_handler(struct hrtimer *timer)
+{
+	int i;
+
+	for (i = 0; i < fusb30x_port_used; i++) {
+		if (timer == &fusb30x_port_info[i]->timer_state_machine) {
+			if (fusb30x_port_info[i]->timer_state != T_DISABLED)
+				fusb30x_port_info[i]->timer_state = 0;
+			break;
+		}
+
+		if (timer == &fusb30x_port_info[i]->timer_mux_machine) {
+			if (fusb30x_port_info[i]->timer_mux != T_DISABLED)
+				fusb30x_port_info[i]->timer_mux = 0;
+			break;
+		}
+	}
+
+	if (i != fusb30x_port_used)
+		queue_work(fusb30x_port_info[i]->fusb30x_wq,
+			   &fusb30x_port_info[i]->work);
+
+	return HRTIMER_NORESTART;
+}
+
+static void fusb_initialize_timer(struct fusb30x_chip *chip)
+{
+	hrtimer_init(&chip->timer_state_machine, CLOCK_MONOTONIC,
+		     HRTIMER_MODE_REL);
+	chip->timer_state_machine.function = fusb_timer_handler;
+
+	hrtimer_init(&chip->timer_mux_machine, CLOCK_MONOTONIC,
+		     HRTIMER_MODE_REL);
+	chip->timer_mux_machine.function = fusb_timer_handler;
+
+	chip->timer_state = T_DISABLED;
+	chip->timer_mux = T_DISABLED;
+}
+
+static void fusb302_work_func(struct work_struct *work)
+{
+	struct fusb30x_chip *chip;
+
+	chip = container_of(work, struct fusb30x_chip, work);
+	state_machine_typec(chip);
+}
+
+static int fusb30x_probe(struct i2c_client *client,
+			 const struct i2c_device_id *id)
+{
+	struct fusb30x_chip *chip;
+	struct PD_CAP_INFO *pd_cap_info;
+	int ret;
+	char *string[2];
+
+	chip = devm_kzalloc(&client->dev, sizeof(*chip), GFP_KERNEL);
+	if (!chip)
+		return -ENOMEM;
+
+	if (fusb30x_port_used == 0xff)
+		return -1;
+
+	chip->port_num = fusb30x_port_used++;
+	fusb30x_port_info[chip->port_num] = chip;
+
+	chip->dev = &client->dev;
+	chip->regmap = devm_regmap_init_i2c(client, &fusb302_regmap_config);
+	if (IS_ERR(chip->regmap)) {
+		dev_err(&client->dev, "Failed to allocate regmap!\n");
+		return PTR_ERR(chip->regmap);
+	}
+
+	ret = fusb_initialize_gpio(chip);
+	if (ret)
+		return ret;
+
+	fusb_initialize_timer(chip);
+
+	chip->fusb30x_wq = create_workqueue("fusb302_wq");
+	INIT_WORK(&chip->work, fusb302_work_func);
+
+	chip->role = ROLE_MODE_NONE;
+	chip->try_role = ROLE_MODE_NONE;
+	if (!of_property_read_string(chip->dev->of_node, "fusb302,role",
+				     (const char **)&string[0])) {
+		if (!strcmp(string[0], "ROLE_MODE_DRP"))
+			chip->role = ROLE_MODE_DRP;
+		else if (!strcmp(string[0], "ROLE_MODE_DFP"))
+			chip->role = ROLE_MODE_DFP;
+		else if (!strcmp(string[0], "ROLE_MODE_UFP"))
+			chip->role = ROLE_MODE_UFP;
+	}
+
+	if (chip->role == ROLE_MODE_NONE) {
+		dev_warn(chip->dev,
+			 "Can't get property of role, set role to default DRP\n");
+		chip->role = ROLE_MODE_DRP;
+		string[0] = "ROLE_MODE_DRP";
+	}
+
+	if (!of_property_read_string(chip->dev->of_node, "fusb302,try_role",
+				     (const char **)&string[1])) {
+		if (!strcmp(string[1], "ROLE_MODE_DFP"))
+			chip->try_role = ROLE_MODE_DFP;
+		else if (!strcmp(string[1], "ROLE_MODE_UFP"))
+			chip->try_role = ROLE_MODE_UFP;
+	}
+
+	if (chip->try_role == ROLE_MODE_NONE)
+		string[1] = "ROLE_MODE_NONE";
+
+	chip->vconn_supported = true;
+	tcpm_init(chip);
+	tcpm_set_rx_enable(chip, 0);
+	chip->conn_state = unattached;
+	tcpm_set_cc(chip, chip->role);
+
+	chip->n_caps_used = 1;
+	chip->source_power_supply[0] = 0x64;
+	chip->source_max_current[0] = 0x96;
+
+	pd_cap_info = &chip->pd_cap_info;
+	pd_cap_info->dual_role_power = 1;
+	pd_cap_info->data_role_swap = 1;
+
+	pd_cap_info->externally_powered = 1;
+	pd_cap_info->usb_suspend_support = 0;
+	pd_cap_info->usb_communications_cap = 0;
+	pd_cap_info->supply_type = 0;
+	pd_cap_info->peak_current = 0;
+
+	chip->extcon = devm_extcon_dev_allocate(&client->dev, fusb302_cable);
+	if (IS_ERR(chip->extcon)) {
+		dev_err(&client->dev, "allocat extcon failed\n");
+		return PTR_ERR(chip->extcon);
+	}
+
+	ret = devm_extcon_dev_register(&client->dev, chip->extcon);
+	if (ret) {
+		dev_err(&client->dev, "failed to register extcon: %d\n",
+			ret);
+		return ret;
+	}
+
+	ret = extcon_set_property_capability(chip->extcon, EXTCON_USB,
+					     EXTCON_PROP_USB_TYPEC_POLARITY);
+	if (ret) {
+		dev_err(&client->dev,
+			"failed to set USB property capability: %d\n",
+			ret);
+		return ret;
+	}
+
+	ret = extcon_set_property_capability(chip->extcon, EXTCON_USB_HOST,
+					     EXTCON_PROP_USB_TYPEC_POLARITY);
+	if (ret) {
+		dev_err(&client->dev,
+			"failed to set USB_HOST property capability: %d\n",
+			ret);
+		return ret;
+	}
+
+	ret = extcon_set_property_capability(chip->extcon, EXTCON_DISP_DP,
+					     EXTCON_PROP_USB_TYPEC_POLARITY);
+	if (ret) {
+		dev_err(&client->dev,
+			"failed to set DISP_DP property capability: %d\n",
+			ret);
+		return ret;
+	}
+
+	ret = extcon_set_property_capability(chip->extcon, EXTCON_USB,
+					     EXTCON_PROP_USB_SS);
+	if (ret) {
+		dev_err(&client->dev,
+			"failed to set USB USB_SS property capability: %d\n",
+			ret);
+		return ret;
+	}
+
+	ret = extcon_set_property_capability(chip->extcon, EXTCON_USB_HOST,
+					     EXTCON_PROP_USB_SS);
+	if (ret) {
+		dev_err(&client->dev,
+			"failed to set USB_HOST USB_SS property capability: %d\n",
+			ret);
+		return ret;
+	}
+
+	ret = extcon_set_property_capability(chip->extcon, EXTCON_DISP_DP,
+					     EXTCON_PROP_USB_SS);
+	if (ret) {
+		dev_err(&client->dev,
+			"failed to set DISP_DP USB_SS property capability: %d\n",
+			ret);
+		return ret;
+	}
+
+	ret = extcon_set_property_capability(chip->extcon, EXTCON_CHG_USB_FAST,
+					     EXTCON_PROP_USB_TYPEC_POLARITY);
+	if (ret) {
+		dev_err(&client->dev,
+			"failed to set USB_PD property capability: %d\n", ret);
+		return ret;
+	}
+
+	i2c_set_clientdata(client, chip);
+
+	spin_lock_init(&chip->irq_lock);
+	chip->enable_irq = 1;
+
+	chip->gpio_int_irq = gpiod_to_irq(chip->gpio_int);
+	if (chip->gpio_int_irq < 0) {
+		dev_err(&client->dev,
+			"Unable to request IRQ for INT_N GPIO! %d\n",
+			ret);
+		ret = chip->gpio_int_irq;
+		goto IRQ_ERR;
+	}
+
+	ret = devm_request_threaded_irq(&client->dev,
+					chip->gpio_int_irq,
+					NULL,
+					cc_interrupt_handler,
+					IRQF_ONESHOT | IRQF_TRIGGER_LOW,
+					client->name,
+					chip);
+	if (ret) {
+		dev_err(&client->dev, "irq request failed\n");
+		goto IRQ_ERR;
+	}
+
+	dev_info(chip->dev,
+		 "port %d probe success with role %s, try_role %s\n",
+		 chip->port_num, string[0], string[1]);
+
+	return 0;
+
+IRQ_ERR:
+	destroy_workqueue(chip->fusb30x_wq);
+	return ret;
+}
+
+static int fusb30x_remove(struct i2c_client *client)
+{
+	struct fusb30x_chip *chip = i2c_get_clientdata(client);
+
+	destroy_workqueue(chip->fusb30x_wq);
+	return 0;
+}
+
+static void fusb30x_shutdown(struct i2c_client *client)
+{
+	struct fusb30x_chip *chip = i2c_get_clientdata(client);
+
+	if (chip->gpio_vbus_5v)
+		gpiod_set_value(chip->gpio_vbus_5v, 0);
+	if (chip->gpio_discharge) {
+		gpiod_set_value(chip->gpio_discharge, 1);
+		msleep(100);
+		gpiod_set_value(chip->gpio_discharge, 0);
+	}
+}
+
+static const struct of_device_id fusb30x_dt_match[] = {
+	{ .compatible = FUSB30X_I2C_DEVICETREE_NAME },
+	{},
+};
+MODULE_DEVICE_TABLE(of, fusb30x_dt_match);
+
+static const struct i2c_device_id fusb30x_i2c_device_id[] = {
+	{ FUSB30X_I2C_DRIVER_NAME, 0 },
+	{}
+};
+MODULE_DEVICE_TABLE(i2c, fusb30x_i2c_device_id);
+
+static struct i2c_driver fusb30x_driver = {
+	.driver = {
+		.name = FUSB30X_I2C_DRIVER_NAME,
+		.of_match_table = of_match_ptr(fusb30x_dt_match),
+	},
+	.probe = fusb30x_probe,
+	.remove = fusb30x_remove,
+	.shutdown = fusb30x_shutdown,
+	.id_table = fusb30x_i2c_device_id,
+};
+
+module_i2c_driver(fusb30x_driver);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("zain wang <zain.wang@rock-chips.com>");
+MODULE_DESCRIPTION("fusb302 typec pd driver");
--- /dev/null	2023-04-29 08:31:15.023562380 -0400
+++ b/drivers/staging/fusb30x/fusb30x.h	2023-05-06 08:46:30.703660291 -0400
@@ -0,0 +1,552 @@
+/*
+ * Copyright (c) 2016, Fuzhou Rockchip Electronics Co., Ltd
+ * Author: Zain Wang <zain.wang@rock-chips.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * Some ideas are from chrome ec and fairchild GPL fusb302 driver.
+ */
+
+#ifndef FUSB302_H
+#define FUSB302_H
+
+#include <linux/i2c.h>
+#include <linux/hrtimer.h>
+
+const char *FUSB_DT_INTERRUPT_INTN =	"fsc_interrupt_int_n";
+#define FUSB_DT_GPIO_INTN		"fairchild,int_n"
+#define FUSB_DT_GPIO_VBUS_5V		"fairchild,vbus5v"
+#define FUSB_DT_GPIO_VBUS_OTHER		"fairchild,vbusOther"
+
+#define FUSB30X_I2C_DRIVER_NAME		"fusb302"
+#define FUSB30X_I2C_DEVICETREE_NAME	"fairchild,fusb302"
+
+/* FUSB300 Register Addresses */
+#define FUSB_REG_DEVICEID		0x01
+#define FUSB_REG_SWITCHES0		0x02
+#define FUSB_REG_SWITCHES1		0x03
+#define FUSB_REG_MEASURE		0x04
+#define FUSB_REG_SLICE			0x05
+#define FUSB_REG_CONTROL0		0x06
+#define FUSB_REG_CONTROL1		0x07
+#define FUSB_REG_CONTROL2		0x08
+#define FUSB_REG_CONTROL3		0x09
+#define FUSB_REG_MASK			0x0A
+#define FUSB_REG_POWER			0x0B
+#define FUSB_REG_RESET			0x0C
+#define FUSB_REG_OCPREG			0x0D
+#define FUSB_REG_MASKA			0x0E
+#define FUSB_REG_MASKB			0x0F
+#define FUSB_REG_CONTROL4		0x10
+#define FUSB_REG_STATUS0A		0x3C
+#define FUSB_REG_STATUS1A		0x3D
+#define FUSB_REG_INTERRUPTA		0x3E
+#define FUSB_REG_INTERRUPTB		0x3F
+#define FUSB_REG_STATUS0		0x40
+#define FUSB_REG_STATUS1		0x41
+#define FUSB_REG_INTERRUPT		0x42
+#define FUSB_REG_FIFO			0x43
+
+enum connection_state {
+	disabled = 0,
+	error_recovery,
+	unattached,
+	attach_wait_sink,
+	attach_wait_source,
+	attached_source,
+	attached_sink,
+
+	policy_src_startup,
+	policy_src_send_caps,
+	policy_src_discovery,
+	policy_src_negotiate_cap,
+	policy_src_cap_response,
+	policy_src_transition_supply,
+	policy_src_transition_default,
+
+	policy_src_ready,
+	policy_src_get_sink_caps,
+
+	policy_src_send_softrst,
+	policy_src_softrst,
+	policy_src_send_hardrst,
+
+	policy_snk_startup,
+	policy_snk_discovery,
+	policy_snk_wait_caps,
+	policy_snk_evaluate_caps,
+	policy_snk_select_cap,
+	policy_snk_transition_sink,
+	policy_snk_ready,
+
+	policy_snk_send_softrst,
+	policy_snk_softrst,
+	policy_snk_send_hardrst,
+
+	policy_snk_transition_default,
+
+	/* PR SWAP */
+	policy_src_prs_evaluate,
+	policy_src_prs_accept,
+	policy_src_prs_transition_to_off,
+	policy_src_prs_source_off,
+	policy_src_prs_assert_rd,
+	policy_src_prs_reject,
+	policy_src_prs_send_swap,
+
+	policy_snk_prs_evaluate,
+	policy_snk_prs_accept,
+	policy_snk_prs_transition_to_off,
+	policy_snk_prs_source_on,
+	policy_snk_prs_assert_rp,
+	policy_snk_prs_reject,
+	policy_snk_prs_send_swap,
+
+	/* VC SWAP */
+	policy_vcs_dfp_send_swap,
+	policy_vcs_dfp_wait_for_ufp_vconn,
+	policy_vcs_dfp_turn_off_vconn,
+	policy_vcs_dfp_turn_on_vconn,
+	policy_vcs_dfp_send_ps_rdy,
+
+	policy_vcs_ufp_evaluate_swap,
+	policy_vcs_ufp_reject,
+	policy_vcs_ufp_accept,
+	policy_vcs_ufp_wait_for_dfp_vconn,
+	policy_vcs_ufp_turn_off_vconn,
+	policy_vcs_ufp_turn_on_vconn,
+	policy_vcs_ufp_send_ps_rdy,
+
+	policy_drs_ufp_evaluate,
+	policy_drs_ufp_accept,
+	policy_drs_ufp_reject,
+	policy_drs_ufp_change,
+	policy_drs_ufp_send_swap,
+
+	policy_drs_dfp_evaluate,
+	policy_drs_dfp_accept,
+	policy_drs_dfp_reject,
+	policy_drs_dfp_change,
+	policy_drs_dfp_send_swap,
+
+	attach_try_src,
+	attach_try_snk,
+};
+
+enum vdm_state {
+	VDM_STATE_DISCOVERY_ID,
+	VDM_STATE_DISCOVERY_SVID,
+	VDM_STATE_DISCOVERY_MODES,
+	VDM_STATE_ENTER_MODE,
+	VDM_STATE_UPDATE_STATUS,
+	VDM_STATE_DP_CONFIG,
+	VDM_STATE_NOTIFY,
+	VDM_STATE_READY,
+	VDM_STATE_ERR,
+};
+
+enum tcpm_rp_value {
+	TYPEC_RP_USB = 0,
+	TYPEC_RP_1A5 = 1,
+	TYPEC_RP_3A0 = 2,
+	TYPEC_RP_RESERVED = 3,
+};
+
+enum role_mode {
+	ROLE_MODE_NONE,
+	ROLE_MODE_DRP,
+	ROLE_MODE_UFP,
+	ROLE_MODE_DFP,
+	ROLE_MODE_ASS,
+};
+
+#define SBF(s, v)		((s) << (v))
+#define SWITCHES0_PDWN1		SBF(1, 0)
+#define SWITCHES0_PDWN2		SBF(1, 1)
+#define SWITCHES0_MEAS_CC1	SBF(1, 2)
+#define SWITCHES0_MEAS_CC2	SBF(1, 3)
+#define SWITCHES0_VCONN_CC1	SBF(1, 4)
+#define SWITCHES0_VCONN_CC2	SBF(1, 5)
+#define SWITCHES0_PU_EN1	SBF(1, 6)
+#define SWITCHES0_PU_EN2	SBF(1, 7)
+
+#define SWITCHES1_TXCC1		SBF(1, 0)
+#define SWITCHES1_TXCC2		SBF(1, 1)
+#define SWITCHES1_AUTO_CRC	SBF(1, 2)
+#define SWITCHES1_DATAROLE	SBF(1, 4)
+#define SWITCHES1_SPECREV	SBF(3, 5)
+#define SWITCHES1_POWERROLE	SBF(1, 7)
+
+#define MEASURE_MDAC		SBF(0x3f, 0)
+#define MEASURE_VBUS		SBF(1, 6)
+
+#define SLICE_SDAC		SBF(0x3f, 0)
+#define SLICE_SDAC_HYS		SBF(3, 6)
+
+#define CONTROL0_TX_START	SBF(1, 0)
+#define CONTROL0_AUTO_PRE	SBF(1, 1)
+#define CONTROL0_HOST_CUR	SBF(3, 2)
+#define CONTROL0_HOST_CUR_USB		SBF(1, 2)
+#define CONTROL0_HOST_CUR_1A5		SBF(2, 2)
+#define CONTROL0_HOST_CUR_3A0		SBF(3, 2)
+#define CONTROL0_INT_MASK	SBF(1, 5)
+#define CONTROL0_TX_FLUSH	SBF(1, 6)
+
+#define CONTROL1_ENSOP1		SBF(1, 0)
+#define CONTROL1_ENSOP2		SBF(1, 1)
+#define CONTROL1_RX_FLUSH	SBF(1, 2)
+#define CONTROL1_BIST_MODE2	SBF(1, 4)
+#define CONTROL1_ENSOP1DB	SBF(1, 5)
+#define CONTROL1_ENSOP2DB	SBF(1, 6)
+
+#define CONTROL2_TOGGLE		SBF(1, 0)
+#define CONTROL2_MODE		SBF(3, 1)
+#define CONTROL2_MODE_NONE	0
+#define CONTROL2_MODE_DFP	SBF(3, 1)
+#define CONTROL2_MODE_UFP	SBF(2, 1)
+#define CONTROL2_MODE_DRP	SBF(1, 1)
+#define CONTROL2_WAKE_EN	SBF(1, 3)
+#define CONTROL2_TOG_RD_ONLY	SBF(1, 5)
+#define CONTROL2_TOG_SAVE_PWR1	SBF(1, 6)
+#define CONTROL2_TOG_SAVE_PWR2	SBF(1, 7)
+
+#define CONTROL3_AUTO_RETRY	SBF(1, 0)
+#define CONTROL3_N_RETRIES	SBF(3, 1)
+#define CONTROL3_AUTO_SOFTRESET	SBF(1, 3)
+#define CONTROL3_AUTO_HARDRESET	SBF(1, 4)
+#define CONTROL3_SEND_HARDRESET	SBF(1, 6)
+
+#define MASK_M_BC_LVL		SBF(1, 0)
+#define MASK_M_COLLISION	SBF(1, 1)
+#define MASK_M_WAKE		SBF(1, 2)
+#define MASK_M_ALERT		SBF(1, 3)
+#define MASK_M_CRC_CHK		SBF(1, 4)
+#define MASK_M_COMP_CHNG	SBF(1, 5)
+#define MASK_M_ACTIVITY		SBF(1, 6)
+#define MASK_M_VBUSOK		SBF(1, 7)
+
+#define POWER_PWR		SBF(0xf, 0)
+
+#define RESET_SW_RESET		SBF(1, 0)
+#define RESET_PD_RESET		SBF(1, 1)
+
+#define MASKA_M_HARDRST		SBF(1, 0)
+#define MASKA_M_SOFTRST		SBF(1, 1)
+#define MASKA_M_TXSENT		SBF(1, 2)
+#define MASKA_M_HARDSENT	SBF(1, 3)
+#define MASKA_M_RETRYFAIL	SBF(1, 4)
+#define MASKA_M_SOFTFAIL	SBF(1, 5)
+#define MASKA_M_TOGDONE		SBF(1, 6)
+#define MASKA_M_OCP_TEMP	SBF(1, 7)
+
+#define MASKB_M_GCRCSEND	SBF(1, 0)
+
+#define CONTROL4_TOG_USRC_EXIT	SBF(1, 0)
+
+#define MDAC_1P6V		0x26
+
+#define STATUS0A_HARDRST	SBF(1, 0)
+#define STATUS0A_SOFTRST	SBF(1, 1)
+#define STATUS0A_POWER23	SBF(3, 2)
+#define STATUS0A_RETRYFAIL	SBF(1, 4)
+#define STATUS0A_SOFTFAIL	SBF(1, 5)
+#define STATUS0A_TOGDONE	SBF(1, 6)
+#define STATUS0A_M_OCP_TEMP	SBF(1, 7)
+
+#define STATUS1A_RXSOP		SBF(1, 0)
+#define STATUS1A_RXSOP1DB	SBF(1, 1)
+#define STATUS1A_RXSOP2DB	SBF(1, 2)
+#define STATUS1A_TOGSS		SBF(7, 3)
+#define CC_STATE_TOGSS_CC1	SBF(1, 0)
+#define CC_STATE_TOGSS_CC2	SBF(1, 1)
+#define CC_STATE_TOGSS_IS_UFP	SBF(1, 2)
+
+#define INTERRUPTA_HARDRST	SBF(1, 0)
+#define INTERRUPTA_SOFTRST	SBF(1, 1)
+#define INTERRUPTA_TXSENT	SBF(1, 2)
+#define INTERRUPTA_HARDSENT	SBF(1, 3)
+#define INTERRUPTA_RETRYFAIL	SBF(1, 4)
+#define INTERRUPTA_SOFTFAIL	SBF(1, 5)
+#define INTERRUPTA_TOGDONE	SBF(1, 6)
+#define INTERRUPTA_OCP_TEMP	SBF(1, 7)
+
+#define INTERRUPTB_GCRCSENT	SBF(1, 0)
+
+#define STATUS0_BC_LVL		SBF(3, 0)
+#define STATUS0_WAKE		SBF(1, 2)
+#define STATUS0_ALERT		SBF(1, 3)
+#define STATUS0_CRC_CHK		SBF(1, 4)
+#define STATUS0_COMP		SBF(1, 5)
+#define STATUS0_ACTIVITY	SBF(1, 6)
+#define STATUS0_VBUSOK		SBF(1, 7)
+
+#define STATUS1_OCP		SBF(1, 0)
+#define STATUS1_OVRTEMP		SBF(1, 1)
+#define STATUS1_TX_FULL		SBF(1, 2)
+#define STATUS1_TX_EMPTY	SBF(1, 3)
+#define STATUS1_RX_FULL		SBF(1, 4)
+#define STATUS1_RX_EMPTY	SBF(1, 5)
+#define STATUS1_RXSOP1		SBF(1, 6)
+#define STATUS1_RXSOP2		SBF(1, 7)
+
+#define INTERRUPT_BC_LVL	SBF(1, 0)
+#define INTERRUPT_COLLISION	SBF(1, 1)
+#define INTERRUPT_WAKE		SBF(1, 2)
+#define INTERRUPT_ALERT		SBF(1, 3)
+#define INTERRUPT_CRC_CHK	SBF(1, 4)
+#define INTERRUPT_COMP_CHNG	SBF(1, 5)
+#define INTERRUPT_ACTIVITY	SBF(1, 6)
+#define INTERRUPT_VBUSOK	SBF(1, 7)
+
+#define FUSB_TKN_TXON		0xa1
+#define FUSB_TKN_SYNC1		0x12
+#define FUSB_TKN_SYNC2		0x13
+#define FUSB_TKN_SYNC3		0x1b
+#define FUSB_TKN_RST1		0x15
+#define FUSB_TKN_RST2		0x16
+#define FUSB_TKN_PACKSYM	0x80
+#define FUSB_TKN_JAMCRC		0xff
+#define FUSB_TKN_EOP		0x14
+#define FUSB_TKN_TXOFF		0xfe
+
+/* USB PD Control Message Types */
+#define CONTROLMESSAGE		0
+#define CMT_GOODCRC		1
+#define CMT_GOTOMIN		2
+#define CMT_ACCEPT		3
+#define CMT_REJECT		4
+#define CMT_PING		5
+#define CMT_PS_RDY		6
+#define CMT_GETSOURCECAP	7
+#define CMT_GETSINKCAP		8
+#define CMT_DR_SWAP		9
+#define CMT_PR_SWAP		10
+#define CMT_VCONN_SWAP		11
+#define CMT_WAIT		12
+#define CMT_SOFTRESET		13
+
+/* USB PD Data Message Types */
+#define DATAMESSAGE		1
+#define DMT_SOURCECAPABILITIES	1
+#define DMT_REQUEST		2
+#define DMT_BIST		3
+#define DMT_SINKCAPABILITIES	4
+#define DMT_VENDERDEFINED	15
+
+/* VDM Command Types */
+#define VDM_DISCOVERY_ID	0X01
+#define VDM_DISCOVERY_SVIDS	0X02
+#define VDM_DISCOVERY_MODES	0X03
+#define VDM_ENTER_MODE		0X04
+#define VDM_EXIT_MODE		0X05
+#define VDM_ATTENTION		0X06
+#define VDM_DP_STATUS_UPDATE	0X10
+#define VDM_DP_CONFIG		0X11
+
+#define VDM_TYPE_INIT		0
+#define VDM_TYPE_ACK		1
+#define VDM_TYPE_NACK		2
+#define VDM_TYPE_BUSY		3
+
+/* 200ms at least, 1 cycle about 6ms */
+#define N_DEBOUNCE_CNT		33
+#define N_CAPS_COUNT		50
+#define N_HARDRESET_COUNT	0
+
+#define T_NO_RESPONSE		5000
+#define T_SRC_RECOVER		830
+#define T_TYPEC_SEND_SOURCECAP	100
+#define T_SENDER_RESPONSE	30
+#define T_SRC_TRANSITION	30
+#define T_TYPEC_SINK_WAIT_CAP	500
+#define T_PS_TRANSITION		500
+#define T_BMC_TIMEOUT		5
+#define T_PS_HARD_RESET_MAX	35
+#define T_SAFE_0V		650
+#define T_SRC_TURN_ON		275
+#define T_SRC_RECOVER_MAX	1000
+#define T_PD_SOURCE_OFF		920
+#define T_PD_SOURCE_ON		480
+#define T_PD_SWAP_SOURCE_START	20
+#define T_PD_VCONN_SRC_ON	100
+#define T_PD_TRY_DRP		75
+
+#define T_NO_TRIGGER		500
+#define T_DISABLED		0xffff
+
+#define PD_HEADER_CNT(header)		(((header) >> 12) & 7)
+#define PD_HEADER_TYPE(header)		((header) & 0xF)
+#define PD_HEADER_ID(header)		(((header) >> 9) & 7)
+
+#define VDM_HEADER_TYPE(header)		(((header) >> 6) & 3)
+#define VDMHEAD_CMD_TYPE_MASK		(3 << 6)
+#define VDMHEAD_CMD_MASK		(0x1f << 0)
+#define VDMHEAD_STRUCT_TYPE_MASK	BIT(15)
+
+#define GET_VDMHEAD_CMD_TYPE(head)	((head & VDMHEAD_CMD_TYPE_MASK) >> 6)
+#define GET_VDMHEAD_CMD(head)		(head & VDMHEAD_CMD_MASK)
+#define GET_VDMHEAD_STRUCT_TYPE(head)	((head & VDMHEAD_STRUCT_TYPE_MASK) >> 15)
+
+#define DP_STATUS_MASK			0x000000ff
+#define DP_STATUS_HPD_STATE		BIT(7)
+
+#define GET_DP_STATUS(status)		(status & DP_STATUS_MASK)
+#define GET_DP_STATUS_HPD(status)	((status & DP_STATUS_HPD_STATE) >> 7)
+
+#define VDM_IDHEAD_USBVID_MASK		(0xffff << 0)
+#define VDM_IDHEAD_MODALSUPPORT_MASK	BIT(26)
+#define VDM_IDHEAD_PRODUCTTYPE		(7 << 27)
+#define VDM_IDHEAD_USBDEVICE		BIT(30)
+#define VDM_IDHEAD_USBHOST		BIT(30)
+
+#define CAP_POWER_TYPE(PDO)		((PDO >> 30) & 3)
+#define CAP_FPDO_VOLTAGE(PDO)		((PDO >> 10) & 0x3ff)
+#define CAP_VPDO_VOLTAGE(PDO)		((PDO >> 20) & 0x3ff)
+#define CAP_FPDO_CURRENT(PDO)		((PDO >> 0) & 0x3ff)
+#define CAP_VPDO_CURRENT(PDO)		((PDO >> 0) & 0x3ff)
+
+enum CC_ORIENTATION {
+	NONE,
+	CC1,
+	CC2,
+};
+
+enum typec_cc_polarity {
+	TYPEC_POLARITY_CC1,
+	TYPEC_POLARITY_CC2,
+};
+
+enum CC_MODE {
+	CC_PULL_UP,
+	CC_PULL_DOWN,
+	CC_PULL_NONE,
+};
+
+enum typec_power_role {
+	POWER_ROLE_SINK = 0,
+	POWER_ROLE_SOURCE,
+};
+
+enum typec_data_role {
+	DATA_ROLE_UFP = 0,
+	DATA_ROLE_DFP,
+};
+
+struct notify_info {
+	enum CC_ORIENTATION orientation;
+	/* 0 UFP : 1 DFP */
+	enum typec_power_role power_role;
+	enum typec_data_role data_role;
+
+	bool is_cc_connected;
+	bool is_pd_connected;
+
+	bool is_enter_mode;
+	int pin_assignment_support;
+	int pin_assignment_def;
+	bool attention;
+	u32 dp_status;
+	u32 dp_caps;
+};
+
+enum tx_state {
+	tx_idle,
+	tx_busy,
+	tx_failed,
+	tx_success
+};
+
+struct PD_CAP_INFO {
+	u32 peak_current;
+	u32 specification_revision;
+	u32 externally_powered;
+	u32 usb_suspend_support;
+	u32 usb_communications_cap;
+	u32 dual_role_power;
+	u32 data_role_swap;
+	u32 supply_type;
+};
+
+struct fusb30x_chip {
+	struct i2c_client *client;
+	struct device *dev;
+	struct regmap *regmap;
+	struct work_struct work;
+	struct workqueue_struct *fusb30x_wq;
+	struct hrtimer timer_state_machine;
+	struct hrtimer timer_mux_machine;
+	struct PD_CAP_INFO pd_cap_info;
+	struct notify_info notify;
+	struct notify_info notify_cmp;
+	struct extcon_dev *extcon;
+	enum connection_state conn_state;
+	struct gpio_desc *gpio_vbus_5v;
+	struct gpio_desc *gpio_vbus_other;
+	struct gpio_desc *gpio_int;
+	struct gpio_desc *gpio_discharge;
+	int timer_state;
+	int timer_mux;
+	int port_num;
+	u32 work_continue;
+	spinlock_t irq_lock;
+	int gpio_int_irq;
+	int enable_irq;
+
+	/*
+	 * ---------------------------------
+	 * | role 0x03 << 2, | cc_use 0x03 |
+	 * | src  1 << 2,    | cc1 1       |
+	 * | snk  2 << 2,    | cc2 2       |
+	 * ---------------------------------
+	 */
+	u8 cc_state;
+	int cc1;
+	int cc2;
+	enum typec_cc_polarity cc_polarity;
+	u8 val_tmp;
+	u8 debounce_cnt;
+	int sub_state;
+	int caps_counter;
+	u32 send_load[7];
+	u32 rec_load[7];
+	u16 send_head;
+	u16 rec_head;
+	int msg_id;
+	enum tx_state tx_state;
+	int hardrst_count;
+	u32 source_power_supply[7];
+	/* 50mv unit */
+	u32 source_max_current[7];
+	/* 10ma uint*/
+	int pos_power;
+	/*
+	 * if PartnerCap[0] == 0xffffffff
+	 * show Partner Device do not support supply
+	 */
+	u32 partner_cap[7];
+	int n_caps_used;
+	int vdm_state;
+	int vdm_substate;
+	int vdm_send_state;
+	u16 vdm_svid[12];
+	int vdm_svid_num;
+	u32 vdm_id;
+	u8 chip_id;
+	bool vconn_enabled;
+	bool is_pd_support;
+	int pd_output_vol;
+	int pd_output_cur;
+	int cc_meas_high;
+	int cc_meas_low;
+	bool vbus_begin;
+
+	enum role_mode role;
+	bool vconn_supported;
+	bool try_role_complete;
+	enum role_mode try_role;
+};
+
+#endif /* FUSB302_H */
+
--- /dev/null	2023-04-29 08:31:15.023562380 -0400
+++ b/drivers/staging/fusb30x/Kconfig	2023-05-06 08:46:30.703660291 -0400
@@ -0,0 +1,10 @@
+config FUSB_30X
+	tristate "Fairchild FUSB30X Type-C chip driver"
+	depends on I2C
+	help
+	  This is a driver for the Fairchild FUSB302 Type-C chip.  It supports
+	  USB Type-C PD functionality controlled using I2C.
+
+	  This driver supports extcon reporting not yet implemented in the
+	  mainline FUSB302 driver.
+
--- /dev/null	2023-04-29 08:31:15.023562380 -0400
+++ b/drivers/staging/fusb30x/Makefile	2023-05-06 08:46:30.703660291 -0400
@@ -0,0 +1,2 @@
+# SPDX-License-Identifier: GPL-2.0
+obj-$(CONFIG_FUSB_30X)	+= fusb30x.o
diff -Naur a/drivers/staging/Kconfig b/drivers/staging/Kconfig
--- a/drivers/staging/Kconfig	2023-04-30 19:32:26.000000000 -0400
+++ b/drivers/staging/Kconfig	2023-05-06 08:46:30.703660291 -0400
@@ -60,6 +60,8 @@
 
 source "drivers/staging/fbtft/Kconfig"
 
+source "drivers/staging/fusb30x/Kconfig"
+
 source "drivers/staging/most/Kconfig"
 
 source "drivers/staging/ks7010/Kconfig"
diff -Naur a/drivers/staging/Makefile b/drivers/staging/Makefile
--- a/drivers/staging/Makefile	2023-04-30 19:32:26.000000000 -0400
+++ b/drivers/staging/Makefile	2023-05-06 08:46:30.703660291 -0400
@@ -20,6 +20,7 @@
 obj-$(CONFIG_STAGING_BOARD)	+= board/
 obj-$(CONFIG_LTE_GDM724X)	+= gdm724x/
 obj-$(CONFIG_FB_TFT)		+= fbtft/
+obj-$(CONFIG_FUSB_30X)		+= fusb30x/
 obj-$(CONFIG_MOST)		+= most/
 obj-$(CONFIG_KS7010)		+= ks7010/
 obj-$(CONFIG_GREYBUS)		+= greybus/
diff -Naur a/drivers/usb/dwc3/core.c b/drivers/usb/dwc3/core.c
--- a/drivers/usb/dwc3/core.c	2023-04-30 19:32:26.000000000 -0400
+++ b/drivers/usb/dwc3/core.c	2023-05-06 08:46:30.715660173 -0400
@@ -1551,6 +1551,8 @@
 				"snps,dis-del-phy-power-chg-quirk");
 	dwc->dis_tx_ipgap_linecheck_quirk = device_property_read_bool(dev,
 				"snps,dis-tx-ipgap-linecheck-quirk");
+	dwc->xhci_trb_ent_quirk = device_property_read_bool(dev,
+				"snps,xhci-trb-ent-quirk");
 	dwc->resume_hs_terminations = device_property_read_bool(dev,
 				"snps,resume-hs-terminations");
 	dwc->parkmode_disable_ss_quirk = device_property_read_bool(dev,
diff -Naur a/drivers/usb/dwc3/core.h b/drivers/usb/dwc3/core.h
--- a/drivers/usb/dwc3/core.h	2023-04-30 19:32:26.000000000 -0400
+++ b/drivers/usb/dwc3/core.h	2023-05-06 08:46:30.715660173 -0400
@@ -1098,6 +1098,9 @@
  *			change quirk.
  * @dis_tx_ipgap_linecheck_quirk: set if we disable u2mac linestate
  *			check during HS transmit.
+ * @xhci_trb_ent_quirk: set if need to enable the Evaluate Next TRB(ENT)
+ *			flag in the TRB data structure to force xHC to
+ *			pre-fetch the next TRB of a TD.
  * @resume_hs_terminations: Set if we enable quirk for fixing improper crc
  *			generation after resume from suspend.
  * @parkmode_disable_ss_quirk: set if we need to disable all SuperSpeed
@@ -1316,6 +1319,7 @@
 	unsigned		dis_u2_freeclk_exists_quirk:1;
 	unsigned		dis_del_phy_power_chg_quirk:1;
 	unsigned		dis_tx_ipgap_linecheck_quirk:1;
+	unsigned		xhci_trb_ent_quirk:1;
 	unsigned		resume_hs_terminations:1;
 	unsigned		parkmode_disable_ss_quirk:1;
 	unsigned		gfladj_refclk_lpm_sel:1;
diff -Naur a/drivers/usb/dwc3/host.c b/drivers/usb/dwc3/host.c
--- a/drivers/usb/dwc3/host.c	2023-04-30 19:32:26.000000000 -0400
+++ b/drivers/usb/dwc3/host.c	2023-05-06 08:46:30.716660164 -0400
@@ -66,7 +66,7 @@
 
 int dwc3_host_init(struct dwc3 *dwc)
 {
-	struct property_entry	props[4];
+	struct property_entry	props[5];
 	struct platform_device	*xhci;
 	int			ret, irq;
 	int			prop_idx = 0;
@@ -97,6 +97,9 @@
 	if (dwc->usb3_lpm_capable)
 		props[prop_idx++] = PROPERTY_ENTRY_BOOL("usb3-lpm-capable");
 
+	if (dwc->xhci_trb_ent_quirk)
+		props[prop_idx++] = PROPERTY_ENTRY_BOOL("xhci-trb-ent-quirk");
+
 	if (dwc->usb2_lpm_disable)
 		props[prop_idx++] = PROPERTY_ENTRY_BOOL("usb2-lpm-disable");
 
diff -Naur a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
--- a/drivers/usb/host/xhci.h	2023-04-30 19:32:26.000000000 -0400
+++ b/drivers/usb/host/xhci.h	2023-05-06 08:46:30.716660164 -0400
@@ -1528,7 +1528,11 @@
 #define TRB_SEGMENT_SIZE	(TRBS_PER_SEGMENT*16)
 #define TRB_SEGMENT_SHIFT	(ilog2(TRB_SEGMENT_SIZE))
 /* TRB buffer pointers can't cross 64KB boundaries */
+#ifdef CONFIG_ARCH_ROCKCHIP
+#define TRB_MAX_BUFF_SHIFT		12
+#else
 #define TRB_MAX_BUFF_SHIFT		16
+#endif
 #define TRB_MAX_BUFF_SIZE	(1 << TRB_MAX_BUFF_SHIFT)
 /* How much data is left before the 64KB boundary? */
 #define TRB_BUFF_LEN_UP_TO_BOUNDARY(addr)	(TRB_MAX_BUFF_SIZE - \
@@ -1849,6 +1853,7 @@
 #define XHCI_STATE_HALTED	(1 << 1)
 #define XHCI_STATE_REMOVING	(1 << 2)
 	unsigned long long	quirks;
+#define XHCI_TRB_ENT_QUIRK	BIT_ULL(63)
 #define	XHCI_LINK_TRB_QUIRK	BIT_ULL(0)
 #define XHCI_RESET_EP_QUIRK	BIT_ULL(1) /* Deprecated */
 #define XHCI_NEC_HOST		BIT_ULL(2)
diff -Naur a/drivers/usb/host/xhci-plat.c b/drivers/usb/host/xhci-plat.c
--- a/drivers/usb/host/xhci-plat.c	2023-04-30 19:32:26.000000000 -0400
+++ b/drivers/usb/host/xhci-plat.c	2023-05-06 08:46:30.717660154 -0400
@@ -255,6 +255,9 @@
 		if (device_property_read_bool(tmpdev, "quirk-broken-port-ped"))
 			xhci->quirks |= XHCI_BROKEN_PORT_PED;
 
+		if (device_property_read_bool(tmpdev, "xhci-trb-ent-quirk"))
+			xhci->quirks |= XHCI_TRB_ENT_QUIRK;
+
 		device_property_read_u32(tmpdev, "imod-interval-ns",
 					 &xhci->imod_interval);
 	}
diff -Naur a/drivers/usb/host/xhci-ring.c b/drivers/usb/host/xhci-ring.c
--- a/drivers/usb/host/xhci-ring.c	2023-04-30 19:32:26.000000000 -0400
+++ b/drivers/usb/host/xhci-ring.c	2023-05-06 08:46:30.718660144 -0400
@@ -3529,6 +3529,7 @@
 	bool more_trbs_coming = true;
 	bool need_zero_pkt = false;
 	bool first_trb = true;
+	bool en_trb_ent = true;
 	unsigned int num_trbs;
 	unsigned int start_cycle, num_sgs = 0;
 	unsigned int enqd_len, block_len, trb_buff_len, full_len;
@@ -3565,6 +3566,13 @@
 	if (urb->transfer_flags & URB_ZERO_PACKET && urb_priv->num_tds > 1)
 		need_zero_pkt = true;
 
+	/*
+	 * Don't enable the ENT flag in the TRB if
+	 * the EP support bulk streaming protocol.
+	 */
+	if (urb->stream_id)
+		en_trb_ent = false;
+
 	td = &urb_priv->td[0];
 
 	/*
@@ -3593,6 +3601,13 @@
 			first_trb = false;
 			if (start_cycle == 0)
 				field |= TRB_CYCLE;
+			/*
+			 * Don't enable the ENT flag in the TRB if the
+			 * transfer length of the first TRB isn't an
+			 * integer multiple of the EP maxpacket.
+			 */
+			if (trb_buff_len % usb_endpoint_maxp(&urb->ep->desc))
+				en_trb_ent = false;
 		} else
 			field |= ring->cycle_state;
 
@@ -3601,6 +3616,8 @@
 		 */
 		if (enqd_len + trb_buff_len < full_len) {
 			field |= TRB_CHAIN;
+			if (xhci->quirks & XHCI_TRB_ENT_QUIRK && en_trb_ent)
+				field |= TRB_ENT;
 			if (trb_is_link(ring->enqueue + 1)) {
 				if (xhci_align_td(xhci, urb, enqd_len,
 						  &trb_buff_len,
--- /dev/null	2023-04-29 08:31:15.023562380 -0400
+++ b/include/dt-bindings/clock/rockchip-ddr.h	2023-05-06 08:46:30.744659889 -0400
@@ -0,0 +1,63 @@
+/*
+ *
+ * Copyright (C) 2017 ROCKCHIP, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _DT_BINDINGS_CLOCK_ROCKCHIP_DDR_H
+#define _DT_BINDINGS_CLOCK_ROCKCHIP_DDR_H
+
+#define DDR2_DEFAULT	(0)
+
+#define DDR3_800D	(0)	/* 5-5-5 */
+#define DDR3_800E	(1)	/* 6-6-6 */
+#define DDR3_1066E	(2)	/* 6-6-6 */
+#define DDR3_1066F	(3)	/* 7-7-7 */
+#define DDR3_1066G	(4)	/* 8-8-8 */
+#define DDR3_1333F	(5)	/* 7-7-7 */
+#define DDR3_1333G	(6)	/* 8-8-8 */
+#define DDR3_1333H	(7)	/* 9-9-9 */
+#define DDR3_1333J	(8)	/* 10-10-10 */
+#define DDR3_1600G	(9)	/* 8-8-8 */
+#define DDR3_1600H	(10)	/* 9-9-9 */
+#define DDR3_1600J	(11)	/* 10-10-10 */
+#define DDR3_1600K	(12)	/* 11-11-11 */
+#define DDR3_1866J	(13)	/* 10-10-10 */
+#define DDR3_1866K	(14)	/* 11-11-11 */
+#define DDR3_1866L	(15)	/* 12-12-12 */
+#define DDR3_1866M	(16)	/* 13-13-13 */
+#define DDR3_2133K	(17)	/* 11-11-11 */
+#define DDR3_2133L	(18)	/* 12-12-12 */
+#define DDR3_2133M	(19)	/* 13-13-13 */
+#define DDR3_2133N	(20)	/* 14-14-14 */
+#define DDR3_DEFAULT	(21)
+#define DDR_DDR2	(22)
+#define DDR_LPDDR	(23)
+#define DDR_LPDDR2	(24)
+
+#define DDR4_1600J	(0)	/* 10-10-10 */
+#define DDR4_1600K	(1)	/* 11-11-11 */
+#define DDR4_1600L	(2)	/* 12-12-12 */
+#define DDR4_1866L	(3)	/* 12-12-12 */
+#define DDR4_1866M	(4)	/* 13-13-13 */
+#define DDR4_1866N	(5)	/* 14-14-14 */
+#define DDR4_2133N	(6)	/* 14-14-14 */
+#define DDR4_2133P	(7)	/* 15-15-15 */
+#define DDR4_2133R	(8)	/* 16-16-16 */
+#define DDR4_2400P	(9)	/* 15-15-15 */
+#define DDR4_2400R	(10)	/* 16-16-16 */
+#define DDR4_2400U	(11)	/* 18-18-18 */
+#define DDR4_DEFAULT	(12)
+
+#define PAUSE_CPU_STACK_SIZE	16
+
+#endif
--- /dev/null	2023-04-29 08:31:15.023562380 -0400
+++ b/include/dt-bindings/memory/rk3328-dram.h	2023-05-06 08:46:30.744659889 -0400
@@ -0,0 +1,159 @@
+/*
+ * Copyright (c) 2017 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * This file is dual-licensed: you can use it either under the terms
+ * of the GPL or the X11 license, at your option. Note that this dual
+ * licensing only applies to this file, and not this project as a
+ * whole.
+ *
+ *  a) This library is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of the
+ *     License, or (at your option) any later version.
+ *
+ *     This library is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ * Or, alternatively,
+ *
+ *  b) Permission is hereby granted, free of charge, to any person
+ *     obtaining a copy of this software and associated documentation
+ *     files (the "Software"), to deal in the Software without
+ *     restriction, including without limitation the rights to use,
+ *     copy, modify, merge, publish, distribute, sublicense, and/or
+ *     sell copies of the Software, and to permit persons to whom the
+ *     Software is furnished to do so, subject to the following
+ *     conditions:
+ *
+ *     The above copyright notice and this permission notice shall be
+ *     included in all copies or substantial portions of the Software.
+ *
+ *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+ *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+ *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ *     OTHER DEALINGS IN THE SOFTWARE.
+ */
+#ifndef _DT_BINDINGS_DRAM_ROCKCHIP_RK3328_H
+#define _DT_BINDINGS_DRAM_ROCKCHIP_RK3328_H
+
+#define DDR3_DS_34ohm			(34)
+#define DDR3_DS_40ohm			(40)
+
+#define DDR3_ODT_DIS			(0)
+#define DDR3_ODT_40ohm			(40)
+#define DDR3_ODT_60ohm			(60)
+#define DDR3_ODT_120ohm			(120)
+
+#define LP2_DS_34ohm			(34)
+#define LP2_DS_40ohm			(40)
+#define LP2_DS_48ohm			(48)
+#define LP2_DS_60ohm			(60)
+#define LP2_DS_68_6ohm			(68)	/* optional */
+#define LP2_DS_80ohm			(80)
+#define LP2_DS_120ohm			(120)	/* optional */
+
+#define LP3_DS_34ohm			(34)
+#define LP3_DS_40ohm			(40)
+#define LP3_DS_48ohm			(48)
+#define LP3_DS_60ohm			(60)
+#define LP3_DS_80ohm			(80)
+#define LP3_DS_34D_40U			(3440)
+#define LP3_DS_40D_48U			(4048)
+#define LP3_DS_34D_48U			(3448)
+
+#define LP3_ODT_DIS			(0)
+#define LP3_ODT_60ohm			(60)
+#define LP3_ODT_120ohm			(120)
+#define LP3_ODT_240ohm			(240)
+
+#define LP4_PDDS_40ohm			(40)
+#define LP4_PDDS_48ohm			(48)
+#define LP4_PDDS_60ohm			(60)
+#define LP4_PDDS_80ohm			(80)
+#define LP4_PDDS_120ohm			(120)
+#define LP4_PDDS_240ohm			(240)
+
+#define LP4_DQ_ODT_40ohm		(40)
+#define LP4_DQ_ODT_48ohm		(48)
+#define LP4_DQ_ODT_60ohm		(60)
+#define LP4_DQ_ODT_80ohm		(80)
+#define LP4_DQ_ODT_120ohm		(120)
+#define LP4_DQ_ODT_240ohm		(240)
+#define LP4_DQ_ODT_DIS			(0)
+
+#define LP4_CA_ODT_40ohm		(40)
+#define LP4_CA_ODT_48ohm		(48)
+#define LP4_CA_ODT_60ohm		(60)
+#define LP4_CA_ODT_80ohm		(80)
+#define LP4_CA_ODT_120ohm		(120)
+#define LP4_CA_ODT_240ohm		(240)
+#define LP4_CA_ODT_DIS			(0)
+
+#define DDR4_DS_34ohm			(34)
+#define DDR4_DS_48ohm			(48)
+#define DDR4_RTT_NOM_DIS		(0)
+#define DDR4_RTT_NOM_60ohm		(60)
+#define DDR4_RTT_NOM_120ohm		(120)
+#define DDR4_RTT_NOM_40ohm		(40)
+#define DDR4_RTT_NOM_240ohm		(240)
+#define DDR4_RTT_NOM_48ohm		(48)
+#define DDR4_RTT_NOM_80ohm		(80)
+#define DDR4_RTT_NOM_34ohm		(34)
+
+#define PHY_DDR3_RON_RTT_DISABLE	(0)
+#define PHY_DDR3_RON_RTT_451ohm		(1)
+#define PHY_DDR3_RON_RTT_225ohm		(2)
+#define PHY_DDR3_RON_RTT_150ohm		(3)
+#define PHY_DDR3_RON_RTT_112ohm		(4)
+#define PHY_DDR3_RON_RTT_90ohm		(5)
+#define PHY_DDR3_RON_RTT_75ohm		(6)
+#define PHY_DDR3_RON_RTT_64ohm		(7)
+#define PHY_DDR3_RON_RTT_56ohm		(16)
+#define PHY_DDR3_RON_RTT_50ohm		(17)
+#define PHY_DDR3_RON_RTT_45ohm		(18)
+#define PHY_DDR3_RON_RTT_41ohm		(19)
+#define PHY_DDR3_RON_RTT_37ohm		(20)
+#define PHY_DDR3_RON_RTT_34ohm		(21)
+#define PHY_DDR3_RON_RTT_33ohm		(22)
+#define PHY_DDR3_RON_RTT_30ohm		(23)
+#define PHY_DDR3_RON_RTT_28ohm		(24)
+#define PHY_DDR3_RON_RTT_26ohm		(25)
+#define PHY_DDR3_RON_RTT_25ohm		(26)
+#define PHY_DDR3_RON_RTT_23ohm		(27)
+#define PHY_DDR3_RON_RTT_22ohm		(28)
+#define PHY_DDR3_RON_RTT_21ohm		(29)
+#define PHY_DDR3_RON_RTT_20ohm		(30)
+#define PHY_DDR3_RON_RTT_19ohm		(31)
+
+#define PHY_DDR4_LPDDR3_RON_RTT_DISABLE (0)
+#define PHY_DDR4_LPDDR3_RON_RTT_480ohm	(1)
+#define PHY_DDR4_LPDDR3_RON_RTT_240ohm	(2)
+#define PHY_DDR4_LPDDR3_RON_RTT_160ohm	(3)
+#define PHY_DDR4_LPDDR3_RON_RTT_120ohm	(4)
+#define PHY_DDR4_LPDDR3_RON_RTT_96ohm	(5)
+#define PHY_DDR4_LPDDR3_RON_RTT_80ohm	(6)
+#define PHY_DDR4_LPDDR3_RON_RTT_68ohm	(7)
+#define PHY_DDR4_LPDDR3_RON_RTT_60ohm	(16)
+#define PHY_DDR4_LPDDR3_RON_RTT_53ohm	(17)
+#define PHY_DDR4_LPDDR3_RON_RTT_48ohm	(18)
+#define PHY_DDR4_LPDDR3_RON_RTT_43ohm	(19)
+#define PHY_DDR4_LPDDR3_RON_RTT_40ohm	(20)
+#define PHY_DDR4_LPDDR3_RON_RTT_37ohm	(21)
+#define PHY_DDR4_LPDDR3_RON_RTT_34ohm	(22)
+#define PHY_DDR4_LPDDR3_RON_RTT_32ohm	(23)
+#define PHY_DDR4_LPDDR3_RON_RTT_30ohm	(24)
+#define PHY_DDR4_LPDDR3_RON_RTT_28ohm	(25)
+#define PHY_DDR4_LPDDR3_RON_RTT_26ohm	(26)
+#define PHY_DDR4_LPDDR3_RON_RTT_25ohm	(27)
+#define PHY_DDR4_LPDDR3_RON_RTT_24ohm	(28)
+#define PHY_DDR4_LPDDR3_RON_RTT_22ohm	(29)
+#define PHY_DDR4_LPDDR3_RON_RTT_21ohm	(30)
+#define PHY_DDR4_LPDDR3_RON_RTT_20ohm	(31)
+
+#endif /*_DT_BINDINGS_DRAM_ROCKCHIP_RK3328_H*/
diff -Naur a/include/soc/rockchip/rockchip_sip.h b/include/soc/rockchip/rockchip_sip.h
--- a/include/soc/rockchip/rockchip_sip.h	2023-04-30 19:32:26.000000000 -0400
+++ b/include/soc/rockchip/rockchip_sip.h	2023-05-06 08:46:30.741659918 -0400
@@ -16,5 +16,16 @@
 #define ROCKCHIP_SIP_CONFIG_DRAM_CLR_IRQ	0x06
 #define ROCKCHIP_SIP_CONFIG_DRAM_SET_PARAM	0x07
 #define ROCKCHIP_SIP_CONFIG_DRAM_SET_ODT_PD	0x08
+#define ROCKCHIP_SIP_CONFIG_DRAM_GET_VERSION	0x08
+
+#define ROCKCHIP_SIP_SHARE_MEM			0x82000009
+
+/* Share mem page types */
+typedef enum {
+    SHARE_PAGE_TYPE_INVALID = 0,
+    SHARE_PAGE_TYPE_UARTDBG,
+    SHARE_PAGE_TYPE_DDR,
+    SHARE_PAGE_TYPE_MAX,
+} share_page_type_t;
 
 #endif
diff -Naur a/kernel/dma/pool.c b/kernel/dma/pool.c
--- a/kernel/dma/pool.c	2023-04-30 19:32:26.000000000 -0400
+++ b/kernel/dma/pool.c	2023-05-06 08:46:30.732660006 -0400
@@ -189,13 +189,10 @@
 	int ret = 0;
 
 	/*
-	 * If coherent_pool was not used on the command line, default the pool
-	 * sizes to 128KB per 1GB of memory, min 128KB, max MAX_ORDER-1.
+	 * Use 2MiB as default pool size.
 	 */
 	if (!atomic_pool_size) {
-		unsigned long pages = totalram_pages() / (SZ_1G / SZ_128K);
-		pages = min_t(unsigned long, pages, MAX_ORDER_NR_PAGES);
-		atomic_pool_size = max_t(size_t, pages << PAGE_SHIFT, SZ_128K);
+		atomic_pool_size = SZ_2M;
 	}
 	INIT_WORK(&atomic_pool_work, atomic_pool_work_fn);
 
diff -Naur a/sound/soc/codecs/es8316.c b/sound/soc/codecs/es8316.c
--- a/sound/soc/codecs/es8316.c	2023-04-30 19:32:26.000000000 -0400
+++ b/sound/soc/codecs/es8316.c	2023-05-06 08:46:30.725660075 -0400
@@ -696,7 +696,7 @@
 	snd_soc_component_update_bits(component, ES8316_GPIO_DEBOUNCE,
 				      ES8316_GPIO_ENABLE_INTERRUPT, 0);
 
-	if (es8316->jack->status & SND_JACK_MICROPHONE) {
+	if (es8316->jack && (es8316->jack->status & SND_JACK_MICROPHONE)) {
 		es8316_disable_micbias_for_mic_gnd_short_detect(component);
 		snd_soc_jack_report(es8316->jack, 0, SND_JACK_BTN_0);
 	}
diff -Naur a/sound/soc/codecs/rt5651.c b/sound/soc/codecs/rt5651.c
--- a/sound/soc/codecs/rt5651.c	2023-04-30 19:32:26.000000000 -0400
+++ b/sound/soc/codecs/rt5651.c	2023-05-06 08:46:30.728660046 -0400
@@ -24,6 +24,7 @@
 #include <sound/initval.h>
 #include <sound/tlv.h>
 #include <sound/jack.h>
+#include <linux/clk.h>
 
 #include "rl6231.h"
 #include "rt5651.h"
@@ -1511,6 +1512,7 @@
 static int rt5651_set_bias_level(struct snd_soc_component *component,
 			enum snd_soc_bias_level level)
 {
+	struct rt5651_priv *rt5651 = snd_soc_component_get_drvdata(component);
 	switch (level) {
 	case SND_SOC_BIAS_PREPARE:
 		if (SND_SOC_BIAS_STANDBY == snd_soc_component_get_bias_level(component)) {
@@ -1518,6 +1520,13 @@
 				snd_soc_component_update_bits(component, RT5651_D_MISC,
 						    0xc00, 0xc00);
 		}
+		if (!IS_ERR(rt5651->mclk)){
+			if (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_ON) {
+				clk_disable_unprepare(rt5651->mclk);
+			} else {
+				clk_prepare_enable(rt5651->mclk);
+			}
+		}
 		break;
 	case SND_SOC_BIAS_STANDBY:
 		if (SND_SOC_BIAS_OFF == snd_soc_component_get_bias_level(component)) {
@@ -2059,6 +2068,13 @@
 {
 	struct rt5651_priv *rt5651 = snd_soc_component_get_drvdata(component);
 
+	/* Check if MCLK provided */
+	rt5651->mclk = devm_clk_get(component->dev, "mclk");
+	if (PTR_ERR(rt5651->mclk) == -EPROBE_DEFER){
+		dev_err(component->dev, "unable to get mclk\n");
+		return -EPROBE_DEFER;
+	}
+
 	rt5651->component = component;
 
 	snd_soc_component_update_bits(component, RT5651_PWR_ANLG1,
diff -Naur a/sound/soc/codecs/rt5651.h b/sound/soc/codecs/rt5651.h
--- a/sound/soc/codecs/rt5651.h	2023-04-30 19:32:26.000000000 -0400
+++ b/sound/soc/codecs/rt5651.h	2023-05-06 08:46:30.729660036 -0400
@@ -2097,6 +2097,7 @@
 
 	int dmic_en;
 	bool hp_mute;
+	struct clk *mclk;
 };
 
 #endif /* __RT5651_H__ */
