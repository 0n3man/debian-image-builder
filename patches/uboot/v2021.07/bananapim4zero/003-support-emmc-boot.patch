From cbdca15b14fa677df322d9754f30a8da662c10c4 Mon Sep 17 00:00:00 2001
From: Banana Pi -BPI <lionwang@sinovoip.com.cn>
Date: Wed, 1 Nov 2023 23:14:04 +0800
Subject: [PATCH] support emmc boot

---
 arch/arm/dts/sun50i-h616-bananapi-m4berry.dts | 27 +++++---
 arch/arm/include/asm/arch-sunxi/mmc.h         |  1 +
 board/sunxi/board.c                           |  2 +-
 drivers/mmc/sunxi_mmc.c                       | 63 ++++++++++++++++---
 4 files changed, 77 insertions(+), 16 deletions(-)

diff --git a/arch/arm/dts/sun50i-h616-bananapi-m4berry.dts b/arch/arm/dts/sun50i-h616-bananapi-m4berry.dts
index 253fa620..e64fc91c 100644
--- a/arch/arm/dts/sun50i-h616-bananapi-m4berry.dts
+++ b/arch/arm/dts/sun50i-h616-bananapi-m4berry.dts
@@ -6,7 +6,7 @@
 /dts-v1/;
 
 #include "sun50i-h616.dtsi"
-#include "sunxi-common-regulators.dtsi"
+
 #include <dt-bindings/gpio/gpio.h>
 #include <dt-bindings/interrupt-controller/arm-gic.h>
 #include <dt-bindings/leds/common.h>
@@ -28,9 +28,9 @@
 		compatible = "gpio-leds";
 
 		led-0 {
-			function = LED_FUNCTION_POWER;
-			color = <LED_COLOR_ID_RED>;
-			gpios = <&pio 2 12 GPIO_ACTIVE_HIGH>; /* PC12 */
+			function = LED_FUNCTION_STATUS;
+			color = <LED_COLOR_ID_GREEN>;
+			gpios = <&pio 2 12 GPIO_ACTIVE_LOW>; /* PC12 */
 			default-state = "on";
 		};
 
@@ -45,6 +45,16 @@
 		regulator-always-on;
 	};
 
+	reg_usb1_vbus: usb1-vbus {
+		compatible = "regulator-fixed";
+		regulator-name = "usb1-vbus";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		vin-supply = <&reg_vcc5v>;
+		regulator-always-on;
+
+		status = "okay";
+	};
 };
 
 &ehci0 {
@@ -75,7 +85,7 @@
 };
 
 &mmc0 {
-	vmmc-supply = <&reg_vcc3v3>;
+
 	cd-gpios = <&pio 5 6 GPIO_ACTIVE_LOW>;	/* PF6 */
 	bus-width = <4>;
 	status = "okay";
@@ -85,8 +95,7 @@
 &mmc2 {
 	pinctrl-names = "default";
 	pinctrl-0 = <&mmc2_pins>;
-	vmmc-supply = <&reg_vcc3v3>;
-	vqmmc-supply = <&reg_vcc3v3>;
+
 	bus-width = <8>;
 	non-removable;
 	status = "okay";
@@ -174,3 +183,7 @@
 	status = "okay";
 };
 
+&usbphy {
+	usb1_vbus-supply = <&reg_usb1_vbus>;
+	status = "okay";
+};
diff --git a/arch/arm/include/asm/arch-sunxi/mmc.h b/arch/arm/include/asm/arch-sunxi/mmc.h
index 340e25b0..5daacf10 100644
--- a/arch/arm/include/asm/arch-sunxi/mmc.h
+++ b/arch/arm/include/asm/arch-sunxi/mmc.h
@@ -119,6 +119,7 @@ struct sunxi_mmc {
 #define SUNXI_MMC_STATUS_CARD_PRESENT		(0x1 << 8)
 #define SUNXI_MMC_STATUS_CARD_DATA_BUSY		(0x1 << 9)
 #define SUNXI_MMC_STATUS_DATA_FSM_BUSY		(0x1 << 10)
+#define SUNXI_MMC_STATUS_FIFO_LEVEL(reg)	(((reg) >> 17) & 0x3fff)
 
 #define SUNXI_MMC_NTSR_MODE_SEL_NEW		(0x1 << 31)
 
diff --git a/board/sunxi/board.c b/board/sunxi/board.c
index 87f1ffe1..73f5745f 100644
--- a/board/sunxi/board.c
+++ b/board/sunxi/board.c
@@ -582,7 +582,7 @@ static void mmc_pinmux_setup(int sdc)
 				continue;
 			sunxi_gpio_set_cfgpin(pin, SUNXI_GPC_SDC2);
 			sunxi_gpio_set_pull(pin, SUNXI_GPIO_PULL_UP);
-			sunxi_gpio_set_drv(pin, 2);
+			sunxi_gpio_set_drv(pin, 3);
 		}		
 #elif defined(CONFIG_MACH_SUN9I)
 		/* SDC2: PC6-PC16 */
diff --git a/drivers/mmc/sunxi_mmc.c b/drivers/mmc/sunxi_mmc.c
index 3503ccdb..a944b191 100644
--- a/drivers/mmc/sunxi_mmc.c
+++ b/drivers/mmc/sunxi_mmc.c
@@ -303,8 +303,9 @@ static int mmc_trans_data_by_cpu(struct sunxi_mmc_priv *priv, struct mmc *mmc,
 					      SUNXI_MMC_STATUS_FIFO_FULL;
 	unsigned i;
 	unsigned *buff = (unsigned int *)(reading ? data->dest : data->src);
-	unsigned byte_cnt = data->blocksize * data->blocks;
-	unsigned timeout_msecs = byte_cnt >> 8;
+	unsigned word_cnt = (data->blocksize * data->blocks) >> 2;
+	unsigned timeout_msecs = word_cnt >> 6;
+	uint32_t status;
 	unsigned long  start;
 
 	if (timeout_msecs < 2000)
@@ -315,16 +316,42 @@ static int mmc_trans_data_by_cpu(struct sunxi_mmc_priv *priv, struct mmc *mmc,
 
 	start = get_timer(0);
 
-	for (i = 0; i < (byte_cnt >> 2); i++) {
-		while (readl(&priv->reg->status) & status_bit) {
+	for (i = 0; i < word_cnt;) {
+		unsigned int in_fifo;
+
+		while ((status = readl(&priv->reg->status)) & status_bit) {
 			if (get_timer(start) > timeout_msecs)
 				return -1;
 		}
 
-		if (reading)
-			buff[i] = readl(&priv->reg->fifo);
-		else
-			writel(buff[i], &priv->reg->fifo);
+		/*
+		 * For writing we do not easily know the FIFO size, so have
+		 * to check the FIFO status after every word written.
+		 * TODO: For optimisation we could work out a minimum FIFO
+		 * size across all SoCs, and use that together with the current
+		 * fill level to write chunks of words.
+		 */
+		if (!reading) {
+			writel(buff[i++], &priv->reg->fifo);
+			continue;
+		}
+
+		/*
+		 * The status register holds the current FIFO level, so we
+		 * can be sure to collect as many words from the FIFO
+		 * register without checking the status register after every
+		 * read. That saves half of the costly MMIO reads, effectively
+		 * doubling the read performance.
+		 * Some SoCs (A20) report a level of 0 if the FIFO is
+		 * completely full (value masked out?). Use a safe minimal
+		 * FIFO size in this case.
+		 */
+		in_fifo = SUNXI_MMC_STATUS_FIFO_LEVEL(status);
+		if (in_fifo == 0 && (status & SUNXI_MMC_STATUS_FIFO_FULL))
+			in_fifo = 32;
+		for (; in_fifo > 0; in_fifo--)
+			buff[i++] = readl_relaxed(&priv->reg->fifo);
+		dmb();
 	}
 
 	return 0;
@@ -531,6 +558,17 @@ struct mmc *sunxi_mmc_init(int sdc_no)
 	cfg->f_min = 400000;
 	cfg->f_max = 52000000;
 
+#ifdef BPI
+#else
+	printf("BPI: init mmc %d clock(%d) and io\n", sdc_no, cfg->f_max);
+	if(sdc_no==2) {
+	cfg->f_max = 2000000;
+	cfg->f_max = 12000000;
+	cfg->f_max = 8000000;
+	printf("BPI: init mmc %d clock(%d) and io\n", sdc_no, cfg->f_max);
+	}
+#endif
+
 	if (mmc_resource_init(sdc_no) != 0)
 		return NULL;
 
@@ -633,6 +671,15 @@ static int sunxi_mmc_probe(struct udevice *dev)
 
 	cfg->f_min = 400000;
 	cfg->f_max = 52000000;
+#ifdef BPI
+else
+	if (bus_width == 8) {
+	cfg->f_max = 2000000;
+	cfg->f_max = 12000000;
+	cfg->f_max = 8000000;
+	printf("BPI: init mmc %d clock(%d) and io\n", 2, cfg->f_max);
+	}
+#endif
 
 	priv->reg = (void *)dev_read_addr(dev);
 
-- 
2.39.2

