From abd1493d8c2c92e9028751d9f92b73d3a9aa54c2 Mon Sep 17 00:00:00 2001
From: Patrick Yavitz <pyavitz@xxxxx.com>
Date: Thu, 1 Aug 2024 16:18:30 -0400
Subject: [PATCH] Update to v1.0.11

Signed-off-by: James Deng <james.deng@spacemit.com>
Signed-off-by: Patrick Yavitz <pyavitz@xxxxx.com>
---
 .../gpu/drm/spacemit/spacemit_mipi_panel.c    |  29 +++++
 .../gpu/drm/spacemit/spacemit_mipi_panel.h    |   1 +
 drivers/input/misc/Kconfig                    |   7 ++
 drivers/input/misc/Makefile                   |   1 +
 drivers/input/misc/hall_sensor_as1911.c       | 118 ++++++++++++++++++
 drivers/mmc/host/sdhci-of-k1x.c               |  38 +++++-
 drivers/net/ethernet/spacemit/k1x-emac.c      |  64 +++++-----
 drivers/pci/controller/dwc/pcie-k1x.c         |  23 +++-
 .../phy/spacemit/phy-spacemit-k1x-combphy.c   |   8 +-
 drivers/power/supply/sbs-battery.c            |   5 +-
 .../spacemit/spacemit-rf/spacemit-pwrseq.c    |   2 +-
 drivers/tty/serial/pxa_k1x.c                  |  10 +-
 drivers/usb/host/ehci-k1x-ci.c                |   2 +-
 include/linux/platform_data/k1x_sdhci.h       |   1 +
 14 files changed, 262 insertions(+), 47 deletions(-)
 create mode 100755 drivers/input/misc/hall_sensor_as1911.c

diff --git a/drivers/gpu/drm/spacemit/spacemit_mipi_panel.c b/drivers/gpu/drm/spacemit/spacemit_mipi_panel.c
index 1a83ecb18275..148957a24ed6 100644
--- a/drivers/gpu/drm/spacemit/spacemit_mipi_panel.c
+++ b/drivers/gpu/drm/spacemit/spacemit_mipi_panel.c
@@ -120,9 +120,17 @@ static int spacemit_panel_unprepare(struct drm_panel *p)
 		gpio_direction_output(panel->gpio_bl, 0);
 	}
 	msleep(150);
+
 	gpio_direction_output(panel->gpio_dc[0], 0);
 	gpio_direction_output(panel->gpio_dc[1], 0);
 
+	if(INVALID_GPIO != panel->gpio_avdd[0]) {
+		gpio_direction_output(panel->gpio_avdd[0], 0);
+	}
+	if(INVALID_GPIO != panel->gpio_avdd[1]) {
+		gpio_direction_output(panel->gpio_avdd[1], 0);
+	}
+
 	if (panel->vdd_1v2) {
 		regulator_disable(panel->vdd_1v2);
 	}
@@ -181,6 +189,13 @@ static int spacemit_panel_prepare(struct drm_panel *p)
 	gpio_direction_output(panel->gpio_dc[0], 1);
 	gpio_direction_output(panel->gpio_dc[1], 1);
 
+	if(panel->gpio_avdd[0] != INVALID_GPIO) {
+		gpio_direction_output(panel->gpio_avdd[0], 1);
+	}
+	if(panel->gpio_avdd[1] != INVALID_GPIO) {
+		gpio_direction_output(panel->gpio_avdd[1], 1);
+	}
+
 	if(panel->gpio_bl != INVALID_GPIO) {
 		gpio_direction_output(panel->gpio_bl, 1);
 	}
@@ -623,6 +638,20 @@ static int spacemit_panel_probe(struct mipi_dsi_device *slave)
 		}
 	}
 
+	ret = of_property_read_u32_array(dev->of_node, "gpios-avdd", panel->gpio_avdd, 2);
+	if (ret || !gpio_is_valid(panel->gpio_avdd[0]) || !gpio_is_valid(panel->gpio_avdd[1])) {
+		dev_dbg(dev, "Missing avdd property: gpios-avdd\n");
+		panel->gpio_avdd[0] = INVALID_GPIO;
+		panel->gpio_avdd[1] = INVALID_GPIO;
+	} else {
+		ret = gpio_request(panel->gpio_avdd[0], NULL);
+		ret |= gpio_request(panel->gpio_avdd[1], NULL);
+		if (ret) {
+			pr_err("gpio_avdd request fail\n");
+			return ret;
+		}
+	}
+
 	if (of_property_read_u32(dev->of_node, "reset-toggle-cnt", &panel->reset_toggle_cnt))
 		panel->reset_toggle_cnt = LCD_PANEL_RESET_CNT;
 
diff --git a/drivers/gpu/drm/spacemit/spacemit_mipi_panel.h b/drivers/gpu/drm/spacemit/spacemit_mipi_panel.h
index 76050d2b4f02..15d37d1d9f39 100644
--- a/drivers/gpu/drm/spacemit/spacemit_mipi_panel.h
+++ b/drivers/gpu/drm/spacemit/spacemit_mipi_panel.h
@@ -84,6 +84,7 @@ struct spacemit_panel {
 	u32 gpio_reset;
 	u32 gpio_bl;
 	u32 gpio_dc[2];
+	u32 gpio_avdd[2];
 	atomic_t enable_refcnt;
 	atomic_t prepare_refcnt;
 	u32 reset_toggle_cnt;
diff --git a/drivers/input/misc/Kconfig b/drivers/input/misc/Kconfig
index 1cb3daa256b0..d260eec8de70 100644
--- a/drivers/input/misc/Kconfig
+++ b/drivers/input/misc/Kconfig
@@ -899,6 +899,13 @@ config INPUT_SPACEMIT_POWERKEY
 	  To compile this driver as a module, choose M here: the
 	  module will be called spacemit-pwrkey.
 
+config HALL_SENSOR_AS1911
+	tristate "Spacemit Hall Sensor Driver"
+	depends on INPUT
+	help
+	  Say Y here if you want to enable the Hall sensor AS1911 driver with
+	  interrupt support.
+
 config INPUT_RAVE_SP_PWRBUTTON
 	tristate "RAVE SP Power button Driver"
 	depends on RAVE_SP_CORE
diff --git a/drivers/input/misc/Makefile b/drivers/input/misc/Makefile
index 07667f786a62..9ecf5d9dab4d 100644
--- a/drivers/input/misc/Makefile
+++ b/drivers/input/misc/Makefile
@@ -90,3 +90,4 @@ obj-$(CONFIG_INPUT_XEN_KBDDEV_FRONTEND)	+= xen-kbdfront.o
 obj-$(CONFIG_INPUT_YEALINK)		+= yealink.o
 obj-$(CONFIG_INPUT_IDEAPAD_SLIDEBAR)	+= ideapad_slidebar.o
 obj-$(CONFIG_INPUT_SPACEMIT_POWERKEY)	+= spacemit-pwrkey.o
+obj-$(CONFIG_HALL_SENSOR_AS1911)	+= hall_sensor_as1911.o
\ No newline at end of file
diff --git a/drivers/input/misc/hall_sensor_as1911.c b/drivers/input/misc/hall_sensor_as1911.c
new file mode 100755
index 000000000000..c80dfff44696
--- /dev/null
+++ b/drivers/input/misc/hall_sensor_as1911.c
@@ -0,0 +1,118 @@
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/input.h>
+#include <linux/gpio.h>
+#include <linux/property.h>
+#include <linux/of.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/of_gpio.h>
+
+/**
+ * struct hall_sensor
+ *
+ * This struct is used by the hall_sensor driver to setup GPIO lines and to
+ * detect state changes using interrupts.
+ */
+struct hall_sensor {
+	int gpio;
+	int irq;
+	struct input_dev *input;
+	int lid_open;  // Indicates the lid state: 1 means the lid is open, 0 means the lid is closed
+};
+
+static irqreturn_t hall_sensor_isr(int irq, void *dev_id)
+{
+	struct hall_sensor *sensor = dev_id;
+	int state = gpio_get_value(sensor->gpio);
+
+	if (sensor->lid_open != state) {
+		sensor->lid_open = state;
+
+		// Report the lid state
+		input_report_switch(sensor->input, SW_LID, state);
+
+		// Send KEY_POWER event
+		input_report_key(sensor->input, KEY_POWER, 1);
+		input_sync(sensor->input);
+		input_report_key(sensor->input, KEY_POWER, 0);
+		input_sync(sensor->input);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int hall_sensor_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct hall_sensor *sensor;
+	int err;
+	int detect_pin;
+
+	sensor = devm_kzalloc(dev, sizeof(*sensor), GFP_KERNEL);
+	if (!sensor)
+		return -ENOMEM;
+
+	detect_pin = of_get_named_gpio(dev->of_node, "detect-gpio", 0);
+	if (detect_pin < 0)
+		return -EINVAL;
+
+	err = devm_gpio_request_one(dev, detect_pin, GPIOF_IN, "detect-gpio");
+	if (err)
+		return err;
+
+	sensor->gpio = detect_pin;
+
+	sensor->irq = gpio_to_irq(detect_pin);
+	if (sensor->irq < 0)
+		return sensor->irq;
+
+	sensor->input = devm_input_allocate_device(dev);
+	if (!sensor->input)
+		return -ENOMEM;
+
+	sensor->input->name = pdev->name;
+	sensor->input->id.bustype = BUS_HOST;
+
+	input_set_drvdata(sensor->input, sensor);
+
+	input_set_capability(sensor->input, EV_SW, SW_LID);
+	input_set_capability(sensor->input, EV_KEY, KEY_POWER);
+
+	err = devm_request_threaded_irq(
+		dev, sensor->irq, NULL, hall_sensor_isr,
+		IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
+		"hall_sensor", sensor);
+	if (err)
+		return err;
+
+	sensor->lid_open = gpio_get_value(sensor->gpio);
+
+	err = input_register_device(sensor->input);
+	if (err)
+		return err;
+
+	return 0;
+}
+
+static const struct of_device_id hall_sensor_of_match[] = {
+	{
+		.compatible = "spacemit,hall-sensor-as1911",
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, hall_sensor_of_match);
+
+static struct platform_driver hall_sensor_device_driver = {
+	.probe = hall_sensor_probe,
+	.driver = {
+		.name = "hall-sensor-as1911",
+		.of_match_table = hall_sensor_of_match,
+	}
+};
+module_platform_driver(hall_sensor_device_driver);
+
+MODULE_AUTHOR("goumin");
+MODULE_DESCRIPTION("Hall sensor driver with interrupt support");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:hall-sensor");
diff --git a/drivers/mmc/host/sdhci-of-k1x.c b/drivers/mmc/host/sdhci-of-k1x.c
index 6fc6555b4c75..fc9d388d637b 100644
--- a/drivers/mmc/host/sdhci-of-k1x.c
+++ b/drivers/mmc/host/sdhci-of-k1x.c
@@ -31,6 +31,7 @@
 #include <linux/pm_runtime.h>
 #include <linux/slab.h>
 #include <linux/reset.h>
+#include <linux/cpufreq.h>
 
 #include "sdhci.h"
 #include "sdhci-pltfm.h"
@@ -1181,6 +1182,8 @@ static int spacemit_sdhci_execute_sw_tuning(struct sdhci_host *host, u32 opcode)
 	struct mmc_ios ios = mmc->ios;
 	struct k1x_sdhci_platdata *pdata = mmc->parent->platform_data;
 	struct rx_tuning *rxtuning = &pdata->rxtuning;
+	struct cpufreq_policy *policy;
+	unsigned int clk_rate;
 
 	/*
 	 * Tuning is required for SDR50/SDR104, HS200/HS400 cards and
@@ -1229,6 +1232,22 @@ static int spacemit_sdhci_execute_sw_tuning(struct sdhci_host *host, u32 opcode)
 		return 0;
 	}
 
+	/* specify cpu freq during tuning rx windows if current cpufreq exceed 1.6G */
+	if (pdata->rx_tuning_freq) {
+		clk_rate= cpufreq_generic_get(0);
+		if (clk_rate && (clk_rate != pdata->rx_tuning_freq)) {
+			policy = cpufreq_cpu_get(0);
+			if (policy) {
+				ret = cpufreq_driver_target(policy, pdata->rx_tuning_freq, 0);
+				pr_info("%s: change cpu frequency from %d to %d before tuning\n", mmc_hostname(mmc),
+					clk_rate, pdata->rx_tuning_freq);
+				if (ret)
+					pr_err("%s: failed to change cpu frequency before tuning, err: %d\n",
+						mmc_hostname(mmc), ret);
+			}
+		}
+	}
+
 	rxtuning->select_delay_num = 0;
 	rxtuning->current_delay_index = 0;
 	memset(rxtuning->windows, 0, sizeof(rxtuning->windows));
@@ -1242,13 +1261,14 @@ static int spacemit_sdhci_execute_sw_tuning(struct sdhci_host *host, u32 opcode)
 	if (ret) {
 		pr_warn("%s: abort tuning, err:%d\n", mmc_hostname(mmc), ret);
 		rxtuning->tuning_fail = 1;
-		return ret;
+		goto restore_freq;
 	}
 
 	if (!spacemit_sw_rx_select_delay(host)) {
 		pr_warn("%s: fail to get delaycode\n", mmc_hostname(mmc));
 		rxtuning->tuning_fail = 1;
-		return -EIO;
+		ret = -EIO;
+		goto restore_freq;
 	}
 
 	/* step 3: set the delay code and store card cid */
@@ -1257,7 +1277,15 @@ static int spacemit_sdhci_execute_sw_tuning(struct sdhci_host *host, u32 opcode)
 	rxtuning->tuning_fail = 0;
 	pr_info("%s: tuning done, use the firstly delay_code:%d\n",
 		mmc_hostname(mmc), rxtuning->select_delay[0]);
-	return 0;
+
+restore_freq:
+	if (pdata->rx_tuning_freq) {
+		if (clk_rate)
+			cpufreq_driver_target(policy, clk_rate, 0);
+		if (policy)
+			cpufreq_cpu_put(policy);
+	}
+	return ret;
 }
 
 static unsigned int spacemit_sdhci_clk_get_max_clock(struct sdhci_host *host)
@@ -1477,6 +1505,10 @@ static void spacemit_get_of_property(struct sdhci_host *host,
 	else
 		pdata->phy_driver_sel = PHY_DRIVE_SEL_DEFAULT;
 
+	/* read rx tuning cpufreq, unit 1000Hz */
+	if (!of_property_read_u32(np, "spacemit,rx_tuning_freq", &property))
+		pdata->rx_tuning_freq = property;
+
 	return;
 }
 
diff --git a/drivers/net/ethernet/spacemit/k1x-emac.c b/drivers/net/ethernet/spacemit/k1x-emac.c
index 4077948874e6..a59f49214dfa 100644
--- a/drivers/net/ethernet/spacemit/k1x-emac.c
+++ b/drivers/net/ethernet/spacemit/k1x-emac.c
@@ -911,24 +911,11 @@ int emac_up(struct emac_priv *priv)
 #ifdef CONFIG_PM_SLEEP
 	pm_runtime_get_sync(&pdev->dev);
 #endif
-	if (priv->ref_clk_frm_soc) {
-		ret = clk_prepare_enable(priv->phy_clk);
-		if (ret < 0) {
-			pr_err("failed to enable phy clock: %d\n", ret);
-			goto err;
-		}
-	}
-
-	ret = clk_prepare_enable(priv->mac_clk);
-	if (ret < 0) {
-		pr_err("failed to enable mac clock: %d\n", ret);
-		goto disable_phy_clk;
-	}
 
 	ret = emac_phy_connect(ndev);
 	if (ret) {
 		pr_err("%s  phy_connet failed\n", __func__);
-		goto disable_mac_clk;
+		goto err;
 	}
 	/* init hardware */
 	emac_init_hw(priv);
@@ -980,11 +967,6 @@ int emac_up(struct emac_priv *priv)
 		phy_stop(ndev->phydev);
 		phy_disconnect(ndev->phydev);
 	}
-disable_mac_clk:
-		clk_disable_unprepare(priv->mac_clk);
-disable_phy_clk:
-	if (priv->ref_clk_frm_soc)
-		clk_disable_unprepare(priv->phy_clk);
 err:
 #ifdef CONFIG_PM_SLEEP
 	pm_runtime_put_sync(&pdev->dev);
@@ -1030,10 +1012,6 @@ int emac_down(struct emac_priv *priv)
 	emac_reset_hw(priv);
 	netif_carrier_off(ndev);
 
-	clk_disable_unprepare(priv->mac_clk);
-	if (priv->ref_clk_frm_soc)
-		clk_disable_unprepare(priv->phy_clk);
-
 #ifdef CONFIG_PM_SLEEP
 	pm_runtime_put_sync(&pdev->dev);
 #endif
@@ -2322,8 +2300,6 @@ static int emac_mdio_init(struct emac_priv *priv)
 		return -ENODEV;
 	}
 
-	/* Indicate that the MAC is responsible for PHY PM */
-	priv->phy->mac_managed_pm = true;
 err_put_node:
 	of_node_put(mii_np);
 	return ret;
@@ -2775,10 +2751,6 @@ static int emac_probe(struct platform_device *pdev)
 
 	netif_napi_add(ndev, &priv->napi, emac_rx_poll);
 
-	if (priv->ref_clk_frm_soc)
-		clk_disable_unprepare(priv->phy_clk);
-	clk_disable_unprepare(priv->mac_clk);
-
 	return 0;
 err_mdio_deinit:
 	emac_mdio_deinit(priv);
@@ -2826,13 +2798,35 @@ static int emac_resume(struct device *dev)
 {
 	struct emac_priv *priv = dev_get_drvdata(dev);
 	struct net_device *ndev = priv->ndev;
+	int ret;
 
-	if (!netif_running(ndev))
+	if (priv->ref_clk_frm_soc) {
+		ret = clk_prepare_enable(priv->phy_clk);
+		if (ret < 0) {
+			pr_err("failed to enable phy clock: %d\n", ret);
+			goto err;
+		}
+	}
+
+	ret = clk_prepare_enable(priv->mac_clk);
+	if (ret < 0) {
+		pr_err("failed to enable mac clock: %d\n", ret);
+		goto disable_phy_clk;
+	}
+
+	if (!netif_running(ndev)) {
 		return 0;
+	}
 
 	emac_open(ndev);
 	netif_device_attach(ndev);
 	return 0;
+
+disable_phy_clk:
+	if (priv->ref_clk_frm_soc)
+		clk_disable_unprepare(priv->phy_clk);
+err:
+	return ret;
 }
 
 static int emac_suspend(struct device *dev)
@@ -2840,11 +2834,17 @@ static int emac_suspend(struct device *dev)
 	struct emac_priv *priv = dev_get_drvdata(dev);
 	struct net_device *ndev = priv->ndev;
 
-
-	if (!ndev || !netif_running(ndev))
+	if (!ndev || !netif_running(ndev)) {
+		clk_disable_unprepare(priv->mac_clk);
+		if (priv->ref_clk_frm_soc)
+			clk_disable_unprepare(priv->phy_clk);
 		return 0;
+	}
 
 	emac_close(ndev);
+	clk_disable_unprepare(priv->mac_clk);
+	if (priv->ref_clk_frm_soc)
+		clk_disable_unprepare(priv->phy_clk);
 	netif_device_detach(ndev);
 	return 0;
 }
diff --git a/drivers/pci/controller/dwc/pcie-k1x.c b/drivers/pci/controller/dwc/pcie-k1x.c
index f958c6f3ca62..f5b519bf7f0e 100644
--- a/drivers/pci/controller/dwc/pcie-k1x.c
+++ b/drivers/pci/controller/dwc/pcie-k1x.c
@@ -469,7 +469,7 @@ void rterm_force(struct k1x_pcie *k1x, u32 pcie_rcal)
 
 static int init_phy(struct k1x_pcie *k1x)
 {
-	u32 rd_data, pcie_rcal;
+	u32 reg, rd_data, pcie_rcal;
 	u32 val = 0;
 	int count;
 
@@ -504,6 +504,27 @@ static int init_phy(struct k1x_pcie *k1x)
 	}
 
 	k1x->pcie_rcal = pcie_rcal;
+
+	/* disable ltssm and phy */
+	reg = k1x_pcie_readl(k1x, PCIECTRL_K1X_CONF_DEVICE_CMD);
+	reg &= ~(0x7f);
+	k1x_pcie_writel(k1x, PCIECTRL_K1X_CONF_DEVICE_CMD, reg);
+
+	/* soft reset */
+	reg = k1x_pcie_readl(k1x, PCIE_CTRL_LOGIC);
+	reg |= (1 << 0);
+	k1x_pcie_writel(k1x, PCIE_CTRL_LOGIC, reg);
+
+	mdelay(2);
+	/* soft no reset */
+	reg = k1x_pcie_readl(k1x, PCIE_CTRL_LOGIC);
+	reg &= ~(1 << 0);
+	k1x_pcie_writel(k1x, PCIE_CTRL_LOGIC, reg);
+
+	reg = k1x_pcie_readl(k1x, PCIECTRL_K1X_CONF_DEVICE_CMD);
+	reg |= 0x3f;
+	k1x_pcie_writel(k1x, PCIECTRL_K1X_CONF_DEVICE_CMD, reg);
+
 	rterm_force(k1x, pcie_rcal);
 
 	pr_debug("Now int init_puphy...\n");
diff --git a/drivers/phy/spacemit/phy-spacemit-k1x-combphy.c b/drivers/phy/spacemit/phy-spacemit-k1x-combphy.c
index 374c621dff79..ddd40d3fbf1f 100644
--- a/drivers/phy/spacemit/phy-spacemit-k1x-combphy.c
+++ b/drivers/phy/spacemit/phy-spacemit-k1x-combphy.c
@@ -29,6 +29,7 @@
 #define SPACEMIT_COMBPHY_USB_PLL_REG 0x8
 #define SPACEMIT_COMBPHY_USB_PLL_MASK 0x1
 #define SPACEMIT_COMBPHY_USB_PLL_VAL 0x1
+#define SPACEMIT_COMBPHY_USB_TERM_SHORT 0x3000
 
 struct spacemit_combphy_priv;
 
@@ -41,6 +42,7 @@ struct spacemit_combphy_priv {
 	void __iomem *puphy_base;
 	struct phy *phy;
 	u8 type;
+	bool suspend_term_quirk;
 };
 
 static inline void spacemit_reg_updatel(void __iomem *reg, u32 offset, u32 mask,
@@ -93,6 +95,10 @@ static int spacemit_combphy_init_usb(struct spacemit_combphy_priv *priv)
 					  SPACEMIT_COMBPHY_USB_PLL_MASK,
 					  SPACEMIT_COMBPHY_USB_PLL_VAL);
 
+	if (priv->suspend_term_quirk) {
+		spacemit_reg_updatel(base, 0x18, 0, SPACEMIT_COMBPHY_USB_TERM_SHORT);
+	}
+
 	if (ret)
 		dev_err(priv->dev, "USB3 PHY init timeout!\n");
 
@@ -208,7 +214,7 @@ static int spacemit_combphy_probe(struct platform_device *pdev)
 		ret = PTR_ERR(priv->phy_sel);
 		return ret;
 	}
-
+	priv->suspend_term_quirk = device_property_read_bool(&pdev->dev, "suspend-term-quirk");
 	priv->dev = dev;
 	priv->type = PHY_NONE;
 
diff --git a/drivers/power/supply/sbs-battery.c b/drivers/power/supply/sbs-battery.c
index 30bff75d2aeb..f20e3ae9cdcc 100644
--- a/drivers/power/supply/sbs-battery.c
+++ b/drivers/power/supply/sbs-battery.c
@@ -672,13 +672,15 @@ static int sbs_get_battery_property(struct i2c_client *client,
 				chip->poll_time = 0;
 			}
 		} else if (psp == POWER_SUPPLY_PROP_CAPACITY) {
-			/* Check if the battery is fully charged */
+			/* Check if the battery is fully charged or nearly full and not charging */
 			union power_supply_propval status_val;
 			int status_index = sbs_get_property_index(client, POWER_SUPPLY_PROP_STATUS);
 			if (status_index >= 0) {
 				sbs_get_battery_property(client, status_index, POWER_SUPPLY_PROP_STATUS, &status_val);
 				if (status_val.intval == POWER_SUPPLY_STATUS_FULL) {
 					val->intval = 100;
+				} else if (ret >= 98 && status_val.intval == POWER_SUPPLY_STATUS_NOT_CHARGING) {
+					val->intval = 100;
 				} else {
 					val->intval = min(ret, 100);
 				}
@@ -703,6 +705,7 @@ static int sbs_get_battery_property(struct i2c_client *client,
 	return 0;
 }
 
+
 static const char *sbs_get_constant_string(struct sbs_info *chip,
 			enum power_supply_property psp)
 {
diff --git a/drivers/soc/spacemit/spacemit-rf/spacemit-pwrseq.c b/drivers/soc/spacemit/spacemit-rf/spacemit-pwrseq.c
index 4e1b5129ef15..fe9cd20545ef 100644
--- a/drivers/soc/spacemit/spacemit-rf/spacemit-pwrseq.c
+++ b/drivers/soc/spacemit/spacemit-rf/spacemit-pwrseq.c
@@ -234,7 +234,7 @@ static int spacemit_pwrseq_probe(struct platform_device *pdev)
 
 	if(device_property_read_u32(dev, "power-on-delay-ms",
 				 &pwrseq->power_on_delay_ms))
-		pwrseq->power_on_delay_ms = 10;
+		pwrseq->power_on_delay_ms = 100;
 
 	if(device_property_read_bool(dev, "power-always-on"))
 		pwrseq->always_on = true;
diff --git a/drivers/tty/serial/pxa_k1x.c b/drivers/tty/serial/pxa_k1x.c
index 73be034c3da9..191a642860dc 100644
--- a/drivers/tty/serial/pxa_k1x.c
+++ b/drivers/tty/serial/pxa_k1x.c
@@ -650,7 +650,7 @@ static void serial_pxa_set_mctrl(struct uart_port *port, unsigned int mctrl)
 
 #ifdef CONFIG_BT
 	if (up->port.line == BT_UART_PORT)
-		pr_info("%s: rts: 0x%x\n", __func__, mcr & UART_MCR_RTS);
+		pr_debug("%s: rts: 0x%x\n", __func__, mcr & UART_MCR_RTS);
 #endif
 }
 
@@ -1540,7 +1540,6 @@ void serial_pxa_get_qos(int port)
 
 	up = serial_pxa_ports[port];
 	if (!mod_timer(&up->pxa_timer, jiffies + PXA_TIMER_TIMEOUT)) {
-		pr_info("bluesleep: %s: get qos\n", __func__);
 		pm_runtime_get_sync(up->port.dev);
 	}
 
@@ -1565,7 +1564,7 @@ void serial_pxa_assert_rts(int port)
 	spin_lock_irqsave(&up->port.lock, flags);
 	if (!serial_pxa_is_open(up)) {
 		spin_unlock_irqrestore(&up->port.lock, flags);
-		pr_info("%s: uart %d is shutdown\n", __func__, port);
+		pr_err("%s: uart %d is shutdown\n", __func__, port);
 		return;
 	}
 	serial_pxa_set_mctrl(&up->port, up->port.mctrl | TIOCM_RTS);
@@ -1593,7 +1592,7 @@ void serial_pxa_deassert_rts(int port)
 	spin_lock_irqsave(&up->port.lock, flags);
 	if (!serial_pxa_is_open(up)) {
 		spin_unlock_irqrestore(&up->port.lock, flags);
-		pr_info("%s: uart %d is shutdown\n", __func__, port);
+		pr_err("%s: uart %d is shutdown\n", __func__, port);
 		return;
 	}
 	serial_pxa_set_mctrl(&up->port, up->port.mctrl & ~TIOCM_RTS);
@@ -2007,9 +2006,6 @@ static void _pxa_timer_handler(struct uart_pxa_port *up)
 #if SUPPORT_POWER_QOS
 	pm_runtime_put_sync(up->port.dev);
 #endif
-	if (up->port.line == BT_UART_PORT) {
-		pr_info("bluesleep: %s: release qos\n", __func__);
-	}
 }
 
 static void pxa_timer_handler(struct timer_list *t)
diff --git a/drivers/usb/host/ehci-k1x-ci.c b/drivers/usb/host/ehci-k1x-ci.c
index e457d1684649..ab26783d76df 100644
--- a/drivers/usb/host/ehci-k1x-ci.c
+++ b/drivers/usb/host/ehci-k1x-ci.c
@@ -285,7 +285,7 @@ static int mv_ehci_probe(struct platform_device *pdev)
 	if (usb_disabled())
 		return -ENODEV;
 
-	hcd = usb_create_hcd(&mv_ehci_hc_driver, &pdev->dev, "mv ehci");
+	hcd = usb_create_hcd(&mv_ehci_hc_driver, &pdev->dev, dev_name(dev));
 	if (!hcd)
 		return -ENOMEM;
 
diff --git a/include/linux/platform_data/k1x_sdhci.h b/include/linux/platform_data/k1x_sdhci.h
index 96ba444ada34..043b3d732089 100644
--- a/include/linux/platform_data/k1x_sdhci.h
+++ b/include/linux/platform_data/k1x_sdhci.h
@@ -90,6 +90,7 @@ struct k1x_sdhci_platdata {
 	u32 curr_dllcfg1;
 	u32 new_dllcfg1;
 	u8 dllcfg1_odd_reset;
+	u32 rx_tuning_freq;
 };
 
 #endif /* _K1X_SDHCI_H_ */
-- 
2.39.2

