diff -Naur a/arch/arm64/boot/dts/amlogic/meson-g12-common.dtsi b/arch/arm64/boot/dts/amlogic/meson-g12-common.dtsi
--- a/arch/arm64/boot/dts/amlogic/meson-g12-common.dtsi	2022-07-07 11:53:35.000000000 -0400
+++ b/arch/arm64/boot/dts/amlogic/meson-g12-common.dtsi	2022-07-08 19:06:40.000000000 -0400
@@ -236,6 +236,8 @@
 				      "timing-adjustment";
 			rx-fifo-depth = <4096>;
 			tx-fifo-depth = <2048>;
+			resets = <&reset RESET_ETHERNET>;
+			reset-names = "stmmaceth";
 			status = "disabled";
 
 			mdio0: mdio {
diff -Naur a/arch/arm64/boot/dts/amlogic/meson-gxl.dtsi b/arch/arm64/boot/dts/amlogic/meson-gxl.dtsi
--- a/arch/arm64/boot/dts/amlogic/meson-gxl.dtsi	2022-07-07 11:53:35.000000000 -0400
+++ b/arch/arm64/boot/dts/amlogic/meson-gxl.dtsi	2022-07-08 19:06:40.000000000 -0400
@@ -134,6 +134,8 @@
 		 <&clkc CLKID_MPLL2>,
 		 <&clkc CLKID_FCLK_DIV2>;
 	clock-names = "stmmaceth", "clkin0", "clkin1", "timing-adjustment";
+	resets = <&reset RESET_ETHERNET>;
+	reset-names = "stmmaceth";
 
 	mdio0: mdio {
 		#address-cells = <1>;
diff -Naur a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c	2022-07-07 11:53:35.000000000 -0400
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c	2022-07-08 19:06:40.000000000 -0400
@@ -1172,7 +1172,6 @@
 
 	writel(ctrl, priv->ioaddr + MAC_CTRL_REG);
 
-	stmmac_mac_set(priv, priv->ioaddr, true);
 	if (phy && priv->dma_cap.eee) {
 		priv->eee_active = phy_init_eee(phy, 1) >= 0;
 		priv->eee_enabled = stmmac_eee_init(priv);
diff -Naur a/drivers/net/mdio/mdio-mux-meson-g12a.c b/drivers/net/mdio/mdio-mux-meson-g12a.c
--- a/drivers/net/mdio/mdio-mux-meson-g12a.c	2022-07-07 11:53:35.000000000 -0400
+++ b/drivers/net/mdio/mdio-mux-meson-g12a.c	2022-07-08 19:06:40.000000000 -0400
@@ -4,6 +4,7 @@
  */
 
 #include <linux/bitfield.h>
+#include <linux/delay.h>
 #include <linux/clk.h>
 #include <linux/clk-provider.h>
 #include <linux/device.h>
@@ -151,6 +152,7 @@
 static int g12a_enable_internal_mdio(struct g12a_mdio_mux *priv)
 {
 	int ret;
+	u32 value;
 
 	/* Enable the phy clock */
 	if (!priv->pll_is_enabled) {
@@ -163,18 +165,25 @@
 
 	/* Initialize ephy control */
 	writel(EPHY_G12A_ID, priv->regs + ETH_PHY_CNTL0);
-	writel(FIELD_PREP(PHY_CNTL1_ST_MODE, 3) |
-	       FIELD_PREP(PHY_CNTL1_ST_PHYADD, EPHY_DFLT_ADD) |
-	       FIELD_PREP(PHY_CNTL1_MII_MODE, EPHY_MODE_RMII) |
-	       PHY_CNTL1_CLK_EN |
-	       PHY_CNTL1_CLKFREQ |
-	       PHY_CNTL1_PHY_ENB,
-	       priv->regs + ETH_PHY_CNTL1);
+
+	/* Make sure we get a 0 -> 1 transition on the enable bit */
+	value = FIELD_PREP(PHY_CNTL1_ST_MODE, 3) |
+		FIELD_PREP(PHY_CNTL1_ST_PHYADD, EPHY_DFLT_ADD) |
+		FIELD_PREP(PHY_CNTL1_MII_MODE, EPHY_MODE_RMII) |
+		PHY_CNTL1_CLK_EN |
+		PHY_CNTL1_CLKFREQ;
+	writel(value, priv->regs + ETH_PHY_CNTL1);
+	value |= PHY_CNTL1_PHY_ENB;
+	writel(value, priv->regs + ETH_PHY_CNTL1);
+
 	writel(PHY_CNTL2_USE_INTERNAL |
 	       PHY_CNTL2_SMI_SRC_MAC |
 	       PHY_CNTL2_RX_CLK_EPHY,
 	       priv->regs + ETH_PHY_CNTL2);
 
+	/* The phy needs a bit of time to come up */
+	mdelay(10);
+
 	return 0;
 }
 
diff -Naur a/drivers/net/phy/meson-gxl.c b/drivers/net/phy/meson-gxl.c
--- a/drivers/net/phy/meson-gxl.c	2022-07-07 11:53:35.000000000 -0400
+++ b/drivers/net/phy/meson-gxl.c	2022-07-08 19:06:40.000000000 -0400
@@ -13,6 +13,7 @@
 #include <linux/phy.h>
 #include <linux/netdevice.h>
 #include <linux/bitfield.h>
+#include <linux/delay.h>
 
 #define TSTCNTL		20
 #define  TSTCNTL_READ		BIT(15)
@@ -40,6 +41,11 @@
 #define BANK_WOL		1
 #define BANK_BIST		3
 
+#define A3_CONFIG	0x14
+#define A6_CONFIG	0x17
+#define A7_CONFIG	0x18
+#define A8_CONFIG	0x1a
+
 /* WOL Registers */
 #define LPI_STATUS	0xc
 #define  LPI_STATUS_RSV12	BIT(12)
@@ -121,10 +127,60 @@
 	return ret;
 }
 
+static int meson_g12_analog_init(struct phy_device *phydev)
+{
+	int ret;
+
+	ret = meson_gxl_write_reg(phydev, BANK_ANALOG_DSP, A7_CONFIG, 0x3);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static void meson_g12_link_change_notify(struct phy_device *phydev)
+{
+	if (phydev->state == PHY_RUNNING && phydev->speed == SPEED_100) {
+		int ret = meson_g12_analog_init(phydev);
+
+		if (ret)
+			phydev_err(phydev, "Analog init failed\n");
+	}
+}
+
+static int meson_gxl_analog_init(struct phy_device *phydev)
+{
+	int ret;
+
+	ret = meson_gxl_write_reg(phydev, BANK_ANALOG_DSP, A3_CONFIG, 0xa900);
+	if (ret)
+		return ret;
+
+	ret = meson_gxl_write_reg(phydev, BANK_ANALOG_DSP, A7_CONFIG, 0xc);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static void meson_gxl_link_change_notify(struct phy_device *phydev)
+{
+	if (phydev->state == PHY_RUNNING && phydev->speed == SPEED_100) {
+		int ret = meson_gxl_analog_init(phydev);
+
+		if (ret)
+			phydev_err(phydev, "Analog init failed\n");
+	}
+}
+
 static int meson_gxl_config_init(struct phy_device *phydev)
 {
 	int ret;
 
+	ret = meson_gxl_write_reg(phydev, BANK_ANALOG_DSP, A6_CONFIG, 0x8E0D);
+	if (ret)
+		return ret;
+
 	/* Enable fractional PLL */
 	ret = meson_gxl_write_reg(phydev, BANK_BIST, FR_PLL_CONTROL, 0x5);
 	if (ret)
@@ -135,11 +191,26 @@
 	if (ret)
 		return ret;
 
-	/* Program fraction FR_PLL_DIV1 */
+	/* Program fraction FR_PLL_DIV0 */
 	ret = meson_gxl_write_reg(phydev, BANK_BIST, FR_PLL_DIV0, 0xaaaa);
 	if (ret)
 		return ret;
 
+	/* Let the PLL stabilize */
+	mdelay(10);
+
+	ret = meson_gxl_write_reg(phydev, BANK_ANALOG_DSP, A7_CONFIG, 0xc);
+	if (ret)
+		return ret;
+
+	ret = meson_gxl_write_reg(phydev, BANK_ANALOG_DSP, A6_CONFIG, 0x1A0C);
+	if (ret)
+		return ret;
+
+	ret = meson_gxl_write_reg(phydev, BANK_ANALOG_DSP, A8_CONFIG, 0x6400);
+	if (ret)
+		return ret;
+
 	return 0;
 }
 
@@ -243,13 +314,7 @@
 	    irq_status == INTSRC_ENERGY_DETECT)
 		return IRQ_HANDLED;
 
-	/* Give PHY some time before MAC starts sending data. This works
-	 * around an issue where network doesn't come up properly.
-	 */
-	if (!(irq_status & INTSRC_LINK_DOWN))
-		phy_queue_state_machine(phydev, msecs_to_jiffies(100));
-	else
-		phy_trigger_machine(phydev);
+	phy_trigger_machine(phydev);
 
 	return IRQ_HANDLED;
 }
@@ -267,16 +332,19 @@
 		.handle_interrupt = meson_gxl_handle_interrupt,
 		.suspend        = genphy_suspend,
 		.resume         = genphy_resume,
+		.link_change_notify	= meson_gxl_link_change_notify,
 	}, {
 		PHY_ID_MATCH_EXACT(0x01803301),
 		.name		= "Meson G12A Internal PHY",
 		/* PHY_BASIC_FEATURES */
 		.flags		= PHY_IS_INTERNAL,
+		.config_init	= meson_g12_analog_init,
 		.soft_reset     = genphy_soft_reset,
 		.config_intr	= meson_gxl_config_intr,
 		.handle_interrupt = meson_gxl_handle_interrupt,
 		.suspend        = genphy_suspend,
 		.resume         = genphy_resume,
+		.link_change_notify	= meson_g12_link_change_notify,
 	},
 };
 
