diff -Naur a/arch/arm/boot/dts/Makefile b/arch/arm/boot/dts/Makefile
--- a/arch/arm/boot/dts/Makefile	2021-10-31 16:53:10.000000000 -0400
+++ b/arch/arm/boot/dts/Makefile	2021-10-31 20:41:20.000000000 -0400
@@ -361,10 +361,14 @@
 	meson6-atv1200.dtb
 dtb-$(CONFIG_MACH_MESON8) += \
 	meson8-minix-neo-x8.dtb \
+	meson8-tronsmart-s82.dtb \
 	meson8b-ec100.dtb \
 	meson8b-mxq.dtb \
 	meson8b-odroidc1.dtb \
-	meson8m2-mxiii-plus.dtb
+	meson8m2-mxiii.dtb \
+	meson8m2-mxiii-plus.dtb \
+	meson8m2-m8s.dtb \
+	meson8m2-wetek-core.dtb
 dtb-$(CONFIG_ARCH_MMP) += \
 	pxa168-aspenite.dtb \
 	pxa910-dkb.dtb \
diff -Naur a/arch/arm/boot/dts/meson6.dtsi b/arch/arm/boot/dts/meson6.dtsi
--- a/arch/arm/boot/dts/meson6.dtsi	2021-10-31 16:53:10.000000000 -0400
+++ b/arch/arm/boot/dts/meson6.dtsi	2021-10-31 20:41:20.000000000 -0400
@@ -28,6 +28,18 @@
 		};
 	};
 
+	reserved-memory {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		/* 1 MiB reserved for Hardware ROM Firmware */
+		hwrom@0 {
+			reg = <0x1ff00000 0x100000>;
+			no-map;
+		};
+	};
+
 	apb2: bus@d0000000 {
 		compatible = "simple-bus";
 		reg = <0xd0000000 0x40000>;
diff -Naur a/arch/arm/boot/dts/meson8b.dtsi b/arch/arm/boot/dts/meson8b.dtsi
--- a/arch/arm/boot/dts/meson8b.dtsi	2021-10-31 16:53:10.000000000 -0400
+++ b/arch/arm/boot/dts/meson8b.dtsi	2021-10-31 20:41:20.000000000 -0400
@@ -276,6 +276,116 @@
 			operating-points-v2 = <&gpu_opp_table>;
 			#cooling-cells = <2>; /* min followed by max */
 		};
+
+		hdmi_tx: hdmi-tx@42000 {
+			compatible = "amlogic,meson8b-hdmi-tx";
+			reg = <0x42000 0xc>;
+			interrupts = <GIC_SPI 57 IRQ_TYPE_EDGE_RISING>;
+			phys = <&hdmi_tx_phy>;
+			phy-names = "hdmi";
+			clocks = <&clkc CLKID_HDMI_PCLK>,
+				 <&clkc CLKID_HDMI_SYS>;
+			clock-names = "pclk", "sys";
+
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			#sound-dai-cells = <1>;
+			sound-name-prefix = "HDMITX";
+
+			status = "disabled";
+
+			/* VPU VENC Input */
+			hdmi_tx_venc_port: port@0 {
+				reg = <0>;
+
+				hdmi_tx_in: endpoint {
+					remote-endpoint = <&hdmi_tx_out>;
+				};
+			};
+
+			/* TMDS Output */
+			hdmi_tx_tmds_port: port@1 {
+				reg = <1>;
+			};
+		};
+
+		vpu: vpu@100000 {
+			compatible = "amlogic,meson8b-vpu";
+
+			reg = <0x100000 0x10000>;
+			reg-names = "vpu";
+
+			interrupts = <GIC_SPI 3 IRQ_TYPE_EDGE_RISING>;
+
+			amlogic,canvas = <&canvas>;
+
+			/*
+			 * The VCLK{,2}_IN path always needs to derived from
+			 * the CLKID_VID_PLL_FINAL_DIV so other clocks like
+			 * MPLL1 are not used (MPLL1 is reserved for audio
+			 * purposes).
+			 */
+			assigned-clocks = <&clkc CLKID_VCLK_IN_SEL>,
+					  <&clkc CLKID_VCLK2_IN_SEL>;
+			assigned-clock-parents = <&clkc CLKID_VID_PLL_FINAL_DIV>,
+						 <&clkc CLKID_VID_PLL_FINAL_DIV>;
+
+			clocks = <&clkc CLKID_VPU_INTR>,
+				 <&clkc CLKID_HDMI_INTR_SYNC>,
+				 <&clkc CLKID_GCLK_VENCI_INT>,
+				 <&clkc CLKID_HDMI_PLL_HDMI_OUT>,
+				 <&clkc CLKID_HDMI_TX_PIXEL>,
+				 <&clkc CLKID_CTS_ENCP>,
+				 <&clkc CLKID_CTS_ENCI>,
+				 <&clkc CLKID_CTS_ENCT>,
+				 <&clkc CLKID_CTS_ENCL>,
+				 <&clkc CLKID_CTS_VDAC0>;
+			clock-names = "vpu_intr",
+				      "hdmi_intr_sync",
+				      "venci_int",
+				      "tmds",
+				      "hdmi_tx_pixel",
+				      "cts_encp",
+				      "cts_enci",
+				      "cts_enct",
+				      "cts_encl",
+				      "cts_vdac0";
+
+			resets = <&clkc CLKC_RESET_VID_DIVIDER_CNTL_RESET_N_PRE>,
+				 <&clkc CLKC_RESET_VID_DIVIDER_CNTL_RESET_N_POST>,
+				 <&clkc CLKC_RESET_VID_DIVIDER_CNTL_SOFT_RESET_PRE>,
+				 <&clkc CLKC_RESET_VID_DIVIDER_CNTL_SOFT_RESET_POST>;
+			reset-names = "vid_pll_pre",
+				      "vid_pll_post",
+				      "vid_pll_soft_pre",
+				      "vid_pll_soft_post";
+
+			phys = <&cvbs_dac>;
+			phy-names = "cvbs-dac";
+
+			power-domains = <&pwrc PWRC_MESON8_VPU_ID>;
+
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			#sound-dai-cells = <0>;
+			sound-name-prefix = "HDMITX";
+
+			/* CVBS VDAC output port */
+			cvbs_vdac_port: port@0 {
+				reg = <0>;
+			};
+
+			/* HDMI-TX output port */
+			hdmi_tx_port: port@1 {
+				reg = <1>;
+
+				hdmi_tx_out: endpoint {
+					remote-endpoint = <&hdmi_tx_in>;
+				};
+			};
+		};
 	};
 }; /* end of / */
 
@@ -322,7 +432,15 @@
 			reg-names = "mux", "pull", "gpio";
 			gpio-controller;
 			#gpio-cells = <2>;
-			gpio-ranges = <&pinctrl_aobus 0 0 16>;
+			gpio-ranges = <&pinctrl_aobus 0 0 15>;
+		};
+
+		hdmi_cec_ao_pins: hdmi-cec-ao {
+			mux {
+				groups = "hdmi_cec_1";
+				function = "hdmi_cec";
+				bias-pull-up;
+			};
 		};
 
 		i2s_am_clk_pins: i2s-am-clk-out {
@@ -381,6 +499,15 @@
 			};
 		};
 	};
+
+	cec_AO: cec@100 {
+		compatible = "amlogic,meson-gx-ao-cec"; // FIXME
+		reg = <0x100 0x14>;
+		interrupts = <GIC_SPI 151 IRQ_TYPE_EDGE_RISING>;
+		// TODO: 32768HZ clock
+		hdmi-phandle = <&hdmi_tx>;
+		status = "disabled";
+	};
 };
 
 &ao_arc_rproc {
@@ -389,6 +516,8 @@
 	sram = <&ao_arc_sram>;
 	resets = <&reset RESET_MEDIA_CPU>;
 	clocks = <&clkc CLKID_AO_MEDIA_CPU>;
+	status = "okay";
+	firmware-name = "zephyr.elf";
 };
 
 &cbus {
@@ -430,7 +559,7 @@
 			reg-names = "mux", "pull", "pull-enable", "gpio";
 			gpio-controller;
 			#gpio-cells = <2>;
-			gpio-ranges = <&pinctrl_cbus 0 0 83>;
+			gpio-ranges = <&pinctrl_cbus 0 0 84>;
 		};
 
 		eth_rgmii_pins: eth-rgmii {
@@ -471,6 +600,22 @@
 			};
 		};
 
+		hdmi_hpd_pins: hdmi-hpd {
+			mux {
+				groups = "hdmi_hpd";
+				function = "hdmi";
+				bias-disable;
+			};
+		};
+
+		hdmi_i2c_pins: hdmi-i2c {
+			mux {
+				groups = "hdmi_sda", "hdmi_scl";
+				function = "hdmi";
+				bias-disable;
+			};
+		};
+
 		i2c_a_pins: i2c-a {
 			mux {
 				groups = "i2c_sda_a", "i2c_sck_a";
@@ -547,6 +692,16 @@
 	};
 };
 
+&cvbs_dac {
+	compatible = "amlogic,meson8-cvbs-dac", "amlogic,meson-cvbs-dac";
+
+	clocks = <&clkc CLKID_CTS_VDAC0>;
+
+	nvmem-cells = <&cvbs_trimming>;
+	nvmem-cell-names = "cvbs_trimming";
+
+	status = "okay";
+};
 
 &efuse {
 	compatible = "amlogic,meson8b-efuse";
@@ -557,6 +712,10 @@
 		/* only the upper two bytes are relevant */
 		reg = <0x1f4 0x4>;
 	};
+
+	cvbs_trimming: calib@1f8 {
+		reg = <0x1f8 0x2>;
+	};
 };
 
 &ethmac {
@@ -586,16 +745,18 @@
 };
 
 &hhi {
-	clkc: clock-controller {
+	clkc: clock-controller@0 {
 		compatible = "amlogic,meson8b-clkc";
+		reg = <0x0 0x39c>;
 		clocks = <&xtal>, <&ddr_clkc DDR_CLKID_DDR_PLL>;
 		clock-names = "xtal", "ddr_pll";
 		#clock-cells = <1>;
 		#reset-cells = <1>;
 	};
 
-	pwrc: power-controller {
+	pwrc: power-controller@100 {
 		compatible = "amlogic,meson8b-pwrc";
+		reg = <0x100 0x10>;
 		#power-domain-cells = <1>;
 		amlogic,ao-sysctrl = <&pmu>;
 		resets = <&reset RESET_DBLK>,
@@ -617,6 +778,14 @@
 		assigned-clocks = <&clkc CLKID_VPU>;
 		assigned-clock-rates = <182142857>;
 	};
+
+	hdmi_tx_phy: hdmi-phy@3a0 {
+		compatible = "amlogic,meson8b-hdmi-tx-phy",
+			     "amlogic,meson8-hdmi-tx-phy";
+		clocks = <&clkc CLKID_HDMI_PLL_HDMI_OUT>;
+		reg = <0x3a0 0xc>;
+		#phy-cells = <0>;
+	};
 };
 
 &hwrng {
diff -Naur a/arch/arm/boot/dts/meson8b-ec100.dts b/arch/arm/boot/dts/meson8b-ec100.dts
--- a/arch/arm/boot/dts/meson8b-ec100.dts	2021-10-31 16:53:10.000000000 -0400
+++ b/arch/arm/boot/dts/meson8b-ec100.dts	2021-10-31 20:41:20.000000000 -0400
@@ -70,6 +70,17 @@
 		timeout-ms = <20000>;
 	};
 
+	hdmi-connector {
+		compatible = "hdmi-connector";
+		type = "a";
+
+		port {
+			hdmi_connector_in: endpoint {
+				remote-endpoint = <&hdmi_tx_tmds_out>;
+			};
+		};
+	};
+
 	leds {
 		compatible = "gpio-leds";
 
@@ -112,6 +123,10 @@
 		};
 
 		dai-link-1 {
+			sound-dai = <&aiu AIU_CPU CPU_SPDIF_FIFO>;
+		};
+
+		dai-link-2 {
 			sound-dai = <&aiu AIU_CPU CPU_I2S_ENCODER>;
 			dai-format = "i2s";
 			mclk-fs = <256>;
@@ -119,6 +134,36 @@
 			codec-0 {
 				sound-dai = <&rt5640>;
 			};
+
+			codec-1 {
+				sound-dai = <&aiu AIU_HDMI CTRL_I2S>;
+			};
+		};
+
+		dai-link-3 {
+			sound-dai = <&aiu AIU_CPU CPU_SPDIF_ENCODER>;
+
+			codec-0 {
+				sound-dai = <&hdmi_tx 1>;
+			};
+		};
+
+		dai-link-4 {
+			sound-dai = <&aiu AIU_HDMI CTRL_OUT>;
+
+			codec-0 {
+				sound-dai = <&hdmi_tx 0>;
+			};
+		};
+	};
+
+	tv-connector {
+		compatible = "composite-video-connector";
+
+		port {
+			cvbs_connector_in: endpoint {
+				remote-endpoint = <&cvbs_vdac_out>;
+			};
 		};
 	};
 
@@ -280,6 +325,12 @@
 	cpu-supply = <&vcck>;
 };
 
+&cvbs_vdac_port {
+	cvbs_vdac_out: endpoint {
+		remote-endpoint = <&cvbs_connector_in>;
+	};
+};
+
 &ethmac {
 	status = "okay";
 
@@ -310,6 +361,18 @@
 	};
 };
 
+&hdmi_tx {
+	status = "okay";
+	pinctrl-0 = <&hdmi_hpd_pins>, <&hdmi_i2c_pins>;
+	pinctrl-names = "default";
+};
+
+&hdmi_tx_tmds_port {
+	hdmi_tx_tmds_out: endpoint {
+		remote-endpoint = <&hdmi_connector_in>;
+	};
+};
+
 &i2c_A {
 	status = "okay";
 	pinctrl-0 = <&i2c_a_pins>;
@@ -394,7 +457,7 @@
 			  "I2S_IN", "SLP_S1_N",
 			  "TCK", "TMS", "TDI", "TDO",
 			  "HDMI_CEC", "5640_IRQ",
-			  "MUTE", "S805_TEST#";
+			  "S805_TEST#";
 };
 
 &gpio {
@@ -434,7 +497,9 @@
 			  "RMII_RXD1", "RMII_RXD0", "RMII_CRS_DV",
 			  "RMII_50M_IN", "GPIODIF_4", "GPIODIF_5",
 			  "RMII_TXEN", "CPUETH_25MOUT", "RMII_MDC",
-			  "RMII_MDIO";
+			  "RMII_MDIO",
+			  /* BSD_EN */
+			  "MUTE";
 };
 
 &pwm_cd {
diff -Naur a/arch/arm/boot/dts/meson8b-odroidc1.dts b/arch/arm/boot/dts/meson8b-odroidc1.dts
--- a/arch/arm/boot/dts/meson8b-odroidc1.dts	2021-10-31 16:53:10.000000000 -0400
+++ b/arch/arm/boot/dts/meson8b-odroidc1.dts	2021-10-31 20:41:20.000000000 -0400
@@ -7,6 +7,7 @@
 /dts-v1/;
 #include "meson8b.dtsi"
 #include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/net/realtek-rtl8211f.h>
 
 / {
 	model = "Hardkernel ODROID-C1";
@@ -32,6 +33,17 @@
 		reset-gpios = <&gpio BOOT_9 GPIO_ACTIVE_LOW>;
 	};
 
+	hdmi-connector {
+		compatible = "hdmi-connector";
+		type = "a";
+
+		port {
+			hdmi_connector_in: endpoint {
+				remote-endpoint = <&hdmi_tx_tmds_out>;
+			};
+		};
+	};
+
 	leds {
 		compatible = "gpio-leds";
 		blue {
@@ -93,6 +105,64 @@
 		#clock-cells = <0>;
 	};
 
+	sound {
+		compatible = "amlogic,gx-sound-card";
+		model = "M8B-ODROID-C1";
+
+		assigned-clocks = <&clkc CLKID_MPLL0>,
+				  <&clkc CLKID_MPLL1>;
+		assigned-clock-rates = <294912000>,
+				       <270950400>;
+
+		dai-link-0 {
+			sound-dai = <&aiu AIU_CPU CPU_I2S_FIFO>;
+		};
+
+		dai-link-1 {
+			sound-dai = <&aiu AIU_CPU CPU_SPDIF_FIFO>;
+		};
+
+		dai-link-2 {
+			sound-dai = <&aiu AIU_CPU CPU_I2S_ENCODER>;
+			dai-format = "i2s";
+			mclk-fs = <256>;
+
+			codec-0 {
+				sound-dai = <&aiu AIU_HDMI CTRL_I2S>;
+			};
+		};
+
+		dai-link-3 {
+			sound-dai = <&aiu AIU_CPU CPU_SPDIF_ENCODER>;
+
+			codec-0 {
+				sound-dai = <&hdmi_tx 1>;
+			};
+		};
+
+		dai-link-4 {
+			sound-dai = <&aiu AIU_HDMI CTRL_OUT>;
+
+			codec-0 {
+				sound-dai = <&hdmi_tx 0>;
+			};
+		};
+	};
+
+	usb0_vbus: regulator-usb0-vbus {
+		/* Richtek RT9715EGB */
+		compatible = "regulator-fixed";
+
+		regulator-name = "USB0_VBUS";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+
+		vin-supply = <&p5v0>;
+
+		gpio = <&gpio_ao GPIOAO_5 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+	};
+
 	vcc_1v8: regulator-vcc-1v8 {
 		/*
 		 * RICHTEK RT9179 configured for a fixed output voltage of
@@ -187,6 +257,12 @@
 	};
 };
 
+&aiu {
+	status = "okay";
+	pinctrl-0 = <&spdif_out_1_pins>;
+	pinctrl-names = "default";
+};
+
 &cpu0 {
 	cpu-supply = <&vcck>;
 };
@@ -225,6 +301,13 @@
 			interrupt-parent = <&gpio_intc>;
 			/* GPIOH_3 */
 			interrupts = <17 IRQ_TYPE_LEVEL_LOW>;
+
+			/* absent */
+			realtek,led-0-mode = <0>;
+			/* green */
+			realtek,led-1-mode = <(RTL8211F_LED_LINK_100 | RTL8211F_LED_ACTIVITY | RTL8211F_LED_EEE)>;
+			/* amber */
+			realtek,led-2-mode = <(RTL8211F_LED_LINK_1000 | RTL8211F_LED_ACTIVITY | RTL8211F_LED_EEE)>;
 		};
 	};
 };
@@ -270,7 +353,9 @@
 			  "ETH_RXD1", "ETH_RXD0", "ETH_RX_DV",
 			  "RGMII_RX_CLK", "ETH_RXD3", "ETH_RXD2",
 			  "ETH_TXEN", "ETH_PHY_REF_CLK_25MOUT",
-			  "ETH_MDC", "ETH_MDIO";
+			  "ETH_MDC", "ETH_MDIO",
+			  /* BSD_EN */
+			  "";
 };
 
 &gpio_ao {
@@ -280,7 +365,7 @@
 			  "IR_IN", "J7 Header Pin 4",
 			  "J7 Header Pin 6", "J7 Header Pin 5",
 			  "J7 Header Pin 7", "HDMI_CEC",
-			  "SYS_LED", "", "";
+			  "SYS_LED", "";
 
 	/*
 	 * WARNING: The USB Hub on the Odroid-C1/C1+ needs a reset signal
@@ -296,6 +381,18 @@
 	};
 };
 
+&hdmi_tx {
+	status = "okay";
+	pinctrl-0 = <&hdmi_hpd_pins>, <&hdmi_i2c_pins>;
+	pinctrl-names = "default";
+};
+
+&hdmi_tx_tmds_port {
+	hdmi_tx_tmds_out: endpoint {
+		remote-endpoint = <&hdmi_connector_in>;
+	};
+};
+
 &ir_receiver {
 	status = "okay";
 	pinctrl-0 = <&ir_recv_pins>;
@@ -376,10 +473,28 @@
 	pinctrl-names = "default";
 };
 
-&usb1_phy {
+&usb0 {
 	status = "okay";
+
+	dr_mode = "otg";
+	usb-role-switch;
+
+	connector {
+		compatible = "gpio-usb-b-connector", "usb-b-connector";
+		type = "micro";
+		id-gpios = <&usb0_phy 0 GPIO_ACTIVE_HIGH>;
+		vbus-supply = <&usb0_vbus>;
+	};
 };
 
 &usb1 {
 	status = "okay";
 };
+
+&usb0_phy {
+	status = "okay";
+};
+
+&usb1_phy {
+	status = "okay";
+};
diff -Naur a/arch/arm/boot/dts/meson8.dtsi b/arch/arm/boot/dts/meson8.dtsi
--- a/arch/arm/boot/dts/meson8.dtsi	2021-10-31 16:53:10.000000000 -0400
+++ b/arch/arm/boot/dts/meson8.dtsi	2021-10-31 20:41:20.000000000 -0400
@@ -193,6 +193,14 @@
 			reg = <0x4f00000 0x100000>;
 			no-map;
 		};
+
+		linux,cma {
+			compatible = "shared-dma-pool";
+			reusable;
+			size = <0x10000000>;
+			alignment = <0x400000>;
+			linux,cma-default;
+		};
 	};
 
 	thermal-zones {
@@ -314,6 +322,124 @@
 			operating-points-v2 = <&gpu_opp_table>;
 			#cooling-cells = <2>; /* min followed by max */
 		};
+
+		hdmi_tx: hdmi-tx@42000 {
+			compatible = "amlogic,meson8-hdmi-tx";
+			reg = <0x42000 0xc>;
+			interrupts = <GIC_SPI 57 IRQ_TYPE_EDGE_RISING>;
+			phys = <&hdmi_tx_phy>;
+			phy-names = "hdmi";
+			clocks = <&clkc CLKID_HDMI_PCLK>,
+				 <&clkc CLKID_HDMI_SYS>;
+			clock-names = "pclk", "sys";
+
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			#sound-dai-cells = <1>;
+			sound-name-prefix = "HDMITX";
+
+			status = "disabled";
+
+			/* VPU VENC Input */
+			hdmi_tx_venc_port: port@0 {
+				reg = <0>;
+
+				hdmi_tx_in: endpoint {
+					remote-endpoint = <&hdmi_tx_out>;
+				};
+			};
+
+			/* TMDS Output */
+			hdmi_tx_tmds_port: port@1 {
+				reg = <1>;
+			};
+		};
+
+		nfc: nand-controller@48600 {
+			compatible = "amlogic,meson8-nfc";
+			reg = <0x48600 0x24>;
+			interrupts = <GIC_SPI 34 IRQ_TYPE_EDGE_RISING>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			clocks = <&clkc CLKID_NAND>, <&clkc CLKID_NAND_CLK>;
+			clock-names = "core", "device";
+			status = "disabled";
+		};
+
+		vpu: vpu@100000 {
+			compatible = "amlogic,meson8-vpu";
+
+			reg = <0x100000 0x10000>;
+			reg-names = "vpu";
+
+			interrupts = <GIC_SPI 3 IRQ_TYPE_EDGE_RISING>;
+
+			amlogic,canvas = <&canvas>;
+
+			/*
+			 * The VCLK{,2}_IN path always needs to derived from
+			 * the CLKID_VID_PLL_FINAL_DIV so other clocks like
+			 * MPLL1 are not used (MPLL1 is reserved for audio
+			 * purposes).
+			 */
+			assigned-clocks = <&clkc CLKID_VCLK_IN_SEL>,
+					  <&clkc CLKID_VCLK2_IN_SEL>;
+			assigned-clock-parents = <&clkc CLKID_VID_PLL_FINAL_DIV>,
+						 <&clkc CLKID_VID_PLL_FINAL_DIV>;
+
+			clocks = <&clkc CLKID_VPU_INTR>,
+				 <&clkc CLKID_HDMI_INTR_SYNC>,
+				 <&clkc CLKID_GCLK_VENCI_INT>,
+				 <&clkc CLKID_HDMI_PLL_HDMI_OUT>,
+				 <&clkc CLKID_HDMI_TX_PIXEL>,
+				 <&clkc CLKID_CTS_ENCP>,
+				 <&clkc CLKID_CTS_ENCI>,
+				 <&clkc CLKID_CTS_ENCT>,
+				 <&clkc CLKID_CTS_ENCL>,
+				 <&clkc CLKID_CTS_VDAC0>;
+			clock-names = "vpu_intr",
+				      "hdmi_intr_sync",
+				      "venci_int",
+				      "tmds",
+				      "hdmi_tx_pixel",
+				      "cts_encp",
+				      "cts_enci",
+				      "cts_enct",
+				      "cts_encl",
+				      "cts_vdac0";
+
+			resets = <&clkc CLKC_RESET_VID_DIVIDER_CNTL_RESET_N_PRE>,
+				 <&clkc CLKC_RESET_VID_DIVIDER_CNTL_RESET_N_POST>,
+				 <&clkc CLKC_RESET_VID_DIVIDER_CNTL_SOFT_RESET_PRE>,
+				 <&clkc CLKC_RESET_VID_DIVIDER_CNTL_SOFT_RESET_POST>;
+			reset-names = "vid_pll_pre",
+				      "vid_pll_post",
+				      "vid_pll_soft_pre",
+				      "vid_pll_soft_post";
+
+			phys = <&cvbs_dac>;
+			phy-names = "cvbs-dac";
+
+			power-domains = <&pwrc PWRC_MESON8_VPU_ID>;
+
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			/* CVBS VDAC output port */
+			cvbs_vdac_port: port@0 {
+				reg = <0>;
+			};
+
+			/* HDMI-TX output port */
+			hdmi_tx_port: port@1 {
+				reg = <1>;
+
+				hdmi_tx_out: endpoint {
+					remote-endpoint = <&hdmi_tx_in>;
+				};
+			};
+		};
 	};
 }; /* end of / */
 
@@ -360,7 +486,15 @@
 			reg-names = "mux", "pull", "gpio";
 			gpio-controller;
 			#gpio-cells = <2>;
-			gpio-ranges = <&pinctrl_aobus 0 0 16>;
+			gpio-ranges = <&pinctrl_aobus 0 0 15>;
+		};
+
+		hdmi_cec_ao_pins: hdmi-cec-ao {
+			mux {
+				groups = "hdmi_cec_ao";
+				function = "hdmi_cec_ao";
+				bias-pull-up;
+			};
 		};
 
 		i2s_am_clk_pins: i2s-am-clk-out {
@@ -427,6 +561,15 @@
 			};
 		};
 	};
+
+	cec_AO: cec@100 {
+		compatible = "amlogic,meson-gx-ao-cec"; // FIXME
+		reg = <0x100 0x14>;
+		interrupts = <GIC_SPI 151 IRQ_TYPE_EDGE_RISING>;
+		// TODO: 32768HZ clock
+		hdmi-phandle = <&hdmi_tx>;
+		status = "disabled";
+	};
 };
 
 &ao_arc_rproc {
@@ -476,7 +619,37 @@
 			reg-names = "mux", "pull", "pull-enable", "gpio";
 			gpio-controller;
 			#gpio-cells = <2>;
-			gpio-ranges = <&pinctrl_cbus 0 0 120>;
+			gpio-ranges = <&pinctrl_cbus 0 0 121>;
+		};
+
+		hdmi_hpd_pins: hdmi-hpd {
+			mux {
+				groups = "hdmi_hpd";
+				function = "hdmi";
+				bias-disable;
+			};
+		};
+
+		hdmi_i2c_pins: hdmi-i2c {
+			mux {
+				groups = "hdmi_sda", "hdmi_scl";
+				function = "hdmi";
+				bias-disable;
+			};
+		};
+
+		pwm_c_dv9_pins: pwm-c-dv9 {
+			mux {
+				groups = "pwm_c_dv9";
+				function = "pwm_c";
+			};
+		};
+
+		pwm_d_pins: pwm-d {
+			mux {
+				groups = "pwm_d";
+				function = "pwm_d";
+			};
 		};
 
 		sd_a_pins: sd-a {
@@ -506,6 +679,15 @@
 			};
 		};
 
+		sdxc_a_pins: sdxc-a {
+			mux {
+				groups = "sdxc_d0_a", "sdxc_d13_a",
+					 "sdxc_clk_a", "sdxc_cmd_a";
+				function = "sdxc_a";
+				bias-pull-up;
+			};
+		};
+
 		sdxc_b_pins: sdxc-b {
 			mux {
 				groups = "sdxc_d0_b", "sdxc_d13_b",
@@ -543,6 +725,35 @@
 			};
 		};
 
+		nand_pins: nand {
+			mux {
+				groups = "nand_io",
+					"nand_ale",
+					"nand_cle",
+					"nand_wen_clk",
+					"nand_ren_clk",
+					"nand_dqs";
+				function = "nand";
+				bias-pull-down;
+			};
+		};
+
+		nand_ce0_pins: nand-ce0 {
+			mux {
+				groups = "nand_io_ce0";
+				function = "nand";
+				bias-pull-up;
+			};
+		};
+
+		nand_rb0_pins: nand-rb0 {
+			mux {
+				groups = "nand_io_rb0";
+				function = "nand";
+				bias-pull-up;
+			};
+		};
+
 		pwm_e_pins: pwm-e {
 			mux {
 				groups = "pwm_e";
@@ -568,6 +779,14 @@
 				bias-disable;
 			};
 		};
+
+		xtal_32k_out_pins: xtal-32k-out {
+			mux {
+				groups = "xtal_32k_out";
+				function = "xtal";
+				bias-disable;
+			};
+		};
 	};
 };
 
@@ -584,6 +803,17 @@
 	};
 };
 
+&cvbs_dac {
+	compatible = "amlogic,meson8-cvbs-dac", "amlogic,meson-cvbs-dac";
+
+	clocks = <&clkc CLKID_CTS_VDAC0>;
+
+	nvmem-cells = <&cvbs_trimming>;
+	nvmem-cell-names = "cvbs_trimming";
+
+	status = "okay";
+};
+
 &efuse {
 	compatible = "amlogic,meson8-efuse";
 	clocks = <&clkc CLKID_EFUSE>;
@@ -593,11 +823,15 @@
 		/* only the upper two bytes are relevant */
 		reg = <0x1f4 0x4>;
 	};
+
+	cvbs_trimming: calib@1f8 {
+		reg = <0x1f8 0x2>;
+	};
 };
 
 &ethmac {
-	clocks = <&clkc CLKID_ETH>;
-	clock-names = "stmmaceth";
+	clocks = <&clkc CLKID_ETH>, <&clkc CLKID_ETH_CLK>;
+	clock-names = "stmmaceth", "ethernet";
 
 	power-domains = <&pwrc PWRC_MESON8_ETHERNET_MEM_ID>;
 };
@@ -608,16 +842,18 @@
 };
 
 &hhi {
-	clkc: clock-controller {
+	clkc: clock-controller@0 {
 		compatible = "amlogic,meson8-clkc";
+		reg = <0x0 0x39c>;
 		clocks = <&xtal>, <&ddr_clkc DDR_CLKID_DDR_PLL>;
 		clock-names = "xtal", "ddr_pll";
 		#clock-cells = <1>;
 		#reset-cells = <1>;
 	};
 
-	pwrc: power-controller {
+	pwrc: power-controller@100 {
 		compatible = "amlogic,meson8-pwrc";
+		reg = <0x100 0x10>;
 		#power-domain-cells = <1>;
 		amlogic,ao-sysctrl = <&pmu>;
 		clocks = <&clkc CLKID_VPU>;
@@ -625,6 +861,13 @@
 		assigned-clocks = <&clkc CLKID_VPU>;
 		assigned-clock-rates = <364285714>;
 	};
+
+	hdmi_tx_phy: hdmi-phy@3a0 {
+		compatible = "amlogic,meson8-hdmi-tx-phy";
+		clocks = <&clkc CLKID_HDMI_PLL_HDMI_OUT>;
+		reg = <0x3a0 0xc>;
+		#phy-cells = <0>;
+	};
 };
 
 &hwrng {
diff -Naur a/arch/arm/boot/dts/meson8m2.dtsi b/arch/arm/boot/dts/meson8m2.dtsi
--- a/arch/arm/boot/dts/meson8m2.dtsi	2021-10-31 16:53:10.000000000 -0400
+++ b/arch/arm/boot/dts/meson8m2.dtsi	2021-10-31 20:41:20.000000000 -0400
@@ -96,6 +96,10 @@
 	compatible = "amlogic,meson8m2-usb2-phy", "amlogic,meson-mx-usb2-phy";
 };
 
+&vpu {
+	compatible = "amlogic,meson8m2-vpu";
+};
+
 &wdt {
 	compatible = "amlogic,meson8m2-wdt", "amlogic,meson8b-wdt";
 };
diff -Naur a/arch/arm/boot/dts/meson8m2-m8s.dts b/arch/arm/boot/dts/meson8m2-m8s.dts
--- a/arch/arm/boot/dts/meson8m2-m8s.dts	1969-12-31 19:00:00.000000000 -0500
+++ b/arch/arm/boot/dts/meson8m2-m8s.dts	2021-10-31 20:41:20.000000000 -0400
@@ -0,0 +1,437 @@
+/*
+ * Copyright (c) 2017 Martin Blumenstingl <martin.blumenstingl@googlemail.com>.
+ *
+ * SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+ */
+
+/dts-v1/;
+
+#include "meson8m2.dtsi"
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+
+/ {
+	model = "Akaso M8S";
+	compatible = "akaso,m8s", "amlogic,meson8m2";
+
+	aliases {
+		ethernet0 = &ethmac;
+		serial0 = &uart_AO;
+		mmc0 = &sdio_sd_card_slot;
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	memory {
+		device_type = "memory";
+		reg = <0x40000000 0x80000000>;
+	};
+
+	adc-keys {
+		compatible = "adc-keys";
+		io-channels = <&saradc 0>;
+		io-channel-names = "buttons";
+		keyup-threshold-microvolt = <1710000>;
+
+		button-function {
+			label = "Function";
+			linux,code = <KEY_FN>;
+			press-threshold-microvolt = <10000>;
+		};
+	};
+
+	hdmi-connector {
+		compatible = "hdmi-connector";
+		type = "a";
+
+		port {
+			hdmi_connector_in: endpoint {
+				remote-endpoint = <&hdmi_tx_tmds_out>;
+			};
+		};
+	};
+
+	pwmleds {
+		compatible = "pwm-leds";
+
+		power {
+			label = "m8s:blue:power";
+			pwms = <&pwm_ef 1 7812500 0>;
+			max-brightness = <255>;
+			active-low;
+			linux,default-trigger = "default-on";
+		};
+	};
+
+	sdio_pwrseq: sdio-pwrseq {
+		compatible = "mmc-pwrseq-simple";
+
+		pinctrl-0 = <&xtal_32k_out_pins>;
+		pinctrl-names = "default";
+
+		reset-gpios = <&gpio_ao GPIOAO_6 GPIO_ACTIVE_LOW>,
+			      <&gpio GPIOX_11 GPIO_ACTIVE_LOW>; /* TODO: should be enable-gpios with GPIO_ACTIVE_HIGH in the card's node, this is WIFI_DISn */
+
+		clocks = <&xtal_32k_out>;
+		clock-names = "ext_clock";
+	};
+
+	sound {
+		compatible = "amlogic,gx-sound-card";
+		model = "M8M2-M8S";
+
+		assigned-clocks = <&clkc CLKID_MPLL0>,
+				  <&clkc CLKID_MPLL1>,
+				  <&clkc CLKID_MPLL2>;
+		assigned-clock-rates = <294912000>,
+				       <270950400>,
+				       <393216000>;
+
+		dai-link-0 {
+			sound-dai = <&aiu AIU_CPU CPU_I2S_FIFO>;
+		};
+
+		dai-link-1 {
+			sound-dai = <&aiu AIU_CPU CPU_SPDIF_FIFO>;
+		};
+
+		dai-link-2 {
+			sound-dai = <&aiu AIU_CPU CPU_I2S_ENCODER>;
+			dai-format = "i2s";
+			mclk-fs = <256>;
+
+			codec-0 {
+				sound-dai = <&aiu AIU_HDMI CTRL_I2S>;
+			};
+
+			codec-1 {
+				sound-dai = <&stereo_i2s_codec>;
+			};
+		};
+
+		dai-link-3 {
+			sound-dai = <&aiu AIU_CPU CPU_SPDIF_ENCODER>;
+
+			codec-0 {
+				sound-dai = <&hdmi_tx 1>;
+			};
+
+			codec-1 {
+				sound-dai = <&spdif_dit>;
+			};
+		};
+
+		dai-link-4 {
+			sound-dai = <&aiu AIU_HDMI CTRL_OUT>;
+
+			codec-0 {
+				sound-dai = <&hdmi_tx 0>;
+			};
+		};
+	};
+
+	stereo_i2s_codec: i2s-audio-codec {
+		compatible = "everest,es7134";
+		#sound-dai-cells = <0>;
+	};
+
+	spdif_dit: spdif-audio-codec {
+		#sound-dai-cells = <0>;
+		compatible = "linux,spdif-dit";
+		sound-name-prefix = "DIT";
+	};
+
+	tv-connector {
+		compatible = "composite-video-connector";
+
+		port {
+			cvbs_connector_in: endpoint {
+				remote-endpoint = <&cvbs_vdac_out>;
+			};
+		};
+	};
+
+	vcck: regulator-vcck {
+		compatible = "regulator-fixed";
+		regulator-name = "VCCK";
+		regulator-min-microvolt = <975000>;
+		regulator-max-microvolt = <975000>;
+		vin-supply = <&vcc_5v>;
+	};
+
+	vddee: regulator-vddee {
+		compatible = "regulator-fixed";
+		regulator-name = "VDD_EE";
+		regulator-min-microvolt = <1150000>;
+		regulator-max-microvolt = <1150000>;
+		vin-supply = <&vcc_5v>;
+	};
+
+	vcc_1v8: regulator-vcc1v8 {
+		compatible = "regulator-fixed";
+		regulator-name = "VCC1V8";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+		vin-supply = <&vcc_5v>;
+	};
+
+	vcc_3v3: regulator-vcc3v3 {
+		compatible = "regulator-fixed";
+		regulator-name = "VCC3V3";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		vin-supply = <&vcc_5v>;
+	};
+
+	vcc_5v: regulator-vcc5v {
+		compatible = "regulator-fixed";
+		regulator-name = "VCC5V";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+	};
+
+	xtal_32k_out: xtal-32k-out-clk {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency = <32768>;
+		clock-output-names = "xtal_32k_out";
+	};
+};
+
+&aiu {
+	status = "okay";
+
+	pinctrl-0 = <&i2s_am_clk_pins>, <&i2s_out_ao_clk_pins>,
+		    <&i2s_out_lr_clk_pins>, <&i2s_out_ch01_ao_pins>,
+		    <&spdif_out_pins>;
+	pinctrl-names = "default";
+};
+
+&cec_AO {
+	// TODO: is this correct?
+	clocks = <&xtal_32k_out>;
+	clock-names = "core";
+
+	pinctrl-0 = <&hdmi_cec_ao_pins>;
+	pinctrl-names = "default";
+};
+
+&cpu0 {
+	cpu-supply = <&vcck>;
+};
+
+&cvbs_vdac_port {
+	cvbs_vdac_out: endpoint {
+		remote-endpoint = <&cvbs_connector_in>;
+	};
+};
+
+&ethmac {
+	status = "okay";
+
+	pinctrl-0 = <&eth_pins>;
+	pinctrl-names = "default";
+
+	phy-handle = <&eth_phy0>;
+	phy-mode = "rmii";
+
+	mdio {
+		compatible = "snps,dwmac-mdio";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		eth_phy0: ethernet-phy@0 {
+			/* IC Plus IP101GR (0x02430c54) */
+			reg = <0>;
+
+			reset-assert-us = <10000>;
+			reset-deassert-us = <10000>;
+			reset-gpios = <&gpio GPIOZ_14 GPIO_ACTIVE_LOW>;
+		};
+	};
+};
+
+&hdmi_tx {
+	status = "okay";
+	pinctrl-0 = <&hdmi_hpd_pins>, <&hdmi_i2c_pins>;
+	pinctrl-names = "default";
+};
+
+&hdmi_tx_tmds_port {
+	hdmi_tx_tmds_out: endpoint {
+		remote-endpoint = <&hdmi_connector_in>;
+	};
+};
+
+&ir_receiver {
+	status = "okay";
+	pinctrl-0 = <&ir_recv_pins>;
+	pinctrl-names = "default";
+};
+
+
+&mali {
+	mali-supply = <&vddee>;
+};
+
+&nfc {
+	/* TODO: status = "okay"; */
+
+	pinctrl-0 = <&nand_pins>, <&nand_ce0_pins>, <&nand_rb0_pins>;
+	pinctrl-names = "default";
+
+	nand@0 {
+		reg = <0>;
+
+		nand-on-flash-bbt;
+
+		partitions {
+			compatible = "fixed-partitions";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			partition@2 {
+				label = "2GiB";
+				reg = <0x0 0xffffffff>;
+				read-only;
+			};
+
+			partition@0 {
+				label = "nand_page0_cfg";
+				reg = <0x0 0x4000>;
+				read-only;
+			};
+
+			partition@4000 {
+				label = "u-boot";
+				reg = <0x4000 0x60000>;
+				read-only;
+			};
+
+			partition@400000 {
+				label = "u-boot-env";
+				reg = <0x400000 0x10000>;
+				read-only;
+			};
+
+			partition@1000000 {
+				label = "boot";
+				reg = <0x1000000 0x400000>;
+				read-only;
+			};
+
+			partition@1400000 {
+				label = "uboot_p1";
+				reg = <0x1400000 0x8000000>;
+				read-only;
+			};
+
+			partition@d000000 {
+				label = "cache";
+				reg = <0xd000000 0x19000000>;
+				read-only;
+			};
+
+			partition@33000000 {
+				label = "system";
+				reg = <0x33000000 0x1f000000>;
+				read-only;
+			};
+
+			partition@85000000 {
+				label = "data";
+				reg = <0x85000000 0xf6000000>;
+				read-only;
+			};
+		};
+	};
+};
+
+&saradc {
+	status = "okay";
+	vref-supply = <&vcc_1v8>;
+};
+
+/* wifi */
+&sdhc {
+	status = "okay";
+
+	pinctrl-0 = <&sdxc_a_pins>;
+	pinctrl-names = "default";
+
+	bus-width = <4>;
+	max-frequency = <50000000>;
+
+	cap-mmc-highspeed;
+	cap-sd-highspeed;
+	non-removable;
+	disable-wp;
+
+	mmc-pwrseq = <&sdio_pwrseq>;
+
+	vmmc-supply = <&vcc_3v3>;
+	vqmmc-supply = <&vcc_3v3>;
+};
+
+/* SD card */
+&sdio {
+	status = "okay";
+
+	pinctrl-0 = <&sd_b_pins>;
+	pinctrl-names = "default";
+
+	sdio_sd_card_slot: slot@1 {
+		compatible = "mmc-slot";
+		reg = <1>;
+
+		bus-width = <4>;
+		max-frequency = <50000000>;
+
+		no-mmc;
+		no-sdio;
+		cap-sd-highspeed;
+		disable-wp;
+
+		cd-gpios = <&gpio CARD_6 GPIO_ACTIVE_LOW>;
+
+		vmmc-supply = <&vcc_3v3>;
+	};
+};
+
+&uart_A {
+	status = "okay";
+
+	pinctrl-0 = <&uart_a1_pins>, <&uart_a1_cts_rts_pins>;
+	pinctrl-names = "default";
+	uart-has-rtscts;
+
+	bluetooth {
+		compatible = "realtek,rtl8723bs-bt";
+		enable-gpios = <&gpio GPIOX_20 GPIO_ACTIVE_HIGH>;
+	};
+};
+
+&uart_AO {
+	status = "okay";
+	pinctrl-0 = <&uart_ao_a_pins>;
+	pinctrl-names = "default";
+};
+
+&usb0 {
+	status = "okay";
+};
+
+&usb1 {
+	status = "okay";
+};
+
+&usb0_phy {
+	status = "okay";
+};
+
+&usb1_phy {
+	status = "okay";
+};
diff -Naur a/arch/arm/boot/dts/meson8m2-mxiii.dts b/arch/arm/boot/dts/meson8m2-mxiii.dts
--- a/arch/arm/boot/dts/meson8m2-mxiii.dts	1969-12-31 19:00:00.000000000 -0500
+++ b/arch/arm/boot/dts/meson8m2-mxiii.dts	2021-10-31 20:41:20.000000000 -0400
@@ -0,0 +1,99 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2018 Martin Blumenstingl <martin.blumenstingl@googlemail.com>
+ */
+
+/dts-v1/;
+
+#include "meson8m2-mxiii.dtsi"
+
+/ {
+	model = "Tronsmart MXIII";
+	compatible = "tronsmart,mxiii", "amlogic,meson8m2";
+
+	gpio-keys-polled {
+		compatible = "gpio-keys-polled";
+		poll-interval = <100>;
+
+		button-power {
+			label = "power";
+			linux,code = <KEY_POWER>;
+			gpios = <&gpio_ao GPIOAO_3 GPIO_ACTIVE_LOW>;
+		};
+	};
+};
+
+&ethmac {
+	status = "okay";
+
+	pinctrl-0 = <&eth_pins>;
+	pinctrl-names = "default";
+
+	phy-handle = <&eth_phy0>;
+	phy-mode = "rmii";
+
+	mdio {
+		compatible = "snps,dwmac-mdio";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		eth_phy0: ethernet-phy@0 {
+			/* IC Plus IP101A/G (0x02430c54) */
+			reg = <0>;
+			icplus,select-interrupt;
+			interrupt-parent = <&gpio_intc>;
+			/* GPIODV_29 = 94 and GPIOZ_4 are not working */
+			/* interrupts = <94 IRQ_TYPE_LEVEL_LOW>; */
+
+			reset-assert-us = <10000>;
+			reset-deassert-us = <10000>;
+			reset-gpios = <&gpio GPIOZ_14 GPIO_ACTIVE_LOW>;
+		};
+	};
+};
+
+/* SDIO wifi */
+&sdhc {
+	status = "okay";
+
+	pinctrl-0 = <&sdxc_a_pins>;
+	pinctrl-names = "default";
+
+	bus-width = <4>;
+	max-frequency = <50000000>;
+
+	disable-wp;
+	non-removable;
+	cap-mmc-highspeed;
+	cap-sd-highspeed;
+
+	mmc-pwrseq = <&sdio_pwrseq>;
+
+	vmmc-supply = <&vcc_3v3>;
+	vqmmc-supply = <&vcc_3v3>;
+};
+
+/* SD card */
+&sdio {
+	status = "okay";
+
+	pinctrl-0 = <&sd_b_pins>;
+	pinctrl-names = "default";
+
+	slot@0 {
+		compatible = "mmc-slot";
+		reg = <1>;
+
+		bus-width = <4>;
+		max-frequency = <50000000>;
+
+		no-mmc;
+		no-sdio;
+		cap-sd-highspeed;
+		disable-wp;
+
+		cd-gpios = <&gpio CARD_6 GPIO_ACTIVE_LOW>;
+
+		vmmc-supply = <&vcc_3v3>;
+	};
+};
diff -Naur a/arch/arm/boot/dts/meson8m2-mxiii.dtsi b/arch/arm/boot/dts/meson8m2-mxiii.dtsi
--- a/arch/arm/boot/dts/meson8m2-mxiii.dtsi	1969-12-31 19:00:00.000000000 -0500
+++ b/arch/arm/boot/dts/meson8m2-mxiii.dtsi	2021-10-31 20:41:20.000000000 -0400
@@ -0,0 +1,328 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2018 Oleg Ivanov <balbes-150@yandex.ru>
+ * Copyright (c) 2018 Martin Blumenstingl <martin.blumenstingl@googlemail.com>
+ */
+
+/dts-v1/;
+
+#include "meson8m2.dtsi"
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+
+/ {
+	aliases {
+		ethernet0 = &ethmac;
+		i2c0 = &i2c_AO;
+		serial0 = &uart_AO;
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	memory {
+		reg = <0x40000000 0x40000000>;
+		device_type = "memory";
+	};
+
+	adc-keys {
+		compatible = "adc-keys";
+		io-channels = <&saradc 0>;
+		io-channel-names = "buttons";
+		keyup-threshold-microvolt = <1710000>;
+
+		button-function {
+			label = "Function";
+			linux,code = <KEY_FN>;
+			press-threshold-microvolt = <10000>;
+		};
+	};
+
+	hdmi-connector {
+		compatible = "hdmi-connector";
+		type = "a";
+
+		port {
+			hdmi_connector_in: endpoint {
+				remote-endpoint = <&hdmi_tx_tmds_out>;
+			};
+		};
+	};
+
+	sdio_pwrseq: sdio-pwrseq {
+		compatible = "mmc-pwrseq-simple";
+
+		pinctrl-0 = <&xtal_32k_out_pins>;
+		pinctrl-names = "default";
+
+		reset-gpios = <&gpio GPIOX_11 GPIO_ACTIVE_LOW>,
+			      <&gpio_ao GPIOAO_6 GPIO_ACTIVE_LOW>;
+
+		clocks = <&xtal_32k_out>;
+		clock-names = "ext_clock";
+	};
+
+	sound {
+		compatible = "amlogic,gx-sound-card";
+		model = "M8M2-MXIII";
+		audio-routing = "I2S Encoder Playback", "I2S FIFO Playback",
+				"SPDIF Encoder Playback", "I2S FIFO Playback",
+				"SPDIF Encoder Playback", "SPDIF FIFO Playback";
+
+		assigned-clocks = <&clkc CLKID_MPLL0>,
+				  <&clkc CLKID_MPLL1>;
+		assigned-clock-rates = <270950400>,
+				       <294912000>;
+
+		dai-link-0 {
+			sound-dai = <&aiu AIU_CPU CPU_I2S_FIFO>;
+		};
+
+		dai-link-1 {
+			sound-dai = <&aiu AIU_CPU CPU_SPDIF_FIFO>;
+		};
+
+		dai-link-2 {
+			sound-dai = <&aiu AIU_CPU CPU_I2S_ENCODER>;
+			dai-format = "i2s";
+			mclk-fs = <256>;
+
+			codec-0 {
+				sound-dai = <&aiu AIU_HDMI CTRL_I2S>;
+			};
+		};
+
+		dai-link-3 {
+			sound-dai = <&aiu AIU_HDMI CTRL_OUT>;
+
+			codec-0 {
+				sound-dai = <&hdmi_tx>;
+			};
+		};
+
+		dai-link-4 {
+			sound-dai = <&aiu AIU_CPU CPU_SPDIF_ENCODER>;
+
+			codec-0 {
+				sound-dai = <&spdif_dit>;
+			};
+		};
+	};
+
+	spdif_dit: spdif-audio-codec {
+		compatible = "linux,spdif-dit";
+		#sound-dai-cells = <0>;
+		sound-name-prefix = "DIT";
+	};
+
+	tv-connector {
+		compatible = "composite-video-connector";
+
+		port {
+			cvbs_connector_in: endpoint {
+				remote-endpoint = <&cvbs_vdac_out>;
+			};
+		};
+	};
+
+	usb_vbus: regulator-usb-vbus {
+		compatible = "regulator-fixed";
+
+		regulator-name = "USB_VBUS";
+
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+
+		gpio = <&gpio GPIOZ_1 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+	};
+
+	vcc_3v3: regulator-vcc3v3 {
+		compatible = "regulator-fixed";
+		regulator-name = "VCC3V3";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	xtal_32k_out: xtal-32k-out-clk {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency = <32768>;
+		clock-output-names = "xtal_32k_out";
+	};
+};
+
+&aiu {
+	status = "okay";
+
+	pinctrl-0 = <&i2s_am_clk_pins>, <&i2s_out_ao_clk_pins>,
+		    <&i2s_out_lr_clk_pins>, <&i2s_out_ch01_ao_pins>,
+		    <&spdif_out_pins>;
+	pinctrl-names = "default";
+};
+
+&cpu0 {
+	cpu-supply = <&vcck>;
+};
+
+&cvbs_vdac_port {
+	cvbs_vdac_out: endpoint {
+		remote-endpoint = <&cvbs_connector_in>;
+	};
+};
+
+&hdmi_tx {
+	status = "okay";
+	pinctrl-0 = <&hdmi_hpd_pins>, <&hdmi_i2c_pins>;
+	pinctrl-names = "default";
+};
+
+&hdmi_tx_tmds_port {
+	hdmi_tx_tmds_out: endpoint {
+		remote-endpoint = <&hdmi_connector_in>;
+	};
+};
+
+&ir_receiver {
+	status = "okay";
+	pinctrl-0 = <&ir_recv_pins>;
+	pinctrl-names = "default";
+};
+
+&i2c_AO {
+	status = "okay";
+	pinctrl-0 = <&i2c_ao_pins>;
+	pinctrl-names = "default";
+
+	pmic@32 {
+		compatible = "ricoh,rn5t618";
+		reg = <0x32>;
+		system-power-controller;
+
+		regulators {
+			vcck: DCDC1 {
+				regulator-name = "VCCK";
+				regulator-min-microvolt = <825000>;
+				regulator-max-microvolt = <1150000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			vddee: DCDC2 {
+				/* the output is also used as VDDAO */
+				regulator-name = "VDD_EE";
+				regulator-min-microvolt = <950000>;
+				regulator-max-microvolt = <1150000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			DCDC3 {
+				regulator-name = "VDD_DDR";
+				regulator-min-microvolt = <1500000>;
+				regulator-max-microvolt = <1500000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			LDO1 {
+				regulator-name = "VDDIO_AO28";
+				regulator-min-microvolt = <2900000>;
+				regulator-max-microvolt = <2900000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			vddio_ao1v8: LDO2 {
+				regulator-name = "VDDIO_AO18";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			LDO3 {
+				regulator-name = "VCC1V8";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			LDO4 {
+				regulator-name = "VCC2V8";
+				regulator-min-microvolt = <2850000>;
+				regulator-max-microvolt = <2850000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			LDO5 {
+				regulator-name = "AVDD1V8";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			LDORTC1 {
+				regulator-name = "VDD_LDO";
+				regulator-min-microvolt = <2700000>;
+				regulator-max-microvolt = <2700000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			LDORTC2 {
+				regulator-name = "RTC_0V9";
+				regulator-min-microvolt = <900000>;
+				regulator-max-microvolt = <900000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+		};
+	};
+};
+
+&mali {
+	mali-supply = <&vddee>;
+};
+
+&saradc {
+	status = "okay";
+	vref-supply = <&vddio_ao1v8>;
+};
+
+&uart_AO {
+	status = "okay";
+	pinctrl-0 = <&uart_ao_a_pins>;
+	pinctrl-names = "default";
+};
+
+&usb0 {
+	status = "okay";
+
+	dr_mode = "otg";
+	usb-role-switch;
+
+	connector {
+		compatible = "gpio-usb-b-connector", "usb-b-connector";
+		type = "micro";
+		id-gpios = <&usb0_phy 0 GPIO_ACTIVE_HIGH>;
+		vbus-supply = <&usb_vbus>;
+	};
+};
+
+&usb1 {
+	status = "okay";
+};
+
+&usb0_phy {
+	status = "okay";
+};
+
+&usb1_phy {
+	status = "okay";
+};
diff -Naur a/arch/arm/boot/dts/meson8m2-mxiii-plus.dts b/arch/arm/boot/dts/meson8m2-mxiii-plus.dts
--- a/arch/arm/boot/dts/meson8m2-mxiii-plus.dts	2021-10-31 16:53:10.000000000 -0400
+++ b/arch/arm/boot/dts/meson8m2-mxiii-plus.dts	2021-10-31 20:41:20.000000000 -0400
@@ -6,55 +6,15 @@
 
 /dts-v1/;
 
-#include "meson8m2.dtsi"
-
-#include <dt-bindings/gpio/gpio.h>
-#include <dt-bindings/input/input.h>
+#include "meson8m2-mxiii.dtsi"
 
 / {
 	model = "Tronsmart MXIII Plus";
 	compatible = "tronsmart,mxiii-plus", "amlogic,meson8m2";
 
 	aliases {
-		ethernet0 = &ethmac;
-		i2c0 = &i2c_AO;
-		serial0 = &uart_AO;
 		serial1 = &uart_A;
-		mmc0 = &sd_card_slot;
-	};
-
-	chosen {
-		stdout-path = "serial0:115200n8";
 	};
-
-	memory {
-		device_type = "memory";
-		reg = <0x40000000 0x80000000>;
-	};
-
-	adc-keys {
-		compatible = "adc-keys";
-		io-channels = <&saradc 0>;
-		io-channel-names = "buttons";
-		keyup-threshold-microvolt = <1710000>;
-
-		button-function {
-			label = "Function";
-			linux,code = <KEY_FN>;
-			press-threshold-microvolt = <10000>;
-		};
-	};
-
-	vcc_3v3: regulator-vcc3v3 {
-		compatible = "regulator-fixed";
-		regulator-name = "VCC3V3";
-		regulator-min-microvolt = <3300000>;
-		regulator-max-microvolt = <3300000>;
-	};
-};
-
-&cpu0 {
-	cpu-supply = <&vcck>;
 };
 
 &ethmac {
@@ -82,116 +42,6 @@
 	};
 };
 
-&ir_receiver {
-	status = "okay";
-	pinctrl-0 = <&ir_recv_pins>;
-	pinctrl-names = "default";
-};
-
-&i2c_AO {
-	status = "okay";
-	pinctrl-0 = <&i2c_ao_pins>;
-	pinctrl-names = "default";
-
-	pmic@32 {
-		compatible = "ricoh,rn5t618";
-		reg = <0x32>;
-		system-power-controller;
-
-		regulators {
-			vcck: DCDC1 {
-				regulator-name = "VCCK";
-				regulator-min-microvolt = <825000>;
-				regulator-max-microvolt = <1150000>;
-				regulator-boot-on;
-				regulator-always-on;
-			};
-
-			vddee: DCDC2 {
-				/* the output is also used as VDDAO */
-				regulator-name = "VDD_EE";
-				regulator-min-microvolt = <950000>;
-				regulator-max-microvolt = <1150000>;
-				regulator-boot-on;
-				regulator-always-on;
-			};
-
-			DCDC3 {
-				regulator-name = "VDD_DDR";
-				regulator-min-microvolt = <1500000>;
-				regulator-max-microvolt = <1500000>;
-				regulator-boot-on;
-				regulator-always-on;
-			};
-
-			LDO1 {
-				regulator-name = "VDDIO_AO28";
-				regulator-min-microvolt = <2900000>;
-				regulator-max-microvolt = <2900000>;
-				regulator-boot-on;
-				regulator-always-on;
-			};
-
-			vddio_ao1v8: LDO2 {
-				regulator-name = "VDDIO_AO18";
-				regulator-min-microvolt = <1800000>;
-				regulator-max-microvolt = <1800000>;
-				regulator-boot-on;
-				regulator-always-on;
-			};
-
-			LDO3 {
-				regulator-name = "VCC1V8";
-				regulator-min-microvolt = <1800000>;
-				regulator-max-microvolt = <1800000>;
-				regulator-boot-on;
-				regulator-always-on;
-			};
-
-			LDO4 {
-				regulator-name = "VCC2V8";
-				regulator-min-microvolt = <2850000>;
-				regulator-max-microvolt = <2850000>;
-				regulator-boot-on;
-				regulator-always-on;
-			};
-
-			LDO5 {
-				regulator-name = "AVDD1V8";
-				regulator-min-microvolt = <1800000>;
-				regulator-max-microvolt = <1800000>;
-				regulator-boot-on;
-				regulator-always-on;
-			};
-
-			LDORTC1 {
-				regulator-name = "VDD_LDO";
-				regulator-min-microvolt = <2700000>;
-				regulator-max-microvolt = <2700000>;
-				regulator-boot-on;
-				regulator-always-on;
-			};
-
-			LDORTC2 {
-				regulator-name = "RTC_0V9";
-				regulator-min-microvolt = <900000>;
-				regulator-max-microvolt = <900000>;
-				regulator-boot-on;
-				regulator-always-on;
-			};
-		};
-	};
-};
-
-&mali {
-	mali-supply = <&vddee>;
-};
-
-&saradc {
-	status = "okay";
-	vref-supply = <&vddio_ao1v8>;
-};
-
 &sdio {
 	status = "okay";
 
@@ -216,32 +66,9 @@
 	};
 };
 
-/* connected to the Bluetooth module */
 &uart_A {
 	status = "okay";
 	pinctrl-0 = <&uart_a1_pins>, <&uart_a1_cts_rts_pins>;
 	pinctrl-names = "default";
 	uart-has-rtscts;
 };
-
-&uart_AO {
-	status = "okay";
-	pinctrl-0 = <&uart_ao_a_pins>;
-	pinctrl-names = "default";
-};
-
-&usb0 {
-	status = "okay";
-};
-
-&usb1 {
-	status = "okay";
-};
-
-&usb0_phy {
-	status = "okay";
-};
-
-&usb1_phy {
-	status = "okay";
-};
diff -Naur a/arch/arm/boot/dts/meson8m2-wetek-core.dts b/arch/arm/boot/dts/meson8m2-wetek-core.dts
--- a/arch/arm/boot/dts/meson8m2-wetek-core.dts	1969-12-31 19:00:00.000000000 -0500
+++ b/arch/arm/boot/dts/meson8m2-wetek-core.dts	2021-10-31 20:41:20.000000000 -0400
@@ -0,0 +1,482 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2021 Martin Blumenstingl <martin.blumenstingl@googlemail.com>
+ */
+
+/dts-v1/;
+
+#include "meson8m2.dtsi"
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+
+/ {
+	model = "WeTek Core";
+	compatible = "wetek,core", "amlogic,meson8m2";
+
+	aliases {
+		ethernet0 = &ethmac;
+		serial0 = &uart_AO;
+		mmc0 = &sdhc;
+		mmc1 = &sd_card_slot;
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	memory {
+		device_type = "memory";
+		reg = <0x40000000 0x80000000>;
+	};
+
+	adc-keys {
+		compatible = "adc-keys";
+		io-channels = <&saradc 0>;
+		io-channel-names = "buttons";
+		keyup-threshold-microvolt = <1710000>;
+
+		button-function {
+			label = "update";
+			linux,code = <KEY_VENDOR>;
+			press-threshold-microvolt = <10000>;
+		};
+	};
+
+	ao_5v: regulator-ao-5v {
+		/* SY8120BABC */
+		compatible = "regulator-fixed";
+		regulator-name = "AO_5V";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		vin-supply = <&dc_12v>;
+	};
+
+	dc_12v: regulator-dc-12v {
+		compatible = "regulator-fixed";
+		regulator-name = "DC_12V";
+		regulator-min-microvolt = <12000000>;
+		regulator-max-microvolt = <12000000>;
+	};
+
+	firmware {
+		trustzone-firmware {
+			compatible = "amlogic,meson8m2-trustzone-firmware",
+				     "amlogic,meson-mx-trustzone-firmware";
+		};
+	};
+
+	gpio-keys {
+		compatible = "gpio-keys-polled";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		poll-interval = <100>;
+
+		button-power {
+			label = "power";
+			linux,code = <KEY_POWER>;
+			gpios = <&gpio_ao GPIOAO_4 GPIO_ACTIVE_LOW>;
+		};
+	};
+
+	reserved-memory {
+		trustzone-firmware@6100000 {
+			reg = <0x6100000 0x3000000>;
+			no-map;
+		};
+
+		video-stream-buf-config@aa00000 {
+			reg = <0xaa00000 0x2000000>;
+			no-map;
+		};
+
+		video-frame-buf-config@ca00000 {
+			reg = <0xca00000 0x10000000>;
+			no-map;
+		};
+	};
+
+	rtc_xin: rtc-xin-clk {
+		compatible = "fixed-clock";
+		clock-frequency = <32768>;
+		clock-output-names = "RTC_XIN";
+		#clock-cells = <0>;
+	};
+
+	sdio_pwrseq: sdio-pwrseq {
+		compatible = "mmc-pwrseq-simple";
+
+		reset-gpios = <&gpio GPIOX_11 GPIO_ACTIVE_LOW>;
+
+		clocks = <&rtc_xin>;
+		clock-names = "ext_clock";
+	};
+
+	vcc_1v8: regulator-vcc-1v8 {
+		/* Will Semiconductor WL2803E18-5 */
+		compatible = "regulator-fixed";
+		regulator-name = "VCC_1V8";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+
+		vin-supply = <&vcc_3v3>;
+
+		regulator-boot-on;
+		regulator-always-on;
+	};
+
+	vcc_3v3: regulator-vcc-3v3 {
+		/* transistor controlled by 3V3_5V_EN */
+		compatible = "regulator-fixed";
+		regulator-name = "VCC3V3";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+
+		vin-supply = <&vddio_ao_3v3>;
+
+		gpios = <&gpio GPIOAO_2 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+
+		regulator-boot-on;
+		regulator-always-on;
+	};
+
+	vcc_5v: regulator-vcc-5v {
+		/* transistor controlled by 3V3_5V_EN */
+		compatible = "regulator-fixed";
+		regulator-name = "VCC5V";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+
+		vin-supply = <&ao_5v>;
+
+		gpios = <&gpio GPIOAO_2 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+
+		regulator-boot-on;
+		regulator-always-on;
+	};
+
+	vcck: regulator-vcck {
+		/* Silergy SY8120BABC */
+		compatible = "pwm-regulator";
+
+		regulator-name = "VCCK";
+		regulator-min-microvolt = <860000>;
+		regulator-max-microvolt = <1140000>;
+
+		pwm-supply = <&dc_12v>;
+
+		pwms = <&pwm_cd 0 1148 0>;
+		pwm-dutycycle-range = <100 0>;
+
+		regulator-boot-on;
+		regulator-always-on;
+	};
+
+	vdd_ee: regulator-vdd-ee {
+		/* Silergy SY8113BADC */
+		compatible = "pwm-regulator";
+
+		regulator-name = "VDD_EE";
+		regulator-min-microvolt = <860000>;
+		regulator-max-microvolt = <1140000>;
+
+		pwm-supply = <&dc_12v>;
+
+		pwms = <&pwm_cd 1 12218 0>;
+		pwm-dutycycle-range = <91 0>;
+
+		regulator-boot-on;
+		regulator-always-on;
+	};
+
+	vddio_ao_3v3: regulator-vddio-ao-3v3 {
+		compatible = "regulator-fixed";
+		regulator-name = "VDDIO_AO_3V3";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+
+		vin-supply = <&dc_12v>;
+
+		gpios = <&gpio GPIOAO_2 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+
+		regulator-boot-on;
+		regulator-always-on;
+	};
+
+	vddio_ao_1v8: regulator-vddio-ao-1v8 {
+		/* Will Semiconductor WL2803E18-5 */
+		compatible = "regulator-fixed";
+		regulator-name = "VDDIO_AO_1V8";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+
+		vin-supply = <&ao_5v>;
+
+		regulator-boot-on;
+		regulator-always-on;
+	};
+};
+
+&cpu0 {
+	cpu-supply = <&vcck>;
+};
+
+/*
+ * The VCCK regulator is limited in range and requires higher voltages
+ * on lower frequencies (<= 720MHz) as well as lower voltages on 1992MHz.
+ */
+&cpu_opp_table {
+	opp-96000000 {
+		opp-microvolt = <860000>;
+	};
+	opp-192000000 {
+		opp-microvolt = <860000>;
+	};
+	opp-312000000 {
+		opp-microvolt = <860000>;
+	};
+	opp-408000000 {
+		opp-microvolt = <860000>;
+	};
+	opp-504000000 {
+		opp-microvolt = <860000>;
+	};
+	opp-600000000 {
+		opp-microvolt = <860000>;
+	};
+	opp-720000000 {
+		opp-microvolt = <860000>;
+	};
+	opp-816000000 {
+		opp-microvolt = <880000>;
+	};
+	opp-1008000000 {
+		opp-microvolt = <930000>;
+	};
+	opp-1200000000 {
+		opp-microvolt = <980000>;
+	};
+	opp-1416000000 {
+		opp-microvolt = <1030000>;
+	};
+	opp-1608000000 {
+		opp-microvolt = <1100000>;
+	};
+	opp-1800000000 {
+		opp-microvolt = <1130000>;
+	};
+	opp-1992000000 {
+		opp-microvolt = <1140000>;
+	};
+};
+
+/*
+ * The VDDEE regulator is limited in range and u-boot configures it
+ * to ~1.135V (instead of 1.15V as used on boards with a Ricoh PMU).
+ */
+&gpu_opp_table {
+	opp-182142857 {
+		opp-microvolt = <1135000>;
+	};
+	opp-318750000 {
+		opp-microvolt = <1135000>;
+	};
+	opp-425000000 {
+		opp-microvolt = <1135000>;
+	};
+	opp-510000000 {
+		opp-microvolt = <1135000>;
+	};
+	opp-637500000 {
+		opp-microvolt = <1135000>;
+	};
+};
+
+&ethmac {
+//	status = "okay"; // FIXME: this seems to hang the board during boot?
+
+	pinctrl-0 = <&eth_rgmii_pins>;
+	pinctrl-names = "default";
+
+	phy-handle = <&eth_phy1>;
+	phy-mode = "rgmii-id";
+
+	mdio {
+		compatible = "snps,dwmac-mdio";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		eth_phy1: ethernet-phy@1 {
+			/* Realtek RTL8211F (0x001cc916) */
+			reg = <1>;
+
+			reset-assert-us = <10000>;
+			reset-deassert-us = <80000>;
+			reset-gpios = <&gpio GPIOZ_14 GPIO_ACTIVE_LOW>;
+
+			interrupt-parent = <&gpio_intc>;
+			/* GPIODV_29 */
+			interrupts = <94 IRQ_TYPE_LEVEL_LOW>;
+		};
+	};
+};
+
+&gpio {
+	gpio-line-names = /* Bank GPIOX */
+			  "WIFI_SD_D0", "WIFI_SD_D1", "WIFI_SD_D2",
+			  "WIFI_SD_D3", "BTPCM_DOUT", "BTPCM_DIN",
+			  "BTPCM_SYNC", "BTPCM_CLK", "WIFI_SD_CLK",
+			  "WIFI_SD_CMD", "WIFI_32K", "WIFI_PWREN",
+			  "UART_A_TX", "UART_A_RX", "UART_A_CTS_N",
+			  "UART_A_RTS_N", "ISO7816_EN/DET", "ISO7816_RST",
+			  "ISO7816_CLK", "ISO7816_DATA", "BT_EN",
+			  "WIFI_WAKE_HOST",
+			  /* Bank GPIOY */
+			  "TSIN_A_VAL", "TSIN_A_SYNC", "", "SPDIF",
+			  "PDN", "TSIN_RST", "ANT1_CTRL", "",
+			  "TSIN_A_CLK", "TSIN_A_D0", "TSIN_A_D1",
+			  "TSIN_A_D2", "TSIN_A_D3", "TSIN_A_D4",
+			  "TSIN_A_D5", "TSIN_A_D6", "TSIN_A_D7",
+			  /* Bank GPIODV */
+			  "", "", "", "", "", "", "", "", "",
+			  "VCCK_PWM_C", "", "", "", "", "", "", "",
+			  "", "", "", "", "", "", "", "", "", "", "",
+			  "VDDEE_PWM_D", "RGMII_IRQ#",
+			  /* Bank GPIOH */
+			  "HDMI_HPD", "HDMI_SDA", "HDMI_SCL", "HUB_REST",
+			  "", "ANT_OVERLOAD", "", "I2C_SDA", "I2C_SCL",
+			  "",
+			  /* Bank GPIOZ */
+			  "RGMII_TXD3", "RGMII_TXD2", "RGMII_RXD3",
+			  "RGMII_RXD2", "RGMII_TXCLK", "RGMII_TXEN",
+			  "RGMII_TXD1", "RGMII_TXD0", "RGMII_RXCLK",
+			  "RGM RGMII_RXDV", "RGMII_RXD1", "RGMII_RXD0",
+			  "RGMII_MDIO", "RGMII_MDC", "RGMII_RST#",
+			  /* Bank CARD */
+			  "SD_D1_B", "SD_D0_B", "SD_CLK_B", "SD_CMD_B",
+			  "SD_D3_B", "SD_D2_B", "CARD_EN_DET",
+			  /* Bank BOOT */
+			  "NAND_D0", "NAND_D1", "NAND_D2", "NAND_D3",
+			  "NAND_D4", "NAND_D5", "NAND_D6", "NAND_D7",
+			  "NAND_CS1", "INAND_RST", "NAND_NR/B",
+			  "NAND_ALE", "SPI_O", "NAND_NWE", "NAND_NRE",
+			  "NAND_DQS", "INAND_CMD", "INAND_CLK",
+			  "SPI_CS";
+
+	/*
+	 * WARNING: The USB Hub on the WeTek core needs a reset signal
+	 * to be turned high in order to be detected by the USB Controller.
+	 * This signal should be handled by a USB specific power sequence
+	 * in order to reset the Hub when USB bus is powered down.
+	 */
+	usb-hub {
+		gpio-hog;
+		gpios = <GPIOH_3 GPIO_ACTIVE_HIGH>;
+		output-high;
+		line-name = "usb-hub-reset";
+	};
+};
+
+&gpio_ao {
+	gpio-line-names = "LINUX_TX", "LINUX_RX", "3V3_5V_EN",
+			  "PWR_KEY", "VCCK_CON", "VDEE_PWM_D",
+			  "RGMII_RST#", "IR", "", "FRONT_CS",
+			  "I2C_SDA_AO", "I2C_SCK_AO", "HDMI_CEC",
+			  "IR_BLASTER", "MUTE", "";
+};
+
+&ir_receiver {
+	status = "okay";
+	pinctrl-0 = <&ir_recv_pins>;
+	pinctrl-names = "default";
+};
+
+&mali {
+	mali-supply = <&vdd_ee>;
+};
+
+&pwm_cd {
+	status = "okay";
+	pinctrl-0 = <&pwm_c_dv9_pins>, <&pwm_d_pins>;
+	pinctrl-names = "default";
+	clocks = <&xtal>, <&xtal>;
+	clock-names = "clkin0", "clkin1";
+};
+
+&saradc {
+	status = "okay";
+	vref-supply = <&vddio_ao_1v8>;
+};
+
+&sdhc {
+	status = "disabled"; // TODO: until pinctrl is updated...
+
+	// TODO: pinctrl-0 = <&sdxc_a_pins>;
+	pinctrl-names = "default";
+
+	bus-width = <4>;
+	cap-sd-highspeed;
+	max-frequency = <50000000>;
+
+	non-removable;
+	disable-wp;
+
+	vmmc-supply = <&vcc_3v3>;
+	vqmmc-supply = <&vddio_ao_3v3>;
+};
+
+&sdio {
+	status = "okay";
+
+	pinctrl-0 = <&sd_b_pins>;
+	pinctrl-names = "default";
+
+	/* SD card */
+	sd_card_slot: slot@1 {
+		compatible = "mmc-slot";
+		reg = <1>;
+		status = "okay";
+
+		bus-width = <4>;
+		no-sdio;
+		cap-mmc-highspeed;
+		cap-sd-highspeed;
+		disable-wp;
+
+		cd-gpios = <&gpio CARD_6 GPIO_ACTIVE_LOW>;
+
+		vmmc-supply = <&vcc_3v3>;
+	};
+};
+
+&uart_A {
+	status = "okay";
+	pinctrl-0 = <&uart_a1_pins>, <&uart_a1_cts_rts_pins>;
+	pinctrl-names = "default";
+	uart-has-rtscts;
+
+	bluetooth {
+		compatible = "brcm,bcm43438-bt";
+		shutdown-gpios = <&gpio GPIOX_20 GPIO_ACTIVE_HIGH>;
+		max-speed = <2000000>;
+		clocks = <&rtc_xin>;
+		clock-names = "lpo";
+	};
+};
+
+&uart_AO {
+	status = "okay";
+	pinctrl-0 = <&uart_ao_a_pins>;
+	pinctrl-names = "default";
+};
+
+&usb1 {
+	status = "okay";
+};
+
+&usb1_phy {
+	status = "okay";
+};
diff -Naur a/arch/arm/boot/dts/meson8-tronsmart-s82.dts b/arch/arm/boot/dts/meson8-tronsmart-s82.dts
--- a/arch/arm/boot/dts/meson8-tronsmart-s82.dts	1969-12-31 19:00:00.000000000 -0500
+++ b/arch/arm/boot/dts/meson8-tronsmart-s82.dts	2021-10-31 20:41:20.000000000 -0400
@@ -0,0 +1,402 @@
+// SPDX-License-Identifier: GPL-2.0 OR MIT
+/*
+ * Copyright 2021 Martin Blumenstingl <martin.blumenstingl@googlemail.com>
+ */
+
+/dts-v1/;
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/leds/common.h>
+#include "meson8.dtsi"
+
+/ {
+	model = "Tronsmart S82";
+	compatible = "tronsmart,s82", "amlogic,meson8";
+
+	aliases {
+		serial0 = &uart_AO;
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	memory {
+		device_type = "memory";
+		reg = <0x40000000 0x80000000>;
+	};
+
+	gpio-leds {
+		compatible = "gpio-leds";
+
+		blue {
+			function = LED_FUNCTION_STATUS;
+			default-state = "on";
+			gpios = <&gpio_ao GPIO_TEST_N GPIO_ACTIVE_HIGH>;
+		};
+	};
+
+	hdmi-connector {
+		compatible = "hdmi-connector";
+		type = "a";
+
+		port {
+			hdmi_connector_in: endpoint {
+				remote-endpoint = <&hdmi_tx_tmds_out>;
+			};
+		};
+	};
+
+	sdio_pwrseq: sdio-pwrseq {
+		compatible = "mmc-pwrseq-simple";
+
+		pinctrl-0 = <&xtal_32k_out_pins>;
+		pinctrl-names = "default";
+
+		reset-gpios = <&gpio GPIOX_11 GPIO_ACTIVE_LOW>,
+			      <&gpio_ao GPIOAO_6 GPIO_ACTIVE_LOW>;
+
+/*
+	TODO:
+		clocks = <&xtal_32k_out>;
+		clock-names = "ext_clock";
+*/
+	};
+
+	sound {
+		compatible = "amlogic,gx-sound-card";
+		model = "M8M2-S82";
+		audio-routing = "I2S Encoder Playback", "I2S FIFO Playback",
+				"SPDIF Encoder Playback", "I2S FIFO Playback",
+				"SPDIF Encoder Playback", "SPDIF FIFO Playback";
+
+		assigned-clocks = <&clkc CLKID_MPLL0>,
+				  <&clkc CLKID_MPLL1>,
+				  <&clkc CLKID_MPLL2>;
+		assigned-clock-rates = <294912000>,
+				       <270950400>,
+				       <393216000>;
+
+		dai-link-0 {
+			sound-dai = <&aiu AIU_CPU CPU_I2S_FIFO>;
+		};
+
+		dai-link-1 {
+			sound-dai = <&aiu AIU_CPU CPU_SPDIF_FIFO>;
+		};
+
+		dai-link-2 {
+			sound-dai = <&aiu AIU_CPU CPU_I2S_ENCODER>;
+			dai-format = "i2s";
+			mclk-fs = <256>;
+
+			codec-0 {
+				sound-dai = <&aiu AIU_HDMI CTRL_I2S>;
+			};
+		};
+
+		dai-link-3 {
+			sound-dai = <&aiu AIU_HDMI CTRL_OUT>;
+
+			codec-0 {
+				sound-dai = <&hdmi_tx>;
+			};
+		};
+
+		dai-link-4 {
+			sound-dai = <&aiu AIU_CPU CPU_SPDIF_ENCODER>;
+
+			codec-0 {
+				sound-dai = <&spdif_dit>;
+			};
+		};
+	};
+
+	spdif_dit: spdif-audio-codec {
+		compatible = "linux,spdif-dit";
+		#sound-dai-cells = <0>;
+		sound-name-prefix = "DIT";
+	};
+
+	tv-connector {
+		compatible = "composite-video-connector";
+
+		port {
+			cvbs_connector_in: endpoint {
+				remote-endpoint = <&cvbs_vdac_out>;
+			};
+		};
+	};
+
+	usb_vbus: regulator-usb-vbus {
+		compatible = "regulator-fixed";
+
+		regulator-name = "USB_VBUS";
+
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+
+		gpio = <&gpio GPIOZ_1 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+	};
+
+	vcc_3v3: regulator-vcc3v3 {
+		compatible = "regulator-fixed";
+		regulator-name = "VCC3V3";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+	};
+};
+
+&aiu {
+	status = "okay";
+
+	pinctrl-0 = <&i2s_am_clk_pins>, <&i2s_out_ao_clk_pins>,
+		    <&i2s_out_lr_clk_pins>, <&i2s_out_ch01_ao_pins>,
+		    <&spdif_out_pins>;
+	pinctrl-names = "default";
+};
+
+&cpu0 {
+	cpu-supply = <&vcck>;
+};
+
+&cvbs_vdac_port {
+	cvbs_vdac_out: endpoint {
+		remote-endpoint = <&cvbs_connector_in>;
+	};
+};
+
+&ethmac {
+	status = "okay";
+
+	pinctrl-0 = <&eth_pins>;
+	pnictrl-names = "default";
+
+	phy-handle = <&eth_phy0>;
+	phy-mode = "rmii";
+
+	mdio {
+		compatible = "snps,dwmac-mdio";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		eth_phy0: ethernet-phy@0 {
+			/* IC Plus IP101A/G (0x02430c54) */
+			reg = <0>;
+		};
+	};
+};
+
+&hdmi_tx {
+	status = "okay";
+	pinctrl-0 = <&hdmi_hpd_pins>, <&hdmi_i2c_pins>;
+	pinctrl-names = "default";
+};
+
+&hdmi_tx_tmds_port {
+	hdmi_tx_tmds_out: endpoint {
+		remote-endpoint = <&hdmi_connector_in>;
+	};
+};
+
+&ir_receiver {
+	status = "okay";
+	pinctrl-0 = <&ir_recv_pins>;
+	pinctrl-names = "default";
+};
+
+&i2c_AO {
+	status = "okay";
+	pinctrl-0 = <&i2c_ao_pins>;
+	pinctrl-names = "default";
+
+	pmic@32 {
+		compatible = "ricoh,rn5t618";
+		reg = <0x32>;
+		system-power-controller;
+
+		regulators {
+			vcck: DCDC1 {
+				regulator-name = "VCCK";
+				regulator-min-microvolt = <825000>;
+				regulator-max-microvolt = <1150000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			vddee: DCDC2 {
+				/* the output is also used as VDDAO */
+				regulator-name = "VDD_EE";
+				regulator-min-microvolt = <950000>;
+				regulator-max-microvolt = <1150000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			DCDC3 {
+				regulator-name = "VDD_DDR";
+				regulator-min-microvolt = <1500000>;
+				regulator-max-microvolt = <1500000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			LDO1 {
+				regulator-name = "VDDIO_AO28";
+				regulator-min-microvolt = <2900000>;
+				regulator-max-microvolt = <2900000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			vddio_ao1v8: LDO2 {
+				regulator-name = "VDDIO_AO18";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			LDO3 {
+				regulator-name = "VCC1V8";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			LDO4 {
+				regulator-name = "VCC2V8";
+				regulator-min-microvolt = <2850000>;
+				regulator-max-microvolt = <2850000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			LDO5 {
+				regulator-name = "AVDD1V8";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			LDORTC1 {
+				regulator-name = "VDD_LDO";
+				regulator-min-microvolt = <2700000>;
+				regulator-max-microvolt = <2700000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			LDORTC2 {
+				regulator-name = "RTC_0V9";
+				regulator-min-microvolt = <900000>;
+				regulator-max-microvolt = <900000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+		};
+	};
+};
+
+&mali {
+	mali-supply = <&vddee>;
+};
+
+&saradc {
+	status = "okay";
+	vref-supply = <&vddio_ao1v8>;
+};
+
+/* SDIO wifi */
+&sdhc {
+	status = "okay";
+
+	pinctrl-0 = <&sdxc_a_pins>;
+	pinctrl-names = "default";
+
+	bus-width = <4>;
+	max-frequency = <50000000>;
+
+	disable-wp;
+	non-removable;
+	cap-mmc-highspeed;
+	cap-sd-highspeed;
+
+	mmc-pwrseq = <&sdio_pwrseq>;
+
+	vmmc-supply = <&vcc_3v3>;
+	vqmmc-supply = <&vcc_3v3>;
+};
+
+/* SD card */
+&sdio {
+	status = "okay";
+
+	pinctrl-0 = <&sd_b_pins>;
+	pinctrl-names = "default";
+
+	slot@1 {
+		compatible = "mmc-slot";
+		reg = <1>;
+
+		bus-width = <4>;
+		max-frequency = <50000000>;
+
+		no-mmc;
+		no-sdio;
+		cap-sd-highspeed;
+		disable-wp;
+
+		cd-gpios = <&gpio CARD_6 GPIO_ACTIVE_LOW>;
+
+		vmmc-supply = <&vcc_3v3>;
+	};
+};
+
+&uart_A {
+	status = "okay";
+
+	pinctrl-0 = <&uart_a1_pins>, <&uart_a1_cts_rts_pins>;
+	pinctrl-names = "default";
+	uart-has-rtscts;
+
+	bluetooth {
+		compatible = "brcm,bcm20702a1";
+		shutdown-gpios = <&gpio GPIOX_20 GPIO_ACTIVE_HIGH>;
+		max-speed = <2000000>;
+	};
+};
+
+&uart_AO {
+	status = "okay";
+	pinctrl-0 = <&uart_ao_a_pins>;
+	pinctrl-names = "default";
+};
+
+&usb0 {
+	status = "okay";
+
+	dr_mode = "otg";
+	usb-role-switch;
+
+	connector {
+		compatible = "gpio-usb-b-connector", "usb-b-connector";
+		type = "micro";
+		id-gpios = <&usb0_phy 0 GPIO_ACTIVE_HIGH>;
+		vbus-supply = <&usb_vbus>;
+	};
+};
+
+&usb1 {
+	status = "okay";
+};
+
+&usb0_phy {
+	status = "okay";
+};
+
+&usb1_phy {
+	status = "okay";
+};
diff -Naur a/arch/arm/boot/dts/meson.dtsi b/arch/arm/boot/dts/meson.dtsi
--- a/arch/arm/boot/dts/meson.dtsi	2021-10-31 16:53:10.000000000 -0400
+++ b/arch/arm/boot/dts/meson.dtsi	2021-10-31 20:41:20.000000000 -0400
@@ -35,6 +35,19 @@
 					     "simple-mfd",
 					     "syscon";
 				reg = <0x4000 0x400>;
+				#address-cells = <1>;
+				#size-cells = <1>;
+				ranges = <0x0 0x4000 0x400>;
+
+
+				cvbs_dac: video-dac@2f4 {
+					compatible = "amlogic,meson-cvbs-dac";
+					reg = <0x2f4 0x8>;
+
+					#phy-cells = <0>;
+
+					status = "disabled";
+				};
 			};
 
 			aiu: audio-controller@5400 {
@@ -124,6 +137,8 @@
 				compatible = "amlogic,meson-mx-usb2-phy";
 				#phy-cells = <0>;
 				reg = <0x8800 0x20>;
+				gpio-controller;
+				#gpio-cells = <2>;
 				status = "disabled";
 			};
 
diff -Naur a/arch/arm/mach-meson/firmware.c b/arch/arm/mach-meson/firmware.c
--- a/arch/arm/mach-meson/firmware.c	1969-12-31 19:00:00.000000000 -0500
+++ b/arch/arm/mach-meson/firmware.c	2021-10-31 20:41:20.000000000 -0400
@@ -0,0 +1,231 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2021 Martin Blumenstingl <martin.blumenstingl@googlemail.com>
+ */
+
+#include <linux/arm-smccc.h>
+#include <linux/firmware/meson/meson_mx_trustzone.h>
+#include <linux/memblock.h>
+#include <linux/of.h>
+
+#include <asm/firmware.h>
+#include <asm/hardware/cache-l2x0.h>
+#include <asm/outercache.h>
+
+#include "firmware.h"
+
+static bool meson_has_secure_firmware __ro_after_init = false;
+static struct meson_mx_trustzone_firmware_memconfig {
+	unsigned char name[64];
+	unsigned int start_phy_addr;
+	unsigned int end_phy_addr;
+} memconfig[2];
+
+static int meson_mx_trustzone_firmware_hal_api(unsigned int cmd, u32 *args)
+{
+	struct arm_smccc_res res;
+
+	arm_smccc_smc(MESON_CALL_TRUSTZONE_HAL_API, cmd, __pa_symbol(args), 0,
+		      0, 0, 0, 0, &res);
+
+	return res.a0;
+}
+
+static unsigned int meson_mx_trustzone_firmware_mon(unsigned int cmd,
+						    unsigned int arg0,
+						    unsigned int arg1)
+{
+	struct arm_smccc_res res;
+
+	arm_smccc_smc(MESON_CALL_TRUSTZONE_MON, cmd, arg0, arg1, 0, 0, 0, 0,
+		      &res);
+
+	return res.a0;
+}
+
+static int __init meson_mx_trustzone_firmware_memconfig_init(void)
+{
+	u32 args[2] = {
+		__pa_symbol(memconfig),
+		ARRAY_SIZE(memconfig),
+	};
+
+	return meson_mx_trustzone_firmware_hal_api(MESON_TRUSTZONE_HAL_API_MEMCONFIG,
+						   args);
+}
+
+static int meson_mx_trustzone_firmware_reseved_memory_init(void)
+{
+	unsigned int i, base, size;
+	int ret;
+
+	base = meson_mx_trustzone_firmware_mon(MESON_TRUSTZONE_MON_MEM_BASE,
+					       0, 0);
+	WARN_ON(!base);
+
+	size = meson_mx_trustzone_firmware_mon(MESON_TRUSTZONE_MON_MEM_TOTAL_SIZE,
+					       0, 0);
+	WARN_ON(!size);
+
+	ret = memblock_mark_nomap(base, size);
+	if (ret) {
+		pr_err("Failed to reserve %u bytes of TrustZone monitor memory: %d\n",
+		       size, ret);
+		return ret;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(memconfig); i++) {
+		size = memconfig[i].end_phy_addr - memconfig[i].start_phy_addr;
+
+		pr_debug("\tTrustZone memblock[%d]: %s (%u bytes)\n", i,
+			 memconfig[i].name, size);
+
+		ret = memblock_mark_nomap(memconfig[i].start_phy_addr, size);
+		if (ret) {
+			pr_err("Failed to reserve %u bytes for TrustZone memblock[%d] (%s): %d\n",
+			       size, i, memconfig[i].name, ret);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static void meson_mx_trustzone_firmware_l2x0_write_sec(unsigned long val,
+						       unsigned int reg)
+{
+	u32 fn;
+
+	switch (reg) {
+	case L2X0_CTRL:
+		fn = MESON_TRUSTZONE_MON_L2X0_CTRL_INDEX;
+		break;
+
+	case L2X0_AUX_CTRL:
+		fn = MESON_TRUSTZONE_MON_L2X0_AUXCTRL_INDEX;
+		break;
+
+	case L310_TAG_LATENCY_CTRL:
+		fn = MESON_TRUSTZONE_MON_L2X0_TAGLATENCY_INDEX;
+		break;
+
+	case L310_DATA_LATENCY_CTRL:
+		fn = MESON_TRUSTZONE_MON_L2X0_DATALATENCY_INDEX;
+		break;
+
+	case L310_ADDR_FILTER_START:
+		fn = MESON_TRUSTZONE_MON_L2X0_FILTERSTART_INDEX;
+		break;
+
+	case L310_ADDR_FILTER_END:
+		fn = MESON_TRUSTZONE_MON_L2X0_FILTEREND_INDEX;
+		break;
+
+	case L2X0_DEBUG_CTRL:
+		fn = MESON_TRUSTZONE_MON_L2X0_DEBUG_INDEX;
+		break;
+
+	case L310_POWER_CTRL:
+		fn = MESON_TRUSTZONE_MON_L2X0_POWER_INDEX;
+		break;
+
+	default:
+		pr_warn("%s: unsupported register 0x%08x\n", __func__, reg);
+		return;
+	}
+
+	WARN_ON(meson_mx_trustzone_firmware_mon(fn, val, 0));
+}
+
+bool meson_mx_trustzone_firmware_available(void)
+{
+	return meson_has_secure_firmware;
+}
+EXPORT_SYMBOL_GPL(meson_mx_trustzone_firmware_available);
+
+int meson_mx_trustzone_firmware_auxcoreboot_addr(unsigned int cpu, unsigned int addr)
+{
+	return meson_mx_trustzone_firmware_mon(MESON_TRUSTZONE_MON_CORE_BOOTADDR_INDEX,
+					       cpu, addr);
+}
+EXPORT_SYMBOL_GPL(meson_mx_trustzone_firmware_auxcoreboot_addr);
+
+int meson_mx_trustzone_firmware_modify_corectrl(unsigned int cpu, bool power_on)
+{
+	u32 ret, corectrl;
+
+	corectrl = meson_mx_trustzone_firmware_mon(MESON_TRUSTZONE_MON_CORE_RD_CTRL_INDEX,
+						   0, 0);
+
+	if (power_on)
+		corectrl |= BIT(cpu);
+	else
+		corectrl &= ~BIT(cpu);
+
+	ret = meson_mx_trustzone_firmware_mon(MESON_TRUSTZONE_MON_CORE_WR_CTRL_INDEX,
+					      corectrl, 0);
+	if (ret != corectrl)
+		return -EINVAL;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(meson_mx_trustzone_firmware_modify_corectrl);
+
+int meson_mx_trustzone_firmware_efuse_read(unsigned int offset,
+					   unsigned int bytes, void *buf)
+{
+	unsigned int read_bytes;
+	u32 args[5] = {
+		MESON_TRUSTZONE_HAL_API_EFUSE_CMD_READ,
+		offset,
+		bytes,
+		__pa_symbol(buf),
+		__pa(&read_bytes)
+	};
+	int ret;
+
+	ret = meson_mx_trustzone_firmware_hal_api(MESON_TRUSTZONE_HAL_API_EFUSE,
+						  args);
+	if (ret)
+		return -EIO;
+
+	if (read_bytes != bytes)
+		return -EINVAL;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(meson_mx_trustzone_firmware_efuse_read);
+
+unsigned int meson_mx_trustzone_read_soc_rev1(void)
+{
+	return meson_mx_trustzone_firmware_mon(MESON_TRUSTZONE_MON_CORE_RD_SOC_REV1,
+					       0, 0);
+}
+EXPORT_SYMBOL_GPL(meson_mx_trustzone_read_soc_rev1);
+
+void __init meson_mx_trustzone_firmware_init(void)
+{
+	struct device_node *np;
+	int ret;
+
+	np = of_find_compatible_node(NULL, NULL,
+				     "amlogic,meson-mx-trustzone-firmware");
+	if (!np)
+		return;
+
+	of_node_put(np);
+	meson_has_secure_firmware = true;
+
+	pr_info("Running under TrustZone secure firmware.\n");
+
+	if (IS_ENABLED(CONFIG_CACHE_L2X0))
+		outer_cache.write_sec = meson_mx_trustzone_firmware_l2x0_write_sec;
+
+	ret = meson_mx_trustzone_firmware_memconfig_init();
+	if (ret) {
+		pr_err("Failed to initialize memconfig: %d\n", ret);
+		return;
+	}
+
+	meson_mx_trustzone_firmware_reseved_memory_init();
+}
diff -Naur a/arch/arm/mach-meson/firmware.h b/arch/arm/mach-meson/firmware.h
--- a/arch/arm/mach-meson/firmware.h	1969-12-31 19:00:00.000000000 -0500
+++ b/arch/arm/mach-meson/firmware.h	2021-10-31 20:41:20.000000000 -0400
@@ -0,0 +1,75 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Amlogic Meson6/8/8b/8m2 secure TrustZone firmware definitions.
+ *
+ * Based on meson-secure.h from the Amlogic vendor kernel:
+ *   Copyright (C) 2002 ARM Ltd.
+ *   Copyright (c) 2010, Code Aurora Forum. All rights reserved.
+ *   Copyright (C) 2013 Amlogic, Inc.
+ *     Author: Platform-SH@amlogic.com
+ *
+ * Copyright (C) 2021 Martin Blumenstingl <martin.blumenstingl@googlemail.com>
+ */
+
+/* Meson Secure Monitor/HAL APIs */
+#define MESON_CALL_TRUSTZONE_API			0x1
+#define MESON_CALL_TRUSTZONE_MON			0x4
+#define MESON_CALL_TRUSTZONE_HAL_API			0x5
+
+/* Secure Monitor mode APIs */
+#define MESON_TRUSTZONE_MON_TYPE_MASK			0xF00
+#define MESON_TRUSTZONE_MON_FUNC_MASK			0x0FF
+
+#define MESON_TRUSTZONE_MON_L2X0			0x100
+#define MESON_TRUSTZONE_MON_L2X0_CTRL_INDEX		0x101
+#define MESON_TRUSTZONE_MON_L2X0_AUXCTRL_INDEX		0x102
+#define MESON_TRUSTZONE_MON_L2X0_PREFETCH_INDEX		0x103
+#define MESON_TRUSTZONE_MON_L2X0_TAGLATENCY_INDEX	0x104
+#define MESON_TRUSTZONE_MON_L2X0_DATALATENCY_INDEX	0x105
+#define MESON_TRUSTZONE_MON_L2X0_FILTERSTART_INDEX	0x106
+#define MESON_TRUSTZONE_MON_L2X0_FILTEREND_INDEX	0x107
+#define MESON_TRUSTZONE_MON_L2X0_DEBUG_INDEX		0x108
+#define MESON_TRUSTZONE_MON_L2X0_POWER_INDEX		0x109
+
+#define MESON_TRUSTZONE_MON_CORE			0x200
+#define MESON_TRUSTZONE_MON_CORE_RD_CTRL_INDEX		0x201
+#define MESON_TRUSTZONE_MON_CORE_WR_CTRL_INDEX		0x202
+#define MESON_TRUSTZONE_MON_CORE_RD_STATUS0_INDEX	0x203
+#define MESON_TRUSTZONE_MON_CORE_WR_STATUS0_INDEX	0x204
+#define MESON_TRUSTZONE_MON_CORE_RD_STATUS1_INDEX	0x205
+#define MESON_TRUSTZONE_MON_CORE_WR_STATUS1_INDEX	0x206
+#define MESON_TRUSTZONE_MON_CORE_BOOTADDR_INDEX		0x207
+#define MESON_TRUSTZONE_MON_CORE_DDR_INDEX		0x208
+#define MESON_TRUSTZONE_MON_CORE_RD_SOC_REV1		0x209
+#define MESON_TRUSTZONE_MON_CORE_RD_SOC_REV2		0x20A
+
+#define MESON_TRUSTZONE_MON_SUSPEND_FIRMWARE		0x300
+#define MESON_TRUSTZONE_MON_SAVE_CPU_GIC		0x400
+
+#define MESON_TRUSTZONE_MON_RTC				0x500
+#define MESON_TRUSTZONE_MON_RTC_RD_REG_INDEX		0x501
+#define MESON_TRUSTZONE_MON_RTC_WR_REG_INDEX		0x502
+
+#define MESON_TRUSTZONE_MON_REG				0x600
+#define MESON_TRUSTZONE_MON_REG_RD_INDEX		0x601
+#define MESON_TRUSTZONE_MON_REG_WR_INDEX		0x602
+
+#define MESON_TRUSTZONE_MON_MEM				0x700
+#define MESON_TRUSTZONE_MON_MEM_BASE			0x701
+#define MESON_TRUSTZONE_MON_MEM_TOTAL_SIZE		0x702
+#define MESON_TRUSTZONE_MON_MEM_FLASH			0x703
+#define MESON_TRUSTZONE_MON_MEM_FLASH_SIZE		0x704
+#define MESON_TRUSTZONE_MON_MEM_GE2D			0x705
+
+/* Secure HAL APIs*/
+#define MESON_TRUSTZONE_HAL_API_EFUSE			0x100
+#define MESON_TRUSTZONE_HAL_API_EFUSE_CMD_READ		0x0
+#define MESON_TRUSTZONE_HAL_API_EFUSE_CMD_WRITE		0x1
+#define MESON_TRUSTZONE_HAL_API_EFUSE_CMD_VERIFY_IMG	0x3
+
+#define MESON_TRUSTZONE_HAL_API_STORAGE			0x200
+
+#define MESON_TRUSTZONE_HAL_API_MEMCONFIG		0x300
+#define MESON_TRUSTZONE_HAL_API_MEMCONFIG_GE2D		0x301
+
+void __init meson_mx_trustzone_firmware_init(void);
diff -Naur a/arch/arm/mach-meson/Makefile b/arch/arm/mach-meson/Makefile
--- a/arch/arm/mach-meson/Makefile	2021-10-31 16:53:10.000000000 -0400
+++ b/arch/arm/mach-meson/Makefile	2021-10-31 20:41:20.000000000 -0400
@@ -1,3 +1,3 @@
 # SPDX-License-Identifier: GPL-2.0-only
-obj-$(CONFIG_ARCH_MESON) += meson.o
+obj-$(CONFIG_ARCH_MESON) += meson.o firmware.o
 obj-$(CONFIG_SMP) += platsmp.o
diff -Naur a/arch/arm/mach-meson/meson.c b/arch/arm/mach-meson/meson.c
--- a/arch/arm/mach-meson/meson.c	2021-10-31 16:53:10.000000000 -0400
+++ b/arch/arm/mach-meson/meson.c	2021-10-31 20:41:20.000000000 -0400
@@ -6,6 +6,8 @@
 #include <linux/of_platform.h>
 #include <asm/mach/arch.h>
 
+#include "firmware.h"
+
 static const char * const meson_common_board_compat[] = {
 	"amlogic,meson6",
 	"amlogic,meson8",
@@ -18,4 +20,5 @@
 	.dt_compat	= meson_common_board_compat,
 	.l2c_aux_val	= 0,
 	.l2c_aux_mask	= ~0,
+	.init_early	= meson_mx_trustzone_firmware_init,
 MACHINE_END
diff -Naur a/arch/arm/mach-meson/platsmp.c b/arch/arm/mach-meson/platsmp.c
--- a/arch/arm/mach-meson/platsmp.c	2021-10-31 16:53:10.000000000 -0400
+++ b/arch/arm/mach-meson/platsmp.c	2021-10-31 20:41:20.000000000 -0400
@@ -5,6 +5,7 @@
  */
 
 #include <linux/delay.h>
+#include <linux/firmware/meson/meson_mx_trustzone.h>
 #include <linux/init.h>
 #include <linux/io.h>
 #include <linux/of.h>
@@ -63,6 +64,9 @@
 {
 	static struct device_node *node;
 
+	if (meson_mx_trustzone_firmware_available())
+		return;
+
 	/* SMP SRAM */
 	node = of_find_compatible_node(NULL, NULL, sram_compatible);
 	if (!node) {
@@ -111,6 +115,30 @@
 			       "amlogic,meson8-smp-sram");
 }
 
+static int meson_trustzone_firmware_smp_boot_secondary(unsigned int cpu)
+{
+	unsigned int addr = __pa_symbol(secondary_startup);
+	int ret;
+
+	ret = meson_mx_trustzone_firmware_auxcoreboot_addr(cpu, addr);
+	if (ret) {
+		pr_err("Failed to set aux core boot address for CPU%u using TrustZone secure firmware\n",
+			cpu);
+		return ret;
+	}
+
+	ret = meson_mx_trustzone_firmware_modify_corectrl(cpu, true);
+	if (ret) {
+		pr_err("Failed to modify core control for CPU%u using TrustZone secure firmware\n",
+			cpu);
+		return ret;
+	}
+
+	udelay(10);
+
+	return 0;
+}
+
 static void meson_smp_begin_secondary_boot(unsigned int cpu)
 {
 	/*
@@ -156,6 +184,9 @@
 	struct reset_control *rstc;
 	int ret;
 
+	if (meson_mx_trustzone_firmware_available())
+		return meson_trustzone_firmware_smp_boot_secondary(cpu);
+
 	rstc = meson_smp_get_core_reset(cpu);
 	if (IS_ERR(rstc)) {
 		pr_err("Couldn't get the reset controller for CPU%d\n", cpu);
@@ -213,6 +244,9 @@
 	int ret;
 	u32 val;
 
+	if (meson_mx_trustzone_firmware_available())
+		return meson_trustzone_firmware_smp_boot_secondary(cpu);
+
 	rstc = meson_smp_get_core_reset(cpu);
 	if (IS_ERR(rstc)) {
 		pr_err("Couldn't get the reset controller for CPU%d\n", cpu);
@@ -292,11 +326,17 @@
 #ifdef CONFIG_HOTPLUG_CPU
 static void meson8_smp_cpu_die(unsigned int cpu)
 {
-	meson_smp_set_cpu_ctrl(cpu, false);
+	if (meson_mx_trustzone_firmware_available()) {
+		meson_mx_trustzone_firmware_modify_corectrl(cpu, false);
+
+		v7_exit_coherency_flush(louis);
+	} else {
+		meson_smp_set_cpu_ctrl(cpu, false);
 
-	v7_exit_coherency_flush(louis);
+		v7_exit_coherency_flush(louis);
 
-	scu_power_mode(scu_base, SCU_PM_POWEROFF);
+		scu_power_mode(scu_base, SCU_PM_POWEROFF);
+	}
 
 	dsb();
 	wfi();
@@ -310,6 +350,9 @@
 	int ret, power_mode;
 	unsigned long timeout;
 
+	if (meson_mx_trustzone_firmware_available())
+		return 1;
+
 	timeout = jiffies + (50 * HZ);
 	do {
 		power_mode = scu_get_cpu_power_mode(scu_base, cpu);
@@ -353,6 +396,9 @@
 {
 	int ret, power_mode, count = 5000;
 
+	if (meson_mx_trustzone_firmware_available())
+		return 1;
+
 	do {
 		power_mode = scu_get_cpu_power_mode(scu_base, cpu);
 
diff -Naur a/arch/arm64/boot/dts/amlogic/Makefile b/arch/arm64/boot/dts/amlogic/Makefile
--- a/arch/arm64/boot/dts/amlogic/Makefile	2021-10-31 16:53:10.000000000 -0400
+++ b/arch/arm64/boot/dts/amlogic/Makefile	2021-10-31 20:41:20.000000000 -0400
@@ -53,4 +53,6 @@
 dtb-$(CONFIG_ARCH_MESON) += meson-sm1-odroid-c4.dtb
 dtb-$(CONFIG_ARCH_MESON) += meson-sm1-odroid-hc4.dtb
 dtb-$(CONFIG_ARCH_MESON) += meson-sm1-sei610.dtb
+dtb-$(CONFIG_ARCH_MESON) += meson-sm1-x96-air-100.dtb
+dtb-$(CONFIG_ARCH_MESON) += meson-sm1-x96-air-1000.dtb
 dtb-$(CONFIG_ARCH_MESON) += meson-a1-ad401.dtb
diff -Naur a/arch/arm64/boot/dts/amlogic/meson-sm1-ac2xx.dtsi b/arch/arm64/boot/dts/amlogic/meson-sm1-ac2xx.dtsi
--- a/arch/arm64/boot/dts/amlogic/meson-sm1-ac2xx.dtsi	1969-12-31 19:00:00.000000000 -0500
+++ b/arch/arm64/boot/dts/amlogic/meson-sm1-ac2xx.dtsi	2021-10-31 20:41:20.000000000 -0400
@@ -0,0 +1,298 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2019 BayLibre SAS. All rights reserved.
+ * Copyright (c) 2020 Christian Hewitt <christianshewitt@gmail.com>
+ *
+ * AC200/AC202 = S905D3
+ * AC213/AC214 = S905X3
+ *
+ */
+
+#include "meson-sm1.dtsi"
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/gpio/meson-g12a-gpio.h>
+#include <dt-bindings/input/input.h>
+
+/ {
+	aliases {
+		serial0 = &uart_AO;
+		ethernet0 = &ethmac;
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	emmc_pwrseq: emmc-pwrseq {
+		compatible = "mmc-pwrseq-emmc";
+		reset-gpios = <&gpio BOOT_12 GPIO_ACTIVE_LOW>;
+	};
+
+	cvbs-connector {
+		compatible = "composite-video-connector";
+
+		port {
+			cvbs_connector_in: endpoint {
+				remote-endpoint = <&cvbs_vdac_out>;
+			};
+		};
+	};
+
+	hdmi-connector {
+		compatible = "hdmi-connector";
+		type = "a";
+
+		port {
+			hdmi_connector_in: endpoint {
+				remote-endpoint = <&hdmi_tx_tmds_out>;
+			};
+		};
+	};
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0x40000000>;
+	};
+
+	ao_5v: regulator-ao_5v {
+		compatible = "regulator-fixed";
+		regulator-name = "AO_5V";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		vin-supply = <&dc_in>;
+		regulator-always-on;
+	};
+
+	dc_in: regulator-dc_in {
+		compatible = "regulator-fixed";
+		regulator-name = "DC_IN";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		regulator-always-on;
+	};
+
+	emmc_1v8: regulator-emmc_1v8 {
+		compatible = "regulator-fixed";
+		regulator-name = "EMMC_1V8";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+		vin-supply = <&vddao_3v3>;
+		regulator-always-on;
+	};
+
+	vddao_3v3: regulator-vddao_3v3 {
+		compatible = "regulator-fixed";
+		regulator-name = "VDDAO_3V3";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		vin-supply = <&dc_in>;
+		regulator-always-on;
+	};
+
+	vddcpu: regulator-vddcpu {
+		compatible = "pwm-regulator";
+
+		regulator-name = "VDDCPU";
+		regulator-min-microvolt = <690000>;
+		regulator-max-microvolt = <1050000>;
+
+		vin-supply = <&dc_in>;
+
+		pwms = <&pwm_AO_cd 1 1500 0>;
+		pwm-dutycycle-range = <100 0>;
+
+		regulator-boot-on;
+		regulator-always-on;
+	};
+
+	vddio_ao1v8: regulator-vddio_ao1v8 {
+		compatible = "regulator-fixed";
+		regulator-name = "VDDIO_AO1V8";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+		vin-supply = <&vddao_3v3>;
+		regulator-always-on;
+	};
+
+	sdio_pwrseq: sdio-pwrseq {
+		compatible = "mmc-pwrseq-simple";
+		reset-gpios = <&gpio GPIOX_6 GPIO_ACTIVE_LOW>;
+		clocks = <&wifi32k>;
+		clock-names = "ext_clock";
+	};
+
+	wifi32k: wifi32k {
+		compatible = "pwm-clock";
+		#clock-cells = <0>;
+		clock-frequency = <32768>;
+		pwms = <&pwm_ef 0 30518 0>; /* PWM_E at 32.768KHz */
+	};
+};
+
+&cec_AO {
+	pinctrl-0 = <&cec_ao_a_h_pins>;
+	pinctrl-names = "default";
+	status = "disabled";
+	hdmi-phandle = <&hdmi_tx>;
+};
+
+&cecb_AO {
+	pinctrl-0 = <&cec_ao_b_h_pins>;
+	pinctrl-names = "default";
+	status = "okay";
+	hdmi-phandle = <&hdmi_tx>;
+};
+
+&cpu0 {
+	cpu-supply = <&vddcpu>;
+	operating-points-v2 = <&cpu_opp_table>;
+	clocks = <&clkc CLKID_CPU_CLK>;
+	clock-latency = <50000>;
+};
+
+&cpu1 {
+	cpu-supply = <&vddcpu>;
+	operating-points-v2 = <&cpu_opp_table>;
+	clocks = <&clkc CLKID_CPU1_CLK>;
+	clock-latency = <50000>;
+};
+
+&cpu2 {
+	cpu-supply = <&vddcpu>;
+	operating-points-v2 = <&cpu_opp_table>;
+	clocks = <&clkc CLKID_CPU2_CLK>;
+	clock-latency = <50000>;
+};
+
+&cpu3 {
+	cpu-supply = <&vddcpu>;
+	operating-points-v2 = <&cpu_opp_table>;
+	clocks = <&clkc CLKID_CPU3_CLK>;
+	clock-latency = <50000>;
+};
+
+&cvbs_vdac_port {
+	cvbs_vdac_out: endpoint {
+		remote-endpoint = <&cvbs_connector_in>;
+	};
+};
+
+&hdmi_tx {
+	status = "okay";
+	pinctrl-0 = <&hdmitx_hpd_pins>, <&hdmitx_ddc_pins>;
+	pinctrl-names = "default";
+};
+
+&hdmi_tx_tmds_port {
+	hdmi_tx_tmds_out: endpoint {
+		remote-endpoint = <&hdmi_connector_in>;
+	};
+};
+
+&ir {
+	status = "okay";
+	pinctrl-0 = <&remote_input_ao_pins>;
+	pinctrl-names = "default";
+};
+
+&pwm_AO_ab {
+	status = "okay";
+	pinctrl-0 = <&pwm_ao_a_pins>;
+	pinctrl-names = "default";
+	clocks = <&xtal>;
+	clock-names = "clkin0";
+};
+
+&pwm_AO_cd {
+	pinctrl-0 = <&pwm_ao_d_e_pins>;
+	pinctrl-names = "default";
+	clocks = <&xtal>;
+	clock-names = "clkin1";
+	status = "okay";
+};
+
+&pwm_ef {
+	status = "okay";
+	pinctrl-0 = <&pwm_e_pins>;
+	pinctrl-names = "default";
+	clocks = <&xtal>;
+	clock-names = "clkin0";
+};
+
+&saradc {
+	status = "okay";
+	vref-supply = <&vddio_ao1v8>;
+};
+
+/* SDIO */
+&sd_emmc_a {
+	status = "okay";
+	pinctrl-0 = <&sdio_pins>;
+	pinctrl-1 = <&sdio_clk_gate_pins>;
+	pinctrl-names = "default", "clk-gate";
+	#address-cells = <1>;
+	#size-cells = <0>;
+
+	bus-width = <4>;
+	cap-sd-highspeed;
+	max-frequency = <100000000>;
+
+	non-removable;
+	disable-wp;
+
+	/* WiFi firmware requires power to be kept while in suspend */
+	keep-power-in-suspend;
+
+	mmc-pwrseq = <&sdio_pwrseq>;
+
+	vmmc-supply = <&vddao_3v3>;
+	vqmmc-supply = <&vddio_ao1v8>;
+};
+
+/* SD card */
+&sd_emmc_b {
+	status = "okay";
+	pinctrl-0 = <&sdcard_c_pins>;
+	pinctrl-1 = <&sdcard_clk_gate_c_pins>;
+	pinctrl-names = "default", "clk-gate";
+
+	bus-width = <4>;
+	cap-sd-highspeed;
+	max-frequency = <50000000>;
+	disable-wp;
+
+	cd-gpios = <&gpio GPIOC_6 GPIO_ACTIVE_LOW>;
+	vmmc-supply = <&vddao_3v3>;
+	vqmmc-supply = <&vddao_3v3>;
+};
+
+/* eMMC */
+&sd_emmc_c {
+	status = "okay";
+	pinctrl-0 = <&emmc_ctrl_pins>, <&emmc_data_8b_pins>, <&emmc_ds_pins>;
+	pinctrl-1 = <&emmc_clk_gate_pins>;
+	pinctrl-names = "default", "clk-gate";
+
+	bus-width = <8>;
+	cap-mmc-highspeed;
+	mmc-ddr-1_8v;
+	mmc-hs200-1_8v;
+	max-frequency = <200000000>;
+	non-removable;
+	disable-wp;
+
+	mmc-pwrseq = <&emmc_pwrseq>;
+	vmmc-supply = <&vddao_3v3>;
+	vqmmc-supply = <&emmc_1v8>;
+};
+
+&uart_AO {
+	status = "okay";
+	pinctrl-0 = <&uart_ao_a_pins>;
+	pinctrl-names = "default";
+};
+
+&usb {
+	status = "okay";
+	dr_mode = "otg";
+};
diff -Naur a/arch/arm64/boot/dts/amlogic/meson-sm1-x96-air-1000.dts b/arch/arm64/boot/dts/amlogic/meson-sm1-x96-air-1000.dts
--- a/arch/arm64/boot/dts/amlogic/meson-sm1-x96-air-1000.dts	1969-12-31 19:00:00.000000000 -0500
+++ b/arch/arm64/boot/dts/amlogic/meson-sm1-x96-air-1000.dts	2021-10-31 20:41:20.000000000 -0400
@@ -0,0 +1,147 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2019 BayLibre SAS. All rights reserved.
+ * Copyright (c) 2020 Christian Hewitt <christianshewitt@gmail.com>
+ */
+
+/dts-v1/;
+
+#include "meson-sm1-ac2xx.dtsi"
+#include <dt-bindings/sound/meson-g12a-tohdmitx.h>
+
+/ {
+	compatible = "amediatech,x96-air-1000", "amlogic,sm1";
+	model = "Shenzhen Amediatech Technology Co., Ltd X96 Air";
+
+	sound {
+		compatible = "amlogic,axg-sound-card";
+		model = "X96-AIR";
+		audio-aux-devs = <&tdmout_b>;
+		audio-routing = "TDMOUT_B IN 0", "FRDDR_A OUT 1",
+				"TDMOUT_B IN 1", "FRDDR_B OUT 1",
+				"TDMOUT_B IN 2", "FRDDR_C OUT 1",
+				"TDM_B Playback", "TDMOUT_B OUT";
+
+		assigned-clocks = <&clkc CLKID_MPLL2>,
+				  <&clkc CLKID_MPLL0>,
+				  <&clkc CLKID_MPLL1>;
+		assigned-clock-parents = <0>, <0>, <0>;
+		assigned-clock-rates = <294912000>,
+				       <270950400>,
+				       <393216000>;
+		status = "okay";
+
+		dai-link-0 {
+			sound-dai = <&frddr_a>;
+		};
+
+		dai-link-1 {
+			sound-dai = <&frddr_b>;
+		};
+
+		dai-link-2 {
+			sound-dai = <&frddr_c>;
+		};
+
+		/* 8ch hdmi interface */
+		dai-link-3 {
+			sound-dai = <&tdmif_b>;
+			dai-format = "i2s";
+			dai-tdm-slot-tx-mask-0 = <1 1>;
+			dai-tdm-slot-tx-mask-1 = <1 1>;
+			dai-tdm-slot-tx-mask-2 = <1 1>;
+			dai-tdm-slot-tx-mask-3 = <1 1>;
+			mclk-fs = <256>;
+
+			codec {
+				sound-dai = <&tohdmitx TOHDMITX_I2S_IN_B>;
+			};
+		};
+
+		/* hdmi glue */
+		dai-link-4 {
+			sound-dai = <&tohdmitx TOHDMITX_I2S_OUT>;
+
+			codec {
+				sound-dai = <&hdmi_tx>;
+			};
+		};
+	};
+};
+
+&arb {
+	status = "okay";
+};
+
+&clkc_audio {
+	status = "okay";
+};
+
+&ethmac {
+	status = "okay";
+
+	pinctrl-0 = <&eth_pins>, <&eth_rgmii_pins>;
+	pinctrl-names = "default";
+	phy-mode = "rgmii-txid";
+	phy-handle = <&external_phy>;
+
+	rx-internal-delay-ps = <800>;
+};
+
+&ext_mdio {
+	external_phy: ethernet-phy@0 {
+		/* Realtek RTL8211F (0x001cc916) */
+		reg = <0>;
+		max-speed = <1000>;
+
+		reset-assert-us = <10000>;
+		reset-deassert-us = <80000>;
+		reset-gpios = <&gpio GPIOZ_15 (GPIO_ACTIVE_LOW | GPIO_OPEN_DRAIN)>;
+
+		interrupt-parent = <&gpio_intc>;
+		/* MAC_INTR on GPIOZ_14 */
+		interrupts = <26 IRQ_TYPE_LEVEL_LOW>;
+	};
+};
+
+&frddr_a {
+	status = "okay";
+};
+
+&frddr_b {
+	status = "okay";
+};
+
+&frddr_c {
+	status = "okay";
+};
+
+&ir {
+	linux,rc-map-name = "rc-x96max";
+};
+
+&sd_emmc_a {
+	sd-uhs-sdr104;
+	max-frequency = <200000000>;
+
+	rtl8822cs: sdio-wifi@1 {
+		reg = <1>;
+	};
+};
+
+&sd_emmc_b {
+	/* CRC errors are observed at 50MHz */
+	max-frequency = <35000000>;
+};
+
+&tdmif_b {
+	status = "okay";
+};
+
+&tdmout_b {
+	status = "okay";
+};
+
+&tohdmitx {
+	status = "okay";
+};
diff -Naur a/arch/arm64/boot/dts/amlogic/meson-sm1-x96-air-100.dts b/arch/arm64/boot/dts/amlogic/meson-sm1-x96-air-100.dts
--- a/arch/arm64/boot/dts/amlogic/meson-sm1-x96-air-100.dts	1969-12-31 19:00:00.000000000 -0500
+++ b/arch/arm64/boot/dts/amlogic/meson-sm1-x96-air-100.dts	2021-10-31 20:41:20.000000000 -0400
@@ -0,0 +1,112 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2019 BayLibre SAS. All rights reserved.
+ * Copyright (c) 2020 Christian Hewitt <christianshewitt@gmail.com>
+ */
+
+/dts-v1/;
+
+#include "meson-sm1-ac2xx.dtsi"
+#include <dt-bindings/sound/meson-g12a-tohdmitx.h>
+
+/ {
+	compatible = "amediatech,x96-air-100", "amlogic,sm1";
+	model = "Shenzhen Amediatech Technology Co., Ltd X96 Air";
+
+	sound {
+		compatible = "amlogic,axg-sound-card";
+		model = "X96-AIR";
+		audio-aux-devs = <&tdmout_b>;
+		audio-routing = "TDMOUT_B IN 0", "FRDDR_A OUT 1",
+				"TDMOUT_B IN 1", "FRDDR_B OUT 1",
+				"TDMOUT_B IN 2", "FRDDR_C OUT 1",
+				"TDM_B Playback", "TDMOUT_B OUT";
+
+		assigned-clocks = <&clkc CLKID_MPLL2>,
+				  <&clkc CLKID_MPLL0>,
+				  <&clkc CLKID_MPLL1>;
+		assigned-clock-parents = <0>, <0>, <0>;
+		assigned-clock-rates = <294912000>,
+				       <270950400>,
+				       <393216000>;
+		status = "okay";
+
+		dai-link-0 {
+			sound-dai = <&frddr_a>;
+		};
+
+		dai-link-1 {
+			sound-dai = <&frddr_b>;
+		};
+
+		dai-link-2 {
+			sound-dai = <&frddr_c>;
+		};
+
+		/* 8ch hdmi interface */
+		dai-link-3 {
+			sound-dai = <&tdmif_b>;
+			dai-format = "i2s";
+			dai-tdm-slot-tx-mask-0 = <1 1>;
+			dai-tdm-slot-tx-mask-1 = <1 1>;
+			dai-tdm-slot-tx-mask-2 = <1 1>;
+			dai-tdm-slot-tx-mask-3 = <1 1>;
+			mclk-fs = <256>;
+
+			codec {
+				sound-dai = <&tohdmitx TOHDMITX_I2S_IN_B>;
+			};
+		};
+
+		/* hdmi glue */
+		dai-link-4 {
+			sound-dai = <&tohdmitx TOHDMITX_I2S_OUT>;
+
+			codec {
+				sound-dai = <&hdmi_tx>;
+			};
+		};
+	};
+};
+
+&arb {
+	status = "okay";
+};
+
+&clkc_audio {
+	status = "okay";
+};
+
+&ethmac {
+        status = "okay";
+        phy-handle = <&internal_ephy>;
+        phy-mode = "rmii";
+};
+
+&frddr_a {
+	status = "okay";
+};
+
+&frddr_b {
+	status = "okay";
+};
+
+&frddr_c {
+	status = "okay";
+};
+
+&ir {
+	linux,rc-map-name = "rc-beelink-gs1";
+};
+
+&tdmif_b {
+	status = "okay";
+};
+
+&tdmout_b {
+	status = "okay";
+};
+
+&tohdmitx {
+	status = "okay";
+};
diff -Naur a/Documentation/devicetree/bindings/arm/amlogic.yaml b/Documentation/devicetree/bindings/arm/amlogic.yaml
--- a/Documentation/devicetree/bindings/arm/amlogic.yaml	2021-10-31 16:53:10.000000000 -0400
+++ b/Documentation/devicetree/bindings/arm/amlogic.yaml	2021-10-31 20:41:20.000000000 -0400
@@ -35,12 +35,15 @@
         items:
           - enum:
               - minix,neo-x8
+              - tronsmart,s82
           - const: amlogic,meson8
 
       - description: Boards with the Amlogic Meson8m2 SoC
         items:
           - enum:
+              - tronsmart,mxiii
               - tronsmart,mxiii-plus
+              - wetek,core
           - const: amlogic,meson8m2
 
       - description: Boards with the Amlogic Meson8b SoC
diff -Naur a/Documentation/devicetree/bindings/clock/amlogic,meson8b-clkc.txt b/Documentation/devicetree/bindings/clock/amlogic,meson8b-clkc.txt
--- a/Documentation/devicetree/bindings/clock/amlogic,meson8b-clkc.txt	2021-10-31 16:53:10.000000000 -0400
+++ b/Documentation/devicetree/bindings/clock/amlogic,meson8b-clkc.txt	2021-10-31 20:41:20.000000000 -0400
@@ -16,6 +16,10 @@
   * "xtal": the 24MHz system oscillator
   * "ddr_pll": the DDR PLL clock
   * "clk_32k": (if present) the 32kHz clock signal from GPIOAO_6 (CLK_32K_IN)
+  * "rtc_32k": the clock signal from the 32kHz oscillator connected to the
+               RTC32K_XI and RTC32K_XO pads
+  * "rmii_clk": (if present) the 50MHz RMII reference clock (from the PHY or
+                an external oscillator
 
 Parent node should have the following properties :
 - compatible: "amlogic,meson-hhi-sysctrl", "simple-mfd", "syscon"
diff -Naur a/Documentation/devicetree/bindings/display/amlogic,meson-vpu.yaml b/Documentation/devicetree/bindings/display/amlogic,meson-vpu.yaml
--- a/Documentation/devicetree/bindings/display/amlogic,meson-vpu.yaml	2021-10-31 16:53:10.000000000 -0400
+++ b/Documentation/devicetree/bindings/display/amlogic,meson-vpu.yaml	2021-10-31 20:41:20.000000000 -0400
@@ -66,8 +66,12 @@
           - const: amlogic,meson-gx-vpu
       - enum:
           - amlogic,meson-g12a-vpu # G12A (S905X2, S905Y2, S905D2)
+          - amlogic,meson8-vpu
+          - amlogic,meson8b-vpu
+          - amlogic,meson8m2-vpu
 
   reg:
+    minItems: 1
     maxItems: 2
 
   reg-names:
@@ -78,6 +82,15 @@
   interrupts:
     maxItems: 1
 
+  phys:
+    maxItems: 1
+    description:
+      PHY specifier for the CVBS DAC
+
+  phy-names:
+    items:
+      - const: cvbs-dac
+
   power-domains:
     maxItems: 1
     description: phandle to the associated power domain
diff -Naur a/Documentation/devicetree/bindings/firmware/meson/amlogic,meson-mx-trustzone-firmware.yaml b/Documentation/devicetree/bindings/firmware/meson/amlogic,meson-mx-trustzone-firmware.yaml
--- a/Documentation/devicetree/bindings/firmware/meson/amlogic,meson-mx-trustzone-firmware.yaml	1969-12-31 19:00:00.000000000 -0500
+++ b/Documentation/devicetree/bindings/firmware/meson/amlogic,meson-mx-trustzone-firmware.yaml	2021-10-31 20:41:20.000000000 -0400
@@ -0,0 +1,47 @@
+# SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause)
+# Copyright 2021 Martin Blumenstingl <martin.blumenstingl@googlemail.com>
+%YAML 1.2
+---
+$id: "http://devicetree.org/schemas/firmware/meson/amlogic,meson-mx-trustzone-firmware.yaml#"
+$schema: "http://devicetree.org/meta-schemas/core.yaml#"
+
+title: Amlogic Meson6/8/8b/8m2 TrustZone secure firmware
+
+description: |
+  Amlogic Meson6/8/8b/8m2 SoCs can optionally use a TrustZone secure
+  firmware. This prevents anything outside of the TEE (Trusted
+  Execution Environment aka TrustZone secure firmware) from accessing
+  certain functionality of these SoCs, such as (but not limited to):
+  Bringing up/down secondary SMP cores, accessing the eFuse and getting
+  the SoC misc version.
+  ARM SMCCC is used for communication with the TrustZone secure
+  firmware.
+
+maintainers:
+  - Martin Blumenstingl <martin.blumenstingl@googlemail.com>
+
+properties:
+  compatible:
+    oneOf:
+      - items:
+          - enum:
+              - amlogic,meson6-trustzone-firmware
+              - amlogic,meson8-trustzone-firmware
+              - amlogic,meson8b-trustzone-firmware
+              - amlogic,meson8m2-trustzone-firmware
+          - const: amlogic,meson-mx-trustzone-firmware
+
+required:
+  - compatible
+
+additionalProperties: false
+
+examples:
+  - |
+    firmware {
+      trustzone-firmware {
+        compatible = "amlogic,meson8m2-trustzone-firmware",
+                     "amlogic,meson-mx-trustzone-firmware";
+      };
+    };
+...
diff -Naur a/Documentation/devicetree/bindings/mtd/amlogic,meson-nand.txt b/Documentation/devicetree/bindings/mtd/amlogic,meson-nand.txt
--- a/Documentation/devicetree/bindings/mtd/amlogic,meson-nand.txt	2021-10-31 16:53:10.000000000 -0400
+++ b/Documentation/devicetree/bindings/mtd/amlogic,meson-nand.txt	2021-10-31 20:41:20.000000000 -0400
@@ -5,6 +5,9 @@
 
 Required properties:
 - compatible : contains one of:
+  - "amlogic,meson8-nfc"
+  - "amlogic,meson8b-nfc"
+  - "amlogic,meson-gxbb-nfc"
   - "amlogic,meson-gxl-nfc"
   - "amlogic,meson-axg-nfc"
 - clocks     :
@@ -13,12 +16,13 @@
 
 - clock-names: Should contain the following:
 	"core" - NFC module gate clock
-	"device" - device clock from eMMC sub clock controller
-	"rx" - rx clock phase
-	"tx" - tx clock phase
+	"device" - NAND device clock
+	"rx" - rx clock phase, only used on the GXL, GXM and AXG SoCs.
+	"tx" - tx clock phase, only used on the GXL, GXM and AXG SoCs.
 
-- amlogic,mmc-syscon	: Required for NAND clocks, it's shared with SD/eMMC
-				controller port C
+- amlogic,mmc-syscon	: Only used on the GXL, GXM and AXG SoCs.
+			  Required for NAND clocks, it's shared with SD/eMMC
+			  controller port C
 
 Optional children nodes:
 Children nodes represent the available nand chips.
diff -Naur a/Documentation/devicetree/bindings/net/amlogic,meson-dwmac.yaml b/Documentation/devicetree/bindings/net/amlogic,meson-dwmac.yaml
--- a/Documentation/devicetree/bindings/net/amlogic,meson-dwmac.yaml	2021-10-31 16:53:10.000000000 -0400
+++ b/Documentation/devicetree/bindings/net/amlogic,meson-dwmac.yaml	2021-10-31 20:41:20.000000000 -0400
@@ -127,6 +127,28 @@
             - 2800
             - 3000
 
+  - if:
+      properties:
+        compatible:
+          contains:
+            enum:
+              - amlogic,meson6-dwmac
+    then:
+      properties:
+        clocks:
+          minItems: 1
+          maxItems: 2
+          items:
+            - description: GMAC main clock
+            - description: The RMII reference clock
+
+        clock-names:
+          minItems: 1
+          maxItems: 2
+          items:
+            - const: stmmaceth
+            - const: ethernet
+
 properties:
   compatible:
     additionalItems: true
diff -Naur a/Documentation/devicetree/bindings/net/realtek,rtl8211f.yaml b/Documentation/devicetree/bindings/net/realtek,rtl8211f.yaml
--- a/Documentation/devicetree/bindings/net/realtek,rtl8211f.yaml	1969-12-31 19:00:00.000000000 -0500
+++ b/Documentation/devicetree/bindings/net/realtek,rtl8211f.yaml	2021-10-31 20:41:20.000000000 -0400
@@ -0,0 +1,75 @@
+# SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: "http://devicetree.org/schemas/net/realtek,rtl8211f.yaml#"
+$schema: "http://devicetree.org/meta-schemas/core.yaml#"
+
+title: Realtek RTL8211F Ethernet PHY
+
+maintainers:
+  - Martin Blumenstingl <martin.blumenstingl@googlemail.com>
+
+description: |
+  The Realtek RTL8211F-CG/RTL8211FI-CG is a highly integrated Ethernet
+  transceiver that is compatible with 10Base-T, 100Base-TX, and 1000Base-T
+  IEEE 802.3 standards. It provides all the necessary physical layer
+  functions to transmit and receive Ethernet packets over CAT.5 UTP cable.
+  The RTL8211FI-CG is manufactured to industrial grade standards.
+
+  The RTL8211F(I)-CG uses state-of-the-art DSP technology and an Analog
+  Front End (AFE) to enable high-speed data transmission and reception over
+  UTP cable. Functions such as Crossover Detection & Auto-Correction,
+  polarity correction, adaptive equalization, cross-talk cancellation,
+  echo cancellation, timing recovery, and error correction are implemented
+  in the RTL8211F(I)-CG to provide robust transmission and reception
+  capabilities at 10Mbps, 100Mbps, or 1000Mbps.
+
+  Data transfer between MAC and PHY is via the Reduced Gigabit Media
+  Independent Interface (RGMII) for 1000Base-T, 10Base-T, and 100Base-TX.
+  The RTL8211F(I)-CG supports various RGMII signaling voltages, including
+  3.3V, 2.5V, 1.8V, and 1.5V.
+
+  The RTL8211F(I)-CG incorporates a state-of-the-art switching regulator that
+  requires a well-designed PCB layout in order to achieve good power efficiency
+  and lower the output voltage ripple and input overshoot.
+
+allOf:
+  - $ref: ethernet-phy.yaml#
+
+properties:
+  realtek,led-0-mode:
+    $ref: /schemas/types.yaml#definitions/uint32
+    description: |
+       LED0 configuration; see the RTL8211F_LED_* values from
+       <dt-bindings/net/realtek-rtl8211f.h>
+
+  realtek,led-1-mode:
+    $ref: /schemas/types.yaml#definitions/uint32
+    description: |
+       LED1 configuration; see the RTL8211F_LED_* values from
+       <dt-bindings/net/realtek-rtl8211f.h>
+
+  realtek,led-2-mode:
+    $ref: /schemas/types.yaml#definitions/uint32
+    description: |
+       LED2 configuration; see the RTL8211F_LED_* values from
+       <dt-bindings/net/realtek-rtl8211f.h>
+
+required:
+  - reg
+
+examples:
+  - |
+    #include <dt-bindings/net/realtek-rtl8211f.h>
+
+    mdio {
+      #address-cells = <1>;
+      #size-cells = <0>;
+
+      ethernet-phy@0 {
+        reg = <0>;
+        realtek,led-0-mode = <0>;
+        realtek,led-1-mode = <(RTL8211F_LED_LINK_100 | RTL8211F_LED_ACTIVITY | RTL8211F_LED_EEE)>;
+        realtek,led-2-mode = <(RTL8211F_LED_LINK_1000 | RTL8211F_LED_ACTIVITY | RTL8211F_LED_EEE)>;
+      };
+    };
diff -Naur a/Documentation/devicetree/bindings/phy/amlogic,meson8b-usb2-phy.yaml b/Documentation/devicetree/bindings/phy/amlogic,meson8b-usb2-phy.yaml
--- a/Documentation/devicetree/bindings/phy/amlogic,meson8b-usb2-phy.yaml	2021-10-31 16:53:10.000000000 -0400
+++ b/Documentation/devicetree/bindings/phy/amlogic,meson8b-usb2-phy.yaml	2021-10-31 20:41:20.000000000 -0400
@@ -6,6 +6,12 @@
 
 title: Amlogic Meson8, Meson8b, Meson8m2 and GXBB USB2 PHY
 
+description: |
+  Amlogic Meson8, Meson8b, Meson8m2 and GXBB embed two USB2 PHYs.
+  Typically the USB "ID" signal (used for dual role operation) is
+  routed to the first PHY. In that case the value can be read out
+  as a GPIO.
+
 maintainers:
   - Martin Blumenstingl <martin.blumenstingl@googlemail.com>
 
@@ -31,8 +37,13 @@
       - const: usb_general
       - const: usb
 
+  '#gpio-cells':
+    const: 2
+
+  gpio-controller: true
+
   resets:
-    minItems: 1
+    minItems: 2
 
   "#phy-cells":
     const: 0
diff -Naur a/Documentation/devicetree/bindings/phy/amlogic,meson8-hdmi-tx-phy.yaml b/Documentation/devicetree/bindings/phy/amlogic,meson8-hdmi-tx-phy.yaml
--- a/Documentation/devicetree/bindings/phy/amlogic,meson8-hdmi-tx-phy.yaml	1969-12-31 19:00:00.000000000 -0500
+++ b/Documentation/devicetree/bindings/phy/amlogic,meson8-hdmi-tx-phy.yaml	2021-10-31 20:41:20.000000000 -0400
@@ -0,0 +1,65 @@
+# SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: "http://devicetree.org/schemas/phy/amlogic,meson8-hdmi-tx-phy.yaml#"
+$schema: "http://devicetree.org/meta-schemas/core.yaml#"
+
+title: Amlogic Meson8, Meson8b and Meson8m2 HDMI TX PHY
+
+maintainers:
+  - Martin Blumenstingl <martin.blumenstingl@googlemail.com>
+
+description: |+
+  The HDMI TX PHY node should be the child of a syscon node with the
+  required property:
+
+  compatible = "amlogic,meson-hhi-sysctrl", "simple-mfd", "syscon"
+
+  Refer to the bindings described in
+  Documentation/devicetree/bindings/mfd/syscon.yaml
+
+properties:
+  $nodename:
+    pattern: "^hdmi-phy@[0-9a-f]+$"
+
+  compatible:
+    oneOf:
+      - items:
+          - enum:
+              - amlogic,meson8b-hdmi-tx-phy
+              - amlogic,meson8m2-hdmi-tx-phy
+          - const: amlogic,meson8-hdmi-tx-phy
+      - const: amlogic,meson8-hdmi-tx-phy
+
+  reg:
+    maxItems: 1
+
+  clocks:
+    minItems: 1
+    description:
+      HDMI TMDS clock
+
+  "#phy-cells":
+    const: 0
+
+required:
+  - compatible
+  - "#phy-cells"
+
+additionalProperties: false
+
+examples:
+  - |
+    hdmi-phy@3a0 {
+      compatible = "amlogic,meson8-hdmi-tx-phy";
+      reg = <0x3a0 0xc>;
+      clocks = <&tmds_clock>;
+      #phy-cells = <0>;
+    };
+  - |
+    hdmi-phy@3a0 {
+      compatible = "amlogic,meson8b-hdmi-tx-phy", "amlogic,meson8-hdmi-tx-phy";
+      reg = <0x3a0 0xc>;
+      clocks = <&tmds_clock>;
+      #phy-cells = <0>;
+    };
diff -Naur a/Documentation/devicetree/bindings/phy/amlogic,meson-cvbs-dac-phy.yaml b/Documentation/devicetree/bindings/phy/amlogic,meson-cvbs-dac-phy.yaml
--- a/Documentation/devicetree/bindings/phy/amlogic,meson-cvbs-dac-phy.yaml	1969-12-31 19:00:00.000000000 -0500
+++ b/Documentation/devicetree/bindings/phy/amlogic,meson-cvbs-dac-phy.yaml	2021-10-31 20:41:20.000000000 -0400
@@ -0,0 +1,81 @@
+# SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: "http://devicetree.org/schemas/phy/amlogic,meson-cvbs-dac-phy.yaml#"
+$schema: "http://devicetree.org/meta-schemas/core.yaml#"
+
+title: Amlogic Meson Composite Video Baseband Signal DAC
+
+maintainers:
+  - Martin Blumenstingl <martin.blumenstingl@googlemail.com>
+
+description: |+
+  The CVBS DAC node should be the child of a syscon node with the
+  required property:
+
+  compatible = "amlogic,meson-hhi-sysctrl", "simple-mfd", "syscon"
+
+  Refer to the bindings described in
+  Documentation/devicetree/bindings/mfd/syscon.yaml
+
+properties:
+  $nodename:
+    pattern: "^video-dac@[0-9a-f]+$"
+
+  compatible:
+    oneOf:
+      - items:
+          - enum:
+              - amlogic,meson8-cvbs-dac
+              - amlogic,meson-gxbb-cvbs-dac
+              - amlogic,meson-gxl-cvbs-dac
+              - amlogic,meson-g12a-cvbs-dac
+          - const: amlogic,meson-cvbs-dac
+      - const: amlogic,meson-cvbs-dac
+
+  reg:
+    maxItems: 1
+
+  clocks:
+    minItems: 1
+
+  nvmem-cells:
+    minItems: 1
+
+  nvmem-cell-names:
+    items:
+      - const: cvbs_trimming
+
+  "#phy-cells":
+    const: 0
+
+required:
+  - compatible
+  - reg
+  - clocks
+  - "#phy-cells"
+
+additionalProperties: false
+
+examples:
+  - |
+    video-dac@2f4 {
+      compatible = "amlogic,meson8-cvbs-dac", "amlogic,meson-cvbs-dac";
+      reg = <0x2f4 0x8>;
+
+      #phy-cells = <0>;
+
+      clocks = <&vdac_clock>;
+
+      nvmem-cells = <&cvbs_trimming>;
+      nvmem-cell-names = "cvbs_trimming";
+    };
+  - |
+    video-dac@2ec {
+      compatible = "amlogic,meson-g12a-cvbs-dac", "amlogic,meson-cvbs-dac";
+      reg = <0x2ec 0x8>;
+
+      #phy-cells = <0>;
+
+      clocks = <&vdac_clock>;
+    };
diff -Naur a/Documentation/devicetree/bindings/remoteproc/amlogic,meson-mx-ao-arc.yaml b/Documentation/devicetree/bindings/remoteproc/amlogic,meson-mx-ao-arc.yaml
--- a/Documentation/devicetree/bindings/remoteproc/amlogic,meson-mx-ao-arc.yaml	1969-12-31 19:00:00.000000000 -0500
+++ b/Documentation/devicetree/bindings/remoteproc/amlogic,meson-mx-ao-arc.yaml	2021-10-31 20:41:20.000000000 -0400
@@ -0,0 +1,87 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: "http://devicetree.org/schemas/remoteproc/amlogic,meson-mx-ao-arc.yaml#"
+$schema: "http://devicetree.org/meta-schemas/core.yaml#"
+
+title: Amlogic Meson AO ARC Remote Processor bindings
+
+description:
+  Amlogic Meson6, Meson8, Meson8b and Meson8m2 SoCs embed an ARC core
+  controller for always-on operations, typically used for managing
+  system suspend. Meson6 and older use a ARC core based on the ARCv1
+  ISA, while Meson8, Meson8b and Meson8m2 use an ARC EM4 (ARCv2 ISA)
+  core.
+
+maintainers:
+  - Martin Blumenstingl <martin.blumenstingl@googlemail.com>
+
+properties:
+  compatible:
+    items:
+      - enum:
+          - amlogic,meson8-ao-arc
+          - amlogic,meson8b-ao-arc
+      - const: amlogic,meson-mx-ao-arc
+
+  firmware-name:
+    $ref: /schemas/types.yaml#/definitions/string
+    description:
+      The name of the firmware which should be loaded for this remote
+      processor.
+
+  reg:
+    description:
+      Address ranges of the remap and CPU control addresses for the
+      remote processor.
+    minItems: 2
+
+  reg-names:
+    items:
+      - const: remap
+      - const: cpu
+
+  resets:
+    minItems: 1
+
+  clocks:
+    minItems: 1
+
+  sram:
+    $ref: /schemas/types.yaml#/definitions/phandle
+    description:
+      phandles to a reserved SRAM region which is used as the memory of
+      the ARC core. The region should be defined as child nodes of the
+      AHB SRAM node as per the generic bindings in
+      Documentation/devicetree/bindings/sram/sram.yaml
+
+  amlogic,secbus2:
+    $ref: /schemas/types.yaml#/definitions/phandle
+    description:
+      A phandle to the SECBUS2 region which contains some configuration
+      bits of this remote processor
+
+required:
+  - compatible
+  - reg
+  - reg-names
+  - resets
+  - clocks
+  - sram
+  - amlogic,secbus2
+
+additionalProperties: false
+
+examples:
+  - |
+    remoteproc@1c {
+      compatible= "amlogic,meson8-ao-arc", "amlogic,meson-mx-ao-arc";
+      reg = <0x1c 0x8>, <0x38 0x8>;
+      reg-names = "remap", "cpu";
+      resets = <&media_cpu_reset>;
+      clocks = <&media_cpu_clock>;
+      sram = <&ahb_sram_ao_arc>;
+      amlogic,secbus2 = <&secbus2>;
+    };
+
+...
diff -Naur a/Documentation/devicetree/bindings/sound/cirrus,cs4334.yaml b/Documentation/devicetree/bindings/sound/cirrus,cs4334.yaml
--- a/Documentation/devicetree/bindings/sound/cirrus,cs4334.yaml	1969-12-31 19:00:00.000000000 -0500
+++ b/Documentation/devicetree/bindings/sound/cirrus,cs4334.yaml	2021-10-31 20:41:20.000000000 -0400
@@ -0,0 +1,42 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/sound/cirrus,cs4334.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+
+title: Cirrus CS4334 - or functionally compatible - I2S Stereo DACs
+
+maintainers:
+  - Martin Blumenstingl <martin.blumenstingl@googlemail.com>
+
+description: |
+  Cirrus CS4334 16-24 bit stereo DAC with I2S input.
+  https://statics.cirrus.com/pubs/proDatasheet/CS4334-5-8-9_F7.pdf
+  http://www.mxtronics.com/n107/n124/n181/n184/c697/attr/2625.pdf
+
+properties:
+  compatible:
+    enum:
+      - cirrus,cs4334
+      - mxtronics,mxt8234
+
+  "#sound-dai-cells":
+    const: 0
+
+  VDD-supply:
+    description:
+      Regulator for the codec voltage supply
+
+required:
+  - compatible
+  - "#sound-dai-cells"
+  - VDD-supply
+
+examples:
+  - |
+     audio-codec {
+         compatible = "mxtronics,mxt8234";
+         #sound-dai-cells = <0>;
+         VDD-supply = <&codec_vdd>;
+     };
diff -Naur a/Documentation/devicetree/bindings/usb/etron,ej1x8.yaml b/Documentation/devicetree/bindings/usb/etron,ej1x8.yaml
--- a/Documentation/devicetree/bindings/usb/etron,ej1x8.yaml	1969-12-31 19:00:00.000000000 -0500
+++ b/Documentation/devicetree/bindings/usb/etron,ej1x8.yaml	2021-10-31 20:41:20.000000000 -0400
@@ -0,0 +1,49 @@
+# SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/usb/etron,ej1x8.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: EJ168/EJ188/EJ198 xHCI controllers with four GPIO lines
+
+maintainers:
+  - Martin Blumenstingl <martin.blumenstingl@googlemail.com>
+
+allOf:
+  - $ref: "usb-hcd.yaml#"
+
+properties:
+  compatible:
+    enum:
+      - pci1b6f,7023
+      - pci1b6f,7052
+
+  reg:
+    maxItems: 1
+
+  "#gpio-cells":
+    const: 2
+
+  gpio-controller: true
+
+required:
+  - compatible
+  - reg
+
+additionalProperties: false
+
+examples:
+  - |
+      pcie {
+        #address-cells = <3>;
+        #size-cells = <2>;
+
+        usb@0,0,0 {
+          compatible = "pci1b6f,7023";
+          reg = <0x0 0x0 0x0 0x0 0x1000>;
+          gpio-controller;
+          #gpio-cells = <2>;
+        };
+      };
+
+...
diff -Naur a/Documentation/devicetree/bindings/vendor-prefixes.yaml b/Documentation/devicetree/bindings/vendor-prefixes.yaml
--- a/Documentation/devicetree/bindings/vendor-prefixes.yaml	2021-10-31 16:53:10.000000000 -0400
+++ b/Documentation/devicetree/bindings/vendor-prefixes.yaml	2021-10-31 20:41:20.000000000 -0400
@@ -776,6 +776,8 @@
     description: Murata Manufacturing Co., Ltd.
   "^mxicy,.*":
     description: Macronix International Co., Ltd.
+  "^mxtronics,.*":
+    description: Beijing Times Minxin Technology Co., Ltd.
   "^myir,.*":
     description: MYIR Tech Limited
   "^national,.*":
diff -Naur a/drivers/clk/meson/clk-cpu-dyndiv.c b/drivers/clk/meson/clk-cpu-dyndiv.c
--- a/drivers/clk/meson/clk-cpu-dyndiv.c	2021-10-31 16:53:10.000000000 -0400
+++ b/drivers/clk/meson/clk-cpu-dyndiv.c	2021-10-31 20:41:20.000000000 -0400
@@ -27,14 +27,13 @@
 				   NULL, 0, data->div.width);
 }
 
-static long meson_clk_cpu_dyndiv_round_rate(struct clk_hw *hw,
-					    unsigned long rate,
-					    unsigned long *prate)
+static int meson_clk_cpu_dyndiv_determine_rate(struct clk_hw *hw,
+					       struct clk_rate_request *req)
 {
 	struct clk_regmap *clk = to_clk_regmap(hw);
 	struct meson_clk_cpu_dyndiv_data *data = meson_clk_cpu_dyndiv_data(clk);
 
-	return divider_round_rate(hw, rate, prate, NULL, data->div.width, 0);
+	return divider_determine_rate(hw, req, NULL, data->div.width, 0);
 }
 
 static int meson_clk_cpu_dyndiv_set_rate(struct clk_hw *hw, unsigned long rate,
@@ -63,7 +62,7 @@
 
 const struct clk_ops meson_clk_cpu_dyndiv_ops = {
 	.recalc_rate = meson_clk_cpu_dyndiv_recalc_rate,
-	.round_rate = meson_clk_cpu_dyndiv_round_rate,
+	.determine_rate = meson_clk_cpu_dyndiv_determine_rate,
 	.set_rate = meson_clk_cpu_dyndiv_set_rate,
 };
 EXPORT_SYMBOL_GPL(meson_clk_cpu_dyndiv_ops);
diff -Naur a/drivers/clk/meson/clk-dualdiv.c b/drivers/clk/meson/clk-dualdiv.c
--- a/drivers/clk/meson/clk-dualdiv.c	2021-10-31 16:53:10.000000000 -0400
+++ b/drivers/clk/meson/clk-dualdiv.c	2021-10-31 20:41:20.000000000 -0400
@@ -86,18 +86,23 @@
 	return (struct meson_clk_dualdiv_param *)&table[best_i];
 }
 
-static long meson_clk_dualdiv_round_rate(struct clk_hw *hw, unsigned long rate,
-					 unsigned long *parent_rate)
+static int meson_clk_dualdiv_determine_rate(struct clk_hw *hw,
+					    struct clk_rate_request *req)
 {
 	struct clk_regmap *clk = to_clk_regmap(hw);
 	struct meson_clk_dualdiv_data *dualdiv = meson_clk_dualdiv_data(clk);
-	const struct meson_clk_dualdiv_param *setting =
-		__dualdiv_get_setting(rate, *parent_rate, dualdiv);
+	const struct meson_clk_dualdiv_param *setting;
 
-	if (!setting)
-		return meson_clk_dualdiv_recalc_rate(hw, *parent_rate);
+	setting = __dualdiv_get_setting(req->rate, req->best_parent_rate,
+					dualdiv);
+	if (setting)
+		req->rate = __dualdiv_param_to_rate(req->best_parent_rate,
+						    setting);
+	else
+		req->rate = meson_clk_dualdiv_recalc_rate(hw,
+							  req->best_parent_rate);
 
-	return __dualdiv_param_to_rate(*parent_rate, setting);
+	return 0;
 }
 
 static int meson_clk_dualdiv_set_rate(struct clk_hw *hw, unsigned long rate,
@@ -122,7 +127,7 @@
 
 const struct clk_ops meson_clk_dualdiv_ops = {
 	.recalc_rate	= meson_clk_dualdiv_recalc_rate,
-	.round_rate	= meson_clk_dualdiv_round_rate,
+	.determine_rate	= meson_clk_dualdiv_determine_rate,
 	.set_rate	= meson_clk_dualdiv_set_rate,
 };
 EXPORT_SYMBOL_GPL(meson_clk_dualdiv_ops);
diff -Naur a/drivers/clk/meson/clk-mpll.c b/drivers/clk/meson/clk-mpll.c
--- a/drivers/clk/meson/clk-mpll.c	2021-10-31 16:53:10.000000000 -0400
+++ b/drivers/clk/meson/clk-mpll.c	2021-10-31 20:41:20.000000000 -0400
@@ -77,26 +77,35 @@
 {
 	struct clk_regmap *clk = to_clk_regmap(hw);
 	struct meson_clk_mpll_data *mpll = meson_clk_mpll_data(clk);
-	unsigned int sdm, n2;
+	unsigned int n2, sdm_en, sdm = 0;
 	long rate;
 
-	sdm = meson_parm_read(clk->map, &mpll->sdm);
+	sdm_en = meson_parm_read(clk->map, &mpll->sdm_en);
+	if (sdm_en)
+		sdm = meson_parm_read(clk->map, &mpll->sdm);
+
 	n2 = meson_parm_read(clk->map, &mpll->n2);
 
 	rate = rate_from_params(parent_rate, sdm, n2);
 	return rate < 0 ? 0 : rate;
 }
 
-static long mpll_round_rate(struct clk_hw *hw,
-			    unsigned long rate,
-			    unsigned long *parent_rate)
+static int mpll_determine_rate(struct clk_hw *hw, struct clk_rate_request *req)
 {
 	struct clk_regmap *clk = to_clk_regmap(hw);
 	struct meson_clk_mpll_data *mpll = meson_clk_mpll_data(clk);
 	unsigned int sdm, n2;
+	long rate;
+
+	params_from_rate(req->rate, req->best_parent_rate, &sdm, &n2,
+			 mpll->flags);
 
-	params_from_rate(rate, *parent_rate, &sdm, &n2, mpll->flags);
-	return rate_from_params(*parent_rate, sdm, n2);
+	rate = rate_from_params(req->best_parent_rate, sdm, n2);
+	if (rate < 0)
+		return rate;
+
+	req->rate = rate;
+	return 0;
 }
 
 static int mpll_set_rate(struct clk_hw *hw,
@@ -118,6 +127,9 @@
 	/* Set the fractional part */
 	meson_parm_write(clk->map, &mpll->sdm, sdm);
 
+	/* Enable or disable the fractional part as needed */
+	meson_parm_write(clk->map, &mpll->sdm_en, sdm > 0 ? 1 : 0);
+
 	/* Set the integer divider part */
 	meson_parm_write(clk->map, &mpll->n2, n2);
 
@@ -138,9 +150,6 @@
 		regmap_multi_reg_write(clk->map, mpll->init_regs,
 				       mpll->init_count);
 
-	/* Enable the fractional part */
-	meson_parm_write(clk->map, &mpll->sdm_en, 1);
-
 	/* Set spread spectrum if possible */
 	if (MESON_PARM_APPLICABLE(&mpll->ssen)) {
 		unsigned int ss =
@@ -157,13 +166,13 @@
 
 const struct clk_ops meson_clk_mpll_ro_ops = {
 	.recalc_rate	= mpll_recalc_rate,
-	.round_rate	= mpll_round_rate,
+	.determine_rate	= mpll_determine_rate,
 };
 EXPORT_SYMBOL_GPL(meson_clk_mpll_ro_ops);
 
 const struct clk_ops meson_clk_mpll_ops = {
 	.recalc_rate	= mpll_recalc_rate,
-	.round_rate	= mpll_round_rate,
+	.determine_rate	= mpll_determine_rate,
 	.set_rate	= mpll_set_rate,
 	.init		= mpll_init,
 };
diff -Naur a/drivers/clk/meson/gxbb.c b/drivers/clk/meson/gxbb.c
--- a/drivers/clk/meson/gxbb.c	2021-10-31 16:53:10.000000000 -0400
+++ b/drivers/clk/meson/gxbb.c	2021-10-31 20:41:20.000000000 -0400
@@ -720,6 +720,35 @@
 			.width   = 14,
 		},
 		.sdm_en = {
+			.reg_off = HHI_MPLL_CNTL,
+			.shift   = 25,
+			.width	 = 1,
+		},
+		.n2 = {
+			.reg_off = HHI_MPLL_CNTL7,
+			.shift   = 16,
+			.width   = 9,
+		},
+		.lock = &meson_clk_lock,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "mpll0_div",
+		.ops = &meson_clk_mpll_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&gxbb_mpll_prediv.hw
+		},
+		.num_parents = 1,
+	},
+};
+
+static struct clk_regmap gxl_mpll0_div = {
+	.data = &(struct meson_clk_mpll_data){
+		.sdm = {
+			.reg_off = HHI_MPLL_CNTL7,
+			.shift   = 0,
+			.width   = 14,
+		},
+		.sdm_en = {
 			.reg_off = HHI_MPLL_CNTL7,
 			.shift   = 15,
 			.width	 = 1,
@@ -749,7 +778,16 @@
 	.hw.init = &(struct clk_init_data){
 		.name = "mpll0",
 		.ops = &clk_regmap_gate_ops,
-		.parent_hws = (const struct clk_hw *[]) { &gxbb_mpll0_div.hw },
+		.parent_data = &(const struct clk_parent_data) {
+			/*
+			 * Note:
+			 * GXL and GXBB have different SDM_EN registers. We
+			 * fallback to the global naming string mechanism so
+			 * mpll0_div picks up the appropriate one.
+			 */
+			.name = "mpll0_div",
+			.index = -1,
+		},
 		.num_parents = 1,
 		.flags = CLK_SET_RATE_PARENT,
 	},
@@ -3044,7 +3082,7 @@
 		[CLKID_VAPB_1]		    = &gxbb_vapb_1.hw,
 		[CLKID_VAPB_SEL]	    = &gxbb_vapb_sel.hw,
 		[CLKID_VAPB]		    = &gxbb_vapb.hw,
-		[CLKID_MPLL0_DIV]	    = &gxbb_mpll0_div.hw,
+		[CLKID_MPLL0_DIV]	    = &gxl_mpll0_div.hw,
 		[CLKID_MPLL1_DIV]	    = &gxbb_mpll1_div.hw,
 		[CLKID_MPLL2_DIV]	    = &gxbb_mpll2_div.hw,
 		[CLKID_MPLL_PREDIV]	    = &gxbb_mpll_prediv.hw,
@@ -3439,7 +3477,7 @@
 	&gxbb_mpll0,
 	&gxbb_mpll1,
 	&gxbb_mpll2,
-	&gxbb_mpll0_div,
+	&gxl_mpll0_div,
 	&gxbb_mpll1_div,
 	&gxbb_mpll2_div,
 	&gxbb_cts_amclk_div,
diff -Naur a/drivers/clk/meson/Kconfig b/drivers/clk/meson/Kconfig
--- a/drivers/clk/meson/Kconfig	2021-10-31 16:53:10.000000000 -0400
+++ b/drivers/clk/meson/Kconfig	2021-10-31 20:41:20.000000000 -0400
@@ -49,6 +49,7 @@
 	default y
 	select COMMON_CLK_MESON_REGMAP
 	select COMMON_CLK_MESON_MPLL
+	select COMMON_CLK_MESON_PHASE
 	select COMMON_CLK_MESON_PLL
 	select MFD_SYSCON
 	select RESET_CONTROLLER
diff -Naur a/drivers/clk/meson/meson8b.c b/drivers/clk/meson/meson8b.c
--- a/drivers/clk/meson/meson8b.c	2021-10-31 16:53:10.000000000 -0400
+++ b/drivers/clk/meson/meson8b.c	2021-10-31 20:41:20.000000000 -0400
@@ -18,6 +18,7 @@
 
 #include "meson8b.h"
 #include "clk-regmap.h"
+#include "clk-phase.h"
 #include "clk-pll.h"
 #include "clk-mpll.h"
 
@@ -118,6 +119,56 @@
 	},
 };
 
+static struct clk_fixed_factor hdmi_pll_dco_in = {
+	.mult = 2,
+	.div = 1,
+	.hw.init = &(struct clk_init_data){
+		.name = "hdmi_pll_dco_in",
+		.ops = &clk_fixed_factor_ops,
+		.parent_data = &(const struct clk_parent_data) {
+			.fw_name = "xtal",
+			.index = -1,
+		},
+		.num_parents = 1,
+	},
+};
+
+/*
+ * Taken from the vendor driver for the 2970/2975MHz (both only differ in the
+ * FRAC part in HHI_VID_PLL_CNTL2) where these values are identical for Meson8,
+ * Meson8b and Meson8m2. This doubles the input (or output - it's not clear
+ * which one but the result is the same) clock. The vendor driver additionally
+ * has the following comment about: "optimise HPLL VCO 2.97GHz performance".
+ */
+static const struct reg_sequence meson8b_hdmi_pll_init_regs[] = {
+	{ .reg = HHI_VID_PLL_CNTL2,	.def = 0x69c84000 },
+	{ .reg = HHI_VID_PLL_CNTL3,	.def = 0x8a46c023 },
+	{ .reg = HHI_VID_PLL_CNTL4,	.def = 0x4123b100 },
+	{ .reg = HHI_VID_PLL_CNTL5,	.def = 0x00012385 },
+	{ .reg = HHI_VID2_PLL_CNTL2,	.def = 0x0430a800 },
+};
+
+static const struct pll_params_table hdmi_pll_params_table[] = {
+	PLL_PARAMS(40, 1),
+	PLL_PARAMS(42, 1),
+	PLL_PARAMS(44, 1),
+	PLL_PARAMS(45, 1),
+	PLL_PARAMS(49, 1),
+	PLL_PARAMS(52, 1),
+	PLL_PARAMS(54, 1),
+	PLL_PARAMS(56, 1),
+	PLL_PARAMS(59, 1),
+	PLL_PARAMS(60, 1),
+	PLL_PARAMS(61, 1),
+	PLL_PARAMS(62, 1),
+	PLL_PARAMS(64, 1),
+	PLL_PARAMS(66, 1),
+	PLL_PARAMS(68, 1),
+	PLL_PARAMS(71, 1),
+	PLL_PARAMS(82, 1),
+	{ /* sentinel */ }
+};
+
 static struct clk_regmap meson8b_hdmi_pll_dco = {
 	.data = &(struct meson_clk_pll_data){
 		.en = {
@@ -150,15 +201,16 @@
 			.shift   = 29,
 			.width   = 1,
 		},
+		.table = hdmi_pll_params_table,
+		.init_regs = meson8b_hdmi_pll_init_regs,
+		.init_count = ARRAY_SIZE(meson8b_hdmi_pll_init_regs),
 	},
 	.hw.init = &(struct clk_init_data){
 		/* sometimes also called "HPLL" or "HPLL PLL" */
 		.name = "hdmi_pll_dco",
-		.ops = &meson_clk_pll_ro_ops,
-		.parent_data = &(const struct clk_parent_data) {
-			.fw_name = "xtal",
-			.name = "xtal",
-			.index = -1,
+		.ops = &meson_clk_pll_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&hdmi_pll_dco_in.hw
 		},
 		.num_parents = 1,
 	},
@@ -173,7 +225,7 @@
 	},
 	.hw.init = &(struct clk_init_data){
 		.name = "hdmi_pll_lvds_out",
-		.ops = &clk_regmap_divider_ro_ops,
+		.ops = &clk_regmap_divider_ops,
 		.parent_hws = (const struct clk_hw *[]) {
 			&meson8b_hdmi_pll_dco.hw
 		},
@@ -191,7 +243,7 @@
 	},
 	.hw.init = &(struct clk_init_data){
 		.name = "hdmi_pll_hdmi_out",
-		.ops = &clk_regmap_divider_ro_ops,
+		.ops = &clk_regmap_divider_ops,
 		.parent_hws = (const struct clk_hw *[]) {
 			&meson8b_hdmi_pll_dco.hw
 		},
@@ -555,7 +607,24 @@
 	},
 };
 
-static u32 mux_table_clk81[]	= { 6, 5, 7 };
+static struct clk_regmap meson8b_mpeg_rtc_osc_sel = {
+	.data = &(struct clk_regmap_mux_data){
+		.offset = HHI_MPEG_CLK_CNTL,
+		.mask = 0x1,
+		.shift = 9,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "mpeg_rtc_osc_sel",
+		.ops = &clk_regmap_mux_ro_ops,
+		.parent_data = (const struct clk_parent_data[]) {
+			{ .fw_name = "xtal", .index = -1, },
+			{ .fw_name = "rtc_32k", .index = -1, },
+		},
+		.num_parents = 2,
+	},
+};
+
+static u32 mux_table_clk81[] = { 0, 6, 5, 7 };
 static struct clk_regmap meson8b_mpeg_clk_sel = {
 	.data = &(struct clk_regmap_mux_data){
 		.offset = HHI_MPEG_CLK_CNTL,
@@ -572,11 +641,12 @@
 		 * fclk_div4, fclk_div3, fclk_div5
 		 */
 		.parent_hws = (const struct clk_hw *[]) {
+			&meson8b_mpeg_rtc_osc_sel.hw,
 			&meson8b_fclk_div3.hw,
 			&meson8b_fclk_div4.hw,
 			&meson8b_fclk_div5.hw,
 		},
-		.num_parents = 3,
+		.num_parents = 4,
 	},
 };
 
@@ -1045,6 +1115,23 @@
 	},
 };
 
+/* also called LVDS_CLK_EN */
+static struct clk_regmap meson8b_vid_pll_lvds_en = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = HHI_VID_DIVIDER_CNTL,
+		.bit_idx = 11,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "vid_pll_lvds_en",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&meson8b_hdmi_pll_lvds_out.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT,
+	},
+};
+
 static struct clk_regmap meson8b_vid_pll_in_sel = {
 	.data = &(struct clk_regmap_mux_data){
 		.offset = HHI_VID_DIVIDER_CNTL,
@@ -1053,7 +1140,7 @@
 	},
 	.hw.init = &(struct clk_init_data){
 		.name = "vid_pll_in_sel",
-		.ops = &clk_regmap_mux_ro_ops,
+		.ops = &clk_regmap_mux_ops,
 		/*
 		 * TODO: depending on the SoC there is also a second parent:
 		 * Meson8: unknown
@@ -1061,7 +1148,7 @@
 		 * Meson8m2: vid2_pll
 		 */
 		.parent_hws = (const struct clk_hw *[]) {
-			&meson8b_hdmi_pll_lvds_out.hw
+			&meson8b_vid_pll_lvds_en.hw
 		},
 		.num_parents = 1,
 		.flags = CLK_SET_RATE_PARENT,
@@ -1075,7 +1162,7 @@
 	},
 	.hw.init = &(struct clk_init_data){
 		.name = "vid_pll_in_en",
-		.ops = &clk_regmap_gate_ro_ops,
+		.ops = &clk_regmap_gate_ops,
 		.parent_hws = (const struct clk_hw *[]) {
 			&meson8b_vid_pll_in_sel.hw
 		},
@@ -1092,7 +1179,7 @@
 	},
 	.hw.init = &(struct clk_init_data){
 		.name = "vid_pll_pre_div",
-		.ops = &clk_regmap_divider_ro_ops,
+		.ops = &clk_regmap_divider_ops,
 		.parent_hws = (const struct clk_hw *[]) {
 			&meson8b_vid_pll_in_en.hw
 		},
@@ -1109,7 +1196,7 @@
 	},
 	.hw.init = &(struct clk_init_data){
 		.name = "vid_pll_post_div",
-		.ops = &clk_regmap_divider_ro_ops,
+		.ops = &clk_regmap_divider_ops,
 		.parent_hws = (const struct clk_hw *[]) {
 			&meson8b_vid_pll_pre_div.hw
 		},
@@ -1126,7 +1213,7 @@
 	},
 	.hw.init = &(struct clk_init_data){
 		.name = "vid_pll",
-		.ops = &clk_regmap_mux_ro_ops,
+		.ops = &clk_regmap_mux_ops,
 		/* TODO: parent 0x2 is vid_pll_pre_div_mult7_div2 */
 		.parent_hws = (const struct clk_hw *[]) {
 			&meson8b_vid_pll_pre_div.hw,
@@ -1145,7 +1232,7 @@
 	},
 	.hw.init = &(struct clk_init_data){
 		.name = "vid_pll_final_div",
-		.ops = &clk_regmap_divider_ro_ops,
+		.ops = &clk_regmap_divider_ops,
 		.parent_hws = (const struct clk_hw *[]) {
 			&meson8b_vid_pll.hw
 		},
@@ -1172,10 +1259,10 @@
 	},
 	.hw.init = &(struct clk_init_data){
 		.name = "vclk_in_sel",
-		.ops = &clk_regmap_mux_ro_ops,
+		.ops = &clk_regmap_mux_ops,
 		.parent_hws = meson8b_vclk_mux_parent_hws,
 		.num_parents = ARRAY_SIZE(meson8b_vclk_mux_parent_hws),
-		.flags = CLK_SET_RATE_PARENT,
+		.flags = CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT,
 	},
 };
 
@@ -1186,7 +1273,7 @@
 	},
 	.hw.init = &(struct clk_init_data){
 		.name = "vclk_in_en",
-		.ops = &clk_regmap_gate_ro_ops,
+		.ops = &clk_regmap_gate_ops,
 		.parent_hws = (const struct clk_hw *[]) {
 			&meson8b_vclk_in_sel.hw
 		},
@@ -1202,7 +1289,7 @@
 	},
 	.hw.init = &(struct clk_init_data){
 		.name = "vclk_en",
-		.ops = &clk_regmap_gate_ro_ops,
+		.ops = &clk_regmap_gate_ops,
 		.parent_hws = (const struct clk_hw *[]) {
 			&meson8b_vclk_in_en.hw
 		},
@@ -1218,7 +1305,7 @@
 	},
 	.hw.init = &(struct clk_init_data){
 		.name = "vclk_div1_en",
-		.ops = &clk_regmap_gate_ro_ops,
+		.ops = &clk_regmap_gate_ops,
 		.parent_hws = (const struct clk_hw *[]) {
 			&meson8b_vclk_en.hw
 		},
@@ -1248,7 +1335,7 @@
 	},
 	.hw.init = &(struct clk_init_data){
 		.name = "vclk_div2_en",
-		.ops = &clk_regmap_gate_ro_ops,
+		.ops = &clk_regmap_gate_ops,
 		.parent_hws = (const struct clk_hw *[]) {
 			&meson8b_vclk_div2_div.hw
 		},
@@ -1278,7 +1365,7 @@
 	},
 	.hw.init = &(struct clk_init_data){
 		.name = "vclk_div4_en",
-		.ops = &clk_regmap_gate_ro_ops,
+		.ops = &clk_regmap_gate_ops,
 		.parent_hws = (const struct clk_hw *[]) {
 			&meson8b_vclk_div4_div.hw
 		},
@@ -1308,7 +1395,7 @@
 	},
 	.hw.init = &(struct clk_init_data){
 		.name = "vclk_div6_en",
-		.ops = &clk_regmap_gate_ro_ops,
+		.ops = &clk_regmap_gate_ops,
 		.parent_hws = (const struct clk_hw *[]) {
 			&meson8b_vclk_div6_div.hw
 		},
@@ -1338,7 +1425,7 @@
 	},
 	.hw.init = &(struct clk_init_data){
 		.name = "vclk_div12_en",
-		.ops = &clk_regmap_gate_ro_ops,
+		.ops = &clk_regmap_gate_ops,
 		.parent_hws = (const struct clk_hw *[]) {
 			&meson8b_vclk_div12_div.hw
 		},
@@ -1355,10 +1442,10 @@
 	},
 	.hw.init = &(struct clk_init_data){
 		.name = "vclk2_in_sel",
-		.ops = &clk_regmap_mux_ro_ops,
+		.ops = &clk_regmap_mux_ops,
 		.parent_hws = meson8b_vclk_mux_parent_hws,
 		.num_parents = ARRAY_SIZE(meson8b_vclk_mux_parent_hws),
-		.flags = CLK_SET_RATE_PARENT,
+		.flags = CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT,
 	},
 };
 
@@ -1369,7 +1456,7 @@
 	},
 	.hw.init = &(struct clk_init_data){
 		.name = "vclk2_in_en",
-		.ops = &clk_regmap_gate_ro_ops,
+		.ops = &clk_regmap_gate_ops,
 		.parent_hws = (const struct clk_hw *[]) {
 			&meson8b_vclk2_in_sel.hw
 		},
@@ -1385,7 +1472,7 @@
 	},
 	.hw.init = &(struct clk_init_data){
 		.name = "vclk2_en",
-		.ops = &clk_regmap_gate_ro_ops,
+		.ops = &clk_regmap_gate_ops,
 		.parent_hws = (const struct clk_hw *[]) {
 			&meson8b_vclk2_clk_in_en.hw
 		},
@@ -1401,7 +1488,7 @@
 	},
 	.hw.init = &(struct clk_init_data){
 		.name = "vclk2_div1_en",
-		.ops = &clk_regmap_gate_ro_ops,
+		.ops = &clk_regmap_gate_ops,
 		.parent_hws = (const struct clk_hw *[]) {
 			&meson8b_vclk2_clk_en.hw
 		},
@@ -1431,7 +1518,7 @@
 	},
 	.hw.init = &(struct clk_init_data){
 		.name = "vclk2_div2_en",
-		.ops = &clk_regmap_gate_ro_ops,
+		.ops = &clk_regmap_gate_ops,
 		.parent_hws = (const struct clk_hw *[]) {
 			&meson8b_vclk2_div2_div.hw
 		},
@@ -1461,7 +1548,7 @@
 	},
 	.hw.init = &(struct clk_init_data){
 		.name = "vclk2_div4_en",
-		.ops = &clk_regmap_gate_ro_ops,
+		.ops = &clk_regmap_gate_ops,
 		.parent_hws = (const struct clk_hw *[]) {
 			&meson8b_vclk2_div4_div.hw
 		},
@@ -1491,7 +1578,7 @@
 	},
 	.hw.init = &(struct clk_init_data){
 		.name = "vclk2_div6_en",
-		.ops = &clk_regmap_gate_ro_ops,
+		.ops = &clk_regmap_gate_ops,
 		.parent_hws = (const struct clk_hw *[]) {
 			&meson8b_vclk2_div6_div.hw
 		},
@@ -1521,7 +1608,7 @@
 	},
 	.hw.init = &(struct clk_init_data){
 		.name = "vclk2_div12_en",
-		.ops = &clk_regmap_gate_ro_ops,
+		.ops = &clk_regmap_gate_ops,
 		.parent_hws = (const struct clk_hw *[]) {
 			&meson8b_vclk2_div12_div.hw
 		},
@@ -1546,7 +1633,7 @@
 	},
 	.hw.init = &(struct clk_init_data){
 		.name = "cts_enct_sel",
-		.ops = &clk_regmap_mux_ro_ops,
+		.ops = &clk_regmap_mux_ops,
 		.parent_hws = meson8b_vclk_enc_mux_parent_hws,
 		.num_parents = ARRAY_SIZE(meson8b_vclk_enc_mux_parent_hws),
 		.flags = CLK_SET_RATE_PARENT,
@@ -1560,7 +1647,7 @@
 	},
 	.hw.init = &(struct clk_init_data){
 		.name = "cts_enct",
-		.ops = &clk_regmap_gate_ro_ops,
+		.ops = &clk_regmap_gate_ops,
 		.parent_hws = (const struct clk_hw *[]) {
 			&meson8b_cts_enct_sel.hw
 		},
@@ -1577,7 +1664,7 @@
 	},
 	.hw.init = &(struct clk_init_data){
 		.name = "cts_encp_sel",
-		.ops = &clk_regmap_mux_ro_ops,
+		.ops = &clk_regmap_mux_ops,
 		.parent_hws = meson8b_vclk_enc_mux_parent_hws,
 		.num_parents = ARRAY_SIZE(meson8b_vclk_enc_mux_parent_hws),
 		.flags = CLK_SET_RATE_PARENT,
@@ -1591,7 +1678,7 @@
 	},
 	.hw.init = &(struct clk_init_data){
 		.name = "cts_encp",
-		.ops = &clk_regmap_gate_ro_ops,
+		.ops = &clk_regmap_gate_ops,
 		.parent_hws = (const struct clk_hw *[]) {
 			&meson8b_cts_encp_sel.hw
 		},
@@ -1608,7 +1695,7 @@
 	},
 	.hw.init = &(struct clk_init_data){
 		.name = "cts_enci_sel",
-		.ops = &clk_regmap_mux_ro_ops,
+		.ops = &clk_regmap_mux_ops,
 		.parent_hws = meson8b_vclk_enc_mux_parent_hws,
 		.num_parents = ARRAY_SIZE(meson8b_vclk_enc_mux_parent_hws),
 		.flags = CLK_SET_RATE_PARENT,
@@ -1622,7 +1709,7 @@
 	},
 	.hw.init = &(struct clk_init_data){
 		.name = "cts_enci",
-		.ops = &clk_regmap_gate_ro_ops,
+		.ops = &clk_regmap_gate_ops,
 		.parent_hws = (const struct clk_hw *[]) {
 			&meson8b_cts_enci_sel.hw
 		},
@@ -1639,7 +1726,7 @@
 	},
 	.hw.init = &(struct clk_init_data){
 		.name = "hdmi_tx_pixel_sel",
-		.ops = &clk_regmap_mux_ro_ops,
+		.ops = &clk_regmap_mux_ops,
 		.parent_hws = meson8b_vclk_enc_mux_parent_hws,
 		.num_parents = ARRAY_SIZE(meson8b_vclk_enc_mux_parent_hws),
 		.flags = CLK_SET_RATE_PARENT,
@@ -1653,7 +1740,7 @@
 	},
 	.hw.init = &(struct clk_init_data){
 		.name = "hdmi_tx_pixel",
-		.ops = &clk_regmap_gate_ro_ops,
+		.ops = &clk_regmap_gate_ops,
 		.parent_hws = (const struct clk_hw *[]) {
 			&meson8b_hdmi_tx_pixel_sel.hw
 		},
@@ -1678,7 +1765,7 @@
 	},
 	.hw.init = &(struct clk_init_data){
 		.name = "cts_encl_sel",
-		.ops = &clk_regmap_mux_ro_ops,
+		.ops = &clk_regmap_mux_ops,
 		.parent_hws = meson8b_vclk2_enc_mux_parent_hws,
 		.num_parents = ARRAY_SIZE(meson8b_vclk2_enc_mux_parent_hws),
 		.flags = CLK_SET_RATE_PARENT,
@@ -1692,7 +1779,7 @@
 	},
 	.hw.init = &(struct clk_init_data){
 		.name = "cts_encl",
-		.ops = &clk_regmap_gate_ro_ops,
+		.ops = &clk_regmap_gate_ops,
 		.parent_hws = (const struct clk_hw *[]) {
 			&meson8b_cts_encl_sel.hw
 		},
@@ -1709,7 +1796,7 @@
 	},
 	.hw.init = &(struct clk_init_data){
 		.name = "cts_vdac0_sel",
-		.ops = &clk_regmap_mux_ro_ops,
+		.ops = &clk_regmap_mux_ops,
 		.parent_hws = meson8b_vclk2_enc_mux_parent_hws,
 		.num_parents = ARRAY_SIZE(meson8b_vclk2_enc_mux_parent_hws),
 		.flags = CLK_SET_RATE_PARENT,
@@ -1723,7 +1810,7 @@
 	},
 	.hw.init = &(struct clk_init_data){
 		.name = "cts_vdac0",
-		.ops = &clk_regmap_gate_ro_ops,
+		.ops = &clk_regmap_gate_ops,
 		.parent_hws = (const struct clk_hw *[]) {
 			&meson8b_cts_vdac0_sel.hw
 		},
@@ -2610,6 +2697,78 @@
 	},
 };
 
+static u32 meson8_eth_clk_mux_table[] = { 7 };
+
+static struct clk_regmap meson8_eth_clk_sel = {
+	.data = &(struct clk_regmap_mux_data) {
+		.offset = HHI_ETH_CLK_CNTL,
+		.mask = 0x7,
+		.shift = 9,
+		.table = meson8_eth_clk_mux_table,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "eth_clk_sel",
+		.ops = &clk_regmap_mux_ops,
+		.parent_data = &(const struct clk_parent_data) {
+			/* TODO: all other parents are unknown */
+			.fw_name = "rmii_clk",
+		},
+		.num_parents = 1,
+	},
+};
+
+static struct clk_regmap meson8_eth_clk_div = {
+	.data = &(struct clk_regmap_div_data) {
+		.offset = HHI_ETH_CLK_CNTL,
+		.shift = 0,
+		.width = 8,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "eth_clk_div",
+		.ops = &clk_regmap_divider_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&meson8_eth_clk_sel.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT,
+	},
+};
+
+static struct clk_regmap meson8_eth_clk_phase = {
+	.data = &(struct meson_clk_phase_data) {
+		.ph = {
+			.reg_off = HHI_ETH_CLK_CNTL,
+			.shift = 14,
+			.width = 1,
+		},
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "eth_clk_inverted",
+		.ops = &meson_clk_phase_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&meson8_eth_clk_div.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT,
+	},
+};
+
+static struct clk_regmap meson8_eth_clk_gate = {
+	.data = &(struct clk_regmap_gate_data) {
+		.offset = HHI_ETH_CLK_CNTL,
+		.bit_idx = 8,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "eth_clk_en",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&meson8_eth_clk_phase.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT,
+	},
+};
+
 #define MESON_GATE(_name, _reg, _bit) \
 	MESON_PCLK(_name, _reg, _bit, &meson8b_clk81.hw)
 
@@ -2905,6 +3064,13 @@
 		[CLKID_CTS_MCLK_I958_DIV]   = &meson8b_cts_mclk_i958_div.hw,
 		[CLKID_CTS_MCLK_I958]	    = &meson8b_cts_mclk_i958.hw,
 		[CLKID_CTS_I958]	    = &meson8b_cts_i958.hw,
+		[CLKID_VID_PLL_LVDS_EN]	    = &meson8b_vid_pll_lvds_en.hw,
+		[CLKID_HDMI_PLL_DCO_IN]	    = &hdmi_pll_dco_in.hw,
+		[CLKID_MPEG_RTC_OSC_SEL]    = &meson8b_mpeg_rtc_osc_sel.hw,
+		[CLKID_ETH_CLK_SEL]	    = &meson8_eth_clk_sel.hw,
+		[CLKID_ETH_CLK_DIV]	    = &meson8_eth_clk_div.hw,
+		[CLKID_ETH_CLK_PHASE]	    = &meson8_eth_clk_phase.hw,
+		[CLKID_ETH_CLK]		    = &meson8_eth_clk_gate.hw,
 		[CLK_NR_CLKS]		    = NULL,
 	},
 	.num = CLK_NR_CLKS,
@@ -3122,6 +3288,9 @@
 		[CLKID_CTS_MCLK_I958_DIV]   = &meson8b_cts_mclk_i958_div.hw,
 		[CLKID_CTS_MCLK_I958]	    = &meson8b_cts_mclk_i958.hw,
 		[CLKID_CTS_I958]	    = &meson8b_cts_i958.hw,
+		[CLKID_VID_PLL_LVDS_EN]	    = &meson8b_vid_pll_lvds_en.hw,
+		[CLKID_HDMI_PLL_DCO_IN]	    = &hdmi_pll_dco_in.hw,
+		[CLKID_MPEG_RTC_OSC_SEL]    = &meson8b_mpeg_rtc_osc_sel.hw,
 		[CLK_NR_CLKS]		    = NULL,
 	},
 	.num = CLK_NR_CLKS,
@@ -3341,6 +3510,9 @@
 		[CLKID_CTS_MCLK_I958_DIV]   = &meson8b_cts_mclk_i958_div.hw,
 		[CLKID_CTS_MCLK_I958]	    = &meson8b_cts_mclk_i958.hw,
 		[CLKID_CTS_I958]	    = &meson8b_cts_i958.hw,
+		[CLKID_VID_PLL_LVDS_EN]	    = &meson8b_vid_pll_lvds_en.hw,
+		[CLKID_HDMI_PLL_DCO_IN]	    = &hdmi_pll_dco_in.hw,
+		[CLKID_MPEG_RTC_OSC_SEL]    = &meson8b_mpeg_rtc_osc_sel.hw,
 		[CLK_NR_CLKS]		    = NULL,
 	},
 	.num = CLK_NR_CLKS,
@@ -3539,6 +3711,12 @@
 	&meson8b_cts_mclk_i958_div,
 	&meson8b_cts_mclk_i958,
 	&meson8b_cts_i958,
+	&meson8b_vid_pll_lvds_en,
+	&meson8b_mpeg_rtc_osc_sel,
+	&meson8_eth_clk_sel,
+	&meson8_eth_clk_div,
+	&meson8_eth_clk_phase,
+	&meson8_eth_clk_gate,
 };
 
 static const struct meson8b_clk_reset_line {
diff -Naur a/drivers/clk/meson/meson8b.h b/drivers/clk/meson/meson8b.h
--- a/drivers/clk/meson/meson8b.h	2021-10-31 16:53:10.000000000 -0400
+++ b/drivers/clk/meson/meson8b.h	2021-10-31 20:41:20.000000000 -0400
@@ -43,6 +43,7 @@
 #define HHI_MALI_CLK_CNTL		0x1b0 /* 0x6c offset in data sheet */
 #define HHI_VPU_CLK_CNTL		0x1bc /* 0x6f offset in data sheet */
 #define HHI_HDMI_CLK_CNTL		0x1cc /* 0x73 offset in data sheet */
+#define HHI_ETH_CLK_CNTL		0x1d8 /* 0x76 offset in data sheet */
 #define HHI_VDEC_CLK_CNTL		0x1e0 /* 0x78 offset in data sheet */
 #define HHI_VDEC2_CLK_CNTL		0x1e4 /* 0x79 offset in data sheet */
 #define HHI_VDEC3_CLK_CNTL		0x1e8 /* 0x7a offset in data sheet */
@@ -51,6 +52,16 @@
 #define HHI_SYS_PLL_CNTL		0x300 /* 0xc0 offset in data sheet */
 #define HHI_VID_PLL_CNTL		0x320 /* 0xc8 offset in data sheet */
 #define HHI_VID_PLL_CNTL2		0x324 /* 0xc9 offset in data sheet */
+#define HHI_VID_PLL_CNTL3		0x328 /* 0xca offset in data sheet */
+#define HHI_VID_PLL_CNTL4		0x32c /* 0xcb offset in data sheet */
+#define HHI_VID_PLL_CNTL5		0x330 /* 0xcc offset in data sheet */
+#define HHI_VID_PLL_CNTL6		0x334 /* 0xcd offset in data sheet */
+#define HHI_VID2_PLL_CNTL		0x380 /* 0xe0 offset in data sheet */
+#define HHI_VID2_PLL_CNTL2		0x384 /* 0xe1 offset in data sheet */
+#define HHI_VID2_PLL_CNTL3		0x388 /* 0xe2 offset in data sheet */
+#define HHI_VID2_PLL_CNTL4		0x38c /* 0xe3 offset in data sheet */
+#define HHI_VID2_PLL_CNTL5		0x390 /* 0xe4 offset in data sheet */
+#define HHI_VID2_PLL_CNTL6		0x394 /* 0xe5 offset in data sheet */
 
 /*
  * MPLL register offeset taken from the S905 datasheet. Vendor kernel source
@@ -107,14 +118,11 @@
 #define CLKID_PERIPH_SEL	125
 #define CLKID_AXI_SEL		127
 #define CLKID_L2_DRAM_SEL	129
-#define CLKID_HDMI_PLL_LVDS_OUT	131
-#define CLKID_HDMI_PLL_HDMI_OUT	132
+#define CLKID_HDMI_PLL_LVDS_OUT 131
 #define CLKID_VID_PLL_IN_SEL	133
 #define CLKID_VID_PLL_IN_EN	134
 #define CLKID_VID_PLL_PRE_DIV	135
 #define CLKID_VID_PLL_POST_DIV	136
-#define CLKID_VID_PLL_FINAL_DIV	137
-#define CLKID_VCLK_IN_SEL	138
 #define CLKID_VCLK_IN_EN	139
 #define CLKID_VCLK_DIV1		140
 #define CLKID_VCLK_DIV2_DIV	141
@@ -125,7 +133,6 @@
 #define CLKID_VCLK_DIV6		146
 #define CLKID_VCLK_DIV12_DIV	147
 #define CLKID_VCLK_DIV12	148
-#define CLKID_VCLK2_IN_SEL	149
 #define CLKID_VCLK2_IN_EN	150
 #define CLKID_VCLK2_DIV1	151
 #define CLKID_VCLK2_DIV2_DIV	152
@@ -137,17 +144,11 @@
 #define CLKID_VCLK2_DIV12_DIV	158
 #define CLKID_VCLK2_DIV12	159
 #define CLKID_CTS_ENCT_SEL	160
-#define CLKID_CTS_ENCT		161
 #define CLKID_CTS_ENCP_SEL	162
-#define CLKID_CTS_ENCP		163
 #define CLKID_CTS_ENCI_SEL	164
-#define CLKID_CTS_ENCI		165
 #define CLKID_HDMI_TX_PIXEL_SEL	166
-#define CLKID_HDMI_TX_PIXEL	167
 #define CLKID_CTS_ENCL_SEL	168
-#define CLKID_CTS_ENCL		169
 #define CLKID_CTS_VDAC0_SEL	170
-#define CLKID_CTS_VDAC0		171
 #define CLKID_HDMI_SYS_SEL	172
 #define CLKID_HDMI_SYS_DIV	173
 #define CLKID_MALI_0_SEL	175
@@ -182,8 +183,14 @@
 #define CLKID_CTS_MCLK_I958_DIV	211
 #define CLKID_VCLK_EN		214
 #define CLKID_VCLK2_EN		215
+#define CLKID_VID_PLL_LVDS_EN	216
+#define CLKID_HDMI_PLL_DCO_IN   217
+#define CLKID_MPEG_RTC_OSC_SEL	218
+#define CLKID_ETH_CLK_SEL	219
+#define CLKID_ETH_CLK_DIV	220
+#define CLKID_ETH_CLK_PHASE	221
 
-#define CLK_NR_CLKS		216
+#define CLK_NR_CLKS		223
 
 /*
  * include the CLKID and RESETID that have
diff -Naur a/drivers/clk/meson/sclk-div.c b/drivers/clk/meson/sclk-div.c
--- a/drivers/clk/meson/sclk-div.c	2021-10-31 16:53:10.000000000 -0400
+++ b/drivers/clk/meson/sclk-div.c	2021-10-31 20:41:20.000000000 -0400
@@ -96,16 +96,17 @@
 	return bestdiv;
 }
 
-static long sclk_div_round_rate(struct clk_hw *hw, unsigned long rate,
-				unsigned long *prate)
+static int sclk_div_determine_rate(struct clk_hw *hw,
+				   struct clk_rate_request *req)
 {
 	struct clk_regmap *clk = to_clk_regmap(hw);
 	struct meson_sclk_div_data *sclk = meson_sclk_div_data(clk);
 	int div;
 
-	div = sclk_div_bestdiv(hw, rate, prate, sclk);
+	div = sclk_div_bestdiv(hw, req->rate, &req->best_parent_rate, sclk);
+	req->rate = DIV_ROUND_UP_ULL((u64)req->best_parent_rate, div);
 
-	return DIV_ROUND_UP_ULL((u64)*prate, div);
+	return 0;
 }
 
 static void sclk_apply_ratio(struct clk_regmap *clk,
@@ -237,7 +238,7 @@
 
 const struct clk_ops meson_sclk_div_ops = {
 	.recalc_rate	= sclk_div_recalc_rate,
-	.round_rate	= sclk_div_round_rate,
+	.determine_rate	= sclk_div_determine_rate,
 	.set_rate	= sclk_div_set_rate,
 	.enable		= sclk_div_enable,
 	.disable	= sclk_div_disable,
diff -Naur a/drivers/gpu/drm/bridge/display-connector.c b/drivers/gpu/drm/bridge/display-connector.c
--- a/drivers/gpu/drm/bridge/display-connector.c	2021-10-31 16:53:10.000000000 -0400
+++ b/drivers/gpu/drm/bridge/display-connector.c	2021-10-31 20:41:20.000000000 -0400
@@ -13,6 +13,7 @@
 #include <linux/platform_device.h>
 #include <linux/regulator/consumer.h>
 
+#include <drm/drm_atomic_helper.h>
 #include <drm/drm_bridge.h>
 #include <drm/drm_edid.h>
 
@@ -87,10 +88,95 @@
 	return drm_get_edid(connector, conn->bridge.ddc);
 }
 
+/*
+ * Since this bridge is tied to the connector, it acts like a passthrough,
+ * so concerning the output bus formats, either pass the bus formats from the
+ * previous bridge or return fallback data like done in the bridge function:
+ * drm_atomic_bridge_chain_select_bus_fmts().
+ * This supports negotiation if the bridge chain has all bits in place.
+ */
+static u32 *display_connector_get_output_bus_fmts(struct drm_bridge *bridge,
+					struct drm_bridge_state *bridge_state,
+					struct drm_crtc_state *crtc_state,
+					struct drm_connector_state *conn_state,
+					unsigned int *num_output_fmts)
+{
+	struct drm_bridge *prev_bridge = drm_bridge_get_prev_bridge(bridge);
+	struct drm_bridge_state *prev_bridge_state;
+
+	if (!prev_bridge || !prev_bridge->funcs->atomic_get_output_bus_fmts) {
+		struct drm_connector *conn = conn_state->connector;
+		u32 *out_bus_fmts;
+
+		*num_output_fmts = 1;
+		out_bus_fmts = kmalloc(sizeof(*out_bus_fmts), GFP_KERNEL);
+		if (!out_bus_fmts)
+			return NULL;
+
+		if (conn->display_info.num_bus_formats &&
+		    conn->display_info.bus_formats)
+			out_bus_fmts[0] = conn->display_info.bus_formats[0];
+		else
+			out_bus_fmts[0] = MEDIA_BUS_FMT_FIXED;
+
+		return out_bus_fmts;
+	}
+
+	prev_bridge_state = drm_atomic_get_new_bridge_state(crtc_state->state,
+							    prev_bridge);
+
+	return prev_bridge->funcs->atomic_get_output_bus_fmts(prev_bridge, prev_bridge_state,
+							      crtc_state, conn_state,
+							      num_output_fmts);
+}
+
+/*
+ * Since this bridge is tied to the connector, it acts like a passthrough,
+ * so concerning the input bus formats, either pass the bus formats from the
+ * previous bridge or MEDIA_BUS_FMT_FIXED (like select_bus_fmt_recursive())
+ * when atomic_get_input_bus_fmts is not supported.
+ * This supports negotiation if the bridge chain has all bits in place.
+ */
+static u32 *display_connector_get_input_bus_fmts(struct drm_bridge *bridge,
+					struct drm_bridge_state *bridge_state,
+					struct drm_crtc_state *crtc_state,
+					struct drm_connector_state *conn_state,
+					u32 output_fmt,
+					unsigned int *num_input_fmts)
+{
+	struct drm_bridge *prev_bridge = drm_bridge_get_prev_bridge(bridge);
+	struct drm_bridge_state *prev_bridge_state;
+
+	if (!prev_bridge || !prev_bridge->funcs->atomic_get_input_bus_fmts) {
+		u32 *in_bus_fmts;
+
+		*num_input_fmts = 1;
+		in_bus_fmts = kmalloc(sizeof(*in_bus_fmts), GFP_KERNEL);
+		if (!in_bus_fmts)
+			return NULL;
+
+		in_bus_fmts[0] = MEDIA_BUS_FMT_FIXED;
+
+		return in_bus_fmts;
+	}
+
+	prev_bridge_state = drm_atomic_get_new_bridge_state(crtc_state->state,
+							    prev_bridge);
+
+	return prev_bridge->funcs->atomic_get_input_bus_fmts(prev_bridge, prev_bridge_state,
+							     crtc_state, conn_state, output_fmt,
+							     num_input_fmts);
+}
+
 static const struct drm_bridge_funcs display_connector_bridge_funcs = {
 	.attach = display_connector_attach,
 	.detect = display_connector_detect,
 	.get_edid = display_connector_get_edid,
+	.atomic_get_output_bus_fmts = display_connector_get_output_bus_fmts,
+	.atomic_get_input_bus_fmts = display_connector_get_input_bus_fmts,
+	.atomic_duplicate_state = drm_atomic_helper_bridge_duplicate_state,
+	.atomic_destroy_state = drm_atomic_helper_bridge_destroy_state,
+	.atomic_reset = drm_atomic_helper_bridge_reset,
 };
 
 static irqreturn_t display_connector_hpd_irq(int irq, void *arg)
diff -Naur a/drivers/gpu/drm/meson/Kconfig b/drivers/gpu/drm/meson/Kconfig
--- a/drivers/gpu/drm/meson/Kconfig	2021-10-31 16:53:10.000000000 -0400
+++ b/drivers/gpu/drm/meson/Kconfig	2021-10-31 20:41:20.000000000 -0400
@@ -6,9 +6,11 @@
 	select DRM_KMS_HELPER
 	select DRM_KMS_CMA_HELPER
 	select DRM_GEM_CMA_HELPER
+	select DRM_DISPLAY_CONNECTOR
 	select VIDEOMODE_HELPERS
 	select REGMAP_MMIO
 	select MESON_CANVAS
+	select CEC_CORE if CEC_NOTIFIER
 
 config DRM_MESON_DW_HDMI
 	tristate "HDMI Synopsys Controller support for Amlogic Meson Display"
@@ -16,3 +18,11 @@
 	default y if DRM_MESON
 	select DRM_DW_HDMI
 	imply DRM_DW_HDMI_I2S_AUDIO
+
+config DRM_MESON_TRANSWITCH_HDMI
+	tristate "Amlogic Meson8/8b/8m2 TranSwitch HDMI 1.4 Controller support"
+	depends on ARM || COMPILE_TEST
+	depends on DRM_MESON
+	default y if DRM_MESON
+	select REGMAP_MMIO
+	select SND_SOC_HDMI_CODEC if SND_SOC
diff -Naur a/drivers/gpu/drm/meson/Makefile b/drivers/gpu/drm/meson/Makefile
--- a/drivers/gpu/drm/meson/Makefile	2021-10-31 16:53:10.000000000 -0400
+++ b/drivers/gpu/drm/meson/Makefile	2021-10-31 20:41:20.000000000 -0400
@@ -1,7 +1,9 @@
 # SPDX-License-Identifier: GPL-2.0-only
-meson-drm-y := meson_drv.o meson_plane.o meson_crtc.o meson_venc_cvbs.o
+meson-drm-y := meson_drv.o meson_plane.o meson_crtc.o meson_encoder_cvbs.o
 meson-drm-y += meson_viu.o meson_vpp.o meson_venc.o meson_vclk.o meson_overlay.o
 meson-drm-y += meson_rdma.o meson_osd_afbcd.o
+meson-drm-y += meson_encoder_hdmi.o
 
 obj-$(CONFIG_DRM_MESON) += meson-drm.o
 obj-$(CONFIG_DRM_MESON_DW_HDMI) += meson_dw_hdmi.o
+obj-$(CONFIG_DRM_MESON_TRANSWITCH_HDMI) += meson_transwitch_hdmi.o
diff -Naur a/drivers/gpu/drm/meson/meson_drv.c b/drivers/gpu/drm/meson/meson_drv.c
--- a/drivers/gpu/drm/meson/meson_drv.c	2021-10-31 16:53:10.000000000 -0400
+++ b/drivers/gpu/drm/meson/meson_drv.c	2021-10-31 20:41:20.000000000 -0400
@@ -12,6 +12,7 @@
 #include <linux/module.h>
 #include <linux/of_graph.h>
 #include <linux/sys_soc.h>
+#include <linux/phy/phy.h>
 #include <linux/platform_device.h>
 #include <linux/soc/amlogic/meson-canvas.h>
 
@@ -31,7 +32,8 @@
 #include "meson_plane.h"
 #include "meson_osd_afbcd.h"
 #include "meson_registers.h"
-#include "meson_venc_cvbs.h"
+#include "meson_encoder_cvbs.h"
+#include "meson_encoder_hdmi.h"
 #include "meson_viu.h"
 #include "meson_vpp.h"
 #include "meson_rdma.h"
@@ -129,28 +131,100 @@
 
 static void meson_vpu_init(struct meson_drm *priv)
 {
-	u32 value;
+	if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8) ||
+	    meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8B) ||
+	    meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8M2)) {
+		writel(0x0, priv->io_base + _REG(VPU_MEM_PD_REG0));
+		writel(0x0, priv->io_base + _REG(VPU_MEM_PD_REG1));
+	} else {
+		u32 value;
+
+		/*
+		* Slave dc0 and dc5 connected to master port 1.
+		* By default other slaves are connected to master port 0.
+		*/
+		value = VPU_RDARB_SLAVE_TO_MASTER_PORT(0, 1) |
+			VPU_RDARB_SLAVE_TO_MASTER_PORT(5, 1);
+		writel_relaxed(value,
+			       priv->io_base + _REG(VPU_RDARB_MODE_L1C1));
+
+		/* Slave dc0 connected to master port 1 */
+		value = VPU_RDARB_SLAVE_TO_MASTER_PORT(0, 1);
+		writel_relaxed(value,
+			       priv->io_base + _REG(VPU_RDARB_MODE_L1C2));
+
+		/* Slave dc4 and dc7 connected to master port 1 */
+		value = VPU_RDARB_SLAVE_TO_MASTER_PORT(4, 1) |
+			VPU_RDARB_SLAVE_TO_MASTER_PORT(7, 1);
+		writel_relaxed(value,
+			       priv->io_base + _REG(VPU_RDARB_MODE_L2C1));
+
+		/* Slave dc1 connected to master port 1 */
+		value = VPU_RDARB_SLAVE_TO_MASTER_PORT(1, 1);
+		writel_relaxed(value,
+			       priv->io_base + _REG(VPU_WRARB_MODE_L2C1));
+	}
+}
+
+static int meson_video_clock_init(struct meson_drm *priv)
+{
+	int ret;
+
+	if (!meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8) &&
+	    !meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8B) &&
+	    !meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8M2))
+		return 0;
+
+	ret = clk_bulk_prepare(VPU_VID_CLK_NUM, priv->vid_clks);
+	if (ret)
+		return dev_err_probe(priv->dev, ret,
+				     "Failed to prepare the video clocks\n");
+
+	ret = clk_bulk_prepare(VPU_INTR_CLK_NUM, priv->intr_clks);
+	if (ret)
+		return dev_err_probe(priv->dev, ret,
+				     "Failed to prepare the interrupt clocks\n");
+
+	return 0;
+}
+
+static void meson_video_clock_exit(struct meson_drm *priv)
+{
+	if (!meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8) &&
+	    !meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8B) &&
+	    !meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8M2))
+		return;
+
+	if (priv->clk_dac_enabled)
+		clk_disable(priv->clk_dac);
+
+	if (priv->clk_venc_enabled)
+		clk_disable(priv->clk_venc);
+
+	clk_bulk_unprepare(VPU_INTR_CLK_NUM, priv->intr_clks);
+	clk_bulk_unprepare(VPU_VID_CLK_NUM, priv->vid_clks);
+}
+
+static void meson_fbdev_setup(struct meson_drm *priv)
+{
+	unsigned int preferred_bpp;
 
 	/*
-	 * Slave dc0 and dc5 connected to master port 1.
-	 * By default other slaves are connected to master port 0.
+	 * All SoC generations before GXBB don't have a way to configure the
+	 * alpha value for DRM_FORMAT_XRGB8888 and DRM_FORMAT_XBGR8888 with
+	 * 32-bit but missing alpha ??? TODO: better explanation here.
+	 * Use 24-bit to get a working framebuffer console. Applications that
+	 * can do better (for example: kmscube) will switch to a better format
+	 * like DRM_FORMAT_XRGB8888 while passing a sane alpha value.
 	 */
-	value = VPU_RDARB_SLAVE_TO_MASTER_PORT(0, 1) |
-		VPU_RDARB_SLAVE_TO_MASTER_PORT(5, 1);
-	writel_relaxed(value, priv->io_base + _REG(VPU_RDARB_MODE_L1C1));
-
-	/* Slave dc0 connected to master port 1 */
-	value = VPU_RDARB_SLAVE_TO_MASTER_PORT(0, 1);
-	writel_relaxed(value, priv->io_base + _REG(VPU_RDARB_MODE_L1C2));
-
-	/* Slave dc4 and dc7 connected to master port 1 */
-	value = VPU_RDARB_SLAVE_TO_MASTER_PORT(4, 1) |
-		VPU_RDARB_SLAVE_TO_MASTER_PORT(7, 1);
-	writel_relaxed(value, priv->io_base + _REG(VPU_RDARB_MODE_L2C1));
-
-	/* Slave dc1 connected to master port 1 */
-	value = VPU_RDARB_SLAVE_TO_MASTER_PORT(1, 1);
-	writel_relaxed(value, priv->io_base + _REG(VPU_WRARB_MODE_L2C1));
+	if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8) ||
+	    meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8B) ||
+	    meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8M2))
+		preferred_bpp = 24;
+	else
+		preferred_bpp = 32;
+
+	drm_fbdev_generic_setup(priv->drm, preferred_bpp);
 }
 
 struct meson_drm_soc_attr {
@@ -159,6 +233,16 @@
 };
 
 static const struct meson_drm_soc_attr meson_drm_soc_attrs[] = {
+	/* The maximum frequency of HDMI PLL on Meson8/8b/8m2 is ~3GHz */
+	{
+		.limits = {
+			.max_hdmi_phy_freq = 2976000,
+		},
+		.attrs = (const struct soc_device_attribute []) {
+			{ .soc_id = "Meson8*", },
+			{ /* sentinel */ },
+		}
+	},
 	/* S805X/S805Y HDMI PLL won't lock for HDMI PHY freq > 1,65GHz */
 	{
 		.limits = {
@@ -206,8 +290,47 @@
 	priv->compat = match->compat;
 	priv->afbcd.ops = match->afbcd_ops;
 
-	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "vpu");
-	regs = devm_ioremap_resource(dev, res);
+	if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8) ||
+	    meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8B) ||
+	    meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8M2)) {
+		priv->vid_pll_resets[VPU_RESET_VID_PLL_PRE].id = "vid_pll_pre";
+		priv->vid_pll_resets[VPU_RESET_VID_PLL_POST].id = "vid_pll_post";
+		priv->vid_pll_resets[VPU_RESET_VID_PLL_SOFT_PRE].id = "vid_pll_soft_pre";
+		priv->vid_pll_resets[VPU_RESET_VID_PLL_SOFT_POST].id = "vid_pll_soft_post";
+
+		ret = devm_reset_control_bulk_get_exclusive(dev,
+							    VPU_RESET_VID_PLL_NUM,
+							    priv->vid_pll_resets);
+		if (ret)
+			return ret;
+
+		priv->intr_clks[VPU_INTR_CLK_VPU].id = "vpu_intr";
+		priv->intr_clks[VPU_INTR_CLK_HDMI_INTR_SYNC].id = "hdmi_intr_sync";
+		priv->intr_clks[VPU_INTR_CLK_VENCI].id = "venci_int";
+
+		ret = devm_clk_bulk_get(dev, VPU_INTR_CLK_NUM, priv->intr_clks);
+		if (ret)
+			return ret;
+
+		priv->vid_clks[VPU_VID_CLK_TMDS].id = "tmds";
+		priv->vid_clks[VPU_VID_CLK_HDMI_TX_PIXEL].id = "hdmi_tx_pixel";
+		priv->vid_clks[VPU_VID_CLK_CTS_ENCP].id = "cts_encp";
+		priv->vid_clks[VPU_VID_CLK_CTS_ENCI].id = "cts_enci";
+		priv->vid_clks[VPU_VID_CLK_CTS_ENCT].id = "cts_enct";
+		priv->vid_clks[VPU_VID_CLK_CTS_ENCL].id = "cts_encl";
+		priv->vid_clks[VPU_VID_CLK_CTS_VDAC0].id = "cts_vdac0";
+
+		ret = devm_clk_bulk_get(dev, VPU_VID_CLK_NUM, priv->vid_clks);
+		if (ret)
+			return ret;
+
+		ret = meson_video_clock_init(priv);
+		if (ret)
+			goto free_drm;
+		// TODO: error handling below
+	}
+
+	regs = devm_platform_ioremap_resource_byname(pdev, "vpu");
 	if (IS_ERR(regs)) {
 		ret = PTR_ERR(regs);
 		goto free_drm;
@@ -215,24 +338,27 @@
 
 	priv->io_base = regs;
 
+	/*
+	 * The HHI resource is optional because it contains the clocks and CVBS
+	 * encoder registers. These are managed by separate drivers though.
+	 */
 	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "hhi");
-	if (!res) {
-		ret = -EINVAL;
-		goto free_drm;
-	}
-	/* Simply ioremap since it may be a shared register zone */
-	regs = devm_ioremap(dev, res->start, resource_size(res));
-	if (!regs) {
-		ret = -EADDRNOTAVAIL;
-		goto free_drm;
-	}
+	if (res) {
+		/* Simply ioremap since it may be a shared register zone */
+		regs = devm_ioremap(dev, res->start, resource_size(res));
+		if (!regs) {
+			ret = -EADDRNOTAVAIL;
+			goto free_drm;
+		}
 
-	priv->hhi = devm_regmap_init_mmio(dev, regs,
-					  &meson_regmap_config);
-	if (IS_ERR(priv->hhi)) {
-		dev_err(&pdev->dev, "Couldn't create the HHI regmap\n");
-		ret = PTR_ERR(priv->hhi);
-		goto free_drm;
+		priv->hhi = devm_regmap_init_mmio(dev, regs,
+						  &meson_regmap_config);
+		if (IS_ERR(priv->hhi)) {
+			dev_err(&pdev->dev,
+				"Couldn't create the HHI regmap\n");
+			ret = PTR_ERR(priv->hhi);
+			goto free_drm;
+		}
 	}
 
 	priv->canvas = meson_canvas_get(dev);
@@ -263,6 +389,11 @@
 		goto free_drm;
 	}
 
+	priv->cvbs_dac = devm_phy_optional_get(dev, "cvbs-dac");
+	if (IS_ERR(priv->cvbs_dac))
+		return dev_err_probe(dev, PTR_ERR(priv->cvbs_dac),
+				     "Failed to get the 'cvbs-dac' PHY\n");
+
 	priv->vsync_irq = platform_get_irq(pdev, 0);
 
 	ret = drm_vblank_init(drm, 1);
@@ -307,7 +438,7 @@
 
 	/* Encoder Initialization */
 
-	ret = meson_venc_cvbs_create(priv);
+	ret = meson_encoder_cvbs_init(priv);
 	if (ret)
 		goto free_drm;
 
@@ -319,6 +450,10 @@
 		}
 	}
 
+	ret = meson_encoder_hdmi_init(priv);
+	if (ret)
+		goto free_drm;
+
 	ret = meson_plane_create(priv);
 	if (ret)
 		goto free_drm;
@@ -345,7 +480,7 @@
 	if (ret)
 		goto uninstall_irq;
 
-	drm_fbdev_generic_setup(drm, 32);
+	meson_fbdev_setup(priv);
 
 	return 0;
 
@@ -385,6 +520,8 @@
 		priv->afbcd.ops->reset(priv);
 		meson_rdma_free(priv);
 	}
+
+	meson_video_clock_exit(priv);
 }
 
 static const struct component_master_ops meson_drv_master_ops = {
@@ -399,6 +536,8 @@
 	if (!priv)
 		return 0;
 
+	// TODO: video clock suspend
+
 	return drm_mode_config_helper_suspend(priv->drm);
 }
 
@@ -409,6 +548,7 @@
 	if (!priv)
 		return 0;
 
+	meson_video_clock_init(priv);
 	meson_vpu_init(priv);
 	meson_venc_init(priv);
 	meson_vpp_init(priv);
@@ -427,46 +567,6 @@
 	return dev->of_node == data;
 }
 
-/* Possible connectors nodes to ignore */
-static const struct of_device_id connectors_match[] = {
-	{ .compatible = "composite-video-connector" },
-	{ .compatible = "svideo-connector" },
-	{ .compatible = "hdmi-connector" },
-	{ .compatible = "dvi-connector" },
-	{}
-};
-
-static int meson_probe_remote(struct platform_device *pdev,
-			      struct component_match **match,
-			      struct device_node *parent,
-			      struct device_node *remote)
-{
-	struct device_node *ep, *remote_node;
-	int count = 1;
-
-	/* If node is a connector, return and do not add to match table */
-	if (of_match_node(connectors_match, remote))
-		return 1;
-
-	component_match_add(&pdev->dev, match, compare_of, remote);
-
-	for_each_endpoint_of_node(remote, ep) {
-		remote_node = of_graph_get_remote_port_parent(ep);
-		if (!remote_node ||
-		    remote_node == parent || /* Ignore parent endpoint */
-		    !of_device_is_available(remote_node)) {
-			of_node_put(remote_node);
-			continue;
-		}
-
-		count += meson_probe_remote(pdev, match, remote, remote_node);
-
-		of_node_put(remote_node);
-	}
-
-	return count;
-}
-
 static void meson_drv_shutdown(struct platform_device *pdev)
 {
 	struct meson_drm *priv = dev_get_drvdata(&pdev->dev);
@@ -478,6 +578,13 @@
 	drm_atomic_helper_shutdown(priv->drm);
 }
 
+/* Possible connectors nodes to ignore */
+static const struct of_device_id connectors_match[] = {
+	{ .compatible = "composite-video-connector" },
+	{ .compatible = "svideo-connector" },
+	{}
+};
+
 static int meson_drv_probe(struct platform_device *pdev)
 {
 	struct component_match *match = NULL;
@@ -492,8 +599,21 @@
 			continue;
 		}
 
-		count += meson_probe_remote(pdev, &match, np, remote);
+		/* If an analog connector is detected, count it as an output */
+		if (of_match_node(connectors_match, remote)) {
+			++count;
+			of_node_put(remote);
+			continue;
+		}
+
+		dev_dbg(&pdev->dev, "parent %pOF remote match add %pOF parent %s\n",
+			np, remote, dev_name(&pdev->dev));
+
+		component_match_add(&pdev->dev, &match, compare_of, remote);
+
 		of_node_put(remote);
+
+		++count;
 	}
 
 	if (count && !match)
@@ -512,6 +632,18 @@
 	return 0;
 };
 
+static struct meson_drm_match_data meson_drm_m8_data = {
+	.compat = VPU_COMPATIBLE_M8,
+};
+
+static struct meson_drm_match_data meson_drm_m8b_data = {
+	.compat = VPU_COMPATIBLE_M8B,
+};
+
+static struct meson_drm_match_data meson_drm_m8m2_data = {
+	.compat = VPU_COMPATIBLE_M8M2,
+};
+
 static struct meson_drm_match_data meson_drm_gxbb_data = {
 	.compat = VPU_COMPATIBLE_GXBB,
 };
@@ -531,6 +663,12 @@
 };
 
 static const struct of_device_id dt_match[] = {
+	{ .compatible = "amlogic,meson8-vpu",
+	  .data       = (void *)&meson_drm_m8_data },
+	{ .compatible = "amlogic,meson8b-vpu",
+	  .data       = (void *)&meson_drm_m8b_data },
+	{ .compatible = "amlogic,meson8m2-vpu",
+	  .data       = (void *)&meson_drm_m8m2_data },
 	{ .compatible = "amlogic,meson-gxbb-vpu",
 	  .data       = (void *)&meson_drm_gxbb_data },
 	{ .compatible = "amlogic,meson-gxl-vpu",
diff -Naur a/drivers/gpu/drm/meson/meson_drv.h b/drivers/gpu/drm/meson/meson_drv.h
--- a/drivers/gpu/drm/meson/meson_drv.h	2021-10-31 16:53:10.000000000 -0400
+++ b/drivers/gpu/drm/meson/meson_drv.h	2021-10-31 20:41:20.000000000 -0400
@@ -7,22 +7,28 @@
 #ifndef __MESON_DRV_H
 #define __MESON_DRV_H
 
+#include <linux/clk.h>
 #include <linux/device.h>
 #include <linux/of.h>
 #include <linux/of_device.h>
 #include <linux/regmap.h>
+#include <linux/reset.h>
 
 struct drm_crtc;
 struct drm_device;
 struct drm_plane;
 struct meson_drm;
 struct meson_afbcd_ops;
+struct phy;
 
 enum vpu_compatible {
-	VPU_COMPATIBLE_GXBB = 0,
-	VPU_COMPATIBLE_GXL  = 1,
-	VPU_COMPATIBLE_GXM  = 2,
-	VPU_COMPATIBLE_G12A = 3,
+	VPU_COMPATIBLE_M8 = 0,
+	VPU_COMPATIBLE_M8B = 1,
+	VPU_COMPATIBLE_M8M2 = 2,
+	VPU_COMPATIBLE_GXBB = 3,
+	VPU_COMPATIBLE_GXL  = 4,
+	VPU_COMPATIBLE_GXM  = 5,
+	VPU_COMPATIBLE_G12A = 6,
 };
 
 struct meson_drm_match_data {
@@ -34,6 +40,32 @@
 	unsigned int max_hdmi_phy_freq;
 };
 
+enum vpu_bulk_intr_clk_id {
+	VPU_INTR_CLK_VPU = 0,
+	VPU_INTR_CLK_HDMI_INTR_SYNC,
+	VPU_INTR_CLK_VENCI,
+	VPU_INTR_CLK_NUM
+};
+
+enum vpu_bulk_clk_id {
+	VPU_VID_CLK_TMDS = 0,
+	VPU_VID_CLK_HDMI_TX_PIXEL,
+	VPU_VID_CLK_CTS_ENCP,
+	VPU_VID_CLK_CTS_ENCI,
+	VPU_VID_CLK_CTS_ENCT,
+	VPU_VID_CLK_CTS_ENCL,
+	VPU_VID_CLK_CTS_VDAC0,
+	VPU_VID_CLK_NUM
+};
+
+enum vpu_bulk_vid_pll_reset_id {
+	VPU_RESET_VID_PLL_PRE = 0,
+	VPU_RESET_VID_PLL_POST,
+	VPU_RESET_VID_PLL_SOFT_PRE,
+	VPU_RESET_VID_PLL_SOFT_POST,
+	VPU_RESET_VID_PLL_NUM
+};
+
 struct meson_drm {
 	struct device *dev;
 	enum vpu_compatible compat;
@@ -54,6 +86,19 @@
 
 	const struct meson_drm_soc_limits *limits;
 
+	struct phy *cvbs_dac;
+	bool cvbs_dac_enabled;
+
+	struct clk_bulk_data intr_clks[VPU_INTR_CLK_NUM];
+	bool intr_clks_enabled;
+	struct clk_bulk_data vid_clks[VPU_VID_CLK_NUM];
+	bool vid_clk_rate_exclusive[VPU_VID_CLK_NUM];
+	struct clk *clk_venc;
+	bool clk_venc_enabled;
+	struct clk *clk_dac;
+	bool clk_dac_enabled;
+	struct reset_control_bulk_data vid_pll_resets[VPU_RESET_VID_PLL_NUM];
+
 	/* Components Data */
 	struct {
 		bool osd1_enabled;
diff -Naur a/drivers/gpu/drm/meson/meson_dw_hdmi.c b/drivers/gpu/drm/meson/meson_dw_hdmi.c
--- a/drivers/gpu/drm/meson/meson_dw_hdmi.c	2021-10-31 16:53:10.000000000 -0400
+++ b/drivers/gpu/drm/meson/meson_dw_hdmi.c	2021-10-31 20:41:20.000000000 -0400
@@ -22,14 +22,11 @@
 #include <drm/drm_probe_helper.h>
 #include <drm/drm_print.h>
 
-#include <linux/media-bus-format.h>
 #include <linux/videodev2.h>
 
 #include "meson_drv.h"
 #include "meson_dw_hdmi.h"
 #include "meson_registers.h"
-#include "meson_vclk.h"
-#include "meson_venc.h"
 
 #define DRIVER_NAME "meson-dw-hdmi"
 #define DRIVER_DESC "Amlogic Meson HDMI-TX DRM driver"
@@ -135,8 +132,6 @@
 };
 
 struct meson_dw_hdmi {
-	struct drm_encoder encoder;
-	struct drm_bridge bridge;
 	struct dw_hdmi_plat_data dw_plat_data;
 	struct meson_drm *priv;
 	struct device *dev;
@@ -148,12 +143,8 @@
 	struct regulator *hdmi_supply;
 	u32 irq_stat;
 	struct dw_hdmi *hdmi;
-	unsigned long output_bus_fmt;
+	struct drm_bridge *bridge;
 };
-#define encoder_to_meson_dw_hdmi(x) \
-	container_of(x, struct meson_dw_hdmi, encoder)
-#define bridge_to_meson_dw_hdmi(x) \
-	container_of(x, struct meson_dw_hdmi, bridge)
 
 static inline int dw_hdmi_is_compatible(struct meson_dw_hdmi *dw_hdmi,
 					const char *compat)
@@ -295,14 +286,14 @@
 
 /* Setup PHY bandwidth modes */
 static void meson_hdmi_phy_setup_mode(struct meson_dw_hdmi *dw_hdmi,
-				      const struct drm_display_mode *mode)
+				      const struct drm_display_mode *mode,
+				      bool mode_is_420)
 {
 	struct meson_drm *priv = dw_hdmi->priv;
 	unsigned int pixel_clock = mode->clock;
 
 	/* For 420, pixel clock is half unlike venc clock */
-	if (dw_hdmi->output_bus_fmt == MEDIA_BUS_FMT_UYYVYY8_0_5X24)
-		pixel_clock /= 2;
+	if (mode_is_420) pixel_clock /= 2;
 
 	if (dw_hdmi_is_compatible(dw_hdmi, "amlogic,meson-gxl-dw-hdmi") ||
 	    dw_hdmi_is_compatible(dw_hdmi, "amlogic,meson-gxm-dw-hdmi")) {
@@ -374,68 +365,25 @@
 	mdelay(2);
 }
 
-static void dw_hdmi_set_vclk(struct meson_dw_hdmi *dw_hdmi,
-			     const struct drm_display_mode *mode)
-{
-	struct meson_drm *priv = dw_hdmi->priv;
-	int vic = drm_match_cea_mode(mode);
-	unsigned int phy_freq;
-	unsigned int vclk_freq;
-	unsigned int venc_freq;
-	unsigned int hdmi_freq;
-
-	vclk_freq = mode->clock;
-
-	/* For 420, pixel clock is half unlike venc clock */
-	if (dw_hdmi->output_bus_fmt == MEDIA_BUS_FMT_UYYVYY8_0_5X24)
-		vclk_freq /= 2;
-
-	/* TMDS clock is pixel_clock * 10 */
-	phy_freq = vclk_freq * 10;
-
-	if (!vic) {
-		meson_vclk_setup(priv, MESON_VCLK_TARGET_DMT, phy_freq,
-				 vclk_freq, vclk_freq, vclk_freq, false);
-		return;
-	}
-
-	/* 480i/576i needs global pixel doubling */
-	if (mode->flags & DRM_MODE_FLAG_DBLCLK)
-		vclk_freq *= 2;
-
-	venc_freq = vclk_freq;
-	hdmi_freq = vclk_freq;
-
-	/* VENC double pixels for 1080i, 720p and YUV420 modes */
-	if (meson_venc_hdmi_venc_repeat(vic) ||
-	    dw_hdmi->output_bus_fmt == MEDIA_BUS_FMT_UYYVYY8_0_5X24)
-		venc_freq *= 2;
-
-	vclk_freq = max(venc_freq, hdmi_freq);
-
-	if (mode->flags & DRM_MODE_FLAG_DBLCLK)
-		venc_freq /= 2;
-
-	DRM_DEBUG_DRIVER("vclk:%d phy=%d venc=%d hdmi=%d enci=%d\n",
-		phy_freq, vclk_freq, venc_freq, hdmi_freq,
-		priv->venc.hdmi_use_enci);
-
-	meson_vclk_setup(priv, MESON_VCLK_TARGET_HDMI, phy_freq, vclk_freq,
-			 venc_freq, hdmi_freq, priv->venc.hdmi_use_enci);
-}
-
 static int dw_hdmi_phy_init(struct dw_hdmi *hdmi, void *data,
 			    const struct drm_display_info *display,
 			    const struct drm_display_mode *mode)
 {
 	struct meson_dw_hdmi *dw_hdmi = (struct meson_dw_hdmi *)data;
+	bool is_hdmi2_sink = display->hdmi.scdc.supported;
 	struct meson_drm *priv = dw_hdmi->priv;
 	unsigned int wr_clk =
 		readl_relaxed(priv->io_base + _REG(VPU_HDMI_SETTING));
+	bool mode_is_420 = false;
 
 	DRM_DEBUG_DRIVER("\"%s\" div%d\n", mode->name,
 			 mode->clock > 340000 ? 40 : 10);
 
+	if (drm_mode_is_420_only(display, mode) ||
+	    (!is_hdmi2_sink &&
+	     drm_mode_is_420_also(display, mode)))
+		mode_is_420 = true;
+
 	/* Enable clocks */
 	regmap_update_bits(priv->hhi, HHI_HDMI_CLK_CNTL, 0xffff, 0x100);
 
@@ -457,8 +405,7 @@
 	dw_hdmi->data->top_write(dw_hdmi, HDMITX_TOP_BIST_CNTL, BIT(12));
 
 	/* TMDS pattern setup */
-	if (mode->clock > 340000 &&
-	    dw_hdmi->output_bus_fmt == MEDIA_BUS_FMT_YUV8_1X24) {
+	if (mode->clock > 340000 && !mode_is_420) {
 		dw_hdmi->data->top_write(dw_hdmi, HDMITX_TOP_TMDS_CLK_PTTN_01,
 				  0);
 		dw_hdmi->data->top_write(dw_hdmi, HDMITX_TOP_TMDS_CLK_PTTN_23,
@@ -476,7 +423,7 @@
 	dw_hdmi->data->top_write(dw_hdmi, HDMITX_TOP_TMDS_CLK_PTTN_CNTL, 0x2);
 
 	/* Setup PHY parameters */
-	meson_hdmi_phy_setup_mode(dw_hdmi, mode);
+	meson_hdmi_phy_setup_mode(dw_hdmi, mode, mode_is_420);
 
 	/* Setup PHY */
 	regmap_update_bits(priv->hhi, HHI_HDMI_PHY_CNTL1,
@@ -622,214 +569,15 @@
 		dw_hdmi_setup_rx_sense(dw_hdmi->hdmi, hpd_connected,
 				       hpd_connected);
 
-		drm_helper_hpd_irq_event(dw_hdmi->encoder.dev);
+		drm_helper_hpd_irq_event(dw_hdmi->bridge->dev);
+		drm_bridge_hpd_notify(dw_hdmi->bridge,
+				      hpd_connected ? connector_status_connected
+						    : connector_status_disconnected);
 	}
 
 	return IRQ_HANDLED;
 }
 
-static enum drm_mode_status
-dw_hdmi_mode_valid(struct dw_hdmi *hdmi, void *data,
-		   const struct drm_display_info *display_info,
-		   const struct drm_display_mode *mode)
-{
-	struct meson_dw_hdmi *dw_hdmi = data;
-	struct meson_drm *priv = dw_hdmi->priv;
-	bool is_hdmi2_sink = display_info->hdmi.scdc.supported;
-	unsigned int phy_freq;
-	unsigned int vclk_freq;
-	unsigned int venc_freq;
-	unsigned int hdmi_freq;
-	int vic = drm_match_cea_mode(mode);
-	enum drm_mode_status status;
-
-	DRM_DEBUG_DRIVER("Modeline " DRM_MODE_FMT "\n", DRM_MODE_ARG(mode));
-
-	/* If sink does not support 540MHz, reject the non-420 HDMI2 modes */
-	if (display_info->max_tmds_clock &&
-	    mode->clock > display_info->max_tmds_clock &&
-	    !drm_mode_is_420_only(display_info, mode) &&
-	    !drm_mode_is_420_also(display_info, mode))
-		return MODE_BAD;
-
-	/* Check against non-VIC supported modes */
-	if (!vic) {
-		status = meson_venc_hdmi_supported_mode(mode);
-		if (status != MODE_OK)
-			return status;
-
-		return meson_vclk_dmt_supported_freq(priv, mode->clock);
-	/* Check against supported VIC modes */
-	} else if (!meson_venc_hdmi_supported_vic(vic))
-		return MODE_BAD;
-
-	vclk_freq = mode->clock;
-
-	/* For 420, pixel clock is half unlike venc clock */
-	if (drm_mode_is_420_only(display_info, mode) ||
-	    (!is_hdmi2_sink &&
-	     drm_mode_is_420_also(display_info, mode)))
-		vclk_freq /= 2;
-
-	/* TMDS clock is pixel_clock * 10 */
-	phy_freq = vclk_freq * 10;
-
-	/* 480i/576i needs global pixel doubling */
-	if (mode->flags & DRM_MODE_FLAG_DBLCLK)
-		vclk_freq *= 2;
-
-	venc_freq = vclk_freq;
-	hdmi_freq = vclk_freq;
-
-	/* VENC double pixels for 1080i, 720p and YUV420 modes */
-	if (meson_venc_hdmi_venc_repeat(vic) ||
-	    drm_mode_is_420_only(display_info, mode) ||
-	    (!is_hdmi2_sink &&
-	     drm_mode_is_420_also(display_info, mode)))
-		venc_freq *= 2;
-
-	vclk_freq = max(venc_freq, hdmi_freq);
-
-	if (mode->flags & DRM_MODE_FLAG_DBLCLK)
-		venc_freq /= 2;
-
-	dev_dbg(dw_hdmi->dev, "%s: vclk:%d phy=%d venc=%d hdmi=%d\n",
-		__func__, phy_freq, vclk_freq, venc_freq, hdmi_freq);
-
-	return meson_vclk_vic_supported_freq(priv, phy_freq, vclk_freq);
-}
-
-/* Encoder */
-
-static const u32 meson_dw_hdmi_out_bus_fmts[] = {
-	MEDIA_BUS_FMT_YUV8_1X24,
-	MEDIA_BUS_FMT_UYYVYY8_0_5X24,
-};
-
-static void meson_venc_hdmi_encoder_destroy(struct drm_encoder *encoder)
-{
-	drm_encoder_cleanup(encoder);
-}
-
-static const struct drm_encoder_funcs meson_venc_hdmi_encoder_funcs = {
-	.destroy        = meson_venc_hdmi_encoder_destroy,
-};
-
-static u32 *
-meson_venc_hdmi_encoder_get_inp_bus_fmts(struct drm_bridge *bridge,
-					struct drm_bridge_state *bridge_state,
-					struct drm_crtc_state *crtc_state,
-					struct drm_connector_state *conn_state,
-					u32 output_fmt,
-					unsigned int *num_input_fmts)
-{
-	u32 *input_fmts = NULL;
-	int i;
-
-	*num_input_fmts = 0;
-
-	for (i = 0 ; i < ARRAY_SIZE(meson_dw_hdmi_out_bus_fmts) ; ++i) {
-		if (output_fmt == meson_dw_hdmi_out_bus_fmts[i]) {
-			*num_input_fmts = 1;
-			input_fmts = kcalloc(*num_input_fmts,
-					     sizeof(*input_fmts),
-					     GFP_KERNEL);
-			if (!input_fmts)
-				return NULL;
-
-			input_fmts[0] = output_fmt;
-
-			break;
-		}
-	}
-
-	return input_fmts;
-}
-
-static int meson_venc_hdmi_encoder_atomic_check(struct drm_bridge *bridge,
-					struct drm_bridge_state *bridge_state,
-					struct drm_crtc_state *crtc_state,
-					struct drm_connector_state *conn_state)
-{
-	struct meson_dw_hdmi *dw_hdmi = bridge_to_meson_dw_hdmi(bridge);
-
-	dw_hdmi->output_bus_fmt = bridge_state->output_bus_cfg.format;
-
-	DRM_DEBUG_DRIVER("output_bus_fmt %lx\n", dw_hdmi->output_bus_fmt);
-
-	return 0;
-}
-
-static void meson_venc_hdmi_encoder_disable(struct drm_bridge *bridge)
-{
-	struct meson_dw_hdmi *dw_hdmi = bridge_to_meson_dw_hdmi(bridge);
-	struct meson_drm *priv = dw_hdmi->priv;
-
-	DRM_DEBUG_DRIVER("\n");
-
-	writel_bits_relaxed(0x3, 0,
-			    priv->io_base + _REG(VPU_HDMI_SETTING));
-
-	writel_relaxed(0, priv->io_base + _REG(ENCI_VIDEO_EN));
-	writel_relaxed(0, priv->io_base + _REG(ENCP_VIDEO_EN));
-}
-
-static void meson_venc_hdmi_encoder_enable(struct drm_bridge *bridge)
-{
-	struct meson_dw_hdmi *dw_hdmi = bridge_to_meson_dw_hdmi(bridge);
-	struct meson_drm *priv = dw_hdmi->priv;
-
-	DRM_DEBUG_DRIVER("%s\n", priv->venc.hdmi_use_enci ? "VENCI" : "VENCP");
-
-	if (priv->venc.hdmi_use_enci)
-		writel_relaxed(1, priv->io_base + _REG(ENCI_VIDEO_EN));
-	else
-		writel_relaxed(1, priv->io_base + _REG(ENCP_VIDEO_EN));
-}
-
-static void meson_venc_hdmi_encoder_mode_set(struct drm_bridge *bridge,
-				   const struct drm_display_mode *mode,
-				   const struct drm_display_mode *adjusted_mode)
-{
-	struct meson_dw_hdmi *dw_hdmi = bridge_to_meson_dw_hdmi(bridge);
-	struct meson_drm *priv = dw_hdmi->priv;
-	int vic = drm_match_cea_mode(mode);
-	unsigned int ycrcb_map = VPU_HDMI_OUTPUT_CBYCR;
-	bool yuv420_mode = false;
-
-	DRM_DEBUG_DRIVER("\"%s\" vic %d\n", mode->name, vic);
-
-	if (dw_hdmi->output_bus_fmt == MEDIA_BUS_FMT_UYYVYY8_0_5X24) {
-		ycrcb_map = VPU_HDMI_OUTPUT_CRYCB;
-		yuv420_mode = true;
-	}
-
-	/* VENC + VENC-DVI Mode setup */
-	meson_venc_hdmi_mode_set(priv, vic, ycrcb_map, yuv420_mode, mode);
-
-	/* VCLK Set clock */
-	dw_hdmi_set_vclk(dw_hdmi, mode);
-
-	if (dw_hdmi->output_bus_fmt == MEDIA_BUS_FMT_UYYVYY8_0_5X24)
-		/* Setup YUV420 to HDMI-TX, no 10bit diphering */
-		writel_relaxed(2 | (2 << 2),
-			       priv->io_base + _REG(VPU_HDMI_FMT_CTRL));
-	else
-		/* Setup YUV444 to HDMI-TX, no 10bit diphering */
-		writel_relaxed(0, priv->io_base + _REG(VPU_HDMI_FMT_CTRL));
-}
-
-static const struct drm_bridge_funcs meson_venc_hdmi_encoder_bridge_funcs = {
-	.atomic_duplicate_state = drm_atomic_helper_bridge_duplicate_state,
-	.atomic_destroy_state = drm_atomic_helper_bridge_destroy_state,
-	.atomic_get_input_bus_fmts = meson_venc_hdmi_encoder_get_inp_bus_fmts,
-	.atomic_reset = drm_atomic_helper_bridge_reset,
-	.atomic_check = meson_venc_hdmi_encoder_atomic_check,
-	.enable	= meson_venc_hdmi_encoder_enable,
-	.disable = meson_venc_hdmi_encoder_disable,
-	.mode_set = meson_venc_hdmi_encoder_mode_set,
-};
-
 /* DW HDMI Regmap */
 
 static int meson_dw_hdmi_reg_read(void *context, unsigned int reg,
@@ -876,28 +624,6 @@
 	.dwc_write = dw_hdmi_g12a_dwc_write,
 };
 
-static bool meson_hdmi_connector_is_available(struct device *dev)
-{
-	struct device_node *ep, *remote;
-
-	/* HDMI Connector is on the second port, first endpoint */
-	ep = of_graph_get_endpoint_by_regs(dev->of_node, 1, 0);
-	if (!ep)
-		return false;
-
-	/* If the endpoint node exists, consider it enabled */
-	remote = of_graph_get_remote_port(ep);
-	if (remote) {
-		of_node_put(ep);
-		return true;
-	}
-
-	of_node_put(ep);
-	of_node_put(remote);
-
-	return false;
-}
-
 static void meson_dw_hdmi_init(struct meson_dw_hdmi *meson_dw_hdmi)
 {
 	struct meson_drm *priv = meson_dw_hdmi->priv;
@@ -976,19 +702,11 @@
 	struct drm_device *drm = data;
 	struct meson_drm *priv = drm->dev_private;
 	struct dw_hdmi_plat_data *dw_plat_data;
-	struct drm_bridge *next_bridge;
-	struct drm_encoder *encoder;
-	struct resource *res;
 	int irq;
 	int ret;
 
 	DRM_DEBUG_DRIVER("\n");
 
-	if (!meson_hdmi_connector_is_available(dev)) {
-		dev_info(drm->dev, "HDMI Output connector not available\n");
-		return -ENODEV;
-	}
-
 	match = of_device_get_match_data(&pdev->dev);
 	if (!match) {
 		dev_err(&pdev->dev, "failed to get match data\n");
@@ -1004,7 +722,6 @@
 	meson_dw_hdmi->dev = dev;
 	meson_dw_hdmi->data = match;
 	dw_plat_data = &meson_dw_hdmi->dw_plat_data;
-	encoder = &meson_dw_hdmi->encoder;
 
 	meson_dw_hdmi->hdmi_supply = devm_regulator_get_optional(dev, "hdmi");
 	if (IS_ERR(meson_dw_hdmi->hdmi_supply)) {
@@ -1042,8 +759,7 @@
 		return PTR_ERR(meson_dw_hdmi->hdmitx_phy);
 	}
 
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	meson_dw_hdmi->hdmitx = devm_ioremap_resource(dev, res);
+	meson_dw_hdmi->hdmitx = devm_platform_ioremap_resource(pdev, 0);
 	if (IS_ERR(meson_dw_hdmi->hdmitx))
 		return PTR_ERR(meson_dw_hdmi->hdmitx);
 
@@ -1076,34 +792,18 @@
 		return ret;
 	}
 
-	/* Encoder */
-
-	ret = drm_encoder_init(drm, encoder, &meson_venc_hdmi_encoder_funcs,
-			       DRM_MODE_ENCODER_TMDS, "meson_hdmi");
-	if (ret) {
-		dev_err(priv->dev, "Failed to init HDMI encoder\n");
-		return ret;
-	}
-
-	meson_dw_hdmi->bridge.funcs = &meson_venc_hdmi_encoder_bridge_funcs;
-	drm_bridge_attach(encoder, &meson_dw_hdmi->bridge, NULL, 0);
-
-	encoder->possible_crtcs = BIT(0);
-
 	meson_dw_hdmi_init(meson_dw_hdmi);
 
-	DRM_DEBUG_DRIVER("encoder initialized\n");
-
 	/* Bridge / Connector */
 
 	dw_plat_data->priv_data = meson_dw_hdmi;
-	dw_plat_data->mode_valid = dw_hdmi_mode_valid;
 	dw_plat_data->phy_ops = &meson_dw_hdmi_phy_ops;
 	dw_plat_data->phy_name = "meson_dw_hdmi_phy";
 	dw_plat_data->phy_data = meson_dw_hdmi;
 	dw_plat_data->input_bus_encoding = V4L2_YCBCR_ENC_709;
 	dw_plat_data->ycbcr_420_allowed = true;
 	dw_plat_data->disable_cec = true;
+	dw_plat_data->output_port = 1;
 
 	if (dw_hdmi_is_compatible(meson_dw_hdmi, "amlogic,meson-gxl-dw-hdmi") ||
 	    dw_hdmi_is_compatible(meson_dw_hdmi, "amlogic,meson-gxm-dw-hdmi") ||
@@ -1112,15 +812,11 @@
 
 	platform_set_drvdata(pdev, meson_dw_hdmi);
 
-	meson_dw_hdmi->hdmi = dw_hdmi_probe(pdev,
-					    &meson_dw_hdmi->dw_plat_data);
+	meson_dw_hdmi->hdmi = dw_hdmi_probe(pdev, &meson_dw_hdmi->dw_plat_data);
 	if (IS_ERR(meson_dw_hdmi->hdmi))
 		return PTR_ERR(meson_dw_hdmi->hdmi);
 
-	next_bridge = of_drm_find_bridge(pdev->dev.of_node);
-	if (next_bridge)
-		drm_bridge_attach(encoder, next_bridge,
-				  &meson_dw_hdmi->bridge, 0);
+	meson_dw_hdmi->bridge = of_drm_find_bridge(pdev->dev.of_node);
 
 	DRM_DEBUG_DRIVER("HDMI controller initialized\n");
 
diff -Naur a/drivers/gpu/drm/meson/meson_encoder_cvbs.c b/drivers/gpu/drm/meson/meson_encoder_cvbs.c
--- a/drivers/gpu/drm/meson/meson_encoder_cvbs.c	1969-12-31 19:00:00.000000000 -0500
+++ b/drivers/gpu/drm/meson/meson_encoder_cvbs.c	2021-10-31 20:41:20.000000000 -0400
@@ -0,0 +1,318 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2016 BayLibre, SAS
+ * Author: Neil Armstrong <narmstrong@baylibre.com>
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ * Copyright (C) 2014 Endless Mobile
+ *
+ * Written by:
+ *     Jasper St. Pierre <jstpierre@mecheye.net>
+ */
+
+#include <linux/export.h>
+#include <linux/of_graph.h>
+#include <linux/phy/phy.h>
+
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_bridge.h>
+#include <drm/drm_bridge_connector.h>
+#include <drm/drm_device.h>
+#include <drm/drm_edid.h>
+#include <drm/drm_probe_helper.h>
+#include <drm/drm_simple_kms_helper.h>
+
+#include "meson_registers.h"
+#include "meson_vclk.h"
+#include "meson_encoder_cvbs.h"
+
+/* HHI VDAC Registers */
+#define HHI_VDAC_CNTL0		0x2F4 /* 0xbd offset in data sheet */
+#define HHI_VDAC_CNTL0_G12A	0x2EC /* 0xbd offset in data sheet */
+#define HHI_VDAC_CNTL1		0x2F8 /* 0xbe offset in data sheet */
+#define HHI_VDAC_CNTL1_G12A	0x2F0 /* 0xbe offset in data sheet */
+
+struct meson_encoder_cvbs {
+	struct drm_encoder	encoder;
+	struct drm_bridge	bridge;
+	struct drm_bridge	*next_bridge;
+	struct meson_drm	*priv;
+};
+
+#define bridge_to_meson_encoder_cvbs(x) \
+	container_of(x, struct meson_encoder_cvbs, bridge)
+
+/* Supported Modes */
+
+struct meson_cvbs_mode meson_cvbs_modes[MESON_CVBS_MODES_COUNT] = {
+	{ /* PAL */
+		.enci = &meson_cvbs_enci_pal,
+		.mode = {
+			DRM_MODE("720x576i", DRM_MODE_TYPE_DRIVER, 13500,
+				 720, 732, 795, 864, 0, 576, 580, 586, 625, 0,
+				 DRM_MODE_FLAG_INTERLACE),
+			.picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3,
+		},
+	},
+	{ /* NTSC */
+		.enci = &meson_cvbs_enci_ntsc,
+		.mode = {
+			DRM_MODE("720x480i", DRM_MODE_TYPE_DRIVER, 13500,
+				720, 739, 801, 858, 0, 480, 488, 494, 525, 0,
+				DRM_MODE_FLAG_INTERLACE),
+			.picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3,
+		},
+	},
+};
+
+static const struct meson_cvbs_mode *
+meson_cvbs_get_mode(const struct drm_display_mode *req_mode)
+{
+	int i;
+
+	for (i = 0; i < MESON_CVBS_MODES_COUNT; ++i) {
+		struct meson_cvbs_mode *meson_mode = &meson_cvbs_modes[i];
+
+		if (drm_mode_match(req_mode, &meson_mode->mode,
+				   DRM_MODE_MATCH_TIMINGS |
+				   DRM_MODE_MATCH_CLOCK |
+				   DRM_MODE_MATCH_FLAGS |
+				   DRM_MODE_MATCH_3D_FLAGS))
+			return meson_mode;
+	}
+
+	return NULL;
+}
+
+static int meson_encoder_cvbs_attach(struct drm_bridge *bridge,
+				     enum drm_bridge_attach_flags flags)
+{
+	struct meson_encoder_cvbs *meson_encoder_cvbs =
+					bridge_to_meson_encoder_cvbs(bridge);
+	int ret;
+
+	ret = phy_init(meson_encoder_cvbs->priv->cvbs_dac);
+	if (ret)
+		return ret;
+
+	return drm_bridge_attach(bridge->encoder, meson_encoder_cvbs->next_bridge,
+				 &meson_encoder_cvbs->bridge, flags);
+}
+
+static void meson_encoder_cvbs_detach(struct drm_bridge *bridge)
+{
+	struct meson_encoder_cvbs *meson_encoder_cvbs =
+					bridge_to_meson_encoder_cvbs(bridge);
+	int ret;
+
+	ret = phy_exit(meson_encoder_cvbs->priv->cvbs_dac);
+	if (ret)
+		dev_err(meson_encoder_cvbs->priv->dev,
+			"Failed to exit the CVBS DAC\n");
+}
+
+static int meson_encoder_cvbs_get_modes(struct drm_bridge *bridge,
+					struct drm_connector *connector)
+{
+	struct meson_encoder_cvbs *meson_encoder_cvbs =
+					bridge_to_meson_encoder_cvbs(bridge);
+	struct meson_drm *priv = meson_encoder_cvbs->priv;
+	struct drm_display_mode *mode;
+	int i;
+
+	for (i = 0; i < MESON_CVBS_MODES_COUNT; ++i) {
+		struct meson_cvbs_mode *meson_mode = &meson_cvbs_modes[i];
+
+		mode = drm_mode_duplicate(priv->drm, &meson_mode->mode);
+		if (!mode) {
+			dev_err(priv->dev, "Failed to create a new display mode\n");
+			return 0;
+		}
+
+		drm_mode_probed_add(connector, mode);
+	}
+
+	return i;
+}
+
+static int meson_encoder_cvbs_mode_valid(struct drm_bridge *bridge,
+					const struct drm_display_info *display_info,
+					const struct drm_display_mode *mode)
+{
+	if (meson_cvbs_get_mode(mode))
+		return MODE_OK;
+
+	return MODE_BAD;
+}
+
+static int meson_encoder_cvbs_atomic_check(struct drm_bridge *bridge,
+					struct drm_bridge_state *bridge_state,
+					struct drm_crtc_state *crtc_state,
+					struct drm_connector_state *conn_state)
+{
+	if (meson_cvbs_get_mode(&crtc_state->mode))
+		return 0;
+
+	return -EINVAL;
+}
+
+static void meson_encoder_cvbs_atomic_enable(struct drm_bridge *bridge,
+					     struct drm_bridge_state *bridge_state)
+{
+	struct meson_encoder_cvbs *encoder_cvbs = bridge_to_meson_encoder_cvbs(bridge);
+	struct drm_atomic_state *state = bridge_state->base.state;
+	struct meson_drm *priv = encoder_cvbs->priv;
+	const struct meson_cvbs_mode *meson_mode;
+	struct drm_connector_state *conn_state;
+	struct drm_crtc_state *crtc_state;
+	struct drm_connector *connector;
+
+	connector = drm_atomic_get_new_connector_for_encoder(state, bridge->encoder);
+	if (WARN_ON(!connector))
+		return;
+
+	conn_state = drm_atomic_get_new_connector_state(state, connector);
+	if (WARN_ON(!conn_state))
+		return;
+
+	crtc_state = drm_atomic_get_new_crtc_state(state, conn_state->crtc);
+	if (WARN_ON(!crtc_state))
+		return;
+
+	meson_mode = meson_cvbs_get_mode(&crtc_state->adjusted_mode);
+	if (WARN_ON(!meson_mode))
+		return;
+
+	meson_venci_cvbs_mode_set(priv, meson_mode->enci);
+
+	/* Setup 27MHz vclk2 for ENCI and VDAC */
+	meson_vclk_setup(priv, MESON_VCLK_TARGET_CVBS,
+			 MESON_VCLK_CVBS, MESON_VCLK_CVBS,
+			 MESON_VCLK_CVBS, MESON_VCLK_CVBS,
+			 true);
+
+	/* VDAC0 source is not from ATV */
+	writel_bits_relaxed(VENC_VDAC_SEL_ATV_DMD, 0,
+			    priv->io_base + _REG(VENC_VDAC_DACSEL0));
+
+	if (!priv->cvbs_dac) {
+		if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXBB))
+			regmap_write(priv->hhi, HHI_VDAC_CNTL0, 1);
+		else if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXM) ||
+			 meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXL))
+			regmap_write(priv->hhi, HHI_VDAC_CNTL0, 0xf0001);
+		else if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A))
+			regmap_write(priv->hhi, HHI_VDAC_CNTL0_G12A, 0x906001);
+
+		regmap_write(priv->hhi, HHI_VDAC_CNTL1, 0x0);
+	} else if (!priv->cvbs_dac_enabled) {
+		int ret = phy_power_on(priv->cvbs_dac);
+		if (ret)
+			dev_err(priv->dev,
+				"Failed to power on the CVBS DAC\n");
+
+		priv->cvbs_dac_enabled = true;
+	}
+}
+
+static void meson_encoder_cvbs_atomic_disable(struct drm_bridge *bridge,
+					      struct drm_bridge_state *bridge_state)
+{
+	struct meson_encoder_cvbs *meson_encoder_cvbs =
+					bridge_to_meson_encoder_cvbs(bridge);
+	struct meson_drm *priv = meson_encoder_cvbs->priv;
+
+	/* Disable CVBS VDAC */
+	if (!priv->cvbs_dac) {
+		if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A)) {
+			regmap_write(priv->hhi, HHI_VDAC_CNTL0_G12A, 0);
+			regmap_write(priv->hhi, HHI_VDAC_CNTL1_G12A, 0);
+		} else {
+			regmap_write(priv->hhi, HHI_VDAC_CNTL0, 0);
+			regmap_write(priv->hhi, HHI_VDAC_CNTL1, 8);
+		}
+	} else if (priv->cvbs_dac_enabled) {
+		int ret = phy_power_off(priv->cvbs_dac);
+		if (ret)
+			dev_err(priv->dev,
+				"Failed to power off the CVBS DAC\n");
+
+		priv->cvbs_dac_enabled = false;
+	}
+}
+
+static const struct drm_bridge_funcs meson_encoder_cvbs_bridge_funcs = {
+	.attach = meson_encoder_cvbs_attach,
+	.mode_valid = meson_encoder_cvbs_mode_valid,
+	.get_modes = meson_encoder_cvbs_get_modes,
+	.atomic_enable = meson_encoder_cvbs_atomic_enable,
+	.atomic_disable = meson_encoder_cvbs_atomic_disable,
+	.atomic_check = meson_encoder_cvbs_atomic_check,
+	.atomic_duplicate_state = drm_atomic_helper_bridge_duplicate_state,
+	.atomic_destroy_state = drm_atomic_helper_bridge_destroy_state,
+	.atomic_reset = drm_atomic_helper_bridge_reset,
+};
+
+int meson_encoder_cvbs_init(struct meson_drm *priv)
+{
+	struct drm_device *drm = priv->drm;
+	struct meson_encoder_cvbs *meson_encoder_cvbs;
+	struct drm_connector *connector;
+	struct device_node *remote;
+	int ret;
+
+	meson_encoder_cvbs = devm_kzalloc(priv->dev, sizeof(*meson_encoder_cvbs), GFP_KERNEL);
+	if (!meson_encoder_cvbs)
+		return -ENOMEM;
+
+	/* CVBS Connector Bridge */
+	remote = of_graph_get_remote_node(priv->dev->of_node, 0, 0);
+	if (!remote) {
+		dev_info(drm->dev, "CVBS Output connector not available\n");
+		return 0;
+	}
+
+	meson_encoder_cvbs->next_bridge = of_drm_find_bridge(remote);
+	if (!meson_encoder_cvbs->next_bridge) {
+		dev_err(priv->dev, "Failed to find CVBS Connector bridge\n");
+		return -EPROBE_DEFER;
+	}
+
+	/* CVBS Encoder Bridge */
+	meson_encoder_cvbs->bridge.funcs = &meson_encoder_cvbs_bridge_funcs;
+	meson_encoder_cvbs->bridge.of_node = priv->dev->of_node;
+	meson_encoder_cvbs->bridge.type = DRM_MODE_CONNECTOR_Composite;
+	meson_encoder_cvbs->bridge.ops = DRM_BRIDGE_OP_MODES;
+	meson_encoder_cvbs->bridge.interlace_allowed = true;
+
+	drm_bridge_add(&meson_encoder_cvbs->bridge);
+
+	meson_encoder_cvbs->priv = priv;
+
+	/* Encoder */
+	ret = drm_simple_encoder_init(priv->drm, &meson_encoder_cvbs->encoder,
+				      DRM_MODE_ENCODER_TVDAC);
+	if (ret) {
+		dev_err(priv->dev, "Failed to init CVBS encoder: %d\n", ret);
+		return ret;
+	}
+
+	meson_encoder_cvbs->encoder.possible_crtcs = BIT(0);
+
+	/* Attach CVBS Encoder Bridge to Encoder */
+	ret = drm_bridge_attach(&meson_encoder_cvbs->encoder, &meson_encoder_cvbs->bridge, NULL,
+				DRM_BRIDGE_ATTACH_NO_CONNECTOR);
+	if (ret) {
+		dev_err(priv->dev, "Failed to attach bridge: %d\n", ret);
+		return ret;
+	}
+
+	/* Initialize & attach Bridge Connector */
+	connector = drm_bridge_connector_init(priv->drm, &meson_encoder_cvbs->encoder);
+	if (IS_ERR(connector)) {
+		dev_err(priv->dev, "Unable to create CVBS bridge connector\n");
+		return PTR_ERR(connector);
+	}
+	drm_connector_attach_encoder(connector, &meson_encoder_cvbs->encoder);
+
+	return 0;
+}
diff -Naur a/drivers/gpu/drm/meson/meson_encoder_cvbs.h b/drivers/gpu/drm/meson/meson_encoder_cvbs.h
--- a/drivers/gpu/drm/meson/meson_encoder_cvbs.h	1969-12-31 19:00:00.000000000 -0500
+++ b/drivers/gpu/drm/meson/meson_encoder_cvbs.h	2021-10-31 20:41:20.000000000 -0400
@@ -0,0 +1,29 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (C) 2016 BayLibre, SAS
+ * Author: Neil Armstrong <narmstrong@baylibre.com>
+ * Copyright (C) 2014 Endless Mobile
+ *
+ * Written by:
+ *     Jasper St. Pierre <jstpierre@mecheye.net>
+ */
+
+#ifndef __MESON_VENC_CVBS_H
+#define __MESON_VENC_CVBS_H
+
+#include "meson_drv.h"
+#include "meson_venc.h"
+
+struct meson_cvbs_mode {
+	struct meson_cvbs_enci_mode *enci;
+	struct drm_display_mode mode;
+};
+
+#define MESON_CVBS_MODES_COUNT	2
+
+/* Modes supported by the CVBS output */
+extern struct meson_cvbs_mode meson_cvbs_modes[MESON_CVBS_MODES_COUNT];
+
+int meson_encoder_cvbs_init(struct meson_drm *priv);
+
+#endif /* __MESON_VENC_CVBS_H */
diff -Naur a/drivers/gpu/drm/meson/meson_encoder_hdmi.c b/drivers/gpu/drm/meson/meson_encoder_hdmi.c
--- a/drivers/gpu/drm/meson/meson_encoder_hdmi.c	1969-12-31 19:00:00.000000000 -0500
+++ b/drivers/gpu/drm/meson/meson_encoder_hdmi.c	2021-10-31 20:41:20.000000000 -0400
@@ -0,0 +1,458 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2016 BayLibre, SAS
+ * Author: Neil Armstrong <narmstrong@baylibre.com>
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ */
+
+#include <linux/clk.h>
+#include <linux/component.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/of_graph.h>
+#include <linux/regulator/consumer.h>
+#include <linux/reset.h>
+
+#include <media/cec-notifier.h>
+
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_bridge.h>
+#include <drm/drm_bridge_connector.h>
+#include <drm/drm_device.h>
+#include <drm/drm_edid.h>
+#include <drm/drm_probe_helper.h>
+#include <drm/drm_simple_kms_helper.h>
+
+#include <linux/media-bus-format.h>
+#include <linux/videodev2.h>
+
+#include "meson_drv.h"
+#include "meson_registers.h"
+#include "meson_vclk.h"
+#include "meson_venc.h"
+
+struct meson_encoder_hdmi {
+	struct drm_encoder encoder;
+	struct drm_bridge bridge;
+	struct drm_bridge *next_bridge;
+	struct drm_connector *connector;
+	struct meson_drm *priv;
+	unsigned long output_bus_fmt;
+	struct cec_notifier *cec_notifier;
+};
+
+#define bridge_to_meson_encoder_hdmi(x) \
+	container_of(x, struct meson_encoder_hdmi, bridge)
+
+static int meson_encoder_hdmi_attach(struct drm_bridge *bridge,
+				     enum drm_bridge_attach_flags flags)
+{
+	struct meson_encoder_hdmi *encoder_hdmi = bridge_to_meson_encoder_hdmi(bridge);
+
+	return drm_bridge_attach(bridge->encoder, encoder_hdmi->next_bridge,
+				 &encoder_hdmi->bridge, flags);
+}
+
+static void meson_encoder_hdmi_detach(struct drm_bridge *bridge)
+{
+	struct meson_encoder_hdmi *encoder_hdmi = bridge_to_meson_encoder_hdmi(bridge);
+
+	cec_notifier_conn_unregister(encoder_hdmi->cec_notifier);
+	encoder_hdmi->cec_notifier = NULL;
+}
+
+static void meson_encoder_hdmi_set_vclk(struct meson_encoder_hdmi *encoder_hdmi,
+					const struct drm_display_mode *mode)
+{
+	struct meson_drm *priv = encoder_hdmi->priv;
+	int vic = drm_match_cea_mode(mode);
+	unsigned int phy_freq;
+	unsigned int vclk_freq;
+	unsigned int venc_freq;
+	unsigned int hdmi_freq;
+
+	vclk_freq = mode->clock;
+
+	/* For 420, pixel clock is half unlike venc clock */
+	if (encoder_hdmi->output_bus_fmt == MEDIA_BUS_FMT_UYYVYY8_0_5X24)
+		vclk_freq /= 2;
+
+	/* TMDS clock is pixel_clock * 10 */
+	phy_freq = vclk_freq * 10;
+
+	if (!vic) {
+		meson_vclk_setup(priv, MESON_VCLK_TARGET_DMT, phy_freq,
+				 vclk_freq, vclk_freq, vclk_freq, false);
+		return;
+	}
+
+	/* 480i/576i needs global pixel doubling */
+	if (mode->flags & DRM_MODE_FLAG_DBLCLK)
+		vclk_freq *= 2;
+
+	venc_freq = vclk_freq;
+	hdmi_freq = vclk_freq;
+
+	/* VENC double pixels for 1080i, 720p and YUV420 modes */
+	if (meson_venc_hdmi_venc_repeat(vic) ||
+	    encoder_hdmi->output_bus_fmt == MEDIA_BUS_FMT_UYYVYY8_0_5X24)
+		venc_freq *= 2;
+
+	vclk_freq = max(venc_freq, hdmi_freq);
+
+	if (mode->flags & DRM_MODE_FLAG_DBLCLK)
+		venc_freq /= 2;
+
+	dev_dbg(priv->dev, "vclk:%d phy=%d venc=%d hdmi=%d enci=%d\n",
+		phy_freq, vclk_freq, venc_freq, hdmi_freq,
+		priv->venc.hdmi_use_enci);
+
+	meson_vclk_setup(priv, MESON_VCLK_TARGET_HDMI, phy_freq, vclk_freq,
+			 venc_freq, hdmi_freq, priv->venc.hdmi_use_enci);
+}
+
+static enum drm_mode_status meson_encoder_hdmi_mode_valid(struct drm_bridge *bridge,
+					const struct drm_display_info *display_info,
+					const struct drm_display_mode *mode)
+{
+	struct meson_encoder_hdmi *encoder_hdmi = bridge_to_meson_encoder_hdmi(bridge);
+	struct meson_drm *priv = encoder_hdmi->priv;
+	bool is_hdmi2_sink = display_info->hdmi.scdc.supported;
+	unsigned int phy_freq;
+	unsigned int vclk_freq;
+	unsigned int venc_freq;
+	unsigned int hdmi_freq;
+	int vic = drm_match_cea_mode(mode);
+	enum drm_mode_status status;
+
+	dev_dbg(priv->dev, "Modeline " DRM_MODE_FMT "\n", DRM_MODE_ARG(mode));
+
+	/* If sink does not support 540MHz, reject the non-420 HDMI2 modes */
+	if (display_info->max_tmds_clock &&
+	    mode->clock > display_info->max_tmds_clock &&
+	    !drm_mode_is_420_only(display_info, mode) &&
+	    !drm_mode_is_420_also(display_info, mode))
+		return MODE_BAD;
+
+	/* Check against non-VIC supported modes */
+	if (!vic) {
+		status = meson_venc_hdmi_supported_mode(mode);
+		if (status != MODE_OK)
+			return status;
+
+		return meson_vclk_dmt_supported_freq(priv, mode->clock);
+	/* Check against supported VIC modes */
+	} else if (!meson_venc_hdmi_supported_vic(vic))
+		return MODE_BAD;
+
+	vclk_freq = mode->clock;
+
+	/* For 420, pixel clock is half unlike venc clock */
+	if (drm_mode_is_420_only(display_info, mode) ||
+	    (!is_hdmi2_sink &&
+	     drm_mode_is_420_also(display_info, mode)))
+		vclk_freq /= 2;
+
+	/* TMDS clock is pixel_clock * 10 */
+	phy_freq = vclk_freq * 10;
+
+	/* 480i/576i needs global pixel doubling */
+	if (mode->flags & DRM_MODE_FLAG_DBLCLK)
+		vclk_freq *= 2;
+
+	venc_freq = vclk_freq;
+	hdmi_freq = vclk_freq;
+
+	/* VENC double pixels for 1080i, 720p and YUV420 modes */
+	if (meson_venc_hdmi_venc_repeat(vic) ||
+	    drm_mode_is_420_only(display_info, mode) ||
+	    (!is_hdmi2_sink &&
+	     drm_mode_is_420_also(display_info, mode)))
+		venc_freq *= 2;
+
+	vclk_freq = max(venc_freq, hdmi_freq);
+
+	if (mode->flags & DRM_MODE_FLAG_DBLCLK)
+		venc_freq /= 2;
+
+	dev_dbg(priv->dev, "%s: vclk:%d phy=%d venc=%d hdmi=%d\n",
+		__func__, phy_freq, vclk_freq, venc_freq, hdmi_freq);
+
+	return meson_vclk_vic_supported_freq(priv, phy_freq, vclk_freq);
+}
+
+static void meson_encoder_hdmi_atomic_enable(struct drm_bridge *bridge,
+					     struct drm_bridge_state *bridge_state)
+{
+	struct meson_encoder_hdmi *encoder_hdmi = bridge_to_meson_encoder_hdmi(bridge);
+	struct drm_atomic_state *state = bridge_state->base.state;
+	struct meson_drm *priv = encoder_hdmi->priv;
+	struct drm_connector_state *conn_state;
+	const struct drm_display_mode *mode;
+	struct drm_crtc_state *crtc_state;
+	struct drm_connector *connector;
+	bool yuv420_mode = false;
+	unsigned int ycrcb_map;
+	int vic;
+
+	connector = drm_atomic_get_new_connector_for_encoder(state, bridge->encoder);
+	if (WARN_ON(!connector))
+		return;
+
+	conn_state = drm_atomic_get_new_connector_state(state, connector);
+	if (WARN_ON(!conn_state))
+		return;
+
+	crtc_state = drm_atomic_get_new_crtc_state(state, conn_state->crtc);
+	if (WARN_ON(!crtc_state))
+		return;
+
+	mode = &crtc_state->adjusted_mode;
+
+	vic = drm_match_cea_mode(mode);
+
+	dev_dbg(priv->dev, "\"%s\" vic %d\n", mode->name, vic);
+
+	if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8) ||
+	    meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8B) ||
+	    meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8M2)) {
+		if (encoder_hdmi->output_bus_fmt == MEDIA_BUS_FMT_RGB888_1X24)
+			ycrcb_map = VPU_HDMI_OUTPUT_YCBCR;
+		else
+			ycrcb_map = VPU_HDMI_OUTPUT_CRYCB;
+	} else if (encoder_hdmi->output_bus_fmt == MEDIA_BUS_FMT_UYYVYY8_0_5X24) {
+		ycrcb_map = VPU_HDMI_OUTPUT_CRYCB;
+		yuv420_mode = true;
+	} else {
+		ycrcb_map = VPU_HDMI_OUTPUT_CBYCR;
+	}
+
+	/* VENC + VENC-DVI Mode setup */
+	meson_venc_hdmi_mode_set(priv, vic, ycrcb_map, yuv420_mode, mode);
+
+	/* VCLK Set clock */
+	meson_encoder_hdmi_set_vclk(encoder_hdmi, mode);
+
+	if (encoder_hdmi->output_bus_fmt == MEDIA_BUS_FMT_UYYVYY8_0_5X24)
+		/* Setup YUV420 to HDMI-TX, no 10bit diphering */
+		writel_relaxed(2 | (2 << 2),
+			       priv->io_base + _REG(VPU_HDMI_FMT_CTRL));
+	else
+		/* Setup YUV444 to HDMI-TX, no 10bit diphering */
+		writel_relaxed(0, priv->io_base + _REG(VPU_HDMI_FMT_CTRL));
+
+	dev_dbg(priv->dev, "%s\n", priv->venc.hdmi_use_enci ? "VENCI" : "VENCP");
+
+	if (priv->venc.hdmi_use_enci)
+		writel_relaxed(1, priv->io_base + _REG(ENCI_VIDEO_EN));
+	else
+		writel_relaxed(1, priv->io_base + _REG(ENCP_VIDEO_EN));
+}
+
+static void meson_encoder_hdmi_atomic_disable(struct drm_bridge *bridge,
+					     struct drm_bridge_state *bridge_state)
+{
+	struct meson_encoder_hdmi *encoder_hdmi = bridge_to_meson_encoder_hdmi(bridge);
+	struct meson_drm *priv = encoder_hdmi->priv;
+
+	writel_bits_relaxed(0x3, 0,
+			    priv->io_base + _REG(VPU_HDMI_SETTING));
+
+	writel_relaxed(0, priv->io_base + _REG(ENCI_VIDEO_EN));
+	writel_relaxed(0, priv->io_base + _REG(ENCP_VIDEO_EN));
+}
+
+static const u32 meson_encoder_hdmi_out_bus_fmts[] = {
+	MEDIA_BUS_FMT_YUV8_1X24,
+	MEDIA_BUS_FMT_UYYVYY8_0_5X24,
+};
+
+static u32 *
+meson_encoder_hdmi_get_inp_bus_fmts(struct drm_bridge *bridge,
+					struct drm_bridge_state *bridge_state,
+					struct drm_crtc_state *crtc_state,
+					struct drm_connector_state *conn_state,
+					u32 output_fmt,
+					unsigned int *num_input_fmts)
+{
+	u32 *input_fmts = NULL;
+	int i;
+
+	*num_input_fmts = 0;
+
+	for (i = 0 ; i < ARRAY_SIZE(meson_encoder_hdmi_out_bus_fmts) ; ++i) {
+		if (output_fmt == meson_encoder_hdmi_out_bus_fmts[i]) {
+			*num_input_fmts = 1;
+			input_fmts = kcalloc(*num_input_fmts,
+					     sizeof(*input_fmts),
+					     GFP_KERNEL);
+			if (!input_fmts)
+				return NULL;
+
+			input_fmts[0] = output_fmt;
+
+			break;
+		}
+	}
+
+	return input_fmts;
+}
+
+static int meson_encoder_hdmi_atomic_check(struct drm_bridge *bridge,
+					struct drm_bridge_state *bridge_state,
+					struct drm_crtc_state *crtc_state,
+					struct drm_connector_state *conn_state)
+{
+	struct meson_encoder_hdmi *encoder_hdmi = bridge_to_meson_encoder_hdmi(bridge);
+	struct drm_connector_state *old_conn_state =
+		drm_atomic_get_old_connector_state(conn_state->state, conn_state->connector);
+	struct meson_drm *priv = encoder_hdmi->priv;
+
+	encoder_hdmi->output_bus_fmt = bridge_state->output_bus_cfg.format;
+
+	dev_dbg(priv->dev, "output_bus_fmt %lx\n", encoder_hdmi->output_bus_fmt);
+
+	if (!drm_connector_atomic_hdr_metadata_equal(old_conn_state, conn_state))
+		crtc_state->mode_changed = true;
+
+	return 0;
+}
+
+static void meson_encoder_hdmi_hpd_notify(struct drm_bridge *bridge,
+					  enum drm_connector_status status)
+{
+	struct meson_encoder_hdmi *encoder_hdmi = bridge_to_meson_encoder_hdmi(bridge);
+	struct edid *edid;
+
+	if (!encoder_hdmi->cec_notifier)
+		return;
+
+	if (status == connector_status_connected) {
+		edid = drm_bridge_get_edid(encoder_hdmi->next_bridge, encoder_hdmi->connector);
+		if (!edid)
+			return;
+
+		cec_notifier_set_phys_addr_from_edid(encoder_hdmi->cec_notifier, edid);
+	} else
+		cec_notifier_phys_addr_invalidate(encoder_hdmi->cec_notifier);
+}
+
+static const struct drm_bridge_funcs meson_encoder_hdmi_bridge_funcs = {
+	.attach = meson_encoder_hdmi_attach,
+	.detach = meson_encoder_hdmi_detach,
+	.mode_valid = meson_encoder_hdmi_mode_valid,
+	.hpd_notify = meson_encoder_hdmi_hpd_notify,
+	.atomic_enable = meson_encoder_hdmi_atomic_enable,
+	.atomic_disable = meson_encoder_hdmi_atomic_disable,
+	.atomic_get_input_bus_fmts = meson_encoder_hdmi_get_inp_bus_fmts,
+	.atomic_check = meson_encoder_hdmi_atomic_check,
+	.atomic_duplicate_state = drm_atomic_helper_bridge_duplicate_state,
+	.atomic_destroy_state = drm_atomic_helper_bridge_destroy_state,
+	.atomic_reset = drm_atomic_helper_bridge_reset,
+};
+
+int meson_encoder_hdmi_init(struct meson_drm *priv)
+{
+	struct meson_encoder_hdmi *meson_encoder_hdmi;
+	struct platform_device *pdev;
+	struct device_node *remote;
+	int ret;
+
+	meson_encoder_hdmi = devm_kzalloc(priv->dev, sizeof(*meson_encoder_hdmi), GFP_KERNEL);
+	if (!meson_encoder_hdmi)
+		return -ENOMEM;
+
+	/* HDMI Transceiver Bridge */
+	remote = of_graph_get_remote_node(priv->dev->of_node, 1, 0);
+	if (!remote) {
+		dev_err(priv->dev, "HDMI transceiver device is disabled");
+		return 0;
+	}
+
+	meson_encoder_hdmi->next_bridge = of_drm_find_bridge(remote);
+	if (!meson_encoder_hdmi->next_bridge) {
+		dev_err(priv->dev, "Failed to find HDMI transceiver bridge\n");
+		return -EPROBE_DEFER;
+	}
+
+	/* HDMI Encoder Bridge */
+	meson_encoder_hdmi->bridge.funcs = &meson_encoder_hdmi_bridge_funcs;
+	meson_encoder_hdmi->bridge.of_node = priv->dev->of_node;
+	meson_encoder_hdmi->bridge.type = DRM_MODE_CONNECTOR_HDMIA;
+	meson_encoder_hdmi->bridge.interlace_allowed = true;
+
+	drm_bridge_add(&meson_encoder_hdmi->bridge);
+
+	meson_encoder_hdmi->priv = priv;
+
+	/* Encoder */
+	ret = drm_simple_encoder_init(priv->drm, &meson_encoder_hdmi->encoder,
+				      DRM_MODE_ENCODER_TMDS);
+	if (ret) {
+		dev_err(priv->dev, "Failed to init HDMI encoder: %d\n", ret);
+		return ret;
+	}
+
+	meson_encoder_hdmi->encoder.possible_crtcs = BIT(0);
+
+	/* Attach HDMI Encoder Bridge to Encoder */
+	ret = drm_bridge_attach(&meson_encoder_hdmi->encoder, &meson_encoder_hdmi->bridge, NULL,
+				DRM_BRIDGE_ATTACH_NO_CONNECTOR);
+	if (ret) {
+		dev_err(priv->dev, "Failed to attach bridge: %d\n", ret);
+		return ret;
+	}
+
+	/* Initialize & attach Bridge Connector */
+	meson_encoder_hdmi->connector = drm_bridge_connector_init(priv->drm,
+							&meson_encoder_hdmi->encoder);
+	if (IS_ERR(meson_encoder_hdmi->connector)) {
+		dev_err(priv->dev, "Unable to create HDMI bridge connector\n");
+		return PTR_ERR(meson_encoder_hdmi->connector);
+	}
+	drm_connector_attach_encoder(meson_encoder_hdmi->connector,
+				     &meson_encoder_hdmi->encoder);
+
+	/*
+	 * We should have now in place:
+	 * encoder->[hdmi encoder bridge]->[dw-hdmi bridge]->[display connector bridge]->[display connector]
+	 */
+
+	/*
+	 * drm_connector_attach_max_bpc_property() requires the
+	 * connector to have a state.
+	 */
+	drm_atomic_helper_connector_reset(meson_encoder_hdmi->connector);
+
+	if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXL) ||
+	    meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXM) ||
+	    meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A))
+		drm_connector_attach_hdr_output_metadata_property(meson_encoder_hdmi->connector);
+
+	drm_connector_attach_max_bpc_property(meson_encoder_hdmi->connector, 8, 8);
+
+	if (!meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8) &&
+	    !meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8B) &&
+	    !meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8M2))
+		/* Handle this here until handled by drm_bridge_connector_init() */
+		meson_encoder_hdmi->connector->ycbcr_420_allowed = true;
+
+	pdev = of_find_device_by_node(remote);
+	if (pdev) {
+		struct cec_connector_info conn_info;
+		struct cec_notifier *notifier;
+
+		cec_fill_conn_info_from_drm(&conn_info, meson_encoder_hdmi->connector);
+
+		notifier = cec_notifier_conn_register(&pdev->dev, NULL, &conn_info);
+		if (!notifier)
+			return -ENOMEM;
+
+		meson_encoder_hdmi->cec_notifier = notifier;
+	}
+
+	dev_dbg(priv->dev, "HDMI encoder initialized\n");
+
+	return 0;
+}
diff -Naur a/drivers/gpu/drm/meson/meson_encoder_hdmi.h b/drivers/gpu/drm/meson/meson_encoder_hdmi.h
--- a/drivers/gpu/drm/meson/meson_encoder_hdmi.h	1969-12-31 19:00:00.000000000 -0500
+++ b/drivers/gpu/drm/meson/meson_encoder_hdmi.h	2021-10-31 20:41:20.000000000 -0400
@@ -0,0 +1,12 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (C) 2021 BayLibre, SAS
+ * Author: Neil Armstrong <narmstrong@baylibre.com>
+ */
+
+#ifndef __MESON_ENCODER_HDMI_H
+#define __MESON_ENCODER_HDMI_H
+
+int meson_encoder_hdmi_init(struct meson_drm *priv);
+
+#endif /* __MESON_ENCODER_HDMI_H */
diff -Naur a/drivers/gpu/drm/meson/meson_plane.c b/drivers/gpu/drm/meson/meson_plane.c
--- a/drivers/gpu/drm/meson/meson_plane.c	2021-10-31 16:53:10.000000000 -0400
+++ b/drivers/gpu/drm/meson/meson_plane.c	2021-10-31 20:41:20.000000000 -0400
@@ -199,8 +199,11 @@
 			priv->viu.osd1_ctrl_stat2 &= ~OSD_DPATH_MALI_AFBCD;
 	}
 
-	/* On GXBB, Use the old non-HDR RGB2YUV converter */
-	if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXBB))
+	/* On GXBB and earlier, Use the old non-HDR RGB2YUV converter */
+	if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8) ||
+	    meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8B) ||
+	    meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8M2) ||
+	    meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXBB))
 		priv->viu.osd1_blk0_cfg[0] |= OSD_OUTPUT_COLOR_RGB;
 
 	if (priv->viu.osd1_afbcd &&
@@ -231,17 +234,21 @@
 		}
 	}
 
-	switch (fb->format->format) {
-	case DRM_FORMAT_XRGB8888:
-	case DRM_FORMAT_XBGR8888:
-		/* For XRGB, replace the pixel's alpha by 0xFF */
-		priv->viu.osd1_ctrl_stat2 |= OSD_REPLACE_EN;
-		break;
-	case DRM_FORMAT_ARGB8888:
-	case DRM_FORMAT_ABGR8888:
-		/* For ARGB, use the pixel's alpha */
-		priv->viu.osd1_ctrl_stat2 &= ~OSD_REPLACE_EN;
-		break;
+	if (!meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8) &&
+	    !meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8B) &&
+	    !meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8M2)) {
+		switch (fb->format->format) {
+		case DRM_FORMAT_XRGB8888:
+		case DRM_FORMAT_XBGR8888:
+			/* For XRGB, replace the pixel's alpha by 0xFF */
+			priv->viu.osd1_ctrl_stat2 |= OSD_REPLACE_EN;
+			break;
+		case DRM_FORMAT_ARGB8888:
+		case DRM_FORMAT_ABGR8888:
+			/* For ARGB, use the pixel's alpha */
+			priv->viu.osd1_ctrl_stat2 &= ~OSD_REPLACE_EN;
+			break;
+		}
 	}
 
 	/* Default scaler parameters */
diff -Naur a/drivers/gpu/drm/meson/meson_transwitch_hdmi.c b/drivers/gpu/drm/meson/meson_transwitch_hdmi.c
--- a/drivers/gpu/drm/meson/meson_transwitch_hdmi.c	1969-12-31 19:00:00.000000000 -0500
+++ b/drivers/gpu/drm/meson/meson_transwitch_hdmi.c	2021-10-31 20:41:20.000000000 -0400
@@ -0,0 +1,1602 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2021 Martin Blumenstingl <martin.blumenstingl@googlemail.com>
+ *
+ * All registers and magic values are taken from Amlogic's GPL kernel sources:
+ *   Copyright (C) 2010 Amlogic, Inc.
+ */
+
+#include <linux/clk.h>
+#include <linux/component.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/phy/phy.h>
+#include <linux/platform_device.h>
+#include <linux/regmap.h>
+
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_bridge.h>
+#include <drm/drm_connector.h>
+#include <drm/drm_device.h>
+#include <drm/drm_edid.h>
+#include <drm/drm_probe_helper.h>
+#include <drm/drm_print.h>
+
+#include <sound/hdmi-codec.h>
+
+#include <uapi/linux/media-bus-format.h>
+#include <uapi/linux/videodev2.h>
+
+#include "meson_transwitch_hdmi.h"
+
+#define HDMI_ADDR_PORT					0x0
+#define HDMI_DATA_PORT					0x4
+#define HDMI_CTRL_PORT					0x8
+	#define HDMI_CTRL_PORT_APB3_ERR_EN		BIT(15)
+
+struct meson_txc_hdmi {
+	struct device			*dev;
+
+	struct regmap			*regmap;
+
+	struct clk			*pclk;
+	struct clk			*sys_clk;
+
+	struct phy			*phy;
+	bool				phy_is_on;
+
+	struct mutex			codec_mutex;
+	enum drm_connector_status	last_connector_status;
+	hdmi_codec_plugged_cb		codec_plugged_cb;
+	struct device			*codec_dev;
+
+	struct platform_device		*hdmi_codec_pdev;
+	uint8_t				eld[MAX_ELD_BYTES];
+
+	struct drm_connector		connector;
+	struct drm_bridge		bridge;
+	struct drm_bridge		*next_bridge;
+
+	unsigned int			input_bus_format;
+	unsigned int			output_bus_format;
+	bool				sink_is_hdmi;
+};
+
+#define bridge_to_meson_txc_hdmi(x) container_of(x, struct meson_txc_hdmi, bridge)
+
+static const struct regmap_range meson_txc_hdmi_regmap_ranges[] = {
+	regmap_reg_range(0x0000, 0x07ff),
+	regmap_reg_range(0x8000, 0x800c),
+};
+
+static const struct regmap_access_table meson_txc_hdmi_regmap_access = {
+	.yes_ranges = meson_txc_hdmi_regmap_ranges,
+	.n_yes_ranges = ARRAY_SIZE(meson_txc_hdmi_regmap_ranges),
+};
+
+static int meson_txc_hdmi_reg_read(void *context, unsigned int addr,
+				   unsigned int *data)
+{
+	void __iomem *base = context;
+
+	writel(addr, base + HDMI_ADDR_PORT);
+	writel(addr, base + HDMI_ADDR_PORT);
+
+	*data = readl(base + HDMI_DATA_PORT);
+
+	return 0;
+}
+
+static int meson_txc_hdmi_reg_write(void *context, unsigned int addr,
+				    unsigned int data)
+{
+	void __iomem *base = context;
+
+	writel(addr, base + HDMI_ADDR_PORT);
+	writel(addr, base + HDMI_ADDR_PORT);
+
+	writel(data, base + HDMI_DATA_PORT);
+
+	return 0;
+}
+
+static const struct regmap_config meson_txc_hdmi_regmap_config = {
+	.reg_bits = 16,
+	.val_bits = 16,
+	.reg_stride = 1,
+	.reg_read = meson_txc_hdmi_reg_read,
+	.reg_write = meson_txc_hdmi_reg_write,
+	.rd_table = &meson_txc_hdmi_regmap_access,
+	.wr_table = &meson_txc_hdmi_regmap_access,
+	.max_register = HDMI_OTHER_RX_PACKET_INTR_CLR,
+	.fast_io = true,
+};
+
+static void meson_txc_hdmi_write_infoframe(struct regmap *regmap,
+					   unsigned int tx_pkt_reg, u8 *buf,
+					   unsigned int len, bool enable)
+{
+	unsigned int i;
+
+	/* Write the data bytes by starting at register offset 1 */
+	for (i = HDMI_INFOFRAME_HEADER_SIZE; i < len; i++)
+		regmap_write(regmap,
+			     tx_pkt_reg + i - HDMI_INFOFRAME_HEADER_SIZE + 1,
+			     buf[i]);
+
+	/* Zero all remaining data bytes */
+	for (; i < 0x1c; i++)
+		regmap_write(regmap, tx_pkt_reg + i, 0x00);
+
+	/* Write the header (which we skipped above) */
+	regmap_write(regmap, tx_pkt_reg + 0x00, buf[3]);
+	regmap_write(regmap, tx_pkt_reg + 0x1c, buf[0]);
+	regmap_write(regmap, tx_pkt_reg + 0x1d, buf[1]);
+	regmap_write(regmap, tx_pkt_reg + 0x1e, buf[2]);
+
+	regmap_write(regmap, tx_pkt_reg + 0x1f, enable ? 0xff : 0x00);
+}
+
+static void meson_txc_hdmi_disable_infoframe(struct meson_txc_hdmi *priv,
+					     unsigned int tx_pkt_reg)
+{
+	u8 buf[HDMI_INFOFRAME_HEADER_SIZE] = { 0 };
+
+	meson_txc_hdmi_write_infoframe(priv->regmap, tx_pkt_reg, buf,
+				       HDMI_INFOFRAME_HEADER_SIZE, false);
+}
+
+static void meson_txc_hdmi_sys5_reset_assert(struct meson_txc_hdmi *priv)
+{
+	/* A comment in the vendor driver says: bit5,6 is converted */
+	regmap_write(priv->regmap, TX_SYS5_TX_SOFT_RESET_2,
+		     TX_SYS5_TX_SOFT_RESET_2_HDMI_CH3_RST_IN |
+		     TX_SYS5_TX_SOFT_RESET_2_HDMI_CH0_RST_IN);
+	usleep_range(10, 20);
+
+	regmap_write(priv->regmap, TX_SYS5_TX_SOFT_RESET_2,
+		     TX_SYS5_TX_SOFT_RESET_2_HDMI_CH2_RST_IN |
+		     TX_SYS5_TX_SOFT_RESET_2_HDMI_CH1_RST_IN);
+	usleep_range(10, 20);
+
+	regmap_write(priv->regmap, TX_SYS5_TX_SOFT_RESET_1,
+		     TX_SYS5_TX_SOFT_RESET_1_TX_PIXEL_RSTN |
+		     TX_SYS5_TX_SOFT_RESET_1_TX_TMDS_RSTN |
+		     TX_SYS5_TX_SOFT_RESET_1_TX_AUDIO_MASTER_RSTN |
+		     TX_SYS5_TX_SOFT_RESET_1_TX_AUDIO_RESAMPLE_RSTN |
+		     TX_SYS5_TX_SOFT_RESET_1_TX_I2S_RESET_RSTN |
+		     TX_SYS5_TX_SOFT_RESET_1_TX_DIG_RESET_N_CH2 |
+		     TX_SYS5_TX_SOFT_RESET_1_TX_DIG_RESET_N_CH1 |
+		     TX_SYS5_TX_SOFT_RESET_1_TX_DIG_RESET_N_CH0);
+	usleep_range(10, 20);
+}
+
+static void meson_txc_hdmi_sys5_reset_deassert(struct meson_txc_hdmi *priv)
+{
+	/* Release the resets except tmds_clk */
+	regmap_write(priv->regmap, TX_SYS5_TX_SOFT_RESET_1,
+		     TX_SYS5_TX_SOFT_RESET_1_TX_TMDS_RSTN);
+	usleep_range(10, 20);
+
+	/* Release the tmds_clk reset as well */
+	regmap_write(priv->regmap, TX_SYS5_TX_SOFT_RESET_1, 0x0);
+	usleep_range(10, 20);
+
+	regmap_write(priv->regmap, TX_SYS5_TX_SOFT_RESET_2,
+		     TX_SYS5_TX_SOFT_RESET_2_HDMI_CH2_RST_IN |
+		     TX_SYS5_TX_SOFT_RESET_2_HDMI_CH1_RST_IN |
+		     TX_SYS5_TX_SOFT_RESET_2_HDMI_SR_RST);
+	usleep_range(10, 20);
+
+	regmap_write(priv->regmap, TX_SYS5_TX_SOFT_RESET_2,
+		     TX_SYS5_TX_SOFT_RESET_2_HDMI_CH2_RST_IN |
+		     TX_SYS5_TX_SOFT_RESET_2_HDMI_CH1_RST_IN);
+	usleep_range(10, 20);
+}
+
+static void meson_txc_hdmi_config_hdcp_registers(struct meson_txc_hdmi *priv)
+{
+	regmap_write(priv->regmap, TX_HDCP_CONFIG0,
+		     FIELD_PREP(TX_HDCP_CONFIG0_ROM_ENCRYPT_OFF, 0x3));
+	regmap_write(priv->regmap, TX_HDCP_MEM_CONFIG, 0x0);
+	regmap_write(priv->regmap, TX_HDCP_ENCRYPT_BYTE, 0x0);
+
+	regmap_write(priv->regmap, TX_HDCP_MODE, TX_HDCP_MODE_CLEAR_AVMUTE);
+
+	regmap_write(priv->regmap, TX_HDCP_MODE, TX_HDCP_MODE_ESS_CONFIG);
+}
+
+static u8 meson_txc_hdmi_bus_fmt_to_color_depth(unsigned int bus_format)
+{
+	switch (bus_format) {
+	case MEDIA_BUS_FMT_RGB888_1X24:
+	case MEDIA_BUS_FMT_YUV8_1X24:
+	case MEDIA_BUS_FMT_UYVY8_1X16:
+		/* 8 bit */
+		return 0x0;
+
+	case MEDIA_BUS_FMT_RGB101010_1X30:
+	case MEDIA_BUS_FMT_YUV10_1X30:
+	case MEDIA_BUS_FMT_UYVY10_1X20:
+		/* 10 bit */
+		return 0x1;
+
+	case MEDIA_BUS_FMT_RGB121212_1X36:
+	case MEDIA_BUS_FMT_YUV12_1X36:
+	case MEDIA_BUS_FMT_UYVY12_1X24:
+		/* 12 bit */
+		return 0x2;
+
+	case MEDIA_BUS_FMT_RGB161616_1X48:
+	case MEDIA_BUS_FMT_YUV16_1X48:
+		/* 16 bit */
+		return 0x3;
+
+	default:
+		/* unknown, default to 8 bit */
+		return 0x0;
+	}
+}
+
+static enum hdmi_colorspace
+meson_txc_hdmi_bus_fmt_hdmi_colorspace(unsigned int bus_format)
+{
+	switch (bus_format) {
+	case MEDIA_BUS_FMT_YUV8_1X24:
+	case MEDIA_BUS_FMT_YUV10_1X30:
+	case MEDIA_BUS_FMT_YUV12_1X36:
+	case MEDIA_BUS_FMT_YUV16_1X48:
+		return HDMI_COLORSPACE_YUV444;
+
+	case MEDIA_BUS_FMT_UYVY8_1X16:
+	case MEDIA_BUS_FMT_UYVY10_1X20:
+	case MEDIA_BUS_FMT_UYVY12_1X24:
+		return HDMI_COLORSPACE_YUV422;
+
+	case MEDIA_BUS_FMT_RGB888_1X24:
+	case MEDIA_BUS_FMT_RGB101010_1X30:
+	case MEDIA_BUS_FMT_RGB121212_1X36:
+	case MEDIA_BUS_FMT_RGB161616_1X48:
+	default:
+		return HDMI_COLORSPACE_RGB;
+	}
+}
+
+static u8 meson_txc_hdmi_bus_fmt_to_color_format(unsigned int bus_format)
+{
+	switch (meson_txc_hdmi_bus_fmt_hdmi_colorspace(bus_format)) {
+	case HDMI_COLORSPACE_YUV422:
+		/* Documented as YCbCr422 */
+		return 0x3;
+
+	case HDMI_COLORSPACE_YUV444:
+		/* Documented as YCbCr444 */
+		return 0x1;
+
+	case HDMI_COLORSPACE_RGB:
+	default:
+		/* Documented as RGB444 */
+		return 0x0;
+	}
+}
+
+static void meson_txc_hdmi_config_color_space(struct meson_txc_hdmi *priv,
+					      enum hdmi_quantization_range quant_range,
+					      enum hdmi_colorimetry colorimetry)
+{
+	unsigned int regval;
+
+	regmap_write(priv->regmap, TX_VIDEO_DTV_MODE,
+		     FIELD_PREP(TX_VIDEO_DTV_MODE_COLOR_DEPTH,
+				meson_txc_hdmi_bus_fmt_to_color_depth(priv->output_bus_format)));
+
+	regmap_write(priv->regmap, TX_VIDEO_DTV_OPTION_L,
+		     FIELD_PREP(TX_VIDEO_DTV_OPTION_L_OUTPUT_COLOR_FORMAT,
+				meson_txc_hdmi_bus_fmt_to_color_format(priv->output_bus_format)) |
+		     FIELD_PREP(TX_VIDEO_DTV_OPTION_L_INPUT_COLOR_FORMAT,
+				meson_txc_hdmi_bus_fmt_to_color_format(priv->input_bus_format)) |
+		     FIELD_PREP(TX_VIDEO_DTV_OPTION_L_OUTPUT_COLOR_DEPTH,
+				meson_txc_hdmi_bus_fmt_to_color_depth(priv->output_bus_format)) |
+		     FIELD_PREP(TX_VIDEO_DTV_OPTION_L_INPUT_COLOR_DEPTH,
+				meson_txc_hdmi_bus_fmt_to_color_depth(priv->input_bus_format)));
+
+	if (quant_range == HDMI_QUANTIZATION_RANGE_LIMITED)
+		regval = FIELD_PREP(TX_VIDEO_DTV_OPTION_H_OUTPUT_COLOR_RANGE,
+				    TX_VIDEO_DTV_OPTION_H_COLOR_RANGE_16_235) |
+			 FIELD_PREP(TX_VIDEO_DTV_OPTION_H_INPUT_COLOR_RANGE,
+				    TX_VIDEO_DTV_OPTION_H_COLOR_RANGE_16_235);
+	else
+		regval = FIELD_PREP(TX_VIDEO_DTV_OPTION_H_OUTPUT_COLOR_RANGE,
+				    TX_VIDEO_DTV_OPTION_H_COLOR_RANGE_0_255) |
+			 FIELD_PREP(TX_VIDEO_DTV_OPTION_H_INPUT_COLOR_RANGE,
+				    TX_VIDEO_DTV_OPTION_H_COLOR_RANGE_0_255);
+
+	regmap_write(priv->regmap, TX_VIDEO_DTV_OPTION_H, regval);
+
+	if (colorimetry == HDMI_COLORIMETRY_ITU_601) {
+		regmap_write(priv->regmap, TX_VIDEO_CSC_COEFF_B0, 0x2f);
+		regmap_write(priv->regmap, TX_VIDEO_CSC_COEFF_B1, 0x1d);
+		regmap_write(priv->regmap, TX_VIDEO_CSC_COEFF_R0, 0x8b);
+		regmap_write(priv->regmap, TX_VIDEO_CSC_COEFF_R1, 0x4c);
+
+		regmap_write(priv->regmap, TX_VIDEO_CSC_COEFF_CB0, 0x18);
+		regmap_write(priv->regmap, TX_VIDEO_CSC_COEFF_CB1, 0x58);
+		regmap_write(priv->regmap, TX_VIDEO_CSC_COEFF_CR0, 0xd0);
+		regmap_write(priv->regmap, TX_VIDEO_CSC_COEFF_CR1, 0xb6);
+	} else {
+		regmap_write(priv->regmap, TX_VIDEO_CSC_COEFF_B0, 0x7b);
+		regmap_write(priv->regmap, TX_VIDEO_CSC_COEFF_B1, 0x12);
+		regmap_write(priv->regmap, TX_VIDEO_CSC_COEFF_R0, 0x6c);
+		regmap_write(priv->regmap, TX_VIDEO_CSC_COEFF_R1, 0x36);
+
+		regmap_write(priv->regmap, TX_VIDEO_CSC_COEFF_CB0, 0xf2);
+		regmap_write(priv->regmap, TX_VIDEO_CSC_COEFF_CB1, 0x2f);
+		regmap_write(priv->regmap, TX_VIDEO_CSC_COEFF_CR0, 0xd4);
+		regmap_write(priv->regmap, TX_VIDEO_CSC_COEFF_CR1, 0x77);
+	}
+}
+
+/*
+ * FIXME - questions for CDNS team:
+ * - what is the name of the 0x0018 register?
+ * - what do BIT(1), BIT(2), BIT(4) and BIT(5) mean?
+ * - if it's not clear from the names of these bits: when to set each of them?
+ *   (below code depends on the HDMI_COLORIMETRY and one special case also on
+ *    the color depth and a special HDMI VIC)
+ */
+static void meson_txc_hdmi_config_serializer_clock(struct meson_txc_hdmi *priv,
+						   enum hdmi_colorimetry colorimetry)
+{
+	/* Serializer Internal clock setting */
+	if (colorimetry == HDMI_COLORIMETRY_ITU_601)
+		regmap_write(priv->regmap, 0x0018, 0x24);
+	else
+		regmap_write(priv->regmap, 0x0018, 0x22);
+
+#if 0
+	// TODO: not ported yet
+	if ((param->VIC==HDMI_1080p60)&&(param->color_depth==COLOR_30BIT)&&(hdmi_rd_reg(0x018)==0x22)) {
+		regmap_write(priv->regmap, 0x0018, 0x12);
+	}
+#endif
+}
+
+static void meson_txc_hdmi_reconfig_packet_setting(struct meson_txc_hdmi *priv,
+						   u8 cea_mode)
+{
+	u8 alloc_active2, alloc_eof1, alloc_sof1, alloc_sof2;
+
+	regmap_write(priv->regmap, TX_PACKET_CONTROL_1,
+		     FIELD_PREP(TX_PACKET_CONTROL_1_PACKET_START_LATENCY, 58));
+	regmap_write(priv->regmap, TX_PACKET_CONTROL_2,
+		     TX_PACKET_CONTROL_2_HORIZONTAL_GC_PACKET_TRANSPORT_EN);
+
+	switch (cea_mode) {
+	case 31:
+		/* 1920x1080p50 */
+		alloc_active2 = 0x12;
+		alloc_eof1 = 0x10;
+		alloc_sof1 = 0xb6;
+		alloc_sof2 = 0x11;
+		break;
+	case 93:
+		/* 3840x2160p24 */
+		alloc_active2 = 0x12;
+		alloc_eof1 = 0x47;
+		alloc_sof1 = 0xf8;
+		alloc_sof2 = 0x52;
+		break;
+	case 94:
+		/* 3840x2160p25 */
+		alloc_active2 = 0x12;
+		alloc_eof1 = 0x44;
+		alloc_sof1 = 0xda;
+		alloc_sof2 = 0x52;
+		break;
+	case 95:
+		/* 3840x2160p30 */
+		alloc_active2 = 0x0f;
+		alloc_eof1 = 0x3a;
+		alloc_sof1 = 0x60;
+		alloc_sof2 = 0x52;
+		break;
+	case 98:
+		/* 4096x2160p24 */
+		alloc_active2 = 0x12;
+		alloc_eof1 = 0x47;
+		alloc_sof1 = 0xf8;
+		alloc_sof2 = 0x52;
+		break;
+	default:
+		/* Disable the special packet settings only */
+		regmap_write(priv->regmap, TX_PACKET_ALLOC_ACTIVE_1, 0x00);
+		return;
+	}
+
+	/*
+	 * The vendor driver says: manually configure these register to get
+	 * stable video timings.
+	 */
+	regmap_write(priv->regmap, TX_PACKET_ALLOC_ACTIVE_1, 0x01);
+	regmap_write(priv->regmap, TX_PACKET_ALLOC_ACTIVE_2, alloc_active2);
+	regmap_write(priv->regmap, TX_PACKET_ALLOC_EOF_1, alloc_eof1);
+	regmap_write(priv->regmap, TX_PACKET_ALLOC_EOF_2, 0x12);
+	regmap_write(priv->regmap, TX_CORE_ALLOC_VSYNC_0, 0x01);
+	regmap_write(priv->regmap, TX_CORE_ALLOC_VSYNC_1, 0x00);
+	regmap_write(priv->regmap, TX_CORE_ALLOC_VSYNC_2, 0x0a);
+	regmap_write(priv->regmap, TX_PACKET_ALLOC_SOF_1, alloc_sof1);
+	regmap_write(priv->regmap, TX_PACKET_ALLOC_SOF_2, alloc_sof2);
+	regmap_update_bits(priv->regmap, TX_PACKET_CONTROL_1,
+			   TX_PACKET_CONTROL_1_FORCE_PACKET_TIMING,
+			   TX_PACKET_CONTROL_1_FORCE_PACKET_TIMING);
+}
+
+static void meson_txc_hdmi_set_avi_infoframe(struct meson_txc_hdmi *priv,
+					     struct drm_connector *conn,
+					     const struct drm_display_mode *mode,
+					     enum hdmi_quantization_range quant_range,
+					     enum hdmi_colorimetry colorimetry)
+{
+	u8 buf[HDMI_INFOFRAME_SIZE(AVI)], *video_code;
+	struct hdmi_avi_infoframe frame;
+	int ret;
+
+	ret = drm_hdmi_avi_infoframe_from_display_mode(&frame, conn, mode);
+	if (ret < 0) {
+		drm_err(priv->bridge.dev,
+			"Failed to setup AVI infoframe: %d\n", ret);
+		return;
+	}
+
+	/* fixed infoframe configuration not linked to the mode */
+	frame.colorspace = meson_txc_hdmi_bus_fmt_hdmi_colorspace(priv->output_bus_format);
+	frame.colorimetry = colorimetry;
+
+	drm_hdmi_avi_infoframe_quant_range(&frame, conn, mode, quant_range);
+
+	ret = hdmi_avi_infoframe_pack(&frame, buf, sizeof(buf));
+	if (ret < 0) {
+		drm_err(priv->bridge.dev,
+			"Failed to pack AVI infoframe: %d\n", ret);
+		return;
+	}
+
+	video_code = &buf[HDMI_INFOFRAME_HEADER_SIZE + 3];
+	if (*video_code > 108) {
+		regmap_write(priv->regmap, TX_PKT_REG_EXCEPT0_BASE_ADDR,
+			     *video_code);
+		*video_code = 0x00;
+	} else {
+		regmap_write(priv->regmap, TX_PKT_REG_EXCEPT0_BASE_ADDR,
+			     0x00);
+	}
+
+	meson_txc_hdmi_write_infoframe(priv->regmap,
+				       TX_PKT_REG_AVI_INFO_BASE_ADDR, buf,
+				       sizeof(buf), true);
+}
+
+static void meson_txc_hdmi_set_vendor_infoframe(struct meson_txc_hdmi *priv,
+						struct drm_connector *conn,
+						const struct drm_display_mode *mode)
+{
+	u8 buf[HDMI_INFOFRAME_HEADER_SIZE + 6];
+	struct hdmi_vendor_infoframe frame;
+	int ret;
+
+	ret = drm_hdmi_vendor_infoframe_from_display_mode(&frame, conn, mode);
+	if (ret) {
+		drm_dbg(priv->bridge.dev,
+			"Failed to setup vendor infoframe: %d\n", ret);
+		return;
+	}
+
+	ret = hdmi_vendor_infoframe_pack(&frame, buf, sizeof(buf));
+	if (ret < 0) {
+		drm_err(priv->bridge.dev,
+			"Failed to pack vendor infoframe: %d\n", ret);
+		return;
+	}
+
+	meson_txc_hdmi_write_infoframe(priv->regmap,
+				       TX_PKT_REG_VEND_INFO_BASE_ADDR, buf,
+				       sizeof(buf), true);
+}
+
+static void meson_txc_hdmi_set_spd_infoframe(struct meson_txc_hdmi *priv)
+{
+	u8 buf[HDMI_INFOFRAME_SIZE(SPD)];
+	struct hdmi_spd_infoframe frame;
+	int ret;
+
+	ret = hdmi_spd_infoframe_init(&frame, "Amlogic", "Meson TXC HDMI");
+	if (ret < 0) {
+		drm_err(priv->bridge.dev,
+			"Failed to setup SPD infoframe: %d\n", ret);
+		return;
+	}
+
+	ret = hdmi_spd_infoframe_pack(&frame, buf, sizeof(buf));
+	if (ret < 0) {
+		drm_err(priv->bridge.dev,
+			"Failed to pack SDP infoframe: %d\n", ret);
+		return;
+	}
+
+	meson_txc_hdmi_write_infoframe(priv->regmap,
+				       TX_PKT_REG_SPD_INFO_BASE_ADDR, buf,
+				       sizeof(buf), true);
+}
+
+static void meson_txc_hdmi_handle_plugged_change(struct meson_txc_hdmi *priv)
+{
+	bool plugged;
+
+	plugged = priv->last_connector_status == connector_status_connected;
+
+	if (priv->codec_dev && priv->codec_plugged_cb)
+		priv->codec_plugged_cb(priv->codec_dev, plugged);
+}
+
+static int meson_txc_hdmi_bridge_attach(struct drm_bridge *bridge,
+					enum drm_bridge_attach_flags flags)
+{
+	struct meson_txc_hdmi *priv = bridge->driver_private;
+
+	if (!(flags & DRM_BRIDGE_ATTACH_NO_CONNECTOR)) {
+		drm_err(bridge->dev,
+			"DRM_BRIDGE_ATTACH_NO_CONNECTOR flag is not set but needed\n");
+		return -EINVAL;
+	}
+
+	return drm_bridge_attach(bridge->encoder, priv->next_bridge, bridge,
+				 flags);
+}
+
+static int meson_txc_hdmi_bridge_atomic_check(struct drm_bridge *bridge,
+					      struct drm_bridge_state *bridge_state,
+					      struct drm_crtc_state *crtc_state,
+					      struct drm_connector_state *conn_state)
+{
+	struct meson_txc_hdmi *priv = bridge->driver_private;
+
+	priv->output_bus_format = bridge_state->output_bus_cfg.format;
+	priv->input_bus_format = bridge_state->input_bus_cfg.format;
+
+	drm_dbg(bridge->dev, "input format 0x%04x, output format 0x%04x\n",
+		priv->input_bus_format, priv->output_bus_format);
+
+	return 0;
+}
+
+/* Can return a maximum of 11 possible output formats for a mode/connector */
+#define MAX_OUTPUT_SEL_FORMATS	11
+
+static u32 *
+meson_txc_hdmi_bridge_atomic_get_output_bus_fmts(struct drm_bridge *bridge,
+						 struct drm_bridge_state *bridge_state,
+						 struct drm_crtc_state *crtc_state,
+						 struct drm_connector_state *conn_state,
+						 unsigned int *num_output_fmts)
+{
+	struct drm_connector *conn = conn_state->connector;
+	struct drm_display_info *info = &conn->display_info;
+	u8 max_bpc = conn_state->max_requested_bpc;
+	unsigned int i = 0;
+	u32 *output_fmts;
+
+	*num_output_fmts = 0;
+
+	output_fmts = kcalloc(MAX_OUTPUT_SEL_FORMATS, sizeof(*output_fmts),
+			      GFP_KERNEL);
+	if (!output_fmts)
+		return NULL;
+
+	/* If we are the only bridge, avoid negotiating with ourselves */
+	if (list_is_singular(&bridge->encoder->bridge_chain)) {
+		*num_output_fmts = 1;
+		output_fmts[0] = MEDIA_BUS_FMT_FIXED;
+
+		return output_fmts;
+	}
+
+	/*
+	 * Order bus formats from 16bit to 8bit and from YUV422 to RGB
+	 * if supported. In any case the default RGB888 format is added
+	 */
+
+	if (max_bpc >= 16 && info->bpc == 16) {
+		if (info->color_formats & DRM_COLOR_FORMAT_YCRCB444)
+			output_fmts[i++] = MEDIA_BUS_FMT_YUV16_1X48;
+
+		output_fmts[i++] = MEDIA_BUS_FMT_RGB161616_1X48;
+	}
+
+	if (max_bpc >= 12 && info->bpc >= 12) {
+		if (info->color_formats & DRM_COLOR_FORMAT_YCRCB422)
+			output_fmts[i++] = MEDIA_BUS_FMT_UYVY12_1X24;
+
+		if (info->color_formats & DRM_COLOR_FORMAT_YCRCB444)
+			output_fmts[i++] = MEDIA_BUS_FMT_YUV12_1X36;
+
+		output_fmts[i++] = MEDIA_BUS_FMT_RGB121212_1X36;
+	}
+
+	if (max_bpc >= 10 && info->bpc >= 10) {
+		if (info->color_formats & DRM_COLOR_FORMAT_YCRCB422)
+			output_fmts[i++] = MEDIA_BUS_FMT_UYVY10_1X20;
+
+		if (info->color_formats & DRM_COLOR_FORMAT_YCRCB444)
+			output_fmts[i++] = MEDIA_BUS_FMT_YUV10_1X30;
+
+		output_fmts[i++] = MEDIA_BUS_FMT_RGB101010_1X30;
+	}
+
+	if (info->color_formats & DRM_COLOR_FORMAT_YCRCB422)
+		output_fmts[i++] = MEDIA_BUS_FMT_UYVY8_1X16;
+
+	if (info->color_formats & DRM_COLOR_FORMAT_YCRCB444)
+		output_fmts[i++] = MEDIA_BUS_FMT_YUV8_1X24;
+
+	/* Default 8bit RGB fallback */
+	output_fmts[i++] = MEDIA_BUS_FMT_RGB888_1X24;
+
+	*num_output_fmts = i;
+
+	return output_fmts;
+}
+
+/* Can return a maximum of 3 possible input formats for an output format */
+#define MAX_INPUT_SEL_FORMATS	3
+
+static u32 *
+meson_txc_hdmi_bridge_atomic_get_input_bus_fmts(struct drm_bridge *bridge,
+						struct drm_bridge_state *bridge_state,
+						struct drm_crtc_state *crtc_state,
+						struct drm_connector_state *conn_state,
+						u32 output_fmt,
+						unsigned int *num_input_fmts)
+{
+	u32 *input_fmts;
+	unsigned int i = 0;
+
+	*num_input_fmts = 0;
+
+	input_fmts = kcalloc(MAX_INPUT_SEL_FORMATS, sizeof(*input_fmts),
+			     GFP_KERNEL);
+	if (!input_fmts)
+		return NULL;
+
+	switch (output_fmt) {
+	/* If MEDIA_BUS_FMT_FIXED is tested, return default bus format */
+	case MEDIA_BUS_FMT_FIXED:
+		input_fmts[i++] = MEDIA_BUS_FMT_RGB888_1X24;
+		break;
+
+	/* 8bit */
+	case MEDIA_BUS_FMT_RGB888_1X24:
+		input_fmts[i++] = MEDIA_BUS_FMT_RGB888_1X24;
+		input_fmts[i++] = MEDIA_BUS_FMT_YUV8_1X24;
+		input_fmts[i++] = MEDIA_BUS_FMT_UYVY8_1X16;
+		break;
+	case MEDIA_BUS_FMT_YUV8_1X24:
+		input_fmts[i++] = MEDIA_BUS_FMT_YUV8_1X24;
+		input_fmts[i++] = MEDIA_BUS_FMT_UYVY8_1X16;
+		input_fmts[i++] = MEDIA_BUS_FMT_RGB888_1X24;
+		break;
+	case MEDIA_BUS_FMT_UYVY8_1X16:
+		input_fmts[i++] = MEDIA_BUS_FMT_UYVY8_1X16;
+		input_fmts[i++] = MEDIA_BUS_FMT_YUV8_1X24;
+		input_fmts[i++] = MEDIA_BUS_FMT_RGB888_1X24;
+		break;
+
+	/* 10bit */
+	case MEDIA_BUS_FMT_RGB101010_1X30:
+		input_fmts[i++] = MEDIA_BUS_FMT_RGB101010_1X30;
+		input_fmts[i++] = MEDIA_BUS_FMT_YUV10_1X30;
+		input_fmts[i++] = MEDIA_BUS_FMT_UYVY10_1X20;
+		break;
+	case MEDIA_BUS_FMT_YUV10_1X30:
+		input_fmts[i++] = MEDIA_BUS_FMT_YUV10_1X30;
+		input_fmts[i++] = MEDIA_BUS_FMT_UYVY10_1X20;
+		input_fmts[i++] = MEDIA_BUS_FMT_RGB101010_1X30;
+		break;
+	case MEDIA_BUS_FMT_UYVY10_1X20:
+		input_fmts[i++] = MEDIA_BUS_FMT_UYVY10_1X20;
+		input_fmts[i++] = MEDIA_BUS_FMT_YUV10_1X30;
+		input_fmts[i++] = MEDIA_BUS_FMT_RGB101010_1X30;
+		break;
+
+	/* 12bit */
+	case MEDIA_BUS_FMT_RGB121212_1X36:
+		input_fmts[i++] = MEDIA_BUS_FMT_RGB121212_1X36;
+		input_fmts[i++] = MEDIA_BUS_FMT_YUV12_1X36;
+		input_fmts[i++] = MEDIA_BUS_FMT_UYVY12_1X24;
+		break;
+	case MEDIA_BUS_FMT_YUV12_1X36:
+		input_fmts[i++] = MEDIA_BUS_FMT_YUV12_1X36;
+		input_fmts[i++] = MEDIA_BUS_FMT_UYVY12_1X24;
+		input_fmts[i++] = MEDIA_BUS_FMT_RGB121212_1X36;
+		break;
+	case MEDIA_BUS_FMT_UYVY12_1X24:
+		input_fmts[i++] = MEDIA_BUS_FMT_UYVY12_1X24;
+		input_fmts[i++] = MEDIA_BUS_FMT_YUV12_1X36;
+		input_fmts[i++] = MEDIA_BUS_FMT_RGB121212_1X36;
+		break;
+
+	/* 16bit */
+	case MEDIA_BUS_FMT_RGB161616_1X48:
+		input_fmts[i++] = MEDIA_BUS_FMT_RGB161616_1X48;
+		input_fmts[i++] = MEDIA_BUS_FMT_YUV16_1X48;
+		break;
+	case MEDIA_BUS_FMT_YUV16_1X48:
+		input_fmts[i++] = MEDIA_BUS_FMT_YUV16_1X48;
+		input_fmts[i++] = MEDIA_BUS_FMT_RGB161616_1X48;
+		break;
+	}
+
+	*num_input_fmts = i;
+
+	if (*num_input_fmts == 0) {
+		kfree(input_fmts);
+		input_fmts = NULL;
+	}
+
+	return input_fmts;
+}
+
+static void meson_txc_hdmi_bridge_atomic_enable(struct drm_bridge *bridge,
+						struct drm_bridge_state *bridge_state)
+{
+	struct meson_txc_hdmi *priv = bridge_to_meson_txc_hdmi(bridge);
+	struct drm_atomic_state *state = bridge_state->base.state;
+	enum hdmi_quantization_range quant_range;
+	struct drm_connector_state *conn_state;
+	const struct drm_display_mode *mode;
+	enum hdmi_colorimetry colorimetry;
+	struct drm_crtc_state *crtc_state;
+	struct drm_connector *connector;
+	unsigned int i;
+	u8 cea_mode;
+
+	connector = drm_atomic_get_new_connector_for_encoder(state,
+							     bridge->encoder);
+	if (WARN_ON(!connector))
+		return;
+
+	conn_state = drm_atomic_get_new_connector_state(state, connector);
+	if (WARN_ON(!conn_state))
+		return;
+
+	crtc_state = drm_atomic_get_new_crtc_state(state, conn_state->crtc);
+	if (WARN_ON(!crtc_state))
+		return;
+
+	mode = &crtc_state->adjusted_mode;
+
+	memcpy(connector->eld, priv->eld, MAX_ELD_BYTES);
+
+	if (priv->input_bus_format == MEDIA_BUS_FMT_FIXED)
+		priv->input_bus_format = MEDIA_BUS_FMT_RGB888_1X24;
+
+	cea_mode = drm_match_cea_mode(mode);
+
+	if (priv->sink_is_hdmi) {
+		quant_range = drm_default_rgb_quant_range(mode);
+
+		switch (cea_mode) {
+		case 2 ... 3:
+		case 6 ... 7:
+		case 17 ... 18:
+		case 21 ... 22:
+			colorimetry = HDMI_COLORIMETRY_ITU_601;
+			break;
+
+		default:
+			colorimetry = HDMI_COLORIMETRY_ITU_709;
+			break;
+		}
+
+		meson_txc_hdmi_set_avi_infoframe(priv, connector, mode,
+						 quant_range, colorimetry);
+		meson_txc_hdmi_set_vendor_infoframe(priv, connector, mode);
+		meson_txc_hdmi_set_spd_infoframe(priv);
+	} else {
+		quant_range = HDMI_QUANTIZATION_RANGE_FULL;
+		colorimetry = HDMI_COLORIMETRY_NONE;
+	}
+
+	meson_txc_hdmi_sys5_reset_assert(priv);
+
+	meson_txc_hdmi_config_hdcp_registers(priv);
+
+	if (cea_mode == 39)
+		regmap_write(priv->regmap, TX_VIDEO_DTV_TIMING, 0x0);
+	else
+		regmap_write(priv->regmap, TX_VIDEO_DTV_TIMING,
+			     TX_VIDEO_DTV_TIMING_DISABLE_VIC39_CORRECTION);
+
+	regmap_write(priv->regmap, TX_CORE_DATA_CAPTURE_2,
+		     TX_CORE_DATA_CAPTURE_2_INTERNAL_PACKET_ENABLE);
+	regmap_write(priv->regmap, TX_CORE_DATA_MONITOR_1,
+		     TX_CORE_DATA_MONITOR_1_LANE0 |
+		     FIELD_PREP(TX_CORE_DATA_MONITOR_1_SELECT_LANE0, 0x7));
+	regmap_write(priv->regmap, TX_CORE_DATA_MONITOR_2,
+		     FIELD_PREP(TX_CORE_DATA_MONITOR_2_MONITOR_SELECT, 0x2));
+
+	if (priv->sink_is_hdmi)
+		regmap_write(priv->regmap, TX_TMDS_MODE,
+			     TX_TMDS_MODE_FORCED_HDMI |
+			     TX_TMDS_MODE_HDMI_CONFIG);
+	else
+		regmap_write(priv->regmap, TX_TMDS_MODE,
+			     TX_TMDS_MODE_FORCED_HDMI);
+
+	regmap_write(priv->regmap, TX_SYS4_CONNECT_SEL_1, 0x0);
+
+	/*
+	 * Set tmds_clk pattern to be "0000011111" before being sent to AFE
+	 * clock channel.
+	 */
+	regmap_write(priv->regmap, TX_SYS4_CK_INV_VIDEO,
+		     TX_SYS4_CK_INV_VIDEO_TMDS_CLK_PATTERN);
+
+	regmap_write(priv->regmap, TX_SYS5_FIFO_CONFIG,
+		     TX_SYS5_FIFO_CONFIG_CLK_CHANNEL3_OUTPUT_ENABLE |
+		     TX_SYS5_FIFO_CONFIG_AFE_FIFO_CHANNEL2_ENABLE |
+		     TX_SYS5_FIFO_CONFIG_AFE_FIFO_CHANNEL1_ENABLE |
+		     TX_SYS5_FIFO_CONFIG_AFE_FIFO_CHANNEL0_ENABLE);
+
+	meson_txc_hdmi_config_color_space(priv, quant_range, colorimetry);
+
+	meson_txc_hdmi_sys5_reset_deassert(priv);
+
+	meson_txc_hdmi_config_serializer_clock(priv, colorimetry);
+	meson_txc_hdmi_reconfig_packet_setting(priv, cea_mode);
+
+	/* all resets need to be applied twice */
+	for (i = 0; i < 2; i++) {
+		regmap_write(priv->regmap, TX_SYS5_TX_SOFT_RESET_1,
+			     TX_SYS5_TX_SOFT_RESET_1_TX_PIXEL_RSTN |
+			     TX_SYS5_TX_SOFT_RESET_1_TX_TMDS_RSTN |
+			     TX_SYS5_TX_SOFT_RESET_1_TX_AUDIO_MASTER_RSTN |
+			     TX_SYS5_TX_SOFT_RESET_1_TX_AUDIO_RESAMPLE_RSTN |
+			     TX_SYS5_TX_SOFT_RESET_1_TX_I2S_RESET_RSTN |
+			     TX_SYS5_TX_SOFT_RESET_1_TX_DIG_RESET_N_CH2 |
+			     TX_SYS5_TX_SOFT_RESET_1_TX_DIG_RESET_N_CH1 |
+			     TX_SYS5_TX_SOFT_RESET_1_TX_DIG_RESET_N_CH0);
+		regmap_write(priv->regmap, TX_SYS5_TX_SOFT_RESET_2,
+			     TX_SYS5_TX_SOFT_RESET_2_HDMI_CH3_RST_IN |
+			     TX_SYS5_TX_SOFT_RESET_2_HDMI_CH2_RST_IN |
+			     TX_SYS5_TX_SOFT_RESET_2_HDMI_CH1_RST_IN |
+			     TX_SYS5_TX_SOFT_RESET_2_HDMI_CH0_RST_IN |
+			     TX_SYS5_TX_SOFT_RESET_2_HDMI_SR_RST |
+			     TX_SYS5_TX_SOFT_RESET_2_TX_DDC_HDCP_RSTN |
+			     TX_SYS5_TX_SOFT_RESET_2_TX_DDC_EDID_RSTN |
+			     TX_SYS5_TX_SOFT_RESET_2_TX_DIG_RESET_N_CH3);
+		usleep_range(5000, 10000);
+		regmap_write(priv->regmap, TX_SYS5_TX_SOFT_RESET_1, 0x00);
+		regmap_write(priv->regmap, TX_SYS5_TX_SOFT_RESET_2, 0x00);
+		usleep_range(5000, 10000);
+	}
+
+	if (!priv->phy_is_on) {
+		int ret;
+
+		ret = phy_power_on(priv->phy);
+		if (ret)
+			drm_err(bridge->dev, "Failed to turn on PHY\n");
+		else
+			priv->phy_is_on = true;
+	}
+}
+
+static void meson_txc_hdmi_bridge_atomic_disable(struct drm_bridge *bridge,
+						 struct drm_bridge_state *bridge_state)
+{
+	struct meson_txc_hdmi *priv = bridge_to_meson_txc_hdmi(bridge);
+
+	if (priv->phy_is_on) {
+		int ret;
+
+		ret = phy_power_off(priv->phy);
+		if (ret)
+			drm_err(bridge->dev, "Failed to turn off PHY\n");
+		else
+			priv->phy_is_on = false;
+	}
+
+	meson_txc_hdmi_disable_infoframe(priv, TX_PKT_REG_AUDIO_INFO_BASE_ADDR);
+	meson_txc_hdmi_disable_infoframe(priv, TX_PKT_REG_AVI_INFO_BASE_ADDR);
+	meson_txc_hdmi_disable_infoframe(priv, TX_PKT_REG_EXCEPT0_BASE_ADDR);
+	meson_txc_hdmi_disable_infoframe(priv, TX_PKT_REG_VEND_INFO_BASE_ADDR);
+
+	memset(priv->eld, 0, MAX_ELD_BYTES);
+}
+
+static enum drm_mode_status
+meson_txc_hdmi_bridge_mode_valid(struct drm_bridge *bridge,
+				 const struct drm_display_info *info,
+				 const struct drm_display_mode *mode)
+{
+	return MODE_OK;
+}
+
+static enum drm_connector_status meson_txc_hdmi_bridge_detect(struct drm_bridge *bridge)
+{
+	struct meson_txc_hdmi *priv = bridge_to_meson_txc_hdmi(bridge);
+	enum drm_connector_status status;
+	unsigned int val;
+
+	regmap_read(priv->regmap, TX_HDCP_ST_EDID_STATUS, &val);
+	if (val & TX_HDCP_ST_EDID_STATUS_HPD_STATUS)
+		status = connector_status_connected;
+	else
+		status = connector_status_disconnected;
+
+	mutex_lock(&priv->codec_mutex);
+	if (priv->last_connector_status != status) {
+		priv->last_connector_status = status;
+		meson_txc_hdmi_handle_plugged_change(priv);
+	}
+	mutex_unlock(&priv->codec_mutex);
+
+	return status;
+}
+
+static int meson_txc_hdmi_get_edid_block(void *data, u8 *buf, unsigned int block,
+					 size_t len)
+{
+	unsigned int i, regval, start = block * EDID_LENGTH;
+	struct meson_txc_hdmi *priv = data;
+	int ret;
+
+	/* Start the DDC transaction */
+	regmap_update_bits(priv->regmap, TX_HDCP_EDID_CONFIG,
+			   TX_HDCP_EDID_CONFIG_SYS_TRIGGER_CONFIG, 0);
+	regmap_update_bits(priv->regmap, TX_HDCP_EDID_CONFIG,
+			   TX_HDCP_EDID_CONFIG_SYS_TRIGGER_CONFIG,
+			   TX_HDCP_EDID_CONFIG_SYS_TRIGGER_CONFIG);
+
+	ret = regmap_read_poll_timeout(priv->regmap,
+				       TX_HDCP_ST_EDID_STATUS,
+				       regval,
+				       (regval & TX_HDCP_ST_EDID_STATUS_EDID_DATA_READY),
+				       1000, 200000);
+
+	regmap_update_bits(priv->regmap, TX_HDCP_EDID_CONFIG,
+			   TX_HDCP_EDID_CONFIG_SYS_TRIGGER_CONFIG, 0);
+
+	if (ret)
+		return ret;
+
+	for (i = 0; i < len; i++) {
+		regmap_read(priv->regmap, TX_RX_EDID_OFFSET + start + i,
+			    &regval);
+		buf[i] = regval;
+	}
+
+	return 0;
+}
+
+static struct edid *meson_txc_hdmi_bridge_get_edid(struct drm_bridge *bridge,
+						   struct drm_connector *connector)
+{
+	struct meson_txc_hdmi *priv = bridge_to_meson_txc_hdmi(bridge);
+	struct edid *edid;
+
+	edid = drm_do_get_edid(connector, meson_txc_hdmi_get_edid_block, priv);
+	if (!edid) {
+		drm_dbg(priv->bridge.dev, "Failed to get EDID\n");
+		return NULL;
+	}
+
+	priv->sink_is_hdmi = drm_detect_hdmi_monitor(edid);
+
+	return edid;
+}
+
+static const struct drm_bridge_funcs meson_txc_hdmi_bridge_funcs = {
+	.atomic_duplicate_state = drm_atomic_helper_bridge_duplicate_state,
+	.atomic_destroy_state = drm_atomic_helper_bridge_destroy_state,
+	.atomic_reset = drm_atomic_helper_bridge_reset,
+	.attach = meson_txc_hdmi_bridge_attach,
+	.atomic_check = meson_txc_hdmi_bridge_atomic_check,
+	.atomic_get_output_bus_fmts = meson_txc_hdmi_bridge_atomic_get_output_bus_fmts,
+	.atomic_get_input_bus_fmts = meson_txc_hdmi_bridge_atomic_get_input_bus_fmts,
+	.atomic_enable = meson_txc_hdmi_bridge_atomic_enable,
+	.atomic_disable = meson_txc_hdmi_bridge_atomic_disable,
+	.mode_valid = meson_txc_hdmi_bridge_mode_valid,
+	.detect = meson_txc_hdmi_bridge_detect,
+	.get_edid = meson_txc_hdmi_bridge_get_edid,
+};
+
+static int meson_txc_hdmi_parse_dt(struct meson_txc_hdmi *priv)
+{
+	struct device_node *endpoint, *remote;
+
+	endpoint = of_graph_get_endpoint_by_regs(priv->dev->of_node, 1, -1);
+	if (!endpoint) {
+		dev_err(priv->dev, "Missing endpoint in port@1\n");
+		return -ENODEV;
+	}
+
+	remote = of_graph_get_remote_port_parent(endpoint);
+	of_node_put(endpoint);
+	if (!remote) {
+		dev_err(priv->dev, "Endpoint in port@1 unconnected\n");
+		return -ENODEV;
+	}
+
+	if (!of_device_is_available(remote)) {
+		dev_err(priv->dev, "port@1 remote device is disabled\n");
+		of_node_put(remote);
+		return -ENODEV;
+	}
+
+	priv->next_bridge = of_drm_find_bridge(remote);
+	of_node_put(remote);
+	if (!priv->next_bridge)
+		return -EPROBE_DEFER;
+
+	return 0;
+}
+
+static int meson_txc_hdmi_hw_init(struct meson_txc_hdmi *priv)
+{
+	unsigned long ddc_i2c_bus_clk_hz = 500 * 1000;
+	unsigned long sys_clk_hz = 24 * 1000 * 1000;
+	int ret;
+
+	ret = phy_init(priv->phy);
+	if (ret) {
+		dev_err(priv->dev, "Failed to initialize the PHY: %d\n", ret);
+		return ret;
+	}
+
+	ret = clk_set_rate(priv->sys_clk, sys_clk_hz);
+	if (ret) {
+		dev_err(priv->dev, "Failed to set HDMI system clock to 24MHz\n");
+		goto err_phy_exit;
+	}
+
+	ret = clk_prepare_enable(priv->sys_clk);
+	if (ret) {
+		dev_err(priv->dev, "Failed to enable the sys clk\n");
+		goto err_phy_exit;
+	}
+
+	regmap_update_bits(priv->regmap, HDMI_OTHER_CTRL1,
+			   HDMI_OTHER_CTRL1_POWER_ON,
+			   HDMI_OTHER_CTRL1_POWER_ON);
+
+	/*
+	 * FIXME - questions for CDNS team:
+	 * - what is the name of the 0x0010 register?
+	 * - what do bit [7:0] stand for?
+	 */
+	regmap_write(priv->regmap, 0x0010, 0xff);
+
+	regmap_write(priv->regmap, TX_HDCP_MODE, 0x40);
+
+	/*
+	 * FIXME - questions for CDNS team:
+	 * - what is the name of the 0x0017 register?
+	 * - is there a description for BIT(0), BIT(2), BIT(3) and BIT(4) or
+	 *   are 0x1d and 0x0 the only allowed values?
+	 */
+	/* Band-gap and main-bias. 0x1d = power-up, 0x00 = power-down */
+	regmap_write(priv->regmap, 0x0017, 0x1d);
+
+	meson_txc_hdmi_config_serializer_clock(priv, HDMI_COLORIMETRY_NONE);
+
+	/*
+	 * FIXME - questions for CDNS team:
+	 * - what is the name of the 0x001a register?
+	 * - is there a description for BIT(3), BIT(4), BIT(5), BIT(6) and
+	 *   BIT(7)?
+	 */
+	/*
+	 * bit[2:0]=011: CK channel output TMDS CLOCK
+	 * bit[2:0]=101, ck channel output PHYCLCK
+	 */
+	regmap_write(priv->regmap, 0x001a, 0xfb);
+
+	/* Termination resistor calib value */
+	regmap_write(priv->regmap, TX_CORE_CALIB_VALUE, 0x0f);
+
+	/* HPD glitch filter */
+	regmap_write(priv->regmap, TX_HDCP_HPD_FILTER_L, 0xa0);
+	regmap_write(priv->regmap, TX_HDCP_HPD_FILTER_H, 0xa0);
+
+	/* Disable MEM power-down */
+	regmap_write(priv->regmap, TX_MEM_PD_REG0, 0x0);
+
+	regmap_write(priv->regmap, TX_HDCP_CONFIG3,
+		     FIELD_PREP(TX_HDCP_CONFIG3_DDC_I2C_BUS_CLOCK_TIME_DIVIDER,
+				(sys_clk_hz / ddc_i2c_bus_clk_hz) - 1));
+
+	/* Enable software controlled DDC transaction */
+	regmap_write(priv->regmap, TX_HDCP_EDID_CONFIG,
+		     TX_HDCP_EDID_CONFIG_FORCED_MEM_COPY_DONE |
+		     TX_HDCP_EDID_CONFIG_MEM_COPY_DONE_CONFIG);
+	regmap_write(priv->regmap, TX_CORE_EDID_CONFIG_MORE,
+		     TX_CORE_EDID_CONFIG_MORE_SYS_TRIGGER_CONFIG_SEMI_MANU);
+
+	/* mask (= disable) all interrupts */
+	regmap_write(priv->regmap, HDMI_OTHER_INTR_MASKN, 0x0);
+
+	/* clear any pending interrupt */
+	regmap_write(priv->regmap, HDMI_OTHER_INTR_STAT_CLR,
+		     HDMI_OTHER_INTR_STAT_CLR_EDID_RISING |
+		     HDMI_OTHER_INTR_STAT_CLR_HPD_FALLING |
+		     HDMI_OTHER_INTR_STAT_CLR_HPD_RISING);
+
+	return 0;
+
+err_phy_exit:
+	phy_exit(priv->phy);
+	return 0;
+}
+
+static void meson_txc_hdmi_hw_exit(struct meson_txc_hdmi *priv)
+{
+	int ret;
+
+	/* mask (= disable) all interrupts */
+	regmap_write(priv->regmap, HDMI_OTHER_INTR_MASKN,
+		     HDMI_OTHER_INTR_MASKN_TX_EDID_INT_RISE |
+		     HDMI_OTHER_INTR_MASKN_TX_HPD_INT_FALL |
+		     HDMI_OTHER_INTR_MASKN_TX_HPD_INT_RISE);
+
+	regmap_update_bits(priv->regmap, HDMI_OTHER_CTRL1,
+			   HDMI_OTHER_CTRL1_POWER_ON, 0);
+
+	clk_disable_unprepare(priv->sys_clk);
+
+	ret = phy_exit(priv->phy);
+	if (ret)
+		dev_err(priv->dev, "Failed to exit the PHY: %d\n", ret);
+}
+
+static u32 meson_txc_hdmi_hdmi_codec_calc_audio_n(struct hdmi_codec_params *hparms)
+{
+	u32 audio_n;
+
+	if ((hparms->sample_rate % 44100) == 0)
+		audio_n = (128 * hparms->sample_rate) / 900;
+	else
+		audio_n = (128 * hparms->sample_rate) / 1000;
+
+	if (hparms->cea.coding_type == HDMI_AUDIO_CODING_TYPE_EAC3 ||
+	    hparms->cea.coding_type == HDMI_AUDIO_CODING_TYPE_DTS_HD)
+		audio_n *= 4;
+
+	return audio_n;
+}
+
+static u8 meson_txc_hdmi_hdmi_codec_coding_type(struct hdmi_codec_params *hparms)
+{
+	switch (hparms->cea.coding_type) {
+	case HDMI_AUDIO_CODING_TYPE_MLP:
+		return TX_AUDIO_CONTROL_AUDIO_PACKET_TYPE_HBR_AUDIO_PACKET;
+	case HDMI_AUDIO_CODING_TYPE_DSD:
+		return TX_AUDIO_CONTROL_AUDIO_PACKET_TYPE_ONE_BIT_AUDIO;
+	case HDMI_AUDIO_CODING_TYPE_DST:
+		return TX_AUDIO_CONTROL_AUDIO_PACKET_TYPE_DST_AUDIO_PACKET;
+	default:
+		return TX_AUDIO_CONTROL_AUDIO_PACKET_TYPE_AUDIO_SAMPLE_PACKET;
+	}
+}
+
+static int meson_txc_hdmi_hdmi_codec_hw_params(struct device *dev, void *data,
+					       struct hdmi_codec_daifmt *fmt,
+					       struct hdmi_codec_params *hparms)
+{
+	u8 buf[HDMI_INFOFRAME_SIZE(AUDIO)];
+	struct meson_txc_hdmi *priv = data;
+	u16 audio_tx_format;
+	u32 audio_n;
+	int len, i;
+
+	if (hparms->cea.coding_type == HDMI_AUDIO_CODING_TYPE_MLP) {
+		/*
+		 * TODO: fixed CTS is not supported yet, it needs special
+		 * TX_SYS1_ACR_N_* settings
+		 */
+		return -EINVAL;
+	}
+
+	switch (hparms->sample_width) {
+	case 16:
+		audio_tx_format = FIELD_PREP(TX_AUDIO_FORMAT_BIT_WIDTH_MASK,
+					     TX_AUDIO_FORMAT_BIT_WIDTH_16);
+		break;
+
+	case 20:
+		audio_tx_format = FIELD_PREP(TX_AUDIO_FORMAT_BIT_WIDTH_MASK,
+					     TX_AUDIO_FORMAT_BIT_WIDTH_20);
+		break;
+
+	case 24:
+		audio_tx_format = FIELD_PREP(TX_AUDIO_FORMAT_BIT_WIDTH_MASK,
+					     TX_AUDIO_FORMAT_BIT_WIDTH_24);
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	switch (fmt->fmt) {
+	case HDMI_I2S:
+		regmap_update_bits(priv->regmap, HDMI_OTHER_CTRL1,
+				   HDMI_OTHER_CTRL1_HDMI_AUDIO_CLOCK_ON,
+				   HDMI_OTHER_CTRL1_HDMI_AUDIO_CLOCK_ON);
+
+		audio_tx_format |= TX_AUDIO_FORMAT_SPDIF_OR_I2S |
+				   TX_AUDIO_FORMAT_I2S_ONE_BIT_OR_I2S |
+				   FIELD_PREP(TX_AUDIO_FORMAT_I2S_FORMAT, 0x2);
+
+		if (hparms->channels > 2)
+			audio_tx_format |= TX_AUDIO_FORMAT_I2S_2_OR_8_CH;
+
+		regmap_write(priv->regmap, TX_AUDIO_FORMAT,
+			     audio_tx_format);
+
+		regmap_write(priv->regmap, TX_AUDIO_I2S, TX_AUDIO_I2S_ENABLE);
+		regmap_write(priv->regmap, TX_AUDIO_SPDIF, 0x0);
+		break;
+
+	case HDMI_SPDIF:
+		regmap_update_bits(priv->regmap, HDMI_OTHER_CTRL1,
+				   HDMI_OTHER_CTRL1_HDMI_AUDIO_CLOCK_ON, 0x0);
+
+		if (hparms->cea.coding_type == HDMI_AUDIO_CODING_TYPE_STREAM)
+			audio_tx_format |= TX_AUDIO_FORMAT_SPDIF_CHANNEL_STATUS_FROM_DATA_OR_REG;
+
+		regmap_write(priv->regmap, TX_AUDIO_FORMAT,
+			     audio_tx_format);
+
+		regmap_write(priv->regmap, TX_AUDIO_I2S, 0x0);
+		regmap_write(priv->regmap, TX_AUDIO_SPDIF, TX_AUDIO_SPDIF_ENABLE);
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	if (hparms->channels > 2)
+		regmap_write(priv->regmap, TX_AUDIO_HEADER,
+			     TX_AUDIO_HEADER_AUDIO_SAMPLE_PACKET_HEADER_LAYOUT1);
+	else
+		regmap_write(priv->regmap, TX_AUDIO_HEADER, 0x0);
+
+	regmap_write(priv->regmap, TX_AUDIO_SAMPLE,
+		     FIELD_PREP(TX_AUDIO_SAMPLE_CHANNEL_VALID,
+				BIT(hparms->channels) - 1));
+
+	audio_n = meson_txc_hdmi_hdmi_codec_calc_audio_n(hparms);
+
+	regmap_write(priv->regmap, TX_SYS1_ACR_N_0,
+		     FIELD_PREP(TX_SYS1_ACR_N_0_N_BYTE0,
+				(audio_n >> 0) & 0xff));
+	regmap_write(priv->regmap, TX_SYS1_ACR_N_1,
+		     FIELD_PREP(TX_SYS1_ACR_N_1_N_BYTE1,
+				(audio_n >> 8) & 0xff));
+	regmap_update_bits(priv->regmap, TX_SYS1_ACR_N_2,
+			   TX_SYS1_ACR_N_2_N_UPPER_NIBBLE,
+			   FIELD_PREP(TX_SYS1_ACR_N_2_N_UPPER_NIBBLE,
+				      (audio_n >> 16) & 0xf));
+
+	regmap_write(priv->regmap, TX_SYS0_ACR_CTS_0, 0x0);
+	regmap_write(priv->regmap, TX_SYS0_ACR_CTS_1, 0x0);
+	regmap_write(priv->regmap, TX_SYS0_ACR_CTS_2,
+		     TX_SYS0_ACR_CTS_2_FORCE_ARC_STABLE);
+
+	regmap_write(priv->regmap, TX_AUDIO_CONTROL,
+		     TX_AUDIO_CONTROL_AUTO_AUDIO_FIFO_CLEAR |
+		     FIELD_PREP(TX_AUDIO_CONTROL_AUDIO_PACKET_TYPE_MASK,
+				meson_txc_hdmi_hdmi_codec_coding_type(hparms)) |
+		     TX_AUDIO_CONTROL_AUDIO_SAMPLE_PACKET_FLAT);
+
+	len = hdmi_audio_infoframe_pack(&hparms->cea, buf, sizeof(buf));
+	if (len < 0)
+		return len;
+
+	meson_txc_hdmi_write_infoframe(priv->regmap,
+				       TX_PKT_REG_AUDIO_INFO_BASE_ADDR,
+				       buf, len, true);
+
+	for (i = 0; i < ARRAY_SIZE(hparms->iec.status); i++) {
+		unsigned char sub1, sub2;
+
+		sub1 = sub2 = hparms->iec.status[i];
+
+		if (i == 2) {
+			sub1 |= FIELD_PREP(IEC958_AES2_CON_CHANNEL, 1);
+			sub2 |= FIELD_PREP(IEC958_AES2_CON_CHANNEL, 2);
+		}
+
+		regmap_write(priv->regmap, TX_IEC60958_SUB1_OFFSET + i, sub1);
+		regmap_write(priv->regmap, TX_IEC60958_SUB2_OFFSET + i, sub2);
+	}
+
+	return 0;
+}
+
+static int meson_txc_hdmi_hdmi_codec_audio_startup(struct device *dev,
+						   void *data)
+{
+	struct meson_txc_hdmi *priv = data;
+
+	regmap_update_bits(priv->regmap, TX_PACKET_CONTROL_2,
+			   TX_PACKET_CONTROL_2_AUDIO_REQUEST_DISABLE, 0x0);
+
+	/* reset audio master and sample */
+	regmap_write(priv->regmap, TX_SYS5_TX_SOFT_RESET_1,
+		     TX_SYS5_TX_SOFT_RESET_1_TX_AUDIO_RESAMPLE_RSTN |
+		     TX_SYS5_TX_SOFT_RESET_1_TX_AUDIO_MASTER_RSTN);
+	regmap_write(priv->regmap, TX_SYS5_TX_SOFT_RESET_1, 0x0);
+
+	regmap_write(priv->regmap, TX_AUDIO_CONTROL_MORE,
+		     TX_AUDIO_CONTROL_MORE_ENABLE);
+
+	regmap_write(priv->regmap, TX_AUDIO_FIFO,
+		     FIELD_PREP(TX_AUDIO_FIFO_FIFO_DEPTH_MASK,
+				TX_AUDIO_FIFO_FIFO_DEPTH_512) |
+		     FIELD_PREP(TX_AUDIO_FIFO_CRITICAL_THRESHOLD_MASK,
+			        TX_AUDIO_FIFO_CRITICAL_THRESHOLD_DEPTH_DIV16) |
+		     FIELD_PREP(TX_AUDIO_FIFO_NORMAL_THRESHOLD_MASK,
+			        TX_AUDIO_FIFO_NORMAL_THRESHOLD_DEPTH_DIV8));
+
+	regmap_write(priv->regmap, TX_AUDIO_LIPSYNC, 0x0);
+
+	regmap_write(priv->regmap, TX_SYS1_ACR_N_2,
+		     FIELD_PREP(TX_SYS1_ACR_N_2_N_MEAS_TOLERANCE, 0x3));
+
+	return 0;
+}
+
+static void meson_txc_hdmi_hdmi_codec_audio_shutdown(struct device *dev,
+						     void *data)
+{
+	struct meson_txc_hdmi *priv = data;
+
+	meson_txc_hdmi_disable_infoframe(priv, TX_PKT_REG_AUDIO_INFO_BASE_ADDR);
+
+	regmap_write(priv->regmap, TX_AUDIO_CONTROL_MORE, 0x0);
+	regmap_update_bits(priv->regmap, HDMI_OTHER_CTRL1,
+			   HDMI_OTHER_CTRL1_HDMI_AUDIO_CLOCK_ON, 0x0);
+
+	regmap_update_bits(priv->regmap, TX_PACKET_CONTROL_2,
+			   TX_PACKET_CONTROL_2_AUDIO_REQUEST_DISABLE,
+			   TX_PACKET_CONTROL_2_AUDIO_REQUEST_DISABLE);
+}
+
+static int meson_txc_hdmi_hdmi_codec_mute_stream(struct device *dev,
+						 void *data,
+						 bool enable, int direction)
+{
+	struct meson_txc_hdmi *priv = data;
+
+	regmap_write(priv->regmap, TX_AUDIO_PACK,
+		     enable ? 0 : TX_AUDIO_PACK_AUDIO_SAMPLE_PACKETS_ENABLE);
+
+	return 0;
+}
+
+static int meson_txc_hdmi_hdmi_codec_get_eld(struct device *dev, void *data,
+					     uint8_t *buf, size_t len)
+{
+	struct meson_txc_hdmi *priv = data;
+
+	memcpy(buf, priv->eld, min_t(size_t, MAX_ELD_BYTES, len));
+
+	return 0;
+}
+
+static int meson_txc_hdmi_hdmi_codec_get_dai_id(struct snd_soc_component *component,
+						struct device_node *endpoint)
+{
+	struct of_endpoint of_ep;
+	int ret;
+
+	ret = of_graph_parse_endpoint(endpoint, &of_ep);
+	if (ret < 0)
+		return ret;
+
+	/*
+	 * HDMI sound should be located as reg = <2>
+	 * Then, it is sound port 0
+	 */
+	if (of_ep.port == 2)
+		return 0;
+
+	return -EINVAL;
+}
+
+static int meson_txc_hdmi_hdmi_codec_hook_plugged_cb(struct device *dev,
+						     void *data,
+						     hdmi_codec_plugged_cb fn,
+						     struct device *codec_dev)
+{
+	struct meson_txc_hdmi *priv = data;
+
+	mutex_lock(&priv->codec_mutex);
+	priv->codec_plugged_cb = fn;
+	priv->codec_dev = codec_dev;
+	meson_txc_hdmi_handle_plugged_change(priv);
+	mutex_unlock(&priv->codec_mutex);
+
+	return 0;
+}
+
+static struct hdmi_codec_ops meson_txc_hdmi_hdmi_codec_ops = {
+	.hw_params		= meson_txc_hdmi_hdmi_codec_hw_params,
+	.audio_startup		= meson_txc_hdmi_hdmi_codec_audio_startup,
+	.audio_shutdown		= meson_txc_hdmi_hdmi_codec_audio_shutdown,
+	.mute_stream		= meson_txc_hdmi_hdmi_codec_mute_stream,
+	.get_eld		= meson_txc_hdmi_hdmi_codec_get_eld,
+	.get_dai_id		= meson_txc_hdmi_hdmi_codec_get_dai_id,
+	.hook_plugged_cb	= meson_txc_hdmi_hdmi_codec_hook_plugged_cb,
+};
+
+static int meson_txc_hdmi_hdmi_codec_init(struct meson_txc_hdmi *priv)
+{
+	struct hdmi_codec_pdata pdata = {
+		.ops			= &meson_txc_hdmi_hdmi_codec_ops,
+		.i2s			= 1,
+		.spdif			= 1,
+		.max_i2s_channels	= 8,
+		.data			= priv,
+	};
+
+	priv->hdmi_codec_pdev = platform_device_register_data(priv->dev,
+							      HDMI_CODEC_DRV_NAME,
+							      PLATFORM_DEVID_AUTO,
+							      &pdata, sizeof(pdata));
+	return PTR_ERR_OR_ZERO(priv->hdmi_codec_pdev);
+}
+
+static int meson_txc_hdmi_bind(struct device *dev, struct device *master,
+			       void *data)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct meson_txc_hdmi *priv;
+	void __iomem *base;
+	u32 regval;
+	int ret;
+
+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	priv->dev = dev;
+	priv->input_bus_format = MEDIA_BUS_FMT_FIXED;
+	priv->output_bus_format = MEDIA_BUS_FMT_FIXED;
+
+	mutex_init(&priv->codec_mutex);
+
+	dev_set_drvdata(dev, priv);
+
+	base = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(base))
+		return PTR_ERR(base);
+
+	priv->regmap = devm_regmap_init(dev, NULL, base,
+					&meson_txc_hdmi_regmap_config);
+	if (IS_ERR(priv->regmap))
+		return PTR_ERR(priv->regmap);
+
+	priv->pclk = devm_clk_get(dev, "pclk");
+	if (IS_ERR(priv->pclk)) {
+		ret = PTR_ERR(priv->pclk);
+		return dev_err_probe(dev, ret, "Failed to get the pclk\n");
+	}
+
+	priv->sys_clk = devm_clk_get(dev, "sys");
+	if (IS_ERR(priv->sys_clk)) {
+		ret = PTR_ERR(priv->sys_clk);
+		return dev_err_probe(dev, ret,
+				     "Failed to get the sys clock\n");
+	}
+
+	priv->phy = devm_phy_get(dev, "hdmi");
+	if (IS_ERR(priv->phy)) {
+		ret = PTR_ERR(priv->phy);
+		return dev_err_probe(dev, ret, "Failed to get the HDMI PHY\n");
+	}
+
+	ret = meson_txc_hdmi_parse_dt(priv);
+	if (ret)
+		return ret;
+
+	ret = clk_prepare_enable(priv->pclk);
+	if (ret) {
+		dev_err_probe(dev, ret, "Failed to enable the pclk\n");
+		return ret;
+	}
+
+	regval = readl(base + HDMI_CTRL_PORT);
+	regval |= HDMI_CTRL_PORT_APB3_ERR_EN;
+	writel(regval, base + HDMI_CTRL_PORT);
+
+	ret = meson_txc_hdmi_hw_init(priv);
+	if (ret)
+		goto err_disable_clk;
+
+	ret = meson_txc_hdmi_hdmi_codec_init(priv);
+	if (ret)
+		goto err_hw_exit;
+
+	priv->bridge.driver_private = priv;
+	priv->bridge.funcs = &meson_txc_hdmi_bridge_funcs;
+	priv->bridge.ops = DRM_BRIDGE_OP_DETECT | DRM_BRIDGE_OP_EDID;
+	priv->bridge.of_node = dev->of_node;
+	priv->bridge.interlace_allowed = true;
+
+	drm_bridge_add(&priv->bridge);
+
+	return 0;
+
+err_hw_exit:
+	meson_txc_hdmi_hw_exit(priv);
+err_disable_clk:
+	clk_disable_unprepare(priv->pclk);
+	return ret;
+}
+
+static void meson_txc_hdmi_unbind(struct device *dev, struct device *master,
+				  void *data)
+{
+	struct meson_txc_hdmi *priv = dev_get_drvdata(dev);
+
+	platform_device_unregister(priv->hdmi_codec_pdev);
+
+	drm_bridge_remove(&priv->bridge);
+
+	meson_txc_hdmi_hw_exit(priv);
+
+	clk_disable_unprepare(priv->pclk);
+}
+
+static const struct component_ops meson_txc_hdmi_component_ops = {
+	.bind = meson_txc_hdmi_bind,
+	.unbind = meson_txc_hdmi_unbind,
+};
+
+static int meson_txc_hdmi_probe(struct platform_device *pdev)
+{
+	return component_add(&pdev->dev, &meson_txc_hdmi_component_ops);
+}
+
+static int meson_txc_hdmi_remove(struct platform_device *pdev)
+{
+	component_del(&pdev->dev, &meson_txc_hdmi_component_ops);
+
+	return 0;
+}
+
+static const struct of_device_id meson_txc_hdmi_of_table[] = {
+	{ .compatible = "amlogic,meson8-hdmi-tx" },
+	{ .compatible = "amlogic,meson8b-hdmi-tx" },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, meson_txc_hdmi_of_table);
+
+static struct platform_driver meson_txc_hdmi_platform_driver = {
+	.probe		= meson_txc_hdmi_probe,
+	.remove		= meson_txc_hdmi_remove,
+	.driver		= {
+		.name		= "meson-transwitch-hdmi",
+		.of_match_table	= meson_txc_hdmi_of_table,
+	},
+};
+module_platform_driver(meson_txc_hdmi_platform_driver);
+
+MODULE_AUTHOR("Martin Blumenstingl <martin.blumenstingl@googlemail.com>");
+MODULE_DESCRIPTION("Amlogic Meson8 and Meson8b TranSwitch HDMI 1.4 TX driver");
+MODULE_LICENSE("GPL v2");
diff -Naur a/drivers/gpu/drm/meson/meson_transwitch_hdmi.h b/drivers/gpu/drm/meson/meson_transwitch_hdmi.h
--- a/drivers/gpu/drm/meson/meson_transwitch_hdmi.h	1969-12-31 19:00:00.000000000 -0500
+++ b/drivers/gpu/drm/meson/meson_transwitch_hdmi.h	2021-10-31 20:41:20.000000000 -0400
@@ -0,0 +1,536 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2021 Martin Blumenstingl <martin.blumenstingl@googlemail.com>
+ *
+ * All registers and magic values are taken from Amlogic's GPL kernel sources:
+ *   Copyright (C) 2010 Amlogic, Inc.
+ */
+
+#include <linux/bitfield.h>
+#include <linux/bits.h>
+
+#ifndef __MESON_TRANSWITCH_HDMI_H__
+#define __MESON_TRANSWITCH_HDMI_H__
+
+/* HDMI TX register */
+
+// System config 0
+#define TX_SYS0_AFE_SIGNAL						0x0000
+#define TX_SYS0_AFE_LOOP						0x0001
+#define TX_SYS0_ACR_CTS_0						0x0002
+	#define TX_SYS0_ACR_CTS_0_AUDIO_CTS_BYTE0		GENMASK(7, 0)
+#define TX_SYS0_ACR_CTS_1						0x0003
+	#define TX_SYS0_ACR_CTS_1_AUDIO_CTS_BYTE1		GENMASK(7, 0)
+#define TX_SYS0_ACR_CTS_2						0x0004
+	#define TX_SYS0_ACR_CTS_2_FORCE_ARC_STABLE			BIT(5)
+#define TX_SYS0_BIST_CONTROL						0x0005
+	#define TX_SYS0_BIST_CONTROL_AFE_BIST_ENABLE			BIT(7)
+	#define TX_SYS0_BIST_CONTROL_TMDS_SHIFT_PATTERN_SELECT		BIT(6)
+	#define TX_SYS0_BIST_CONTROL_TMDS_PRBS_PATTERN_SELECT	GENMASK(5, 4)
+	#define TX_SYS0_BIST_CONTROL_TMDS_REPEAT_BIST_PATTERN	GENMASK(2, 0)
+
+#define TX_SYS0_BIST_DATA_0						0x0006
+#define TX_SYS0_BIST_DATA_1						0x0007
+#define TX_SYS0_BIST_DATA_2						0x0008
+#define TX_SYS0_BIST_DATA_3						0x0009
+#define TX_SYS0_BIST_DATA_4						0x000A
+#define TX_SYS0_BIST_DATA_5						0x000B
+#define TX_SYS0_BIST_DATA_6						0x000C
+#define TX_SYS0_BIST_DATA_7						0x000D
+#define TX_SYS0_BIST_DATA_8						0x000E
+#define TX_SYS0_BIST_DATA_9						0x000F
+
+// system config 1
+#define TX_HDMI_PHY_CONFIG0						0x0010
+	#define TX_HDMI_PHY_CONFIG0_HDMI_COMMON_B7_B0		GENMASK(7, 0)
+#define TX_HDMI_PHY_CONFIG1						0x0010
+	#define TX_HDMI_PHY_CONFIG1_HDMI_COMMON_B11_B8		GENMASK(3, 0)
+	#define TX_HDMI_PHY_CONFIG1_HDMI_CTL_REG_B3_B0		GENMASK(7, 4)
+#define TX_HDMI_PHY_CONFIG2						0x0012
+    #define TX_HDMI_PHY_CONFIG_HDMI_CTL_REG_B11_B4		GENMASK(7, 0)
+#define TX_HDMI_PHY_CONFIG3						0x0013
+	#define TX_HDMI_PHY_CONFIG3_HDMI_L2H_CTL		GENMASK(3, 0)
+	#define TX_HDMI_PHY_CONFIG3_HDMI_MDR_PU			GENMASK(7, 4)
+#define TX_HDMI_PHY_CONFIG4						0x0014
+	#define TX_HDMI_PHY_CONFIG4_HDMI_LF_PD				BIT(0)
+	#define TX_HDMI_PHY_CONFIG4_HDMI_PHY_CLK_EN			BIT(1)
+	#define TX_HDMI_PHY_CONFIG4_HDMI_MODE			GENMASK(3, 2)
+	#define TX_HDMI_PHY_CONFIG4_HDMI_MODE_NORMAL			0x0
+	#define TX_HDMI_PHY_CONFIG4_HDMI_MODE_CLK_CH3_EQUAL_CH0		0x1
+	#define TX_HDMI_PHY_CONFIG4_HDMI_MODE_ALTERNATE_HIGH_LOW	0x2
+	#define TX_HDMI_PHY_CONFIG4_HDMI_MODE_ALTERNATE_LOW_HIGH	0x3
+	#define TX_HDMI_PHY_CONFIG4_HDMI_PREM_CTL		GENMASK(7, 4)
+#define TX_HDMI_PHY_CONFIG5						0x0015
+	#define TX_HDMI_PHY_CONFIG5_HDMI_VCM_CTL		GENMASK(7, 5)
+	#define TX_HDMI_PHY_CONFIG5_HDMI_PREFCTL		GENMASK(2, 0)
+#define TX_HDMI_PHY_CONFIG6						0x0016
+	#define TX_HDMI_PHY_CONFIG6_HDMI_RTERM_CTL		GENMASK(3, 0)
+	#define TX_HDMI_PHY_CONFIG6_HDMI_SWING_CTL		GENMASK(7, 4)
+#define TX_SYS1_AFE_TEST						0x0017
+#define TX_SYS1_PLL							0x0018
+#define TX_SYS1_TUNE							0x0019
+#define TX_SYS1_AFE_CONNECT						0x001A
+
+#define TX_SYS1_ACR_N_0							0x001C
+	#define TX_SYS1_ACR_N_0_N_BYTE0				GENMASK(7, 0)
+#define TX_SYS1_ACR_N_1							0x001D
+	#define TX_SYS1_ACR_N_1_N_BYTE1				GENMASK(7, 0)
+#define TX_SYS1_ACR_N_2							0x001E
+	#define TX_SYS1_ACR_N_2_N_MEAS_TOLERANCE		GENMASK(7, 4)
+	#define TX_SYS1_ACR_N_2_N_UPPER_NIBBLE			GENMASK(3, 0)
+#define TX_SYS1_PRBS_DATA						0x001F
+	#define TX_SYS1_PRBS_DATA_PRBS_MODE			GENMASK(1, 0)
+	#define TX_SYS1_PRBS_DATA_PRBS_MODE_11				0x0
+	#define TX_SYS1_PRBS_DATA_PRBS_MODE_15				0x1
+	#define TX_SYS1_PRBS_DATA_PRBS_MODE_7				0x2
+	#define TX_SYS1_PRBS_DATA_PRBS_MODE_31				0x3
+
+// HDCP CONFIG
+#define TX_HDCP_ECC_CONFIG						0x0024
+#define TX_HDCP_CRC_CONFIG						0x0025
+#define TX_HDCP_EDID_CONFIG						0x0026
+	#define TX_HDCP_EDID_CONFIG_FORCED_SYS_TRIGGER			BIT(7)
+	#define TX_HDCP_EDID_CONFIG_SYS_TRIGGER_CONFIG			BIT(6)
+	#define TX_HDCP_EDID_CONFIG_MEM_ACC_SEQ_MODE			BIT(5)
+	#define TX_HDCP_EDID_CONFIG_MEM_ACC_SEQ_START			BIT(4)
+	#define TX_HDCP_EDID_CONFIG_FORCED_MEM_COPY_DONE		BIT(3)
+	#define TX_HDCP_EDID_CONFIG_MEM_COPY_DONE_CONFIG		BIT(2)
+	#define TX_HDCP_EDID_CONFIG_SYS_TRIGGER_CONFIG_SEMI_MANU	BIT(1)
+
+#define TX_HDCP_MEM_CONFIG						0x0027
+	#define TX_HDCP_MEM_CONFIG_READ_DECRYPT				BIT(3)
+
+#define TX_HDCP_HPD_FILTER_L						0x0028
+#define TX_HDCP_HPD_FILTER_H						0x0029
+#define TX_HDCP_ENCRYPT_BYTE						0x002A
+#define TX_HDCP_CONFIG0							0x002B
+	#define TX_HDCP_CONFIG0_ROM_ENCRYPT_OFF			GENMASK(4, 3)
+
+#define TX_HDCP_CONFIG1							0x002C
+#define TX_HDCP_CONFIG2							0x002D
+#define TX_HDCP_CONFIG3							0x002E
+	#define TX_HDCP_CONFIG3_DDC_I2C_BUS_CLOCK_TIME_DIVIDER	GENMASK(7, 0)
+
+#define TX_HDCP_MODE							0x002F
+	#define TX_HDCP_MODE_CP_DESIRED					BIT(7)
+	#define TX_HDCP_MODE_ESS_CONFIG					BIT(6)
+	#define TX_HDCP_MODE_SET_AVMUTE					BIT(5)
+	#define TX_HDCP_MODE_CLEAR_AVMUTE				BIT(4)
+	#define TX_HDCP_MODE_HDCP_1_1					BIT(3)
+	#define TX_HDCP_MODE_VSYNC_HSYNC_FORCED_POLARITY_SELECT		BIT(2)
+	#define TX_HDCP_MODE_FORCED_VSYNC_POLARITY			BIT(1)
+	#define TX_HDCP_MODE_FORCED_HSYNC_POLARITY			BIT(0)
+
+// Video config, part 1
+#define TX_VIDEO_ACTIVE_PIXELS_0					0x0030
+#define TX_VIDEO_ACTIVE_PIXELS_1					0x0031
+#define TX_VIDEO_FRONT_PIXELS						0x0032
+#define TX_VIDEO_HSYNC_PIXELS						0x0033
+#define TX_VIDEO_BACK_PIXELS						0x0034
+#define TX_VIDEO_ACTIVE_LINES_0						0x0035
+#define TX_VIDEO_ACTIVE_LINES_1						0x0036
+#define TX_VIDEO_EOF_LINES						0x0037
+#define TX_VIDEO_VSYNC_LINES						0x0038
+#define TX_VIDEO_SOF_LINES						0x0039
+#define TX_VIDEO_DTV_TIMING						0x003A
+	#define TX_VIDEO_DTV_TIMING_FORCE_DTV_TIMING_AUTO		BIT(7)
+	#define TX_VIDEO_DTV_TIMING_FORCE_VIDEO_SCAN			BIT(6)
+	#define TX_VIDEO_DTV_TIMING_FORCE_VIDEO_FIELD			BIT(5)
+	#define TX_VIDEO_DTV_TIMING_DISABLE_VIC39_CORRECTION		BIT(4)
+
+#define TX_VIDEO_DTV_MODE						0x003B
+	#define TX_VIDEO_DTV_MODE_FORCED_DEFAULT_PHASE			BIT(7)
+	#define TX_VIDEO_DTV_MODE_COLOR_DEPTH			GENMASK(1, 0)
+
+#define TX_VIDEO_DTV_FORMAT0						0x003C
+#define TX_VIDEO_DTV_FORMAT1						0x003D
+#define TX_VIDEO_PIXEL_PACK						0x003F
+// video config, part 2
+#define TX_VIDEO_CSC_COEFF_B0						0x0040
+#define TX_VIDEO_CSC_COEFF_B1						0x0041
+#define TX_VIDEO_CSC_COEFF_R0						0x0042
+#define TX_VIDEO_CSC_COEFF_R1						0x0043
+#define TX_VIDEO_CSC_COEFF_CB0						0x0044
+#define TX_VIDEO_CSC_COEFF_CB1						0x0045
+#define TX_VIDEO_CSC_COEFF_CR0						0x0046
+#define TX_VIDEO_CSC_COEFF_CR1						0x0047
+#define TX_VIDEO_DTV_OPTION_L						0x0048
+	#define TX_VIDEO_DTV_OPTION_L_OUTPUT_COLOR_FORMAT	GENMASK(7, 6)
+	#define TX_VIDEO_DTV_OPTION_L_INPUT_COLOR_FORMAT	GENMASK(5, 4)
+	#define TX_VIDEO_DTV_OPTION_L_OUTPUT_COLOR_DEPTH	GENMASK(3, 2)
+	#define TX_VIDEO_DTV_OPTION_L_INPUT_COLOR_DEPTH		GENMASK(1, 0)
+
+#define TX_VIDEO_DTV_OPTION_H						0x0049
+	#define TX_VIDEO_DTV_OPTION_H_COLOR_RANGE_16_235		0x0
+	#define TX_VIDEO_DTV_OPTION_H_COLOR_RANGE_16_240		0x1
+	#define TX_VIDEO_DTV_OPTION_H_COLOR_RANGE_1_254			0x2
+	#define TX_VIDEO_DTV_OPTION_H_COLOR_RANGE_0_255			0x3
+	#define TX_VIDEO_DTV_OPTION_H_OUTPUT_COLOR_RANGE	GENMASK(3, 2)
+	#define TX_VIDEO_DTV_OPTION_H_INPUT_COLOR_RANGE		GENMASK(1, 0)
+
+#define TX_VIDEO_DTV_FILTER						0x004A
+#define TX_VIDEO_DTV_DITHER						0x004B
+#define TX_VIDEO_DTV_DEDITHER						0x004C
+#define TX_VIDEO_PROC_CONFIG0						0x004E
+#define TX_VIDEO_PROC_CONFIG1						0x004F
+
+// Audio config
+#define TX_AUDIO_FORMAT							0x0058
+	#define TX_AUDIO_FORMAT_SPDIF_OR_I2S				BIT(7)
+	#define TX_AUDIO_FORMAT_I2S_2_OR_8_CH				BIT(6)
+	#define TX_AUDIO_FORMAT_I2S_FORMAT			GENMASK(5, 4)
+	#define TX_AUDIO_FORMAT_BIT_WIDTH_MASK			GENMASK(3, 2)
+	#define TX_AUDIO_FORMAT_BIT_WIDTH_16				0x1
+	#define TX_AUDIO_FORMAT_BIT_WIDTH_20				0x2
+	#define TX_AUDIO_FORMAT_BIT_WIDTH_24				0x3
+	#define TX_AUDIO_FORMAT_WS_POLARITY				BIT(1)
+	#define TX_AUDIO_FORMAT_I2S_ONE_BIT_OR_I2S			BIT(0)
+	#define TX_AUDIO_FORMAT_SPDIF_CHANNEL_STATUS_FROM_DATA_OR_REG	BIT(0)
+
+#define TX_AUDIO_SPDIF							0x0059
+	#define TX_AUDIO_SPDIF_ENABLE					BIT(0)
+#define TX_AUDIO_I2S							0x005A
+	#define TX_AUDIO_I2S_ENABLE					BIT(0)
+#define TX_AUDIO_FIFO							0x005B
+	#define TX_AUDIO_FIFO_FIFO_DEPTH_MASK			GENMASK(7, 4)
+	#define TX_AUDIO_FIFO_FIFO_DEPTH_512				0x4
+	#define TX_AUDIO_FIFO_CRITICAL_THRESHOLD_MASK		GENMASK(3, 2)
+	#define TX_AUDIO_FIFO_CRITICAL_THRESHOLD_DEPTH_DIV16		0x2
+	#define TX_AUDIO_FIFO_NORMAL_THRESHOLD_MASK		GENMASK(1, 0)
+	#define TX_AUDIO_FIFO_NORMAL_THRESHOLD_DEPTH_DIV8		0x1
+#define TX_AUDIO_LIPSYNC						0x005C
+	#define TX_AUDIO_LIPSYNC_NORMALIZED_LIPSYNC_PARAM	GENMASK(7, 0)
+#define TX_AUDIO_CONTROL						0x005D
+	#define TX_AUDIO_CONTROL_FORCED_AUDIO_FIFO_CLEAR		BIT(7)
+	#define TX_AUDIO_CONTROL_AUTO_AUDIO_FIFO_CLEAR			BIT(6)
+	#define TX_AUDIO_CONTROL_AUDIO_PACKET_TYPE_MASK		GENMASK(5, 4)
+	#define TX_AUDIO_CONTROL_AUDIO_PACKET_TYPE_AUDIO_SAMPLE_PACKET	0x0
+	#define TX_AUDIO_CONTROL_AUDIO_PACKET_TYPE_ONE_BIT_AUDIO	0x1
+	#define TX_AUDIO_CONTROL_AUDIO_PACKET_TYPE_HBR_AUDIO_PACKET	0x2
+	#define TX_AUDIO_CONTROL_AUDIO_PACKET_TYPE_DST_AUDIO_PACKET	0x3
+	#define TX_AUDIO_CONTROL_AUDIO_SAMPLE_PACKET_VALID		BIT(2)
+	#define TX_AUDIO_CONTROL_AUDIO_SAMPLE_PACKET_USER		BIT(1)
+	#define TX_AUDIO_CONTROL_AUDIO_SAMPLE_PACKET_FLAT		BIT(0)
+#define TX_AUDIO_HEADER							0x005E
+	#define TX_AUDIO_HEADER_AUDIO_SAMPLE_PACKET_HEADER_LAYOUT1	BIT(7)
+	#define TX_AUDIO_HEADER_SET_NORMAL_DOUBLE_IN_DST_PACKET_HEADER	BIT(6)
+#define TX_AUDIO_SAMPLE							0x005F
+	#define TX_AUDIO_SAMPLE_CHANNEL_VALID			GENMASK(7, 0)
+#define TX_AUDIO_VALID							0x0060
+#define TX_AUDIO_USER							0x0061
+#define TX_AUDIO_PACK							0x0062
+	#define TX_AUDIO_PACK_AUDIO_SAMPLE_PACKETS_ENABLE		BIT(0)
+#define TX_AUDIO_CONTROL_MORE						0x0064
+	#define TX_AUDIO_CONTROL_MORE_ENABLE				BIT(0)
+
+// tmds config
+#define TX_TMDS_MODE							0x0068
+	#define TX_TMDS_MODE_FORCED_HDMI				BIT(7)
+	#define TX_TMDS_MODE_HDMI_CONFIG				BIT(6)
+	#define TX_TMDS_MODE_BIT_SWAP					BIT(3)
+	#define TX_TMDS_MODE_CHANNEL_SWAP			GENMASK(2, 0)
+
+#define TX_TMDS_CONFIG0							0x006C
+#define TX_TMDS_CONFIG1							0x006D
+
+// packet config
+#define TX_PACKET_ALLOC_ACTIVE_1					0x0078
+#define TX_PACKET_ALLOC_ACTIVE_2					0x0079
+#define TX_PACKET_ALLOC_EOF_1						0x007A
+#define TX_PACKET_ALLOC_EOF_2						0x007B
+#define TX_PACKET_ALLOC_SOF_1						0x007C
+#define TX_PACKET_ALLOC_SOF_2						0x007D
+#define TX_PACKET_CONTROL_1						0x007E
+	#define TX_PACKET_CONTROL_1_FORCE_PACKET_TIMING			BIT(7)
+	#define TX_PACKET_CONTROL_1_PACKET_ALLOC_MODE			BIT(6)
+	#define TX_PACKET_CONTROL_1_PACKET_START_LATENCY	GENMASK(5, 0)
+
+#define TX_PACKET_CONTROL_2						0x007F
+	#define TX_PACKET_CONTROL_2_AUDIO_REQUEST_DISABLE		BIT(3)
+	#define TX_PACKET_CONTROL_2_HORIZONTAL_GC_PACKET_TRANSPORT_EN	BIT(1)
+
+#define TX_CORE_EDID_CONFIG_MORE					0x0080
+	#define TX_CORE_EDID_CONFIG_MORE_KEEP_EDID_ERROR		BIT(1)
+	#define TX_CORE_EDID_CONFIG_MORE_SYS_TRIGGER_CONFIG_SEMI_MANU	BIT(0)
+
+#define TX_CORE_ALLOC_VSYNC_0						0x0081
+#define TX_CORE_ALLOC_VSYNC_1						0x0082
+#define TX_CORE_ALLOC_VSYNC_2						0x0083
+#define TX_MEM_PD_REG0							0x0084
+
+// core config
+#define TX_CORE_DATA_CAPTURE_1						0x00F0
+#define TX_CORE_DATA_CAPTURE_2						0x00F1
+	#define TX_CORE_DATA_CAPTURE_2_AUDIO_SOURCE_SELECT	GENMASK(7, 6)
+	#define TX_CORE_DATA_CAPTURE_2_EXTERNAL_PACKET_ENABLE		BIT(5)
+	#define TX_CORE_DATA_CAPTURE_2_INTERNAL_PACKET_ENABLE		BIT(4)
+	#define TX_CORE_DATA_CAPTURE_2_AFE_FIFO_SRC_LANE1	GENMASK(3, 2)
+	#define TX_CORE_DATA_CAPTURE_2_AFE_FIFO_SRC_LANE0	GENMASK(1, 0)
+
+#define TX_CORE_DATA_MONITOR_1						0x00F2
+	#define TX_CORE_DATA_MONITOR_1_LANE1				BIT(7)
+	#define TX_CORE_DATA_MONITOR_1_SELECT_LANE1		GENMASK(6, 4)
+	#define TX_CORE_DATA_MONITOR_1_LANE0				BIT(3)
+	#define TX_CORE_DATA_MONITOR_1_SELECT_LANE0		GENMASK(2, 0)
+
+#define TX_CORE_DATA_MONITOR_2						0x00F3
+	#define TX_CORE_DATA_MONITOR_2_MONITOR_SELECT		GENMASK(2, 0)
+
+#define TX_CORE_CALIB_MODE						0x00F4
+#define TX_CORE_CALIB_SAMPLE_DELAY					0x00F5
+#define TX_CORE_CALIB_VALUE_AUTO					0x00F6
+#define TX_CORE_CALIB_VALUE						0x00F7
+
+// system config 4
+#define TX_SYS4_TX_CKI_DDR						0x00A0
+#define TX_SYS4_TX_CKO_DDR						0x00A1
+#define TX_SYS4_RX_CKI_DDR						0x00A2
+#define TX_SYS4_RX_CKO_DDR						0x00A3
+#define TX_SYS4_CONNECT_SEL_0						0x00A4
+#define TX_SYS4_CONNECT_SEL_1						0x00A5
+	#define TX_SYS4_CONNECT_SEL_1_TX_CONNECT_SEL_UPPER_CHANNEL_DATA	BIT(6)
+
+#define TX_SYS4_CONNECT_SEL_2						0x00A6
+#define TX_SYS4_CONNECT_SEL_3						0x00A7
+#define TX_SYS4_CK_INV_VIDEO						0x00A8
+	#define TX_SYS4_CK_INV_VIDEO_TMDS_CLK_PATTERN			BIT(4)
+#define TX_SYS4_CK_INV_AUDIO						0x00A9
+#define TX_SYS4_CK_INV_AFE						0x00AA
+#define TX_SYS4_CK_INV_CH01						0x00AB
+#define TX_SYS4_CK_INV_CH2						0x00AC
+#define TX_SYS4_CK_CEC							0x00AD
+#define TX_SYS4_CK_SOURCE_1						0x00AE
+#define TX_SYS4_CK_SOURCE_2						0x00AF
+
+#define TX_IEC60958_SUB1_OFFSET						0x00B0
+#define TX_IEC60958_SUB2_OFFSET						0x00C8
+
+// system config 5
+#define TX_SYS5_TX_SOFT_RESET_1						0x00E0
+	#define TX_SYS5_TX_SOFT_RESET_1_TX_PIXEL_RSTN			BIT(7)
+	#define TX_SYS5_TX_SOFT_RESET_1_TX_TMDS_RSTN			BIT(6)
+	#define TX_SYS5_TX_SOFT_RESET_1_TX_AUDIO_MASTER_RSTN		BIT(5)
+	#define TX_SYS5_TX_SOFT_RESET_1_TX_AUDIO_RESAMPLE_RSTN		BIT(4)
+	#define TX_SYS5_TX_SOFT_RESET_1_TX_I2S_RESET_RSTN		BIT(3)
+	#define TX_SYS5_TX_SOFT_RESET_1_TX_DIG_RESET_N_CH2		BIT(2)
+	#define TX_SYS5_TX_SOFT_RESET_1_TX_DIG_RESET_N_CH1		BIT(1)
+	#define TX_SYS5_TX_SOFT_RESET_1_TX_DIG_RESET_N_CH0		BIT(0)
+
+#define TX_SYS5_TX_SOFT_RESET_2						0x00E1
+	#define TX_SYS5_TX_SOFT_RESET_2_HDMI_CH3_RST_IN			BIT(7)
+	#define TX_SYS5_TX_SOFT_RESET_2_HDMI_CH2_RST_IN			BIT(6)
+	#define TX_SYS5_TX_SOFT_RESET_2_HDMI_CH1_RST_IN			BIT(5)
+	#define TX_SYS5_TX_SOFT_RESET_2_HDMI_CH0_RST_IN			BIT(4)
+	#define TX_SYS5_TX_SOFT_RESET_2_HDMI_SR_RST			BIT(3)
+	#define TX_SYS5_TX_SOFT_RESET_2_TX_DDC_HDCP_RSTN		BIT(2)
+	#define TX_SYS5_TX_SOFT_RESET_2_TX_DDC_EDID_RSTN		BIT(1)
+	#define TX_SYS5_TX_SOFT_RESET_2_TX_DIG_RESET_N_CH3		BIT(0)
+
+#define TX_SYS5_RX_SOFT_RESET_1						0x00E2
+#define TX_SYS5_RX_SOFT_RESET_2						0x00E3
+#define TX_SYS5_RX_SOFT_RESET_3						0x00E4
+#define TX_SYS5_SSTL_BIDIR_IN						0x00E5
+#define TX_SYS5_SSTL_IN							0x00E6
+#define TX_SYS5_SSTL_DIFF_IN						0x00E7
+#define TX_SYS5_FIFO_CONFIG						0x00E8
+	#define TX_SYS5_FIFO_CONFIG_AFE_FIFO_CHANNEL2_BYPASS		BIT(6)
+	#define TX_SYS5_FIFO_CONFIG_AFE_FIFO_CHANNEL1_BYPASS		BIT(5)
+	#define TX_SYS5_FIFO_CONFIG_AFE_FIFO_CHANNEL0_BYPASS		BIT(4)
+	#define TX_SYS5_FIFO_CONFIG_CLK_CHANNEL3_OUTPUT_ENABLE		BIT(3)
+	#define TX_SYS5_FIFO_CONFIG_AFE_FIFO_CHANNEL2_ENABLE		BIT(2)
+	#define TX_SYS5_FIFO_CONFIG_AFE_FIFO_CHANNEL1_ENABLE		BIT(1)
+	#define TX_SYS5_FIFO_CONFIG_AFE_FIFO_CHANNEL0_ENABLE		BIT(0)
+
+#define TX_SYS5_FIFO_SAMP01_CFG						0x00E9
+#define TX_SYS5_FIFO_SAMP23_CFG						0x00EA
+#define TX_SYS5_CONNECT_FIFO_CFG					0x00EB
+#define TX_SYS5_IO_CALIB_CONTROL					0x00EC
+#define TX_SYS5_SSTL_BIDIR_OUT						0x00ED
+#define TX_SYS5_SSTL_OUT						0x00EE
+#define TX_SYS5_SSTL_DIFF_OUT						0x00EF
+
+// HDCP shadow register
+#define TX_HDCP_SHW_BKSV_0						0x0100
+#define TX_HDCP_SHW_BKSV_1						0x0101
+#define TX_HDCP_SHW_BKSV_2						0x0102
+#define TX_HDCP_SHW_BKSV_3						0x0103
+#define TX_HDCP_SHW_BKSV_4						0x0104
+#define TX_HDCP_SHW_RI1_0						0x0108
+#define TX_HDCP_SHW_RI1_1						0x0109
+#define TX_HDCP_SHW_PJ1							0x010A
+#define TX_HDCP_SHW_AKSV_0						0x0110
+#define TX_HDCP_SHW_AKSV_1						0x0111
+#define TX_HDCP_SHW_AKSV_2						0x0112
+#define TX_HDCP_SHW_AKSV_3						0x0113
+#define TX_HDCP_SHW_AKSV_4						0x0114
+#define TX_HDCP_SHW_AINFO						0x0115
+#define TX_HDCP_SHW_AN_0						0x0118
+#define TX_HDCP_SHW_AN_1						0x0119
+#define TX_HDCP_SHW_AN_2						0x011A
+#define TX_HDCP_SHW_AN_3						0x011B
+#define TX_HDCP_SHW_AN_4						0x011C
+#define TX_HDCP_SHW_AN_5						0x011D
+#define TX_HDCP_SHW_AN_6						0x011E
+#define TX_HDCP_SHW_AN_7						0x011F
+#define TX_HDCP_SHW_V1_H0_0						0x0120
+#define TX_HDCP_SHW_V1_H0_1						0x0121
+#define TX_HDCP_SHW_V1_H0_2						0x0122
+#define TX_HDCP_SHW_V1_H0_3						0x0123
+#define TX_HDCP_SHW_V1_H1_0						0x0124
+#define TX_HDCP_SHW_V1_H1_1						0x0125
+#define TX_HDCP_SHW_V1_H1_2						0x0126
+#define TX_HDCP_SHW_V1_H1_3						0x0127
+#define TX_HDCP_SHW_V1_H2_0						0x0128
+#define TX_HDCP_SHW_V1_H2_1						0x0129
+#define TX_HDCP_SHW_V1_H2_2						0x012A
+#define TX_HDCP_SHW_V1_H2_3						0x012B
+#define TX_HDCP_SHW_V1_H3_0						0x012C
+#define TX_HDCP_SHW_V1_H3_1						0x012D
+#define TX_HDCP_SHW_V1_H3_2						0x012E
+#define TX_HDCP_SHW_V1_H3_3						0x012F
+#define TX_HDCP_SHW_V1_H4_0						0x0130
+#define TX_HDCP_SHW_V1_H4_1						0x0131
+#define TX_HDCP_SHW_V1_H4_2						0x0132
+#define TX_HDCP_SHW_V1_H4_3						0x0133
+#define TX_HDCP_SHW_BCAPS						0x0140
+#define TX_HDCP_SHW_BSTATUS_0						0x0141
+#define TX_HDCP_SHW_BSTATUS_1						0x0142
+#define TX_HDCP_SHW_KSV_FIFO						0x0143
+
+// system status 0
+#define TX_SYSST0_CONNECT_FIFO						0x0180
+#define TX_SYSST0_PLL_MONITOR						0x0181
+#define TX_SYSST0_AFE_FIFO						0x0182
+#define TX_SYSST0_ROM_STATUS						0x018F
+
+// hdcp status
+#define TX_HDCP_ST_AUTHENTICATION					0x0190
+#define TX_HDCP_ST_FRAME_COUNT						0x0191
+#define TX_HDCP_ST_STATUS_0						0x0192
+#define TX_HDCP_ST_STATUS_1						0x0193
+#define TX_HDCP_ST_STATUS_2						0x0194
+#define TX_HDCP_ST_STATUS_3						0x0195
+#define TX_HDCP_ST_EDID_STATUS						0x0196
+	#define TX_HDCP_ST_EDID_STATUS_SYSTEM_STATUS		GENMASK(7, 6)
+	#define TX_HDCP_ST_EDID_STATUS_SYSTEM_STATUS_NO_SINK_ATTACHED	0x0
+	#define TX_HDCP_ST_EDID_STATUS_SYSTEM_STATUS_READING_EDID	0x1
+	#define TX_HDCP_ST_EDID_STATUS_SYSTEM_STATUS_DVI_MODE		0x2
+	#define TX_HDCP_ST_EDID_STATUS_SYSTEM_STATUS_HDMI_MODE		0x3
+	#define TX_HDCP_ST_EDID_STATUS_EDID_DATA_READY			BIT(4)
+	#define TX_HDCP_ST_EDID_STATUS_HPD_STATUS			BIT(1)
+
+#define TX_HDCP_ST_MEM_STATUS						0x0197
+#define TX_HDCP_ST_ST_MODE						0x019F
+
+// video status
+#define TX_VIDEO_ST_ACTIVE_PIXELS_1					0x01A0
+#define TX_VIDEO_ST_ACTIVE_PIXELS_2					0x01A1
+#define TX_VIDEO_ST_FRONT_PIXELS					0x01A2
+#define TX_VIDEO_ST_HSYNC_PIXELS					0x01A3
+#define TX_VIDEO_ST_BACK_PIXELS						0x01A4
+#define TX_VIDEO_ST_ACTIVE_LINES_1					0x01A5
+#define TX_VIDEO_ST_ACTIVE_LINES_2					0x01A6
+#define TX_VIDEO_ST_EOF_LINES						0x01A7
+#define TX_VIDEO_ST_VSYNC_LINES						0x01A8
+#define TX_VIDEO_ST_SOF_LINES						0x01A9
+#define TX_VIDEO_ST_DTV_TIMING						0x01AA
+#define TX_VIDEO_ST_DTV_MODE						0x01AB
+// audio status
+#define TX_VIDEO_ST_AUDIO_STATUS					0x01AC
+#define TX_AFE_STATUS_0							0x01AE
+#define TX_AFE_STATUS_1							0x01AF
+
+#define TX_IEC60958_ST_SUB1_OFFSET					0x01B0
+#define TX_IEC60958_ST_SUB2_OFFSET					0x01C8
+
+// system status 1
+#define TX_SYSST1_CALIB_BIT_RESULT_0					0x01E0
+#define TX_SYSST1_CALIB_BIT_RESULT_1					0x01E1
+//HDMI_STATUS_OUT[7:0]
+#define TX_HDMI_PHY_READBACK_0						0x01E2
+//HDMI_COMP_OUT[4]
+//HDMI_STATUS_OUT[11:8]
+#define TX_HDMI_PHY_READBACK_1						0x01E3
+#define TX_SYSST1_CALIB_BIT_RESULT_4					0x01E4
+#define TX_SYSST1_CALIB_BIT_RESULT_5					0x01E5
+#define TX_SYSST1_CALIB_BIT_RESULT_6					0x01E6
+#define TX_SYSST1_CALIB_BIT_RESULT_7					0x01E7
+#define TX_SYSST1_CALIB_BUS_RESULT_0					0x01E8
+#define TX_SYSST1_CALIB_BUS_RESULT_1					0x01E9
+#define TX_SYSST1_CALIB_BUS_RESULT_2					0x01EA
+#define TX_SYSST1_CALIB_BUS_RESULT_3					0x01EB
+#define TX_SYSST1_CALIB_BUS_RESULT_4					0x01EC
+#define TX_SYSST1_CALIB_BUS_RESULT_5					0x01ED
+#define TX_SYSST1_CALIB_BUS_RESULT_6					0x01EE
+#define TX_SYSST1_CALIB_BUS_RESULT_7					0x01EF
+
+// Packet status
+#define TX_PACKET_ST_REQUEST_STATUS_1					0x01F0
+#define TX_PACKET_ST_REQUEST_STATUS_2					0x01F1
+#define TX_PACKET_ST_REQUEST_MISSED_1					0x01F2
+#define TX_PACKET_ST_REQUEST_MISSED_2					0x01F3
+#define TX_PACKET_ST_ENCODE_STATUS_0					0x01F4
+#define TX_PACKET_ST_ENCODE_STATUS_1					0x01F5
+#define TX_PACKET_ST_ENCODE_STATUS_2					0x01F6
+#define TX_PACKET_ST_TIMER_STATUS					0x01F7
+
+// tmds status
+#define TX_TMDS_ST_CLOCK_METER_1					0x01F8
+#define TX_TMDS_ST_CLOCK_METER_2					0x01F9
+#define TX_TMDS_ST_CLOCK_METER_3					0x01FA
+#define TX_TMDS_ST_TMDS_STATUS_1					0x01FC
+#define TX_TMDS_ST_TMDS_STATUS_2					0x01FD
+#define TX_TMDS_ST_TMDS_STATUS_3					0x01FE
+#define TX_TMDS_ST_TMDS_STATUS_4					0x01FF
+
+// Packet register
+#define TX_PKT_REG_SPD_INFO_BASE_ADDR					0x0200
+#define TX_PKT_REG_VEND_INFO_BASE_ADDR					0x0220
+#define TX_PKT_REG_MPEG_INFO_BASE_ADDR					0x0240
+#define TX_PKT_REG_AVI_INFO_BASE_ADDR					0x0260
+#define TX_PKT_REG_AUDIO_INFO_BASE_ADDR					0x0280
+#define TX_PKT_REG_ACP_INFO_BASE_ADDR					0x02A0
+#define TX_PKT_REG_ISRC1_BASE_ADDR					0x02C0
+#define TX_PKT_REG_ISRC2_BASE_ADDR					0x02E0
+#define TX_PKT_REG_EXCEPT0_BASE_ADDR					0x0300
+#define TX_PKT_REG_EXCEPT1_BASE_ADDR					0x0320
+#define TX_PKT_REG_EXCEPT2_BASE_ADDR					0x0340
+#define TX_PKT_REG_EXCEPT3_BASE_ADDR					0x0360
+#define TX_PKT_REG_EXCEPT4_BASE_ADDR					0x0380
+#define TX_PKT_REG_GAMUT_P0_BASE_ADDR					0x03A0
+#define TX_PKT_REG_GAMUT_P1_1_BASE_ADDR					0x03C0
+#define TX_PKT_REG_GAMUT_P1_2_BASE_ADDR					0x03E0
+
+#define TX_RX_EDID_OFFSET						0x0600
+
+/* HDMI OTHER registers */
+
+#define HDMI_OTHER_CTRL0						0x8000
+#define HDMI_OTHER_CTRL1						0x8001
+	#define HDMI_OTHER_CTRL1_POWER_ON				BIT(15)
+	#define HDMI_OTHER_CTRL1_HDMI_AUDIO_CLOCK_ON			BIT(13)
+
+#define HDMI_OTHER_STATUS0						0x8002
+#define HDMI_OTHER_CTRL2						0x8003
+#define HDMI_OTHER_INTR_MASKN						0x8004
+	#define HDMI_OTHER_INTR_MASKN_TX_EDID_INT_RISE			BIT(2)
+	#define HDMI_OTHER_INTR_MASKN_TX_HPD_INT_FALL			BIT(1)
+	#define HDMI_OTHER_INTR_MASKN_TX_HPD_INT_RISE			BIT(0)
+
+#define HDMI_OTHER_INTR_STAT						0x8005
+	#define HDMI_OTHER_INTR_STAT_EDID_RISING			BIT(2)
+	#define HDMI_OTHER_INTR_STAT_HPD_FALLING			BIT(1)
+	#define HDMI_OTHER_INTR_STAT_HPD_RISING				BIT(0)
+
+#define HDMI_OTHER_INTR_STAT_CLR					0x8006
+	#define HDMI_OTHER_INTR_STAT_CLR_EDID_RISING			BIT(2)
+	#define HDMI_OTHER_INTR_STAT_CLR_HPD_FALLING			BIT(1)
+	#define HDMI_OTHER_INTR_STAT_CLR_HPD_RISING			BIT(0)
+
+#define HDMI_OTHER_AVI_INTR_MASKN0					0x8008
+#define HDMI_OTHER_AVI_INTR_MASKN1					0x8009
+#define HDMI_OTHER_RX_AINFO_INTR_MASKN0					0x800a
+#define HDMI_OTHER_RX_AINFO_INTR_MASKN1					0x800b
+#define HDMI_OTHER_RX_PACKET_INTR_CLR					0x800c
+
+#endif /* __MESON_TRANSWITCH_HDMI_H__ */
diff -Naur a/drivers/gpu/drm/meson/meson_vclk.c b/drivers/gpu/drm/meson/meson_vclk.c
--- a/drivers/gpu/drm/meson/meson_vclk.c	2021-10-31 16:53:10.000000000 -0400
+++ b/drivers/gpu/drm/meson/meson_vclk.c	2021-10-31 20:41:20.000000000 -0400
@@ -732,6 +732,11 @@
 			return MODE_CLOCK_HIGH;
 	}
 
+	if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8) ||
+	    meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8B) ||
+	    meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8M2))
+		return MODE_OK;
+
 	if (meson_hdmi_pll_find_params(priv, freq, &m, &frac, &od))
 		return MODE_OK;
 
@@ -784,6 +789,11 @@
 			return MODE_CLOCK_HIGH;
 	}
 
+	if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8) ||
+	    meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8B) ||
+	    meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8M2))
+		return MODE_OK;
+
 	for (i = 0 ; params[i].pixel_freq ; ++i) {
 		DRM_DEBUG_DRIVER("i = %d pixel_freq = %d alt = %d\n",
 				 i, params[i].pixel_freq,
@@ -1024,6 +1034,128 @@
 	regmap_update_bits(priv->hhi, HHI_VID_CLK_CNTL, VCLK_EN, VCLK_EN);
 }
 
+static int meson_vclk_set_rate_exclusive(struct meson_drm *priv,
+					 enum vpu_bulk_clk_id clk_id,
+					 unsigned int rate_khz)
+{
+	struct clk *clk = priv->vid_clks[clk_id].clk;
+	int ret;
+
+	ret = clk_set_rate_exclusive(clk, rate_khz * 1000UL);
+	if (ret)
+		return ret;
+
+	priv->vid_clk_rate_exclusive[clk_id] = true;
+
+	return 0;
+}
+
+static void meson_vclk_disable_ccf(struct meson_drm *priv)
+{
+	unsigned int i;
+
+	/* allow all clocks to be changed in _enable again */
+	for (i = 0; i < VPU_VID_CLK_NUM; i++) {
+		if (!priv->vid_clk_rate_exclusive[i])
+			continue;
+
+		clk_rate_exclusive_put(priv->vid_clks[i].clk);
+		priv->vid_clk_rate_exclusive[i] = false;
+	}
+
+	if (priv->clk_dac_enabled) {
+		clk_disable(priv->clk_dac);
+		priv->clk_dac_enabled = false;
+	}
+
+	if (priv->clk_venc_enabled) {
+		clk_disable(priv->clk_venc);
+		priv->clk_venc_enabled = false;
+	}
+}
+
+static int meson_vclk_enable_ccf(struct meson_drm *priv, unsigned int target,
+				 bool hdmi_use_enci, unsigned int phy_freq,
+				 unsigned int dac_freq, unsigned int venc_freq)
+{
+	enum vpu_bulk_clk_id venc_clk_id, dac_clk_id;
+	int ret;
+
+	if (target == MESON_VCLK_TARGET_CVBS || hdmi_use_enci)
+		venc_clk_id = VPU_VID_CLK_CTS_ENCI;
+	else
+		venc_clk_id = VPU_VID_CLK_CTS_ENCP;
+
+	if (target == MESON_VCLK_TARGET_CVBS)
+		dac_clk_id = VPU_VID_CLK_CTS_VDAC0;
+	else
+		dac_clk_id = VPU_VID_CLK_HDMI_TX_PIXEL;
+
+	/*
+	 * The TMDS clock also updates the PLL. Protect the PLL rate so all
+	 * following clocks are derived from the PLL setting which matches the
+	 * TMDS clock.
+	 */
+	ret = meson_vclk_set_rate_exclusive(priv, VPU_VID_CLK_TMDS, phy_freq);
+	if (ret) {
+		dev_err(priv->dev, "Failed to set TMDS clock to %ukHz: %d\n",
+			phy_freq, ret);
+		goto out_enable_clocks;
+	}
+
+	/*
+	 * The DAC clock may be derived from a parent of the VENC clock so we
+	 * must protect the VENC clock from changing it's rate. This works
+	 * because the DAC freq can be divided by the VENC clock.
+	 */
+	ret = meson_vclk_set_rate_exclusive(priv, venc_clk_id, venc_freq);
+	if (ret) {
+		dev_warn(priv->dev,
+			 "Failed to set VENC clock to %ukHz while TMDS clock is %ukHz: %d\n",
+			 venc_freq, phy_freq, ret);
+		goto out_enable_clocks;
+	}
+
+	priv->clk_venc = priv->vid_clks[venc_clk_id].clk;
+
+	/*
+	 * after changing any of the VID_PLL_* clocks (which can happen when
+	 * update the VENC clock rate) we need to assert and then de-assert the
+	 * VID_DIVIDER_CNTL_* reset lines.
+	 */
+	reset_control_bulk_assert(VPU_RESET_VID_PLL_NUM, priv->vid_pll_resets);
+	reset_control_bulk_deassert(VPU_RESET_VID_PLL_NUM, priv->vid_pll_resets);
+
+	ret = meson_vclk_set_rate_exclusive(priv, dac_clk_id, dac_freq);
+	if (ret) {
+		dev_warn(priv->dev,
+			 "Failed to set pixel clock to %ukHz while TMDS clock is %ukHz: %d\n",
+			 dac_freq, phy_freq, ret);
+		goto out_enable_clocks;
+	}
+
+	priv->clk_dac = priv->vid_clks[dac_clk_id].clk;
+
+out_enable_clocks:
+	ret = clk_enable(priv->clk_venc);
+	if (ret)
+		dev_err(priv->dev,
+			"Failed to re-enable the VENC clock at %ukHz: %d\n",
+			venc_freq, ret);
+	else
+		priv->clk_venc_enabled = true;
+
+	ret = clk_enable(priv->clk_dac);
+	if (ret)
+		dev_err(priv->dev,
+			"Failed to re-enable the pixel clock at %ukHz: %d\n",
+			dac_freq, ret);
+	else
+		priv->clk_dac_enabled = true;
+
+	return ret;
+}
+
 void meson_vclk_setup(struct meson_drm *priv, unsigned int target,
 		      unsigned int phy_freq, unsigned int vclk_freq,
 		      unsigned int venc_freq, unsigned int dac_freq,
@@ -1034,6 +1166,20 @@
 	unsigned int hdmi_tx_div;
 	unsigned int venc_div;
 
+	if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8) ||
+	    meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8B) ||
+	    meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8M2)) {
+		/* CVBS video clocks are generated off a 1296MHz base clock */
+		if (target == MESON_VCLK_TARGET_CVBS)
+			phy_freq = 1296000;
+
+		dev_err(priv->dev, "%s(target: %u, phy: %u, dac: %u, venc: %u, hdmi_use_enci: %u)\n", __func__, target, phy_freq, dac_freq, venc_freq, hdmi_use_enci);
+		meson_vclk_disable_ccf(priv);
+		meson_vclk_enable_ccf(priv, target, hdmi_use_enci, phy_freq,
+				      dac_freq, venc_freq);
+		return;
+	}
+
 	if (target == MESON_VCLK_TARGET_CVBS) {
 		meson_venci_cvbs_clock_config(priv);
 		return;
diff -Naur a/drivers/gpu/drm/meson/meson_venc.c b/drivers/gpu/drm/meson/meson_venc.c
--- a/drivers/gpu/drm/meson/meson_venc.c	2021-10-31 16:53:10.000000000 -0400
+++ b/drivers/gpu/drm/meson/meson_venc.c	2021-10-31 20:41:20.000000000 -0400
@@ -1749,31 +1749,56 @@
 {
 	writel_relaxed(VENC_INTCTRL_ENCI_LNRST_INT_EN,
 		       priv->io_base + _REG(VENC_INTCTRL));
-	regmap_update_bits(priv->hhi, HHI_GCLK_MPEG2, BIT(25), BIT(25));
+
+	if (priv->intr_clks[0].clk) {
+		if (!priv->intr_clks_enabled) {
+			int ret;
+
+			ret = clk_bulk_enable(VPU_INTR_CLK_NUM, priv->intr_clks);
+			if (ret)
+				dev_err(priv->dev,
+					"Failed to enable the interrupt clocks\n");
+			else
+				priv->intr_clks_enabled = true;
+		}
+	} else {
+		regmap_update_bits(priv->hhi, HHI_GCLK_MPEG2, BIT(25), BIT(25));
+	}
 }
 
 void meson_venc_disable_vsync(struct meson_drm *priv)
 {
-	regmap_update_bits(priv->hhi, HHI_GCLK_MPEG2, BIT(25), 0);
+	if (priv->intr_clks[0].clk) {
+		if (priv->intr_clks_enabled) {
+			clk_bulk_disable(VPU_INTR_CLK_NUM, priv->intr_clks);
+			priv->intr_clks_enabled = false;
+		}
+	} else {
+		regmap_update_bits(priv->hhi, HHI_GCLK_MPEG2, BIT(25), 0);
+	}
+
 	writel_relaxed(0, priv->io_base + _REG(VENC_INTCTRL));
 }
 
 void meson_venc_init(struct meson_drm *priv)
 {
-	/* Disable CVBS VDAC */
-	if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A)) {
-		regmap_write(priv->hhi, HHI_VDAC_CNTL0_G12A, 0);
-		regmap_write(priv->hhi, HHI_VDAC_CNTL1_G12A, 8);
-	} else {
-		regmap_write(priv->hhi, HHI_VDAC_CNTL0, 0);
-		regmap_write(priv->hhi, HHI_VDAC_CNTL1, 8);
+	if (priv->hhi) {
+		/* Disable CVBS VDAC */
+		if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A)) {
+			regmap_write(priv->hhi, HHI_VDAC_CNTL0_G12A, 0);
+			regmap_write(priv->hhi, HHI_VDAC_CNTL1_G12A, 8);
+		} else {
+			regmap_write(priv->hhi, HHI_VDAC_CNTL0, 0);
+			regmap_write(priv->hhi, HHI_VDAC_CNTL1, 8);
+		}
 	}
 
 	/* Power Down Dacs */
 	writel_relaxed(0xff, priv->io_base + _REG(VENC_VDAC_SETTING));
 
 	/* Disable HDMI PHY */
-	regmap_write(priv->hhi, HHI_HDMI_PHY_CNTL0, 0);
+	if (priv->hhi)
+		regmap_write(priv->hhi, HHI_HDMI_PHY_CNTL0, 0);
 
 	/* Disable HDMI */
 	writel_bits_relaxed(VPU_HDMI_ENCI_DATA_TO_HDMI |
diff -Naur a/drivers/gpu/drm/meson/meson_venc_cvbs.c b/drivers/gpu/drm/meson/meson_venc_cvbs.c
--- a/drivers/gpu/drm/meson/meson_venc_cvbs.c	2021-10-31 16:53:10.000000000 -0400
+++ b/drivers/gpu/drm/meson/meson_venc_cvbs.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,293 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-or-later
-/*
- * Copyright (C) 2016 BayLibre, SAS
- * Author: Neil Armstrong <narmstrong@baylibre.com>
- * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
- * Copyright (C) 2014 Endless Mobile
- *
- * Written by:
- *     Jasper St. Pierre <jstpierre@mecheye.net>
- */
-
-#include <linux/export.h>
-#include <linux/of_graph.h>
-
-#include <drm/drm_atomic_helper.h>
-#include <drm/drm_device.h>
-#include <drm/drm_edid.h>
-#include <drm/drm_probe_helper.h>
-#include <drm/drm_print.h>
-
-#include "meson_registers.h"
-#include "meson_vclk.h"
-#include "meson_venc_cvbs.h"
-
-/* HHI VDAC Registers */
-#define HHI_VDAC_CNTL0		0x2F4 /* 0xbd offset in data sheet */
-#define HHI_VDAC_CNTL0_G12A	0x2EC /* 0xbd offset in data sheet */
-#define HHI_VDAC_CNTL1		0x2F8 /* 0xbe offset in data sheet */
-#define HHI_VDAC_CNTL1_G12A	0x2F0 /* 0xbe offset in data sheet */
-
-struct meson_venc_cvbs {
-	struct drm_encoder	encoder;
-	struct drm_connector	connector;
-	struct meson_drm	*priv;
-};
-#define encoder_to_meson_venc_cvbs(x) \
-	container_of(x, struct meson_venc_cvbs, encoder)
-
-#define connector_to_meson_venc_cvbs(x) \
-	container_of(x, struct meson_venc_cvbs, connector)
-
-/* Supported Modes */
-
-struct meson_cvbs_mode meson_cvbs_modes[MESON_CVBS_MODES_COUNT] = {
-	{ /* PAL */
-		.enci = &meson_cvbs_enci_pal,
-		.mode = {
-			DRM_MODE("720x576i", DRM_MODE_TYPE_DRIVER, 13500,
-				 720, 732, 795, 864, 0, 576, 580, 586, 625, 0,
-				 DRM_MODE_FLAG_INTERLACE),
-			.picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3,
-		},
-	},
-	{ /* NTSC */
-		.enci = &meson_cvbs_enci_ntsc,
-		.mode = {
-			DRM_MODE("720x480i", DRM_MODE_TYPE_DRIVER, 13500,
-				720, 739, 801, 858, 0, 480, 488, 494, 525, 0,
-				DRM_MODE_FLAG_INTERLACE),
-			.picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3,
-		},
-	},
-};
-
-static const struct meson_cvbs_mode *
-meson_cvbs_get_mode(const struct drm_display_mode *req_mode)
-{
-	int i;
-
-	for (i = 0; i < MESON_CVBS_MODES_COUNT; ++i) {
-		struct meson_cvbs_mode *meson_mode = &meson_cvbs_modes[i];
-
-		if (drm_mode_match(req_mode, &meson_mode->mode,
-				   DRM_MODE_MATCH_TIMINGS |
-				   DRM_MODE_MATCH_CLOCK |
-				   DRM_MODE_MATCH_FLAGS |
-				   DRM_MODE_MATCH_3D_FLAGS))
-			return meson_mode;
-	}
-
-	return NULL;
-}
-
-/* Connector */
-
-static void meson_cvbs_connector_destroy(struct drm_connector *connector)
-{
-	drm_connector_cleanup(connector);
-}
-
-static enum drm_connector_status
-meson_cvbs_connector_detect(struct drm_connector *connector, bool force)
-{
-	/* FIXME: Add load-detect or jack-detect if possible */
-	return connector_status_connected;
-}
-
-static int meson_cvbs_connector_get_modes(struct drm_connector *connector)
-{
-	struct drm_device *dev = connector->dev;
-	struct drm_display_mode *mode;
-	int i;
-
-	for (i = 0; i < MESON_CVBS_MODES_COUNT; ++i) {
-		struct meson_cvbs_mode *meson_mode = &meson_cvbs_modes[i];
-
-		mode = drm_mode_duplicate(dev, &meson_mode->mode);
-		if (!mode) {
-			DRM_ERROR("Failed to create a new display mode\n");
-			return 0;
-		}
-
-		drm_mode_probed_add(connector, mode);
-	}
-
-	return i;
-}
-
-static int meson_cvbs_connector_mode_valid(struct drm_connector *connector,
-					   struct drm_display_mode *mode)
-{
-	/* Validate the modes added in get_modes */
-	return MODE_OK;
-}
-
-static const struct drm_connector_funcs meson_cvbs_connector_funcs = {
-	.detect			= meson_cvbs_connector_detect,
-	.fill_modes		= drm_helper_probe_single_connector_modes,
-	.destroy		= meson_cvbs_connector_destroy,
-	.reset			= drm_atomic_helper_connector_reset,
-	.atomic_duplicate_state	= drm_atomic_helper_connector_duplicate_state,
-	.atomic_destroy_state	= drm_atomic_helper_connector_destroy_state,
-};
-
-static const
-struct drm_connector_helper_funcs meson_cvbs_connector_helper_funcs = {
-	.get_modes	= meson_cvbs_connector_get_modes,
-	.mode_valid	= meson_cvbs_connector_mode_valid,
-};
-
-/* Encoder */
-
-static void meson_venc_cvbs_encoder_destroy(struct drm_encoder *encoder)
-{
-	drm_encoder_cleanup(encoder);
-}
-
-static const struct drm_encoder_funcs meson_venc_cvbs_encoder_funcs = {
-	.destroy        = meson_venc_cvbs_encoder_destroy,
-};
-
-static int meson_venc_cvbs_encoder_atomic_check(struct drm_encoder *encoder,
-					struct drm_crtc_state *crtc_state,
-					struct drm_connector_state *conn_state)
-{
-	if (meson_cvbs_get_mode(&crtc_state->mode))
-		return 0;
-
-	return -EINVAL;
-}
-
-static void meson_venc_cvbs_encoder_disable(struct drm_encoder *encoder)
-{
-	struct meson_venc_cvbs *meson_venc_cvbs =
-					encoder_to_meson_venc_cvbs(encoder);
-	struct meson_drm *priv = meson_venc_cvbs->priv;
-
-	/* Disable CVBS VDAC */
-	if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A)) {
-		regmap_write(priv->hhi, HHI_VDAC_CNTL0_G12A, 0);
-		regmap_write(priv->hhi, HHI_VDAC_CNTL1_G12A, 0);
-	} else {
-		regmap_write(priv->hhi, HHI_VDAC_CNTL0, 0);
-		regmap_write(priv->hhi, HHI_VDAC_CNTL1, 8);
-	}
-}
-
-static void meson_venc_cvbs_encoder_enable(struct drm_encoder *encoder)
-{
-	struct meson_venc_cvbs *meson_venc_cvbs =
-					encoder_to_meson_venc_cvbs(encoder);
-	struct meson_drm *priv = meson_venc_cvbs->priv;
-
-	/* VDAC0 source is not from ATV */
-	writel_bits_relaxed(VENC_VDAC_SEL_ATV_DMD, 0,
-			    priv->io_base + _REG(VENC_VDAC_DACSEL0));
-
-	if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXBB)) {
-		regmap_write(priv->hhi, HHI_VDAC_CNTL0, 1);
-		regmap_write(priv->hhi, HHI_VDAC_CNTL1, 0);
-	} else if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXM) ||
-		 meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXL)) {
-		regmap_write(priv->hhi, HHI_VDAC_CNTL0, 0xf0001);
-		regmap_write(priv->hhi, HHI_VDAC_CNTL1, 0);
-	} else if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A)) {
-		regmap_write(priv->hhi, HHI_VDAC_CNTL0_G12A, 0x906001);
-		regmap_write(priv->hhi, HHI_VDAC_CNTL1_G12A, 0);
-	}
-}
-
-static void meson_venc_cvbs_encoder_mode_set(struct drm_encoder *encoder,
-				   struct drm_display_mode *mode,
-				   struct drm_display_mode *adjusted_mode)
-{
-	const struct meson_cvbs_mode *meson_mode = meson_cvbs_get_mode(mode);
-	struct meson_venc_cvbs *meson_venc_cvbs =
-					encoder_to_meson_venc_cvbs(encoder);
-	struct meson_drm *priv = meson_venc_cvbs->priv;
-
-	if (meson_mode) {
-		meson_venci_cvbs_mode_set(priv, meson_mode->enci);
-
-		/* Setup 27MHz vclk2 for ENCI and VDAC */
-		meson_vclk_setup(priv, MESON_VCLK_TARGET_CVBS,
-				 MESON_VCLK_CVBS, MESON_VCLK_CVBS,
-				 MESON_VCLK_CVBS, MESON_VCLK_CVBS,
-				 true);
-	}
-}
-
-static const struct drm_encoder_helper_funcs
-				meson_venc_cvbs_encoder_helper_funcs = {
-	.atomic_check	= meson_venc_cvbs_encoder_atomic_check,
-	.disable	= meson_venc_cvbs_encoder_disable,
-	.enable		= meson_venc_cvbs_encoder_enable,
-	.mode_set	= meson_venc_cvbs_encoder_mode_set,
-};
-
-static bool meson_venc_cvbs_connector_is_available(struct meson_drm *priv)
-{
-	struct device_node *remote;
-
-	remote = of_graph_get_remote_node(priv->dev->of_node, 0, 0);
-	if (!remote)
-		return false;
-
-	of_node_put(remote);
-	return true;
-}
-
-int meson_venc_cvbs_create(struct meson_drm *priv)
-{
-	struct drm_device *drm = priv->drm;
-	struct meson_venc_cvbs *meson_venc_cvbs;
-	struct drm_connector *connector;
-	struct drm_encoder *encoder;
-	int ret;
-
-	if (!meson_venc_cvbs_connector_is_available(priv)) {
-		dev_info(drm->dev, "CVBS Output connector not available\n");
-		return 0;
-	}
-
-	meson_venc_cvbs = devm_kzalloc(priv->dev, sizeof(*meson_venc_cvbs),
-				       GFP_KERNEL);
-	if (!meson_venc_cvbs)
-		return -ENOMEM;
-
-	meson_venc_cvbs->priv = priv;
-	encoder = &meson_venc_cvbs->encoder;
-	connector = &meson_venc_cvbs->connector;
-
-	/* Connector */
-
-	drm_connector_helper_add(connector,
-				 &meson_cvbs_connector_helper_funcs);
-
-	ret = drm_connector_init(drm, connector, &meson_cvbs_connector_funcs,
-				 DRM_MODE_CONNECTOR_Composite);
-	if (ret) {
-		dev_err(priv->dev, "Failed to init CVBS connector\n");
-		return ret;
-	}
-
-	connector->interlace_allowed = 1;
-
-	/* Encoder */
-
-	drm_encoder_helper_add(encoder, &meson_venc_cvbs_encoder_helper_funcs);
-
-	ret = drm_encoder_init(drm, encoder, &meson_venc_cvbs_encoder_funcs,
-			       DRM_MODE_ENCODER_TVDAC, "meson_venc_cvbs");
-	if (ret) {
-		dev_err(priv->dev, "Failed to init CVBS encoder\n");
-		return ret;
-	}
-
-	encoder->possible_crtcs = BIT(0);
-
-	drm_connector_attach_encoder(connector, encoder);
-
-	return 0;
-}
diff -Naur a/drivers/gpu/drm/meson/meson_venc_cvbs.h b/drivers/gpu/drm/meson/meson_venc_cvbs.h
--- a/drivers/gpu/drm/meson/meson_venc_cvbs.h	2021-10-31 16:53:10.000000000 -0400
+++ b/drivers/gpu/drm/meson/meson_venc_cvbs.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,29 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0-or-later */
-/*
- * Copyright (C) 2016 BayLibre, SAS
- * Author: Neil Armstrong <narmstrong@baylibre.com>
- * Copyright (C) 2014 Endless Mobile
- *
- * Written by:
- *     Jasper St. Pierre <jstpierre@mecheye.net>
- */
-
-#ifndef __MESON_VENC_CVBS_H
-#define __MESON_VENC_CVBS_H
-
-#include "meson_drv.h"
-#include "meson_venc.h"
-
-struct meson_cvbs_mode {
-	struct meson_cvbs_enci_mode *enci;
-	struct drm_display_mode mode;
-};
-
-#define MESON_CVBS_MODES_COUNT	2
-
-/* Modes supported by the CVBS output */
-extern struct meson_cvbs_mode meson_cvbs_modes[MESON_CVBS_MODES_COUNT];
-
-int meson_venc_cvbs_create(struct meson_drm *priv);
-
-#endif /* __MESON_VENC_CVBS_H */
diff -Naur a/drivers/gpu/drm/meson/meson_viu.c b/drivers/gpu/drm/meson/meson_viu.c
--- a/drivers/gpu/drm/meson/meson_viu.c	2021-10-31 16:53:10.000000000 -0400
+++ b/drivers/gpu/drm/meson/meson_viu.c	2021-10-31 20:41:20.000000000 -0400
@@ -436,10 +436,22 @@
 
 	/* Initialize OSD1 fifo control register */
 	reg = VIU_OSD_DDR_PRIORITY_URGENT |
-		VIU_OSD_HOLD_FIFO_LINES(31) |
-		VIU_OSD_FIFO_DEPTH_VAL(32) | /* fifo_depth_val: 32*8=256 */
-		VIU_OSD_WORDS_PER_BURST(4) | /* 4 words in 1 burst */
-		VIU_OSD_FIFO_LIMITS(2);      /* fifo_lim: 2*16=32 */
+	      VIU_OSD_FIFO_DEPTH_VAL(32) | /* fifo_depth_val: 32*8=256 */
+	      VIU_OSD_WORDS_PER_BURST(4) | /* 4 words in 1 burst */
+	      VIU_OSD_FIFO_LIMITS(2);      /* fifo_lim: 2*16=32 */
+
+	/*
+	 * When using AFBC on newer SoCs the AFBC encoder has to be reset. To
+	 * leave time for that we need hold more lines to avoid glitches.
+	 * On the 32-bit SoCs however we need to hold fewer lines because
+	 * otherwise screen tearing can occur (for example in kmscube).
+	 */
+	if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8) ||
+	    meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8B) ||
+	    meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8M2))
+		reg |= VIU_OSD_HOLD_FIFO_LINES(12);
+	else
+		reg |= VIU_OSD_HOLD_FIFO_LINES(31);
 
 	if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A))
 		reg |= VIU_OSD_BURST_LENGTH_32;
@@ -449,13 +461,17 @@
 	writel_relaxed(reg, priv->io_base + _REG(VIU_OSD1_FIFO_CTRL_STAT));
 	writel_relaxed(reg, priv->io_base + _REG(VIU_OSD2_FIFO_CTRL_STAT));
 
-	/* Set OSD alpha replace value */
-	writel_bits_relaxed(0xff << OSD_REPLACE_SHIFT,
-			    0xff << OSD_REPLACE_SHIFT,
-			    priv->io_base + _REG(VIU_OSD1_CTRL_STAT2));
-	writel_bits_relaxed(0xff << OSD_REPLACE_SHIFT,
-			    0xff << OSD_REPLACE_SHIFT,
-			    priv->io_base + _REG(VIU_OSD2_CTRL_STAT2));
+	if (!meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8) &&
+	    !meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8B) &&
+	    !meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8M2)) {
+		/* Set OSD alpha replace value */
+		writel_bits_relaxed(0xff << OSD_REPLACE_SHIFT,
+				    0xff << OSD_REPLACE_SHIFT,
+				    priv->io_base + _REG(VIU_OSD1_CTRL_STAT2));
+		writel_bits_relaxed(0xff << OSD_REPLACE_SHIFT,
+				    0xff << OSD_REPLACE_SHIFT,
+				    priv->io_base + _REG(VIU_OSD2_CTRL_STAT2));
+	}
 
 	/* Disable VD1 AFBC */
 	/* di_mif0_en=0 mif0_to_vpp_en=0 di_mad_en=0 and afbc vd1 set=0*/
diff -Naur a/drivers/iio/adc/meson_saradc.c b/drivers/iio/adc/meson_saradc.c
--- a/drivers/iio/adc/meson_saradc.c	2021-10-31 16:53:10.000000000 -0400
+++ b/drivers/iio/adc/meson_saradc.c	2021-10-31 20:41:20.000000000 -0400
@@ -1230,35 +1230,31 @@
 		return ret;
 
 	priv->clkin = devm_clk_get(&pdev->dev, "clkin");
-	if (IS_ERR(priv->clkin)) {
-		dev_err(&pdev->dev, "failed to get clkin\n");
-		return PTR_ERR(priv->clkin);
-	}
+	if (IS_ERR(priv->clkin))
+		return dev_err_probe(&pdev->dev, PTR_ERR(priv->clkin),
+				     "failed to get clkin\n");
 
 	priv->core_clk = devm_clk_get(&pdev->dev, "core");
-	if (IS_ERR(priv->core_clk)) {
-		dev_err(&pdev->dev, "failed to get core clk\n");
-		return PTR_ERR(priv->core_clk);
-	}
+	if (IS_ERR(priv->core_clk))
+		return dev_err_probe(&pdev->dev, PTR_ERR(priv->core_clk),
+				     "failed to get core clk\n");
 
 	priv->adc_clk = devm_clk_get(&pdev->dev, "adc_clk");
 	if (IS_ERR(priv->adc_clk)) {
-		if (PTR_ERR(priv->adc_clk) == -ENOENT) {
+		if (PTR_ERR(priv->adc_clk) == -ENOENT)
 			priv->adc_clk = NULL;
-		} else {
-			dev_err(&pdev->dev, "failed to get adc clk\n");
-			return PTR_ERR(priv->adc_clk);
-		}
+		else
+			return dev_err_probe(&pdev->dev, PTR_ERR(priv->adc_clk),
+					     "failed to get adc clk\n");
 	}
 
 	priv->adc_sel_clk = devm_clk_get(&pdev->dev, "adc_sel");
 	if (IS_ERR(priv->adc_sel_clk)) {
-		if (PTR_ERR(priv->adc_sel_clk) == -ENOENT) {
+		if (PTR_ERR(priv->adc_sel_clk) == -ENOENT)
 			priv->adc_sel_clk = NULL;
-		} else {
-			dev_err(&pdev->dev, "failed to get adc_sel clk\n");
-			return PTR_ERR(priv->adc_sel_clk);
-		}
+		else
+			return dev_err_probe(&pdev->dev, PTR_ERR(priv->adc_sel_clk),
+					     "failed to get adc_sel clk\n");
 	}
 
 	/* on pre-GXBB SoCs the SAR ADC itself provides the ADC clock: */
@@ -1269,10 +1265,9 @@
 	}
 
 	priv->vref = devm_regulator_get(&pdev->dev, "vref");
-	if (IS_ERR(priv->vref)) {
-		dev_err(&pdev->dev, "failed to get vref regulator\n");
-		return PTR_ERR(priv->vref);
-	}
+	if (IS_ERR(priv->vref))
+		return dev_err_probe(&pdev->dev, PTR_ERR(priv->vref),
+				     "failed to get vref regulator\n");
 
 	priv->calibscale = MILLION;
 
diff -Naur a/drivers/mmc/host/Kconfig b/drivers/mmc/host/Kconfig
--- a/drivers/mmc/host/Kconfig	2021-10-31 16:53:10.000000000 -0400
+++ b/drivers/mmc/host/Kconfig	2021-10-31 20:41:20.000000000 -0400
@@ -429,6 +429,7 @@
 	tristate "Amlogic S905/GX*/AXG SD/MMC Host Controller support"
 	depends on ARCH_MESON|| COMPILE_TEST
 	depends on COMMON_CLK
+	select REGMAP_MMIO
 	help
 	  This selects support for the Amlogic SD/MMC Host Controller
 	  found on the S905/GX*/AXG family of SoCs.  This controller is
diff -Naur a/drivers/mmc/host/meson-gx-mmc.c b/drivers/mmc/host/meson-gx-mmc.c
--- a/drivers/mmc/host/meson-gx-mmc.c	2021-10-31 16:53:10.000000000 -0400
+++ b/drivers/mmc/host/meson-gx-mmc.c	2021-10-31 20:41:20.000000000 -0400
@@ -22,6 +22,7 @@
 #include <linux/io.h>
 #include <linux/clk.h>
 #include <linux/clk-provider.h>
+#include <linux/regmap.h>
 #include <linux/regulator/consumer.h>
 #include <linux/reset.h>
 #include <linux/interrupt.h>
@@ -151,7 +152,8 @@
 	struct	mmc_host	*mmc;
 	struct	mmc_command	*cmd;
 
-	void __iomem *regs;
+	struct regmap *regmap;
+
 	struct clk *core_clk;
 	struct clk *mux_clk;
 	struct clk *mmc_clk;
@@ -165,7 +167,6 @@
 
 	unsigned int bounce_buf_size;
 	void *bounce_buf;
-	void __iomem *bounce_iomem_buf;
 	dma_addr_t bounce_dma_addr;
 	struct sd_emmc_desc *descs;
 	dma_addr_t descs_dma_addr;
@@ -318,8 +319,6 @@
  */
 static void meson_mmc_clk_gate(struct meson_host *host)
 {
-	u32 cfg;
-
 	if (host->pins_clk_gate) {
 		pinctrl_select_state(host->pinctrl, host->pins_clk_gate);
 	} else {
@@ -327,23 +326,18 @@
 		 * If the pinmux is not provided - default to the classic and
 		 * unsafe method
 		 */
-		cfg = readl(host->regs + SD_EMMC_CFG);
-		cfg |= CFG_STOP_CLOCK;
-		writel(cfg, host->regs + SD_EMMC_CFG);
+		regmap_update_bits(host->regmap, SD_EMMC_CFG, CFG_STOP_CLOCK,
+				   CFG_STOP_CLOCK);
 	}
 }
 
 static void meson_mmc_clk_ungate(struct meson_host *host)
 {
-	u32 cfg;
-
 	if (host->pins_clk_gate)
 		pinctrl_select_default_state(host->dev);
 
 	/* Make sure the clock is not stopped in the controller */
-	cfg = readl(host->regs + SD_EMMC_CFG);
-	cfg &= ~CFG_STOP_CLOCK;
-	writel(cfg, host->regs + SD_EMMC_CFG);
+	regmap_update_bits(host->regmap, SD_EMMC_CFG, CFG_STOP_CLOCK, 0);
 }
 
 static int meson_mmc_clk_set(struct meson_host *host, unsigned long rate,
@@ -351,7 +345,6 @@
 {
 	struct mmc_host *mmc = host->mmc;
 	int ret;
-	u32 cfg;
 
 	/* Same request - bail-out */
 	if (host->ddr == ddr && host->req_rate == rate)
@@ -367,18 +360,16 @@
 		return 0;
 
 	/* Stop the clock during rate change to avoid glitches */
-	cfg = readl(host->regs + SD_EMMC_CFG);
-	cfg |= CFG_STOP_CLOCK;
-	writel(cfg, host->regs + SD_EMMC_CFG);
+	regmap_update_bits(host->regmap, SD_EMMC_CFG, CFG_STOP_CLOCK,
+			   CFG_STOP_CLOCK);
 
 	if (ddr) {
 		/* DDR modes require higher module clock */
 		rate <<= 1;
-		cfg |= CFG_DDR;
+		regmap_update_bits(host->regmap, SD_EMMC_CFG, CFG_DDR, CFG_DDR);
 	} else {
-		cfg &= ~CFG_DDR;
+		regmap_update_bits(host->regmap, SD_EMMC_CFG, CFG_DDR, 0);
 	}
-	writel(cfg, host->regs + SD_EMMC_CFG);
 	host->ddr = ddr;
 
 	ret = clk_set_rate(host->mmc_clk, rate);
@@ -412,7 +403,7 @@
  * generating the MMC clock.  Use the clock framework to create and
  * manage these clocks.
  */
-static int meson_mmc_clk_init(struct meson_host *host)
+static int meson_mmc_clk_init(struct meson_host *host, void __iomem *regs)
 {
 	struct clk_init_data init;
 	struct clk_mux *mux;
@@ -429,7 +420,7 @@
 	clk_reg |= FIELD_PREP(CLK_CORE_PHASE_MASK, CLK_PHASE_180);
 	clk_reg |= FIELD_PREP(CLK_TX_PHASE_MASK, CLK_PHASE_0);
 	clk_reg |= FIELD_PREP(CLK_RX_PHASE_MASK, CLK_PHASE_0);
-	writel(clk_reg, host->regs + SD_EMMC_CLOCK);
+	regmap_write(host->regmap, SD_EMMC_CLOCK, clk_reg);
 
 	/* get the mux parents */
 	for (i = 0; i < MUX_CLK_NUM_PARENTS; i++) {
@@ -457,7 +448,7 @@
 	init.parent_names = mux_parent_names;
 	init.num_parents = MUX_CLK_NUM_PARENTS;
 
-	mux->reg = host->regs + SD_EMMC_CLOCK;
+	mux->reg = regs + SD_EMMC_CLOCK;
 	mux->shift = __ffs(CLK_SRC_MASK);
 	mux->mask = CLK_SRC_MASK >> mux->shift;
 	mux->hw.init = &init;
@@ -479,7 +470,7 @@
 	init.parent_names = clk_parent;
 	init.num_parents = 1;
 
-	div->reg = host->regs + SD_EMMC_CLOCK;
+	div->reg = regs + SD_EMMC_CLOCK;
 	div->shift = __ffs(CLK_DIV_MASK);
 	div->width = __builtin_popcountl(CLK_DIV_MASK);
 	div->hw.init = &init;
@@ -500,21 +491,15 @@
 
 static void meson_mmc_disable_resampling(struct meson_host *host)
 {
-	unsigned int val = readl(host->regs + host->data->adjust);
-
-	val &= ~ADJUST_ADJ_EN;
-	writel(val, host->regs + host->data->adjust);
+	regmap_update_bits(host->regmap, host->data->adjust, ADJUST_ADJ_EN, 0);
 }
 
 static void meson_mmc_reset_resampling(struct meson_host *host)
 {
-	unsigned int val;
-
 	meson_mmc_disable_resampling(host);
 
-	val = readl(host->regs + host->data->adjust);
-	val &= ~ADJUST_ADJ_DELAY_MASK;
-	writel(val, host->regs + host->data->adjust);
+	regmap_update_bits(host->regmap, host->data->adjust, ADJUST_ADJ_DELAY_MASK,
+			   0);
 }
 
 static int meson_mmc_resampling_tuning(struct mmc_host *mmc, u32 opcode)
@@ -527,19 +512,21 @@
 	max_dly = DIV_ROUND_UP(clk_get_rate(host->mux_clk),
 			       clk_get_rate(host->mmc_clk));
 
-	val = readl(host->regs + host->data->adjust);
-	val |= ADJUST_ADJ_EN;
-	writel(val, host->regs + host->data->adjust);
+	regmap_update_bits(host->regmap, host->data->adjust, ADJUST_ADJ_EN,
+			   ADJUST_ADJ_EN);
 
-	if (mmc_doing_retune(mmc))
+	if (mmc_doing_retune(mmc)) {
+		regmap_read(host->regmap, host->data->adjust, &val);
 		dly = FIELD_GET(ADJUST_ADJ_DELAY_MASK, val) + 1;
-	else
+	} else {
 		dly = 0;
+	}
 
 	for (i = 0; i < max_dly; i++) {
-		val &= ~ADJUST_ADJ_DELAY_MASK;
-		val |= FIELD_PREP(ADJUST_ADJ_DELAY_MASK, (dly + i) % max_dly);
-		writel(val, host->regs + host->data->adjust);
+		regmap_update_bits(host->regmap, host->data->adjust,
+				   ADJUST_ADJ_DELAY_MASK,
+				   FIELD_PREP(ADJUST_ADJ_DELAY_MASK,
+					      (dly + i) % max_dly));
 
 		ret = mmc_send_tuning(mmc, opcode, NULL);
 		if (!ret) {
@@ -644,10 +631,8 @@
 		bus_width = CFG_BUS_WIDTH_4;
 	}
 
-	val = readl(host->regs + SD_EMMC_CFG);
-	val &= ~CFG_BUS_WIDTH_MASK;
-	val |= FIELD_PREP(CFG_BUS_WIDTH_MASK, bus_width);
-	writel(val, host->regs + SD_EMMC_CFG);
+	regmap_update_bits(host->regmap, SD_EMMC_CFG, CFG_BUS_WIDTH_MASK,
+			   FIELD_PREP(CFG_BUS_WIDTH_MASK, bus_width));
 
 	meson_mmc_check_resampling(host, ios);
 	err = meson_mmc_prepare_ios_clock(host, ios);
@@ -671,7 +656,7 @@
 	struct meson_host *host = mmc_priv(mmc);
 	u32 cfg, blksz_old;
 
-	cfg = readl(host->regs + SD_EMMC_CFG);
+	regmap_read(host->regmap, SD_EMMC_CFG, &cfg);
 	blksz_old = FIELD_GET(CFG_BLK_LEN_MASK, cfg);
 
 	if (!is_power_of_2(blksz))
@@ -686,9 +671,8 @@
 	dev_dbg(host->dev, "%s: update blk_len %d -> %d\n", __func__,
 		blksz_old, blksz);
 
-	cfg &= ~CFG_BLK_LEN_MASK;
-	cfg |= FIELD_PREP(CFG_BLK_LEN_MASK, blksz);
-	writel(cfg, host->regs + SD_EMMC_CFG);
+	regmap_update_bits(host->regmap, SD_EMMC_CFG, CFG_BLK_LEN_MASK,
+			   FIELD_PREP(CFG_BLK_LEN_MASK, blksz));
 }
 
 static void meson_mmc_set_response_bits(struct mmc_command *cmd, u32 *cmd_cfg)
@@ -714,7 +698,6 @@
 	struct sd_emmc_desc *desc = host->descs;
 	struct mmc_data *data = host->cmd->data;
 	struct scatterlist *sg;
-	u32 start;
 	int i;
 
 	if (data->flags & MMC_DATA_WRITE)
@@ -742,8 +725,8 @@
 	desc[data->sg_count - 1].cmd_cfg |= CMD_CFG_END_OF_CHAIN;
 
 	dma_wmb(); /* ensure descriptor is written before kicked */
-	start = host->descs_dma_addr | START_DESC_BUSY;
-	writel(start, host->regs + SD_EMMC_START);
+	regmap_write(host->regmap, SD_EMMC_START,
+		     host->descs_dma_addr | START_DESC_BUSY);
 }
 
 /* local sg copy for dram_access_quirk */
@@ -764,28 +747,19 @@
 	sg_miter_start(&miter, sgl, nents, sg_flags);
 
 	while ((offset < buflen) && sg_miter_next(&miter)) {
-		unsigned int buf_offset = 0;
-		unsigned int len, left;
 		u32 *buf = miter.addr;
+		unsigned int len;
 
 		len = min(miter.length, buflen - offset);
-		left = len;
-
-		if (to_buffer) {
-			do {
-				writel(*buf++, host->bounce_iomem_buf + offset + buf_offset);
-
-				buf_offset += 4;
-				left -= 4;
-			} while (left);
-		} else {
-			do {
-				*buf++ = readl(host->bounce_iomem_buf + offset + buf_offset);
 
-				buf_offset += 4;
-				left -= 4;
-			} while (left);
-		}
+		if (to_buffer)
+			regmap_bulk_write(host->regmap,
+					  SD_EMMC_SRAM_DATA_BUF_OFF + offset,
+					  buf, len);
+		else
+			regmap_bulk_read(host->regmap,
+					 SD_EMMC_SRAM_DATA_BUF_OFF + offset,
+					 buf, len);
 
 		offset += len;
 	}
@@ -852,11 +826,11 @@
 
 	/* Last descriptor */
 	cmd_cfg |= CMD_CFG_END_OF_CHAIN;
-	writel(cmd_cfg, host->regs + SD_EMMC_CMD_CFG);
-	writel(cmd_data, host->regs + SD_EMMC_CMD_DAT);
-	writel(0, host->regs + SD_EMMC_CMD_RSP);
+	regmap_write(host->regmap, SD_EMMC_CMD_CFG, cmd_cfg);
+	regmap_write(host->regmap, SD_EMMC_CMD_DAT, cmd_data);
+	regmap_write(host->regmap, SD_EMMC_CMD_RSP, 0);
 	wmb(); /* ensure descriptor is written before kicked */
-	writel(cmd->arg, host->regs + SD_EMMC_CMD_ARG);
+	regmap_write(host->regmap, SD_EMMC_CMD_ARG, cmd->arg);
 }
 
 static int meson_mmc_validate_dram_access(struct mmc_host *mmc, struct mmc_data *data)
@@ -906,7 +880,7 @@
 		meson_mmc_pre_req(mmc, mrq);
 
 	/* Stop execution */
-	writel(0, host->regs + SD_EMMC_START);
+	regmap_write(host->regmap, SD_EMMC_START, 0);
 
 	meson_mmc_start_cmd(mmc, mrq->sbc ?: mrq->cmd);
 
@@ -919,12 +893,12 @@
 	struct meson_host *host = mmc_priv(mmc);
 
 	if (cmd->flags & MMC_RSP_136) {
-		cmd->resp[0] = readl(host->regs + SD_EMMC_CMD_RSP3);
-		cmd->resp[1] = readl(host->regs + SD_EMMC_CMD_RSP2);
-		cmd->resp[2] = readl(host->regs + SD_EMMC_CMD_RSP1);
-		cmd->resp[3] = readl(host->regs + SD_EMMC_CMD_RSP);
+		regmap_read(host->regmap, SD_EMMC_CMD_RSP3, &cmd->resp[0]);
+		regmap_read(host->regmap, SD_EMMC_CMD_RSP2, &cmd->resp[1]);
+		regmap_read(host->regmap, SD_EMMC_CMD_RSP1, &cmd->resp[2]);
+		regmap_read(host->regmap, SD_EMMC_CMD_RSP, &cmd->resp[3]);
 	} else if (cmd->flags & MMC_RSP_PRESENT) {
-		cmd->resp[0] = readl(host->regs + SD_EMMC_CMD_RSP);
+		regmap_read(host->regmap, SD_EMMC_CMD_RSP, &cmd->resp[0]);
 	}
 }
 
@@ -936,8 +910,8 @@
 	u32 irq_en, status, raw_status;
 	irqreturn_t ret = IRQ_NONE;
 
-	irq_en = readl(host->regs + SD_EMMC_IRQ_EN);
-	raw_status = readl(host->regs + SD_EMMC_STATUS);
+	regmap_read(host->regmap, SD_EMMC_IRQ_EN, &irq_en);
+	regmap_read(host->regmap, SD_EMMC_STATUS, &raw_status);
 	status = raw_status & irq_en;
 
 	if (!status) {
@@ -951,7 +925,7 @@
 		return IRQ_NONE;
 
 	/* ack all raised interrupts */
-	writel(status, host->regs + SD_EMMC_STATUS);
+	regmap_write(host->regmap, SD_EMMC_STATUS, status);
 
 	cmd = host->cmd;
 	data = cmd->data;
@@ -988,13 +962,10 @@
 	}
 
 out:
-	if (cmd->error) {
+	if (cmd->error)
 		/* Stop desc in case of errors */
-		u32 start = readl(host->regs + SD_EMMC_START);
-
-		start &= ~START_DESC_BUSY;
-		writel(start, host->regs + SD_EMMC_START);
-	}
+		regmap_update_bits(host->regmap, SD_EMMC_START,
+				   START_DESC_BUSY, 0);
 
 	if (ret == IRQ_HANDLED)
 		meson_mmc_request_done(host->mmc, cmd->mrq);
@@ -1014,9 +985,9 @@
 	 * IRQs after we have called mmc_request_done() which is bad.
 	 */
 
-	return readl_poll_timeout(host->regs + SD_EMMC_STATUS, status,
-				  !(status & (STATUS_BUSY | STATUS_DESC_BUSY)),
-				  100, 5000);
+	return regmap_read_poll_timeout(host->regmap, SD_EMMC_STATUS, status,
+					!(status & (STATUS_BUSY | STATUS_DESC_BUSY)),
+					100, 5000);
 }
 
 static irqreturn_t meson_mmc_irq_thread(int irq, void *dev_id)
@@ -1082,7 +1053,7 @@
 	/* abort chain on R/W errors */
 	cfg |= CFG_ERR_ABORT;
 
-	writel(cfg, host->regs + SD_EMMC_CFG);
+	regmap_write(host->regmap, SD_EMMC_CFG, cfg);
 }
 
 static int meson_mmc_card_busy(struct mmc_host *mmc)
@@ -1090,7 +1061,7 @@
 	struct meson_host *host = mmc_priv(mmc);
 	u32 regval;
 
-	regval = readl(host->regs + SD_EMMC_STATUS);
+	regmap_read(host->regmap, SD_EMMC_STATUS, &regval);
 
 	/* We are only interrested in lines 0 to 3, so mask the other ones */
 	return !(FIELD_GET(STATUS_DATI, regval) & 0xf);
@@ -1131,11 +1102,19 @@
 	.start_signal_voltage_switch = meson_mmc_voltage_switch,
 };
 
+static const struct regmap_config meson_gx_mmc_regmap_config = {
+	.reg_bits = 16,
+	.val_bits = 32,
+	.reg_stride = 4,
+	.max_register = 0x7ff,
+};
+
 static int meson_mmc_probe(struct platform_device *pdev)
 {
 	struct resource *res;
 	struct meson_host *host;
 	struct mmc_host *mmc;
+	void __iomem *regs;
 	int ret;
 
 	mmc = mmc_alloc_host(sizeof(struct meson_host), &pdev->dev);
@@ -1175,9 +1154,9 @@
 		return dev_err_probe(&pdev->dev, ret, "device reset failed\n");
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	host->regs = devm_ioremap_resource(&pdev->dev, res);
-	if (IS_ERR(host->regs)) {
-		ret = PTR_ERR(host->regs);
+	regs = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(regs)) {
+		ret = PTR_ERR(regs);
 		goto free_host;
 	}
 
@@ -1207,11 +1186,16 @@
 		goto free_host;
 	}
 
+	host->regmap = devm_regmap_init_mmio(&pdev->dev, regs,
+					     &meson_gx_mmc_regmap_config);
+	if (IS_ERR(host->regmap))
+		return PTR_ERR(host->regmap);
+
 	ret = clk_prepare_enable(host->core_clk);
 	if (ret)
 		goto free_host;
 
-	ret = meson_mmc_clk_init(host);
+	ret = meson_mmc_clk_init(host, regs);
 	if (ret)
 		goto err_core_clk;
 
@@ -1219,14 +1203,14 @@
 	meson_mmc_cfg_init(host);
 
 	/* Stop execution */
-	writel(0, host->regs + SD_EMMC_START);
+	regmap_write(host->regmap, SD_EMMC_START, 0);
 
 	/* clear, ack and enable interrupts */
-	writel(0, host->regs + SD_EMMC_IRQ_EN);
-	writel(IRQ_CRC_ERR | IRQ_TIMEOUTS | IRQ_END_OF_CHAIN,
-	       host->regs + SD_EMMC_STATUS);
-	writel(IRQ_CRC_ERR | IRQ_TIMEOUTS | IRQ_END_OF_CHAIN,
-	       host->regs + SD_EMMC_IRQ_EN);
+	regmap_write(host->regmap, SD_EMMC_IRQ_EN, 0);
+	regmap_write(host->regmap, SD_EMMC_STATUS,
+		     IRQ_CRC_ERR | IRQ_TIMEOUTS | IRQ_END_OF_CHAIN);
+	regmap_write(host->regmap, SD_EMMC_IRQ_EN,
+		     IRQ_CRC_ERR | IRQ_TIMEOUTS | IRQ_END_OF_CHAIN);
 
 	ret = request_threaded_irq(host->irq, meson_mmc_irq,
 				   meson_mmc_irq_thread, IRQF_ONESHOT,
@@ -1264,7 +1248,6 @@
 		 * instead of the DDR memory
 		 */
 		host->bounce_buf_size = SD_EMMC_SRAM_DATA_BUF_LEN;
-		host->bounce_iomem_buf = host->regs + SD_EMMC_SRAM_DATA_BUF_OFF;
 		host->bounce_dma_addr = res->start + SD_EMMC_SRAM_DATA_BUF_OFF;
 	} else {
 		/* data bounce buffer */
@@ -1314,7 +1297,7 @@
 	mmc_remove_host(host->mmc);
 
 	/* disable interrupts */
-	writel(0, host->regs + SD_EMMC_IRQ_EN);
+	regmap_write(host->regmap, SD_EMMC_IRQ_EN, 0);
 	free_irq(host->irq, host);
 
 	dma_free_coherent(host->dev, SD_EMMC_DESC_BUF_LEN,
diff -Naur a/drivers/mtd/nand/raw/meson_nand.c b/drivers/mtd/nand/raw/meson_nand.c
--- a/drivers/mtd/nand/raw/meson_nand.c	2021-10-31 16:53:10.000000000 -0400
+++ b/drivers/mtd/nand/raw/meson_nand.c	2021-10-31 20:41:20.000000000 -0400
@@ -128,6 +128,7 @@
 
 struct meson_nfc_data {
 	const struct nand_ecc_caps *ecc_caps;
+	bool has_mmc_syscon;
 };
 
 struct meson_nfc_param {
@@ -209,7 +210,7 @@
 	return ecc_bytes;
 }
 
-NAND_ECC_CAPS_SINGLE(meson_gxl_ecc_caps,
+NAND_ECC_CAPS_SINGLE(meson8_ecc_caps,
 		     meson_nand_calc_ecc_bytes, 1024, 8, 24, 30, 40, 50, 60);
 NAND_ECC_CAPS_SINGLE(meson_axg_ecc_caps,
 		     meson_nand_calc_ecc_bytes, 1024, 8);
@@ -1002,21 +1003,22 @@
 		return PTR_ERR(nfc->device_clk);
 	}
 
-	nfc->phase_tx = devm_clk_get(nfc->dev, "tx");
+	nfc->phase_tx = devm_clk_get_optional(nfc->dev, "tx");
 	if (IS_ERR(nfc->phase_tx)) {
 		dev_err(nfc->dev, "failed to get TX clk\n");
 		return PTR_ERR(nfc->phase_tx);
 	}
 
-	nfc->phase_rx = devm_clk_get(nfc->dev, "rx");
+	nfc->phase_rx = devm_clk_get_optional(nfc->dev, "rx");
 	if (IS_ERR(nfc->phase_rx)) {
 		dev_err(nfc->dev, "failed to get RX clk\n");
 		return PTR_ERR(nfc->phase_rx);
 	}
 
-	/* init SD_EMMC_CLOCK to sane defaults w/min clock rate */
-	regmap_update_bits(nfc->reg_clk,
-			   0, CLK_SELECT_NAND, CLK_SELECT_NAND);
+	if (nfc->data->has_mmc_syscon)
+		/* init SD_EMMC_CLOCK to sane defaults w/min clock rate */
+		regmap_update_bits(nfc->reg_clk,
+				   0, CLK_SELECT_NAND, CLK_SELECT_NAND);
 
 	ret = clk_prepare_enable(nfc->core_clk);
 	if (ret) {
@@ -1350,16 +1352,32 @@
 	return IRQ_HANDLED;
 }
 
+static const struct meson_nfc_data meson8_data = {
+	.ecc_caps = &meson8_ecc_caps,
+	.has_mmc_syscon = false,
+};
+
 static const struct meson_nfc_data meson_gxl_data = {
-	.ecc_caps = &meson_gxl_ecc_caps,
+	.ecc_caps = &meson8_ecc_caps,
+	.has_mmc_syscon = true,
 };
 
 static const struct meson_nfc_data meson_axg_data = {
 	.ecc_caps = &meson_axg_ecc_caps,
+	.has_mmc_syscon = true,
 };
 
 static const struct of_device_id meson_nfc_id_table[] = {
 	{
+		.compatible = "amlogic,meson8-nfc",
+		.data = &meson8_data,
+	}, {
+		.compatible = "amlogic,meson8b-nfc",
+		.data = &meson8_data,
+	}, {
+		.compatible = "amlogic,meson-gxbb-nfc",
+		.data = &meson8_data,
+	}, {
 		.compatible = "amlogic,meson-gxl-nfc",
 		.data = &meson_gxl_data,
 	}, {
@@ -1396,12 +1414,14 @@
 	if (IS_ERR(nfc->reg_base))
 		return PTR_ERR(nfc->reg_base);
 
-	nfc->reg_clk =
-		syscon_regmap_lookup_by_phandle(dev->of_node,
-						"amlogic,mmc-syscon");
-	if (IS_ERR(nfc->reg_clk)) {
-		dev_err(dev, "Failed to lookup clock base\n");
-		return PTR_ERR(nfc->reg_clk);
+	if (nfc->data->has_mmc_syscon) {
+		nfc->reg_clk =
+			syscon_regmap_lookup_by_phandle(dev->of_node,
+							"amlogic,mmc-syscon");
+		if (IS_ERR(nfc->reg_clk)) {
+			dev_err(dev, "Failed to lookup clock base\n");
+			return PTR_ERR(nfc->reg_clk);
+		}
 	}
 
 	irq = platform_get_irq(pdev, 0);
diff -Naur a/drivers/net/ethernet/stmicro/stmmac/dwmac-meson.c b/drivers/net/ethernet/stmicro/stmmac/dwmac-meson.c
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac-meson.c	2021-10-31 16:53:10.000000000 -0400
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac-meson.c	2021-10-31 20:41:20.000000000 -0400
@@ -5,6 +5,7 @@
  * Copyright (C) 2014 Beniamino Galvani <b.galvani@gmail.com>
  */
 
+#include <linux/clk.h>
 #include <linux/device.h>
 #include <linux/ethtool.h>
 #include <linux/io.h>
@@ -15,11 +16,14 @@
 
 #include "stmmac_platform.h"
 
+#define ETHMAC_DIV_EN		BIT(0)
+/* divides the input clock by 20 (= 0x0) or 2 (= 0x1) */
 #define ETHMAC_SPEED_100	BIT(1)
 
 struct meson_dwmac {
 	struct device	*dev;
 	void __iomem	*reg;
+	struct clk	*ethernet_clk;
 };
 
 static void meson6_dwmac_fix_mac_speed(void *priv, unsigned int speed)
@@ -41,6 +45,30 @@
 	writel(val, dwmac->reg);
 }
 
+static int meson6_dwmac_init(struct meson_dwmac *dwmac)
+{
+	int ret;
+
+	ret = clk_set_rate(dwmac->ethernet_clk, 50 * 1000 * 1000);
+	if (ret)
+		return ret;
+
+	ret = clk_prepare_enable(dwmac->ethernet_clk);
+	if (ret)
+		return ret;
+
+	writel(readl(dwmac->reg) | ETHMAC_DIV_EN, dwmac->reg);
+
+	return 0;
+}
+
+static void meson6_dwmac_exit(struct meson_dwmac *dwmac)
+{
+	writel(readl(dwmac->reg) & ~ETHMAC_DIV_EN, dwmac->reg);
+
+	clk_disable_unprepare(dwmac->ethernet_clk);
+}
+
 static int meson6_dwmac_probe(struct platform_device *pdev)
 {
 	struct plat_stmmacenet_data *plat_dat;
@@ -68,15 +96,27 @@
 		goto err_remove_config_dt;
 	}
 
+	dwmac->ethernet_clk = devm_clk_get_optional(&pdev->dev, "ethernet");
+	if (IS_ERR(dwmac->ethernet_clk)) {
+		ret = PTR_ERR(dwmac->ethernet_clk);
+		goto err_remove_config_dt;
+	}
+
 	plat_dat->bsp_priv = dwmac;
 	plat_dat->fix_mac_speed = meson6_dwmac_fix_mac_speed;
 
+	ret = meson6_dwmac_init(dwmac);
+	if (ret)
+		return ret;
+
 	ret = stmmac_dvr_probe(&pdev->dev, plat_dat, &stmmac_res);
 	if (ret)
-		goto err_remove_config_dt;
+		goto err_exit_dwmac;
 
 	return 0;
 
+err_exit_dwmac:
+	meson6_dwmac_exit(dwmac);
 err_remove_config_dt:
 	stmmac_remove_config_dt(pdev, plat_dat);
 
diff -Naur a/drivers/net/phy/realtek.c b/drivers/net/phy/realtek.c
--- a/drivers/net/phy/realtek.c	2021-10-31 16:53:10.000000000 -0400
+++ b/drivers/net/phy/realtek.c	2021-10-31 20:41:20.000000000 -0400
@@ -7,9 +7,11 @@
  *
  * Copyright (c) 2004 Freescale Semiconductor, Inc.
  */
+#include <dt-bindings/net/realtek-rtl8211f.h>
 #include <linux/bitops.h>
 #include <linux/of.h>
 #include <linux/phy.h>
+#include <linux/property.h>
 #include <linux/module.h>
 #include <linux/delay.h>
 
@@ -38,6 +40,15 @@
 #define RTL8211F_ALDPS_ENABLE			BIT(2)
 #define RTL8211F_ALDPS_XTAL_OFF			BIT(12)
 
+#define RTL8211F_LED_CONFIG_PAGE		0xd04
+#define RTL8211F_LCR				0x10
+#define RTL8211F_LCR_LED0_LINK_10		BIT(0)
+#define RTL8211F_LCR_LED0_LINK_100		BIT(1)
+#define RTL8211F_LCR_LED0_LINK_1000		BIT(3)
+#define RTL8211F_LCR_LED0_ACTIVITY		BIT(4)
+#define RTL8211F_EEELCR				0x11
+#define RTL8211F_EEELCR_LED0_EEE_ENABLE		BIT(1)
+
 #define RTL8211E_CTRL_DELAY			BIT(13)
 #define RTL8211E_TX_DELAY			BIT(12)
 #define RTL8211E_RX_DELAY			BIT(11)
@@ -329,6 +340,79 @@
 			    CTL1000_ENABLE_MASTER | CTL1000_AS_MASTER);
 }
 
+static int rtl8211f_modify_led_register(struct phy_device *phydev,
+					unsigned int led, u32 regnum, u16 mask,
+					bool set_bit)
+{
+	u8 led_reg_width = regnum == RTL8211F_LCR ? 5 : 1;
+	u16 reg_mask = mask << (led * led_reg_width);
+
+	return phy_modify_paged(phydev, RTL8211F_LED_CONFIG_PAGE, regnum,
+				reg_mask, set_bit ? reg_mask : 0);
+}
+
+static int rtl8211f_config_init_led(struct phy_device *phydev, unsigned int num)
+{
+	struct device *dev = &phydev->mdio.dev;
+	char led_property[29];
+	u32 mode;
+	int ret;
+
+	ret = sprintf(led_property, "realtek,led-%u-mode", num);
+	if (ret < 0)
+		return ret;
+
+	ret = device_property_read_u32(dev, led_property, &mode);
+	if (ret) {
+		dev_dbg(dev,
+			"Keeping LED%u configuration from pin-strapping or bootloader",
+			num);
+		return 0;
+	}
+
+	ret = rtl8211f_modify_led_register(phydev, num, RTL8211F_LCR,
+					   RTL8211F_LCR_LED0_LINK_10,
+					   mode & RTL8211F_LED_LINK_10);
+	if (ret) {
+		dev_err(dev, "Failed to update the LED%u LINK_10 bit\n", num);
+		return ret;
+	}
+
+	ret = rtl8211f_modify_led_register(phydev, num, RTL8211F_LCR,
+					   RTL8211F_LCR_LED0_LINK_100,
+					   mode & RTL8211F_LED_LINK_100);
+	if (ret) {
+		dev_err(dev, "Failed to update the LED%u LINK_100 bit\n", num);
+		return ret;
+	}
+
+	ret = rtl8211f_modify_led_register(phydev, num, RTL8211F_LCR,
+					   RTL8211F_LCR_LED0_LINK_1000,
+					   mode & RTL8211F_LED_LINK_1000);
+	if (ret) {
+		dev_err(dev, "Failed to update the LED%u LINK_1000 bit\n", num);
+		return ret;
+	}
+
+	ret = rtl8211f_modify_led_register(phydev, num, RTL8211F_LCR,
+					   RTL8211F_LCR_LED0_ACTIVITY,
+					   mode & RTL8211F_LED_ACTIVITY);
+	if (ret) {
+		dev_err(dev, "Failed to update the LED%u ACTIVITY bit\n", num);
+		return ret;
+	}
+
+	ret = rtl8211f_modify_led_register(phydev, num, RTL8211F_EEELCR,
+					   RTL8211F_EEELCR_LED0_EEE_ENABLE,
+					   mode & RTL8211F_LED_EEE);
+	if (ret) {
+		dev_err(dev, "Failed to update the LED%u EEE_ENABLE bit\n", num);
+		return ret;
+	}
+
+	return 0;
+}
+
 static int rtl8211f_config_init(struct phy_device *phydev)
 {
 	struct rtl821x_priv *priv = phydev->priv;
@@ -408,6 +492,18 @@
 		return ret;
 	}
 
+	ret = rtl8211f_config_init_led(phydev, 0);
+	if (ret)
+		return ret;
+
+	ret = rtl8211f_config_init_led(phydev, 1);
+	if (ret)
+		return ret;
+
+	ret = rtl8211f_config_init_led(phydev, 2);
+	if (ret)
+		return ret;
+
 	return genphy_soft_reset(phydev);
 }
 
diff -Naur a/drivers/net/wireless/realtek/rtw88/bf.c b/drivers/net/wireless/realtek/rtw88/bf.c
--- a/drivers/net/wireless/realtek/rtw88/bf.c	2021-10-31 16:53:10.000000000 -0400
+++ b/drivers/net/wireless/realtek/rtw88/bf.c	2021-10-31 20:41:20.000000000 -0400
@@ -39,6 +39,7 @@
 	struct ieee80211_sta_vht_cap *vht_cap;
 	struct ieee80211_sta_vht_cap *ic_vht_cap;
 	const u8 *bssid = bss_conf->bssid;
+	bool config_bfee = false;
 	u32 sound_dim;
 	u8 i;
 
@@ -70,7 +71,7 @@
 		bfee->aid = bss_conf->aid;
 		bfinfo->bfer_mu_cnt++;
 
-		rtw_chip_config_bfee(rtwdev, rtwvif, bfee, true);
+		config_bfee = true;
 	} else if ((ic_vht_cap->cap & IEEE80211_VHT_CAP_SU_BEAMFORMEE_CAPABLE) &&
 		   (vht_cap->cap & IEEE80211_VHT_CAP_SU_BEAMFORMER_CAPABLE)) {
 		if (bfinfo->bfer_su_cnt >= chip->bfer_su_max_num) {
@@ -96,11 +97,14 @@
 			}
 		}
 
-		rtw_chip_config_bfee(rtwdev, rtwvif, bfee, true);
+		config_bfee = true;
 	}
 
 out_unlock:
 	rcu_read_unlock();
+
+	if (config_bfee)
+		rtw_chip_config_bfee(rtwdev, rtwvif, bfee, true);
 }
 
 void rtw_bf_init_bfer_entry_mu(struct rtw_dev *rtwdev,
diff -Naur a/drivers/net/wireless/realtek/rtw88/debug.h b/drivers/net/wireless/realtek/rtw88/debug.h
--- a/drivers/net/wireless/realtek/rtw88/debug.h	2021-10-31 16:53:10.000000000 -0400
+++ b/drivers/net/wireless/realtek/rtw88/debug.h	2021-10-31 20:41:20.000000000 -0400
@@ -21,6 +21,7 @@
 	RTW_DBG_WOW		= 0x00001000,
 	RTW_DBG_CFO		= 0x00002000,
 	RTW_DBG_PATH_DIV	= 0x00004000,
+	RTW_DBG_SDIO		= 0x00008000,
 
 	RTW_DBG_ALL		= 0xffffffff
 };
diff -Naur a/drivers/net/wireless/realtek/rtw88/fw.c b/drivers/net/wireless/realtek/rtw88/fw.c
--- a/drivers/net/wireless/realtek/rtw88/fw.c	2021-10-31 16:53:10.000000000 -0400
+++ b/drivers/net/wireless/realtek/rtw88/fw.c	2021-10-31 20:41:20.000000000 -0400
@@ -285,7 +285,7 @@
 		h2c[3], h2c[2], h2c[1], h2c[0],
 		h2c[7], h2c[6], h2c[5], h2c[4]);
 
-	spin_lock(&rtwdev->h2c.lock);
+	mutex_lock(&rtwdev->h2c.lock);
 
 	box = rtwdev->h2c.last_box_num;
 	switch (box) {
@@ -310,9 +310,9 @@
 		goto out;
 	}
 
-	ret = read_poll_timeout_atomic(rtw_read8, box_state,
-				       !((box_state >> box) & 0x1), 100, 3000,
-				       false, rtwdev, REG_HMETFR);
+	ret = read_poll_timeout(rtw_read8, box_state,
+				!((box_state >> box) & 0x1), 100, 3000, false,
+				rtwdev, REG_HMETFR);
 
 	if (ret) {
 		rtw_err(rtwdev, "failed to send h2c command\n");
@@ -328,7 +328,7 @@
 		rtwdev->h2c.last_box_num = 0;
 
 out:
-	spin_unlock(&rtwdev->h2c.lock);
+	mutex_unlock(&rtwdev->h2c.lock);
 }
 
 void rtw_fw_h2c_cmd_dbg(struct rtw_dev *rtwdev, u8 *h2c)
@@ -340,7 +340,7 @@
 {
 	int ret;
 
-	spin_lock(&rtwdev->h2c.lock);
+	mutex_lock(&rtwdev->h2c.lock);
 
 	FW_OFFLOAD_H2C_SET_SEQ_NUM(h2c_pkt, rtwdev->h2c.seq);
 	ret = rtw_hci_write_data_h2c(rtwdev, h2c_pkt, H2C_PKT_SIZE);
@@ -348,7 +348,7 @@
 		rtw_err(rtwdev, "failed to send h2c packet\n");
 	rtwdev->h2c.seq++;
 
-	spin_unlock(&rtwdev->h2c.lock);
+	mutex_unlock(&rtwdev->h2c.lock);
 }
 
 void
diff -Naur a/drivers/net/wireless/realtek/rtw88/hci.h b/drivers/net/wireless/realtek/rtw88/hci.h
--- a/drivers/net/wireless/realtek/rtw88/hci.h	2021-10-31 16:53:10.000000000 -0400
+++ b/drivers/net/wireless/realtek/rtw88/hci.h	2021-10-31 20:41:20.000000000 -0400
@@ -22,6 +22,8 @@
 	int (*write_data_rsvd_page)(struct rtw_dev *rtwdev, u8 *buf, u32 size);
 	int (*write_data_h2c)(struct rtw_dev *rtwdev, u8 *buf, u32 size);
 
+	void (*power_switch)(struct rtw_dev *rtwdev, bool on);
+
 	u8 (*read8)(struct rtw_dev *rtwdev, u32 addr);
 	u16 (*read16)(struct rtw_dev *rtwdev, u32 addr);
 	u32 (*read32)(struct rtw_dev *rtwdev, u32 addr);
@@ -84,6 +86,12 @@
 	return rtwdev->hci.ops->write_data_h2c(rtwdev, buf, size);
 }
 
+static inline void rtw_hci_power_switch(struct rtw_dev *rtwdev, bool on)
+{
+	if (rtwdev->hci.ops->power_switch)
+		rtwdev->hci.ops->power_switch(rtwdev, on);
+}
+
 static inline u8 rtw_read8(struct rtw_dev *rtwdev, u32 addr)
 {
 	return rtwdev->hci.ops->read8(rtwdev, addr);
@@ -166,12 +174,11 @@
 rtw_read_rf(struct rtw_dev *rtwdev, enum rtw_rf_path rf_path,
 	    u32 addr, u32 mask)
 {
-	unsigned long flags;
 	u32 val;
 
-	spin_lock_irqsave(&rtwdev->rf_lock, flags);
+	mutex_lock(&rtwdev->rf_lock);
 	val = rtwdev->chip->ops->read_rf(rtwdev, rf_path, addr, mask);
-	spin_unlock_irqrestore(&rtwdev->rf_lock, flags);
+	mutex_unlock(&rtwdev->rf_lock);
 
 	return val;
 }
@@ -180,11 +187,9 @@
 rtw_write_rf(struct rtw_dev *rtwdev, enum rtw_rf_path rf_path,
 	     u32 addr, u32 mask, u32 data)
 {
-	unsigned long flags;
-
-	spin_lock_irqsave(&rtwdev->rf_lock, flags);
+	mutex_lock(&rtwdev->rf_lock);
 	rtwdev->chip->ops->write_rf(rtwdev, rf_path, addr, mask, data);
-	spin_unlock_irqrestore(&rtwdev->rf_lock, flags);
+	mutex_unlock(&rtwdev->rf_lock);
 }
 
 static inline u32
diff -Naur a/drivers/net/wireless/realtek/rtw88/Kconfig b/drivers/net/wireless/realtek/rtw88/Kconfig
--- a/drivers/net/wireless/realtek/rtw88/Kconfig	2021-10-31 16:53:10.000000000 -0400
+++ b/drivers/net/wireless/realtek/rtw88/Kconfig	2021-10-31 20:41:20.000000000 -0400
@@ -16,6 +16,9 @@
 config RTW88_PCI
 	tristate
 
+config RTW88_SDIO
+	tristate
+
 config RTW88_8822B
 	tristate
 
@@ -72,6 +75,20 @@
 
 	  802.11ac PCIe wireless network adapter
 
+config RTW88_8822BS
+	tristate "Realtek 8822BS SDIO wireless network adapter"
+	depends on MMC
+	select RTW88_CORE
+	select RTW88_SDIO
+	select RTW88_8822B
+
+config RTW88_8822CS
+	tristate "Realtek 8822CS SDIO wireless network adapter"
+	depends on MMC
+	select RTW88_CORE
+	select RTW88_SDIO
+	select RTW88_8822C
+
 config RTW88_DEBUG
 	bool "Realtek rtw88 debug support"
 	depends on RTW88_CORE
diff -Naur a/drivers/net/wireless/realtek/rtw88/mac80211.c b/drivers/net/wireless/realtek/rtw88/mac80211.c
--- a/drivers/net/wireless/realtek/rtw88/mac80211.c	2021-10-31 16:53:10.000000000 -0400
+++ b/drivers/net/wireless/realtek/rtw88/mac80211.c	2021-10-31 20:41:20.000000000 -0400
@@ -721,7 +721,7 @@
 	br_data.rtwdev = rtwdev;
 	br_data.vif = vif;
 	br_data.mask = mask;
-	rtw_iterate_stas_atomic(rtwdev, rtw_ra_mask_info_update_iter, &br_data);
+	rtw_iterate_stas(rtwdev, rtw_ra_mask_info_update_iter, &br_data);
 }
 
 static int rtw_ops_set_bitrate_mask(struct ieee80211_hw *hw,
diff -Naur a/drivers/net/wireless/realtek/rtw88/mac.c b/drivers/net/wireless/realtek/rtw88/mac.c
--- a/drivers/net/wireless/realtek/rtw88/mac.c	2021-10-31 16:53:10.000000000 -0400
+++ b/drivers/net/wireless/realtek/rtw88/mac.c	2021-10-31 20:41:20.000000000 -0400
@@ -7,6 +7,7 @@
 #include "reg.h"
 #include "fw.h"
 #include "debug.h"
+#include "sdio.h"
 
 void rtw_set_channel_mac(struct rtw_dev *rtwdev, u8 channel, u8 bw,
 			 u8 primary_ch_idx)
@@ -60,6 +61,7 @@
 
 static int rtw_mac_pre_system_cfg(struct rtw_dev *rtwdev)
 {
+	unsigned int retry;
 	u32 value32;
 	u8 value8;
 
@@ -77,6 +79,24 @@
 	case RTW_HCI_TYPE_PCIE:
 		rtw_write32_set(rtwdev, REG_HCI_OPT_CTRL, BIT_BT_DIG_CLK_EN);
 		break;
+	case RTW_HCI_TYPE_SDIO:
+		rtw_write8_clr(rtwdev, REG_SDIO_HSUS_CTRL, BIT(0));
+
+		for (retry = 0; retry < RTW_PWR_POLLING_CNT; retry++) {
+			if (rtw_read8(rtwdev, REG_SDIO_HSUS_CTRL) & BIT(1))
+				break;
+
+			usleep_range(10, 50);
+		}
+
+		if (retry == RTW_PWR_POLLING_CNT) {
+			rtw_err(rtwdev, "failed to poll REG_SDIO_HSUS_CTRL[1]");
+			return -ETIMEDOUT;
+		}
+
+		/* FIXME: enable SDIO3 - make this configurable! */
+		rtw_write8_clr(rtwdev, REG_HCI_OPT_CTRL + 2, BIT(2));
+		break;
 	case RTW_HCI_TYPE_USB:
 		break;
 	default:
@@ -222,6 +242,9 @@
 	case RTW_HCI_TYPE_USB:
 		intf_mask = BIT(1);
 		break;
+	case RTW_HCI_TYPE_SDIO:
+		intf_mask = RTW_PWR_INTF_SDIO_MSK;
+		break;
 	default:
 		return -EINVAL;
 	}
@@ -245,6 +268,7 @@
 {
 	struct rtw_chip_info *chip = rtwdev->chip;
 	const struct rtw_pwr_seq_cmd **pwr_seq;
+	u32 imr;
 	u8 rpwm;
 	bool cur_pwr;
 
@@ -260,6 +284,8 @@
 
 	if (rtw_read8(rtwdev, REG_CR) == 0xea)
 		cur_pwr = false;
+	else if (rtw_hci_type(rtwdev) == RTW_HCI_TYPE_SDIO)
+		cur_pwr = false;
 	else if (rtw_hci_type(rtwdev) == RTW_HCI_TYPE_USB &&
 		 (rtw_read8(rtwdev, REG_SYS_STATUS1 + 1) & BIT(0)))
 		cur_pwr = false;
@@ -269,9 +295,18 @@
 	if (pwr_on == cur_pwr)
 		return -EALREADY;
 
+	imr = rtw_read32(rtwdev, REG_SDIO_HIMR);
+	rtw_write32(rtwdev, REG_SDIO_HIMR, 0);
+
 	pwr_seq = pwr_on ? chip->pwr_on_seq : chip->pwr_off_seq;
-	if (rtw_pwr_seq_parser(rtwdev, pwr_seq))
+	if (rtw_pwr_seq_parser(rtwdev, pwr_seq)) {
+		rtw_write32(rtwdev, REG_SDIO_HIMR, imr);
 		return -EINVAL;
+	}
+
+	rtw_hci_power_switch(rtwdev, pwr_on);
+
+	rtw_write32(rtwdev, REG_SDIO_HIMR, imr);
 
 	return 0;
 }
@@ -1014,6 +1049,9 @@
 		else
 			return -EINVAL;
 		break;
+	case RTW_HCI_TYPE_SDIO:
+		rqpn = &chip->rqpn_table[0];
+		break;
 	default:
 		return -EINVAL;
 	}
@@ -1173,6 +1211,9 @@
 		else
 			return -EINVAL;
 		break;
+	case RTW_HCI_TYPE_SDIO:
+		pg_tbl = &chip->page_table[0];
+		break;
 	default:
 		return -EINVAL;
 	}
diff -Naur a/drivers/net/wireless/realtek/rtw88/mac.h b/drivers/net/wireless/realtek/rtw88/mac.h
--- a/drivers/net/wireless/realtek/rtw88/mac.h	2021-10-31 16:53:10.000000000 -0400
+++ b/drivers/net/wireless/realtek/rtw88/mac.h	2021-10-31 20:41:20.000000000 -0400
@@ -7,7 +7,6 @@
 
 #define RTW_HW_PORT_NUM		5
 #define cut_version_to_mask(cut) (0x1 << ((cut) + 1))
-#define SDIO_LOCAL_OFFSET	0x10250000
 #define DDMA_POLLING_COUNT	1000
 #define C2H_PKT_BUF		256
 #define REPORT_BUF		128
diff -Naur a/drivers/net/wireless/realtek/rtw88/main.c b/drivers/net/wireless/realtek/rtw88/main.c
--- a/drivers/net/wireless/realtek/rtw88/main.c	2021-10-31 16:53:10.000000000 -0400
+++ b/drivers/net/wireless/realtek/rtw88/main.c	2021-10-31 20:41:20.000000000 -0400
@@ -17,6 +17,7 @@
 #include "tx.h"
 #include "debug.h"
 #include "bf.h"
+#include "sdio.h"
 
 bool rtw_disable_lps_deep_mode;
 EXPORT_SYMBOL(rtw_disable_lps_deep_mode);
@@ -229,8 +230,8 @@
 	rtw_phy_dynamic_mechanism(rtwdev);
 
 	data.rtwdev = rtwdev;
-	/* use atomic version to avoid taking local->iflist_mtx mutex */
-	rtw_iterate_vifs_atomic(rtwdev, rtw_vif_watch_dog_iter, &data);
+
+	rtw_iterate_vifs(rtwdev, rtw_vif_watch_dog_iter, &data);
 
 	/* fw supports only one station associated to enter lps, if there are
 	 * more than two stations associated to the AP, then we can not enter
@@ -574,11 +575,9 @@
 
 	WARN(1, "firmware crash, start reset and recover\n");
 
-	rcu_read_lock();
-	rtw_iterate_keys_rcu(rtwdev, NULL, rtw_reset_key_iter, rtwdev);
-	rcu_read_unlock();
-	rtw_iterate_stas_atomic(rtwdev, rtw_reset_sta_iter, rtwdev);
-	rtw_iterate_vifs_atomic(rtwdev, rtw_reset_vif_iter, rtwdev);
+	rtw_iterate_keys(rtwdev, NULL, rtw_reset_key_iter, rtwdev);
+	rtw_iterate_stas(rtwdev, rtw_reset_sta_iter, rtwdev);
+	rtw_iterate_vifs(rtwdev, rtw_reset_vif_iter, rtwdev);
 	rtw_enter_ips(rtwdev);
 }
 
@@ -1560,6 +1559,10 @@
 		rtwdev->hci.rpwm_addr = 0x03d9;
 		rtwdev->hci.cpwm_addr = 0x03da;
 		break;
+	case RTW_HCI_TYPE_SDIO:
+		rtwdev->hci.rpwm_addr = REG_SDIO_HRPWM1;
+		rtwdev->hci.cpwm_addr = REG_SDIO_HCPWM1_V2;
+		break;
 	default:
 		rtw_err(rtwdev, "unsupported hci type\n");
 		return -EINVAL;
@@ -1838,12 +1841,12 @@
 	skb_queue_head_init(&rtwdev->coex.queue);
 	skb_queue_head_init(&rtwdev->tx_report.queue);
 
-	spin_lock_init(&rtwdev->rf_lock);
-	spin_lock_init(&rtwdev->h2c.lock);
 	spin_lock_init(&rtwdev->txq_lock);
 	spin_lock_init(&rtwdev->tx_report.q_lock);
 
 	mutex_init(&rtwdev->mutex);
+	mutex_init(&rtwdev->rf_lock);
+	mutex_init(&rtwdev->h2c.lock);
 	mutex_init(&rtwdev->coex.mutex);
 	mutex_init(&rtwdev->hal.tx_power_mutex);
 
diff -Naur a/drivers/net/wireless/realtek/rtw88/main.h b/drivers/net/wireless/realtek/rtw88/main.h
--- a/drivers/net/wireless/realtek/rtw88/main.h	2021-10-31 16:53:10.000000000 -0400
+++ b/drivers/net/wireless/realtek/rtw88/main.h	2021-10-31 20:41:20.000000000 -0400
@@ -1843,7 +1843,7 @@
 	struct mutex mutex;
 
 	/* read/write rf register */
-	spinlock_t rf_lock;
+	struct mutex rf_lock;
 
 	/* watch dog every 2 sec */
 	struct delayed_work watch_dog_work;
@@ -1869,7 +1869,7 @@
 		/* incicate the mail box to use with fw */
 		u8 last_box_num;
 		/* protect to send h2c to fw */
-		spinlock_t lock;
+		struct mutex lock;
 		u32 seq;
 	} h2c;
 
diff -Naur a/drivers/net/wireless/realtek/rtw88/Makefile b/drivers/net/wireless/realtek/rtw88/Makefile
--- a/drivers/net/wireless/realtek/rtw88/Makefile	2021-10-31 16:53:10.000000000 -0400
+++ b/drivers/net/wireless/realtek/rtw88/Makefile	2021-10-31 20:41:20.000000000 -0400
@@ -25,12 +25,18 @@
 obj-$(CONFIG_RTW88_8822BE)	+= rtw88_8822be.o
 rtw88_8822be-objs		:= rtw8822be.o
 
+obj-$(CONFIG_RTW88_8822BS)	+= rtw88_8822bs.o
+rtw88_8822bs-objs		:= rtw8822bs.o
+
 obj-$(CONFIG_RTW88_8822C)	+= rtw88_8822c.o
 rtw88_8822c-objs		:= rtw8822c.o rtw8822c_table.o
 
 obj-$(CONFIG_RTW88_8822CE)	+= rtw88_8822ce.o
 rtw88_8822ce-objs		:= rtw8822ce.o
 
+obj-$(CONFIG_RTW88_8822CS)	+= rtw88_8822cs.o
+rtw88_8822cs-objs		:= rtw8822cs.o
+
 obj-$(CONFIG_RTW88_8723D)	+= rtw88_8723d.o
 rtw88_8723d-objs		:= rtw8723d.o rtw8723d_table.o
 
@@ -45,3 +51,6 @@
 
 obj-$(CONFIG_RTW88_PCI)		+= rtw88_pci.o
 rtw88_pci-objs			:= pci.o
+
+obj-$(CONFIG_RTW88_SDIO)	+= rtw88_sdio.o
+rtw88_sdio-objs			:= sdio.o
diff -Naur a/drivers/net/wireless/realtek/rtw88/phy.c b/drivers/net/wireless/realtek/rtw88/phy.c
--- a/drivers/net/wireless/realtek/rtw88/phy.c	2021-10-31 16:53:10.000000000 -0400
+++ b/drivers/net/wireless/realtek/rtw88/phy.c	2021-10-31 20:41:20.000000000 -0400
@@ -240,7 +240,7 @@
 
 	data.rtwdev = rtwdev;
 	data.min_rssi = U8_MAX;
-	rtw_iterate_stas_atomic(rtwdev, rtw_phy_stat_rssi_iter, &data);
+	rtw_iterate_stas(rtwdev, rtw_phy_stat_rssi_iter, &data);
 
 	dm_info->pre_min_rssi = dm_info->min_rssi;
 	dm_info->min_rssi = data.min_rssi;
@@ -484,7 +484,7 @@
 	if (rtwdev->watch_dog_cnt & 0x3)
 		return;
 
-	rtw_iterate_stas_atomic(rtwdev, rtw_phy_ra_info_update_iter, rtwdev);
+	rtw_iterate_stas(rtwdev, rtw_phy_ra_info_update_iter, rtwdev);
 }
 
 static u32 rtw_phy_get_rrsr_mask(struct rtw_dev *rtwdev, u8 rate_idx)
diff -Naur a/drivers/net/wireless/realtek/rtw88/ps.c b/drivers/net/wireless/realtek/rtw88/ps.c
--- a/drivers/net/wireless/realtek/rtw88/ps.c	2021-10-31 16:53:10.000000000 -0400
+++ b/drivers/net/wireless/realtek/rtw88/ps.c	2021-10-31 20:41:20.000000000 -0400
@@ -58,7 +58,7 @@
 		return ret;
 	}
 
-	rtw_iterate_vifs_atomic(rtwdev, rtw_restore_port_cfg_iter, rtwdev);
+	rtw_iterate_vifs(rtwdev, rtw_restore_port_cfg_iter, rtwdev);
 
 	rtw_coex_ips_notify(rtwdev, COEX_IPS_LEAVE);
 
diff -Naur a/drivers/net/wireless/realtek/rtw88/rtw8822b.c b/drivers/net/wireless/realtek/rtw88/rtw8822b.c
--- a/drivers/net/wireless/realtek/rtw88/rtw8822b.c	2021-10-31 16:53:10.000000000 -0400
+++ b/drivers/net/wireless/realtek/rtw88/rtw8822b.c	2021-10-31 20:41:20.000000000 -0400
@@ -25,6 +25,12 @@
 	ether_addr_copy(efuse->addr, map->e.mac_addr);
 }
 
+static void rtw8822bs_efuse_parsing(struct rtw_efuse *efuse,
+				    struct rtw8822b_efuse *map)
+{
+	ether_addr_copy(efuse->addr, map->s.mac_addr);
+}
+
 static int rtw8822b_read_efuse(struct rtw_dev *rtwdev, u8 *log_map)
 {
 	struct rtw_efuse *efuse = &rtwdev->efuse;
@@ -55,6 +61,9 @@
 	case RTW_HCI_TYPE_PCIE:
 		rtw8822be_efuse_parsing(efuse, map);
 		break;
+	case RTW_HCI_TYPE_SDIO:
+		rtw8822bs_efuse_parsing(efuse, map);
+		break;
 	default:
 		/* unsupported now */
 		return -ENOTSUPP;
diff -Naur a/drivers/net/wireless/realtek/rtw88/rtw8822b.h b/drivers/net/wireless/realtek/rtw88/rtw8822b.h
--- a/drivers/net/wireless/realtek/rtw88/rtw8822b.h	2021-10-31 16:53:10.000000000 -0400
+++ b/drivers/net/wireless/realtek/rtw88/rtw8822b.h	2021-10-31 20:41:20.000000000 -0400
@@ -65,6 +65,11 @@
 	u8 res7;
 };
 
+struct rtw8822bs_efuse {
+	u8 res4[0x4a];			/* 0xd0 */
+	u8 mac_addr[ETH_ALEN];		/* 0x11a */
+};
+
 struct rtw8822b_efuse {
 	__le16 rtl_id;
 	u8 res0[0x0e];
@@ -94,6 +99,7 @@
 	union {
 		struct rtw8822bu_efuse u;
 		struct rtw8822be_efuse e;
+		struct rtw8822bs_efuse s;
 	};
 };
 
diff -Naur a/drivers/net/wireless/realtek/rtw88/rtw8822bs.c b/drivers/net/wireless/realtek/rtw88/rtw8822bs.c
--- a/drivers/net/wireless/realtek/rtw88/rtw8822bs.c	1969-12-31 19:00:00.000000000 -0500
+++ b/drivers/net/wireless/realtek/rtw88/rtw8822bs.c	2021-10-31 20:41:20.000000000 -0400
@@ -0,0 +1,34 @@
+// SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause
+// Copyright(c) Jernej Skrabec <jernej.skrabec@gmail.com>
+
+#include <linux/mmc/sdio_func.h>
+#include <linux/mmc/sdio_ids.h>
+#include <linux/module.h>
+#include "sdio.h"
+#include "rtw8822bs.h"
+
+static const struct sdio_device_id rtw_8822bs_id_table[] =  {
+	{
+		SDIO_DEVICE(SDIO_VENDOR_ID_REALTEK,
+			    SDIO_DEVICE_ID_REALTEK_RTW8822BS),
+		.driver_data = (kernel_ulong_t)&rtw8822b_hw_spec,
+	},
+	{}
+};
+MODULE_DEVICE_TABLE(sdio, rtw_8822bs_id_table);
+
+static struct sdio_driver rtw_8822bs_driver = {
+	.name = "rtw_8822bs",
+	.probe = rtw_sdio_probe,
+	.remove = rtw_sdio_remove,
+	.id_table = rtw_8822bs_id_table,
+	.drv = {
+		.pm = &rtw_sdio_pm_ops,
+		.shutdown = rtw_sdio_shutdown,
+	}
+};
+module_sdio_driver(rtw_8822bs_driver);
+
+MODULE_AUTHOR("Jernej Skrabec <jernej.skrabec@gmail.com>");
+MODULE_DESCRIPTION("Realtek 802.11ac wireless 8822bs driver");
+MODULE_LICENSE("Dual BSD/GPL");
diff -Naur a/drivers/net/wireless/realtek/rtw88/rtw8822bs.h b/drivers/net/wireless/realtek/rtw88/rtw8822bs.h
--- a/drivers/net/wireless/realtek/rtw88/rtw8822bs.h	1969-12-31 19:00:00.000000000 -0500
+++ b/drivers/net/wireless/realtek/rtw88/rtw8822bs.h	2021-10-31 20:41:20.000000000 -0400
@@ -0,0 +1,10 @@
+/* SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause */
+/* Copyright(c) 2021 Jernej Skrabec <jernej.skrabec@gmail.com>
+ */
+
+#ifndef __RTW_8822BS_H_
+#define __RTW_8822BS_H_
+
+extern struct rtw_chip_info rtw8822b_hw_spec;
+
+#endif
diff -Naur a/drivers/net/wireless/realtek/rtw88/rtw8822c.c b/drivers/net/wireless/realtek/rtw88/rtw8822c.c
--- a/drivers/net/wireless/realtek/rtw88/rtw8822c.c	2021-10-31 16:53:10.000000000 -0400
+++ b/drivers/net/wireless/realtek/rtw88/rtw8822c.c	2021-10-31 20:41:20.000000000 -0400
@@ -29,6 +29,12 @@
 	ether_addr_copy(efuse->addr, map->e.mac_addr);
 }
 
+static void rtw8822cs_efuse_parsing(struct rtw_efuse *efuse,
+				    struct rtw8822c_efuse *map)
+{
+	ether_addr_copy(efuse->addr, map->s.mac_addr);
+}
+
 static int rtw8822c_read_efuse(struct rtw_dev *rtwdev, u8 *log_map)
 {
 	struct rtw_efuse *efuse = &rtwdev->efuse;
@@ -58,6 +64,9 @@
 	case RTW_HCI_TYPE_PCIE:
 		rtw8822ce_efuse_parsing(efuse, map);
 		break;
+	case RTW_HCI_TYPE_SDIO:
+		rtw8822cs_efuse_parsing(efuse, map);
+		break;
 	default:
 		/* unsupported now */
 		return -ENOTSUPP;
@@ -4835,6 +4844,7 @@
 	[0] = RTW_DEF_RFE(8822c, 0, 0),
 	[1] = RTW_DEF_RFE(8822c, 0, 0),
 	[2] = RTW_DEF_RFE(8822c, 0, 0),
+	[4] = RTW_DEF_RFE(8822c, 0, 0),
 	[5] = RTW_DEF_RFE(8822c, 0, 5),
 	[6] = RTW_DEF_RFE(8822c, 0, 0),
 };
diff -Naur a/drivers/net/wireless/realtek/rtw88/rtw8822c.h b/drivers/net/wireless/realtek/rtw88/rtw8822c.h
--- a/drivers/net/wireless/realtek/rtw88/rtw8822c.h	2021-10-31 16:53:10.000000000 -0400
+++ b/drivers/net/wireless/realtek/rtw88/rtw8822c.h	2021-10-31 20:41:20.000000000 -0400
@@ -16,6 +16,11 @@
 	u8 res2[0x3d];
 };
 
+struct rtw8822cs_efuse {
+	u8 res0[0x4a];			/* 0x120 */
+	u8 mac_addr[ETH_ALEN];		/* 0x16a */
+};
+
 struct rtw8822ce_efuse {
 	u8 mac_addr[ETH_ALEN];		/* 0x120 */
 	u8 vender_id[2];
@@ -92,6 +97,7 @@
 	u8 res10[0x42];
 	union {
 		struct rtw8822cu_efuse u;
+		struct rtw8822cs_efuse s;
 		struct rtw8822ce_efuse e;
 	};
 };
diff -Naur a/drivers/net/wireless/realtek/rtw88/rtw8822cs.c b/drivers/net/wireless/realtek/rtw88/rtw8822cs.c
--- a/drivers/net/wireless/realtek/rtw88/rtw8822cs.c	1969-12-31 19:00:00.000000000 -0500
+++ b/drivers/net/wireless/realtek/rtw88/rtw8822cs.c	2021-10-31 20:41:20.000000000 -0400
@@ -0,0 +1,34 @@
+// SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause
+// Copyright(c) Martin Blumenstingl
+
+#include <linux/mmc/sdio_func.h>
+#include <linux/mmc/sdio_ids.h>
+#include <linux/module.h>
+#include "sdio.h"
+#include "rtw8822cs.h"
+
+static const struct sdio_device_id rtw_8822cs_id_table[] =  {
+	{
+		SDIO_DEVICE(SDIO_VENDOR_ID_REALTEK,
+			    SDIO_DEVICE_ID_REALTEK_RTW8822CS),
+		.driver_data = (kernel_ulong_t)&rtw8822c_hw_spec,
+	},
+	{}
+};
+MODULE_DEVICE_TABLE(sdio, rtw_8822cs_id_table);
+
+static struct sdio_driver rtw_8822cs_driver = {
+	.name = "rtw_8822cs",
+	.probe = rtw_sdio_probe,
+	.remove = rtw_sdio_remove,
+	.id_table = rtw_8822cs_id_table,
+	.drv = {
+		.pm = &rtw_sdio_pm_ops,
+		.shutdown = rtw_sdio_shutdown,
+	}
+};
+module_sdio_driver(rtw_8822cs_driver);
+
+MODULE_AUTHOR("Martin Blumenstingl");
+MODULE_DESCRIPTION("Realtek 802.11ac wireless 8822cs driver");
+MODULE_LICENSE("Dual BSD/GPL");
diff -Naur a/drivers/net/wireless/realtek/rtw88/rtw8822cs.h b/drivers/net/wireless/realtek/rtw88/rtw8822cs.h
--- a/drivers/net/wireless/realtek/rtw88/rtw8822cs.h	1969-12-31 19:00:00.000000000 -0500
+++ b/drivers/net/wireless/realtek/rtw88/rtw8822cs.h	2021-10-31 20:41:20.000000000 -0400
@@ -0,0 +1,10 @@
+/* SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause */
+/* Copyright(c) 2021 Martin Blumenstingl
+ */
+
+#ifndef __RTW_8822CS_H_
+#define __RTW_8822CS_H_
+
+extern struct rtw_chip_info rtw8822c_hw_spec;
+
+#endif
diff -Naur a/drivers/net/wireless/realtek/rtw88/sdio.c b/drivers/net/wireless/realtek/rtw88/sdio.c
--- a/drivers/net/wireless/realtek/rtw88/sdio.c	1969-12-31 19:00:00.000000000 -0500
+++ b/drivers/net/wireless/realtek/rtw88/sdio.c	2021-10-31 20:41:20.000000000 -0400
@@ -0,0 +1,1091 @@
+// SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause
+/* Copyright (C) 2020 Martin Blumenstingl <martin.blumenstingl@googlemail.com>
+ *
+ * Based on rtw88/pci.c:
+ *   Copyright(c) 2018-2019  Realtek Corporation
+ */
+
+#include <linux/module.h>
+#include <linux/mmc/host.h>
+#include <linux/mmc/sdio_func.h>
+#include "sdio.h"
+#include "reg.h"
+#include "tx.h"
+#include "rx.h"
+#include "fw.h"
+#include "ps.h"
+#include "debug.h"
+
+#define RTW_SDIO_INDIRECT_RW_RETRIES		50
+
+static bool rtw_sdio_is_bus_addr(u32 addr)
+{
+	return (addr & RTW_SDIO_BUS_MSK) != 0;
+}
+
+static bool rtw_sdio_bus_claim_needed(struct rtw_sdio *rtwsdio)
+{
+	return !rtwsdio->irq_thread ||
+	       rtwsdio->irq_thread != current;
+}
+
+static u32 rtw_sdio_to_bus_offset(struct rtw_dev *rtwdev, u32 addr)
+{
+	switch (addr & RTW_SDIO_BUS_MSK) {
+	case WLAN_IOREG_OFFSET:
+		addr &= WLAN_IOREG_REG_MSK;
+		addr |= FIELD_PREP(REG_SDIO_CMD_ADDR_MSK,
+				   REG_SDIO_CMD_ADDR_MAC_REG);
+		break;
+	case SDIO_LOCAL_OFFSET:
+		addr &= SDIO_LOCAL_REG_MSK;
+		addr |= FIELD_PREP(REG_SDIO_CMD_ADDR_MSK,
+				   REG_SDIO_CMD_ADDR_SDIO_REG);
+		break;
+	default:
+		rtw_warn(rtwdev, "Cannot convert addr 0x%08x to bus offset",
+			 addr);
+	}
+
+	return addr;
+}
+
+static u32 rtw_sdio_mask_addr(u32 addr)
+{
+	/* Mask addr to remove driver defined bit and
+	 * make sure addr is in valid range
+	 */
+	return addr & 0x1ffff;
+}
+
+static bool rtw_sdio_is_buffer_dma_ready(void *buf)
+{
+	return virt_addr_valid(buf) && !object_is_on_stack(buf);
+}
+
+static u8 rtw_sdio_readb(struct rtw_dev *rtwdev, u32 addr, int *ret)
+{
+	struct rtw_sdio *rtwsdio = (struct rtw_sdio *)rtwdev->priv;
+
+	addr = rtw_sdio_mask_addr(addr);
+
+	return sdio_readb(rtwsdio->sdio_func, addr, ret);
+}
+
+static int rtw_sdio_writeb(struct rtw_dev *rtwdev, u32 addr, u8 data)
+{
+	struct rtw_sdio *rtwsdio = (struct rtw_sdio *)rtwdev->priv;
+	int ret;
+
+	addr = rtw_sdio_mask_addr(addr);
+
+	sdio_writeb(rtwsdio->sdio_func, data, addr, &ret);
+
+	return ret;
+}
+
+static int rtw_sdio_read_bytes(struct rtw_dev *rtwdev, u32 addr, void *buf,
+			       size_t count)
+{
+	struct rtw_sdio *rtwsdio = (struct rtw_sdio *)rtwdev->priv;
+	u8 *byte_buf = buf;
+	int i, ret = 0;
+
+	addr = rtw_sdio_mask_addr(addr);
+
+	for (i = 0; i < count; i++) {
+		byte_buf[i] = sdio_readb(rtwsdio->sdio_func, addr, &ret);
+		if (ret)
+			break;
+	}
+
+	return ret;
+}
+
+static int rtw_sdio_read_block(struct rtw_dev *rtwdev, u32 addr, void *buf,
+			       size_t count)
+{
+	struct rtw_sdio *rtwsdio = (struct rtw_sdio *)rtwdev->priv;
+	void *ptr = buf;
+	bool bounce;
+	int ret;
+
+	addr = rtw_sdio_mask_addr(addr);
+
+	bounce = !rtw_sdio_is_buffer_dma_ready(buf);
+	if (bounce) {
+		ptr = kmalloc(count, GFP_KERNEL);
+		if (!ptr)
+			return -ENOMEM;
+	}
+
+	ret = sdio_memcpy_fromio(rtwsdio->sdio_func, ptr, addr, count);
+
+	if (bounce) {
+		memcpy(buf, ptr, count);
+		kfree(ptr);
+	}
+
+	return ret;
+}
+
+static int rtw_sdio_write_bytes(struct rtw_dev *rtwdev, u32 addr, void *buf,
+				size_t count)
+{
+	struct rtw_sdio *rtwsdio = (struct rtw_sdio *)rtwdev->priv;
+	u8 *byte_buf = buf;
+	int i, ret = 0;
+
+	addr = rtw_sdio_mask_addr(addr);
+
+	for (i = 0; i < count; i++) {
+		sdio_writeb(rtwsdio->sdio_func, byte_buf[i], addr + i, &ret);
+		if (ret)
+			break;
+	}
+
+	return ret;
+}
+
+static int rtw_sdio_write_block(struct rtw_dev *rtwdev, u32 addr, void *buf,
+				size_t count)
+{
+	struct rtw_sdio *rtwsdio = (struct rtw_sdio *)rtwdev->priv;
+	void *ptr = buf;
+	bool bounce;
+	int ret;
+
+	addr = rtw_sdio_mask_addr(addr);
+
+	bounce = !rtw_sdio_is_buffer_dma_ready(buf);
+	if (bounce) {
+		ptr = kmemdup(buf, count, GFP_KERNEL);
+		if (!ptr)
+			return -ENOMEM;
+	}
+
+	ret = sdio_memcpy_toio(rtwsdio->sdio_func, addr, ptr, count);
+
+	if (bounce)
+		kfree(ptr);
+
+	return ret;
+}
+
+static u8 rtw_sdio_read_indirect8(struct rtw_dev *rtwdev, u32 addr, int *ret)
+{
+	u32 reg_cfg, reg_data;
+	int retry;
+	u8 tmp;
+
+	reg_cfg = rtw_sdio_to_bus_offset(rtwdev, REG_SDIO_INDIRECT_REG_CFG);
+	reg_data = rtw_sdio_to_bus_offset(rtwdev, REG_SDIO_INDIRECT_REG_DATA);
+
+	*ret = rtw_sdio_writeb(rtwdev, reg_cfg, addr);
+	if (*ret)
+		return 0;
+
+	*ret = rtw_sdio_writeb(rtwdev, reg_cfg + 1, addr >> 8);
+	if (*ret)
+		return 0;
+
+	*ret = rtw_sdio_writeb(rtwdev, reg_cfg + 2, BIT(3));
+	if (*ret)
+		return 0;
+
+	for (retry = 0; retry < RTW_SDIO_INDIRECT_RW_RETRIES; retry++) {
+		tmp = rtw_sdio_readb(rtwdev, reg_cfg + 2, ret);
+		if (!ret && tmp & BIT(4))
+			break;
+	}
+
+	if (*ret)
+		return 0;
+
+	return rtw_sdio_readb(rtwdev, reg_data, ret);
+}
+
+static u32 rtw_sdio_read_indirect32(struct rtw_dev *rtwdev, u32 addr, int *ret)
+{
+	u32 reg_cfg, reg_data;
+	int retry;
+	u32 data;
+	u8 tmp;
+
+	reg_cfg = rtw_sdio_to_bus_offset(rtwdev, REG_SDIO_INDIRECT_REG_CFG);
+	reg_data = rtw_sdio_to_bus_offset(rtwdev, REG_SDIO_INDIRECT_REG_DATA);
+
+	data = addr | BIT(19) | BIT(17);
+	*ret = rtw_sdio_write_block(rtwdev, reg_cfg, &data, 4);
+	if (*ret)
+		return 0;
+
+	for (retry = 0; retry < RTW_SDIO_INDIRECT_RW_RETRIES; retry++) {
+		tmp = rtw_sdio_readb(rtwdev, reg_cfg + 2, ret);
+		if (!ret && tmp & BIT(4))
+			break;
+	}
+
+	if (*ret)
+		return 0;
+
+	*ret = rtw_sdio_read_block(rtwdev, reg_data, &data, 4);
+
+	return data;
+}
+
+static int rtw_sdio_read_indirect(struct rtw_dev *rtwdev, u32 addr, u8 *buf,
+				  size_t count)
+{
+	struct rtw_sdio *rtwsdio = (struct rtw_sdio *)rtwdev->priv;
+	bool unaligned;
+	size_t i;
+	int ret;
+
+	mutex_lock(&rtwsdio->indirect_mutex);
+
+	switch (count) {
+	case 1:
+		if (!rtwsdio->is_powered_on)
+			buf[0] = rtw_sdio_read_indirect8(rtwdev, addr, &ret);
+		else
+			buf[0] = rtw_sdio_read_indirect32(rtwdev, addr, &ret);
+		break;
+
+	case 2:
+	case 4:
+		unaligned = (addr & (count - 1));
+		if (!rtwsdio->is_powered_on) {
+			if (unaligned) {
+				for (i = 0; i < count; i++) {
+					buf[i] = rtw_sdio_read_indirect8(rtwdev, addr + i, &ret);
+					if (ret)
+						break;
+				}
+			} else {
+				buf[0] = rtw_sdio_read_indirect8(rtwdev, addr, &ret);
+				if (ret)
+					break;
+				addr = rtw_sdio_to_bus_offset(rtwdev, REG_SDIO_INDIRECT_REG_DATA);
+				for (i = 1; i < count; i++) {
+					buf[i] = rtw_sdio_readb(rtwdev, addr + i, &ret);
+					if (ret)
+						break;
+				}
+			}
+		} else {
+			if (unaligned) {
+				for (i = 0; i < count; i++) {
+					buf[i] = rtw_sdio_read_indirect32(rtwdev, addr + i, &ret);
+					if (ret)
+						break;
+				}
+			} else {
+				u32 val;
+
+				val = rtw_sdio_read_indirect32(rtwdev, addr + i,
+							       &ret);
+				memcpy(buf, &val, count);
+			}
+		}
+		break;
+
+	default:
+		rtw_warn(rtwdev, "Invalid size %lu for indirect read", count);
+	}
+
+	mutex_unlock(&rtwsdio->indirect_mutex);
+
+	return ret;
+}
+
+static int rtw_sdio_read(struct rtw_dev *rtwdev, u32 addr, void *buf,
+			 size_t count)
+{
+	struct rtw_sdio *rtwsdio = (struct rtw_sdio *)rtwdev->priv;
+	bool per_byte, direct, bus_claim;
+	int ret;
+
+	direct = rtw_sdio_is_bus_addr(addr);
+	if (direct) {
+		addr = rtw_sdio_to_bus_offset(rtwdev, addr);
+		per_byte = (addr & 3) ||
+			   (count & 3) ||
+			   !rtwsdio->is_powered_on;
+	}
+
+	bus_claim = rtw_sdio_bus_claim_needed(rtwsdio);
+
+	if (bus_claim)
+		sdio_claim_host(rtwsdio->sdio_func);
+
+	if (!direct)
+		ret = rtw_sdio_read_indirect(rtwdev, addr, buf, count);
+	else if (per_byte)
+		ret = rtw_sdio_read_bytes(rtwdev, addr, buf, count);
+	else
+		ret = rtw_sdio_read_block(rtwdev, addr, buf, count);
+
+	if (bus_claim)
+		sdio_release_host(rtwsdio->sdio_func);
+
+	return ret;
+}
+
+static int rtw_sdio_write(struct rtw_dev *rtwdev, u32 addr, void *buf,
+			  size_t count)
+{
+	struct rtw_sdio *rtwsdio = (struct rtw_sdio *)rtwdev->priv;
+	bool per_byte, bus_claim;
+	int ret;
+
+	if (!rtw_sdio_is_bus_addr(addr))
+		addr |= WLAN_IOREG_OFFSET;
+
+	addr = rtw_sdio_to_bus_offset(rtwdev, addr);
+
+	per_byte = (addr & 3) ||
+		   (count & 3) ||
+		   !rtwsdio->is_powered_on;
+
+	bus_claim = rtw_sdio_bus_claim_needed(rtwsdio);
+
+	if (bus_claim)
+		sdio_claim_host(rtwsdio->sdio_func);
+
+	if (per_byte)
+		ret = rtw_sdio_write_bytes(rtwdev, addr, buf, count);
+	else
+		ret = rtw_sdio_write_block(rtwdev, addr, buf, count);
+
+	if (bus_claim)
+		sdio_release_host(rtwsdio->sdio_func);
+
+	return ret;
+}
+
+static u8 rtw_sdio_read8(struct rtw_dev *rtwdev, u32 addr)
+{
+	int ret;
+	u8 tmp;
+
+	ret = rtw_sdio_read(rtwdev, addr, &tmp, 1);
+	if (ret)
+		rtw_warn(rtwdev, "sdio read8 failed (0x%x): %d", addr, ret);
+
+	return tmp;
+}
+
+static u16 rtw_sdio_read16(struct rtw_dev *rtwdev, u32 addr)
+{
+	__le16 tmp;
+	int ret;
+
+	ret = rtw_sdio_read(rtwdev, addr, &tmp, 2);
+	if (ret)
+		rtw_warn(rtwdev, "sdio read16 failed (0x%x): %d", addr, ret);
+
+	return le16_to_cpu(tmp);
+}
+
+static u32 rtw_sdio_read32(struct rtw_dev *rtwdev, u32 addr)
+{
+	__le32 tmp;
+	int ret;
+
+	ret = rtw_sdio_read(rtwdev, addr, &tmp, 4);
+	if (ret)
+		rtw_warn(rtwdev, "sdio read32 failed (0x%x): %d", addr, ret);
+
+	return le32_to_cpu(tmp);
+}
+
+static void rtw_sdio_write8(struct rtw_dev *rtwdev, u32 addr, u8 val)
+{
+	int ret;
+
+	ret = rtw_sdio_write(rtwdev, addr, &val, 1);
+	if (ret)
+		rtw_warn(rtwdev, "sdio write8 failed (0x%x): %d", addr, ret);
+}
+
+static void rtw_sdio_write16(struct rtw_dev *rtwdev, u32 addr, u16 val)
+{
+	__le16 tmp = cpu_to_le16(val);
+	int ret;
+
+	ret = rtw_sdio_write(rtwdev, addr, &tmp, 2);
+	if (ret)
+		rtw_warn(rtwdev, "sdio write16 failed (0x%x): %d", addr, ret);
+}
+
+static void rtw_sdio_write32(struct rtw_dev *rtwdev, u32 addr, u32 val)
+{
+	__le32 tmp = cpu_to_le32(val);
+	int ret;
+
+	ret = rtw_sdio_write(rtwdev, addr, &tmp, 4);
+	if (ret)
+		rtw_warn(rtwdev, "sdio write32 failed (0x%x): %d", addr, ret);
+}
+
+static size_t rtw_sdio_cmd53_align_size(size_t len)
+{
+	len = ALIGN(len, 4);
+
+	if (len < RTW_SDIO_BLOCK_SIZE)
+		return len;
+
+	return ALIGN(len, RTW_SDIO_BLOCK_SIZE);
+}
+
+static u32 rtw_sdio_get_tx_addr(struct rtw_dev *rtwdev, size_t size, u8 queue)
+{
+	u32 txaddr;
+
+	switch (queue) {
+	case RTW_TX_QUEUE_BCN:
+	case RTW_TX_QUEUE_H2C:
+	case RTW_TX_QUEUE_HI0:
+		txaddr = FIELD_PREP(REG_SDIO_CMD_ADDR_MSK,
+				    REG_SDIO_CMD_ADDR_TXFF_HIGH);
+		break;
+	case RTW_TX_QUEUE_VI:
+	case RTW_TX_QUEUE_VO:
+		txaddr = FIELD_PREP(REG_SDIO_CMD_ADDR_MSK,
+				    REG_SDIO_CMD_ADDR_TXFF_NORMAL);
+		break;
+	case RTW_TX_QUEUE_BE:
+	case RTW_TX_QUEUE_BK:
+		txaddr = FIELD_PREP(REG_SDIO_CMD_ADDR_MSK,
+				    REG_SDIO_CMD_ADDR_TXFF_LOW);
+		break;
+	case RTW_TX_QUEUE_MGMT:
+		txaddr = FIELD_PREP(REG_SDIO_CMD_ADDR_MSK,
+				    REG_SDIO_CMD_ADDR_TXFF_EXTRA);
+		break;
+	default:
+		rtw_warn(rtwdev, "Unsupported queue for TX addr: 0x%02x\n",
+			 queue);
+		return 0;
+	}
+
+	txaddr += DIV_ROUND_UP(size, 4);
+
+	return txaddr;
+};
+
+static int rtw_sdio_read_port(struct rtw_dev *rtwdev, u8 *buf, size_t count)
+{
+	struct rtw_sdio *rtwsdio = (struct rtw_sdio *)rtwdev->priv;
+	u32 rxaddr = rtwsdio->rx_addr++;
+	int ret;
+
+	ret = sdio_memcpy_fromio(rtwsdio->sdio_func, buf,
+				 RTW_SDIO_ADDR_RX_RX0FF_GEN(rxaddr), count);
+	if (ret)
+		rtw_warn(rtwdev,
+			 "Failed to read %lu byte(s) from SDIO port 0x%08x",
+			 count, rxaddr);
+
+	return ret;
+}
+
+static int rtw_sdio_write_port(struct rtw_dev *rtwdev, u8 *buf,
+			       size_t count, u8 queue)
+{
+	struct rtw_sdio *rtwsdio = (struct rtw_sdio *)rtwdev->priv;
+	bool bus_claim;
+	size_t txsize;
+	u32 txaddr;
+	void *ptr;
+	int ret;
+
+	txaddr = rtw_sdio_get_tx_addr(rtwdev, count, queue);
+	if (!txaddr)
+		return -EINVAL;
+
+	txsize = rtw_sdio_cmd53_align_size(count);
+
+	ptr = kmalloc(txsize, GFP_KERNEL | GFP_DMA);
+	if (!ptr)
+		return -ENOMEM;
+
+	memcpy(ptr, buf, count);
+
+	bus_claim = rtw_sdio_bus_claim_needed(rtwsdio);
+
+	if (bus_claim)
+		sdio_claim_host(rtwsdio->sdio_func);
+	ret = sdio_memcpy_toio(rtwsdio->sdio_func,
+			       rtw_sdio_mask_addr(txaddr), ptr, txsize);
+	if (bus_claim)
+		sdio_release_host(rtwsdio->sdio_func);
+
+	if (ret)
+		rtw_warn(rtwdev,
+			 "Failed to write %lu byte(s) to SDIO port 0x%08x",
+			 txsize, txaddr);
+
+	kfree(ptr);
+
+	return ret;
+}
+
+static void rtw_sdio_init(struct rtw_dev *rtwdev)
+{
+	struct rtw_sdio *rtwsdio = (struct rtw_sdio *)rtwdev->priv;
+
+	rtwsdio->irq_mask = REG_SDIO_HIMR_RX_REQUEST | REG_SDIO_HIMR_CPWM1;
+
+	mutex_init(&rtwsdio->indirect_mutex);
+}
+
+static void rtw_sdio_enable_interrupt(struct rtw_dev *rtwdev)
+{
+	struct rtw_sdio *rtwsdio = (struct rtw_sdio *)rtwdev->priv;
+
+	rtw_write32(rtwdev, REG_SDIO_HIMR, rtwsdio->irq_mask);
+}
+
+static void rtw_sdio_disable_interrupt(struct rtw_dev *rtwdev)
+{
+	rtw_write32(rtwdev, REG_SDIO_HIMR, 0x0);
+}
+
+static u8 ac_to_hwq[] = {
+	[IEEE80211_AC_VO] = RTW_TX_QUEUE_VO,
+	[IEEE80211_AC_VI] = RTW_TX_QUEUE_VI,
+	[IEEE80211_AC_BE] = RTW_TX_QUEUE_BE,
+	[IEEE80211_AC_BK] = RTW_TX_QUEUE_BK,
+};
+
+static_assert(ARRAY_SIZE(ac_to_hwq) == IEEE80211_NUM_ACS);
+
+static u8 rtw_hw_queue_mapping(struct sk_buff *skb)
+{
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
+	u8 q_mapping = skb_get_queue_mapping(skb);
+	__le16 fc = hdr->frame_control;
+	u8 queue;
+
+	if (unlikely(ieee80211_is_beacon(fc)))
+		queue = RTW_TX_QUEUE_BCN;
+	else if (unlikely(ieee80211_is_mgmt(fc) || ieee80211_is_ctl(fc)))
+		queue = RTW_TX_QUEUE_MGMT;
+	else if (WARN_ON_ONCE(q_mapping >= ARRAY_SIZE(ac_to_hwq)))
+		queue = ac_to_hwq[IEEE80211_AC_BE];
+	else
+		queue = ac_to_hwq[q_mapping];
+
+	return queue;
+}
+
+static u8 rtw_sdio_get_tx_qsel(struct sk_buff *skb, u8 queue)
+{
+	switch (queue) {
+	case RTW_TX_QUEUE_BCN:
+		return TX_DESC_QSEL_BEACON;
+	case RTW_TX_QUEUE_H2C:
+		return TX_DESC_QSEL_H2C;
+	case RTW_TX_QUEUE_MGMT:
+		return TX_DESC_QSEL_MGMT;
+	case RTW_TX_QUEUE_HI0:
+		return TX_DESC_QSEL_HIGH;
+	default:
+		return skb->priority;
+	}
+};
+
+static void rtw_sdio_tx_kick_off(struct rtw_dev *rtwdev)
+{
+	struct rtw_sdio *rtwsdio = (struct rtw_sdio *)rtwdev->priv;
+
+	queue_work(rtwsdio->txwq, &rtwsdio->tx_handler_data->work);
+}
+
+static int rtw_sdio_setup(struct rtw_dev *rtwdev)
+{
+	/* nothing to do */
+	return 0;
+}
+
+static int rtw_sdio_start(struct rtw_dev *rtwdev)
+{
+	rtw_sdio_enable_interrupt(rtwdev);
+
+	return 0;
+}
+
+static void rtw_sdio_stop(struct rtw_dev *rtwdev)
+{
+	rtw_sdio_disable_interrupt(rtwdev);
+}
+
+static void rtw_sdio_deep_ps(struct rtw_dev *rtwdev, bool enter)
+{
+	/* nothing to do */
+}
+
+static void rtw_sdio_link_ps(struct rtw_dev *rtwdev, bool enter)
+{
+	/* nothing to do */
+}
+
+static void rtw_sdio_interface_cfg(struct rtw_dev *rtwdev)
+{
+	u32 val;
+
+	rtw_read32(rtwdev, REG_SDIO_FREE_TXPG);
+
+	val = rtw_read32(rtwdev, REG_SDIO_FREE_TXPG);
+	val &= 0xffff;
+	val &= ~(REG_SDIO_TX_ERRSTPINTEN |
+		 REG_SDIO_TX_ENMSKTMR |
+		 REG_SDIO_TX_ENRXDMAMSKINT);
+	rtw_write32(rtwdev, REG_SDIO_FREE_TXPG, val);
+}
+
+static void rtw_sdio_power_switch(struct rtw_dev *rtwdev, bool on)
+{
+	struct rtw_sdio *rtwsdio = (struct rtw_sdio *)rtwdev->priv;
+
+	rtwsdio->is_powered_on = true;
+}
+
+static int rtw_sdio_write_data(struct rtw_dev *rtwdev,
+			       struct rtw_tx_pkt_info *pkt_info,
+			       struct sk_buff *skb, u8 queue)
+{
+	struct rtw_chip_info *chip = rtwdev->chip;
+	u8 *pkt_desc;
+	int ret;
+
+	pkt_desc = skb_push(skb, chip->tx_pkt_desc_sz);
+	memset(pkt_desc, 0, chip->tx_pkt_desc_sz);
+	pkt_info->qsel = rtw_sdio_get_tx_qsel(skb, queue);
+	rtw_tx_fill_tx_desc(pkt_info, skb);
+	fill_txdesc_checksum_common(skb->data);
+
+	ret = rtw_sdio_write_port(rtwdev, skb->data, skb->len, queue);
+	dev_kfree_skb_any(skb);
+
+	return ret;
+}
+
+static int rtw_sdio_write_data_rsvd_page(struct rtw_dev *rtwdev, u8 *buf,
+					 u32 size)
+{
+	struct rtw_tx_pkt_info pkt_info = {};
+	struct sk_buff *skb;
+
+	skb = rtw_tx_write_data_rsvd_page_get(rtwdev, &pkt_info, buf, size);
+	if (!skb)
+		return -ENOMEM;
+
+	return rtw_sdio_write_data(rtwdev, &pkt_info, skb, RTW_TX_QUEUE_BCN);
+}
+
+static int rtw_sdio_write_data_h2c(struct rtw_dev *rtwdev, u8 *buf, u32 size)
+{
+	struct rtw_tx_pkt_info pkt_info = {};
+	struct sk_buff *skb;
+
+	skb = rtw_tx_write_data_h2c_get(rtwdev, &pkt_info, buf, size);
+	if (!skb)
+		return -ENOMEM;
+
+	return rtw_sdio_write_data(rtwdev, &pkt_info, skb, RTW_TX_QUEUE_H2C);
+}
+
+static int rtw_sdio_tx_write(struct rtw_dev *rtwdev,
+			     struct rtw_tx_pkt_info *pkt_info,
+			     struct sk_buff *skb)
+{
+	struct rtw_sdio *rtwsdio = (struct rtw_sdio *)rtwdev->priv;
+	struct rtw_chip_info *chip = rtwdev->chip;
+	u8 queue = rtw_hw_queue_mapping(skb);
+	u8 *pkt_desc;
+
+	pkt_desc = skb_push(skb, chip->tx_pkt_desc_sz);
+	memset(pkt_desc, 0, chip->tx_pkt_desc_sz);
+	pkt_info->qsel = rtw_sdio_get_tx_qsel(skb, queue);
+	rtw_tx_fill_tx_desc(pkt_info, skb);
+	fill_txdesc_checksum_common(skb->data);
+
+	skb_queue_tail(&rtwsdio->tx_queue[queue], skb);
+
+	return 0;
+}
+
+static void rtw_sdio_tx_err_isr(struct rtw_dev *rtwdev)
+{
+	u32 val = rtw_read32(rtwdev, REG_TXDMA_STATUS);
+
+	rtw_write32(rtwdev, REG_TXDMA_STATUS, val);
+}
+
+static void rtw_sdio_rxfifo_recv(struct rtw_dev *rtwdev, u32 rx_len)
+{
+	struct rtw_chip_info *chip = rtwdev->chip;
+	u32 pkt_desc_sz = chip->rx_pkt_desc_sz;
+	struct rtw_rx_pkt_stat pkt_stat;
+	struct sk_buff *skb;
+	u32 pkt_offset;
+	size_t bufsz;
+	u8 *rx_desc;
+	int ret;
+
+	bufsz = rtw_sdio_cmd53_align_size(rx_len);
+
+	skb = dev_alloc_skb(bufsz);
+	if (!skb)
+		return;
+
+	ret = rtw_sdio_read_port(rtwdev, skb->data, bufsz);
+	if (ret) {
+		dev_kfree_skb_any(skb);
+		return;
+	}
+
+	rx_desc = skb->data;
+	chip->ops->query_rx_desc(rtwdev, rx_desc, &pkt_stat,
+				 (struct ieee80211_rx_status *)skb->cb);
+	pkt_offset = pkt_desc_sz + pkt_stat.drv_info_sz +
+		     pkt_stat.shift;
+
+	if (pkt_stat.is_c2h) {
+		skb_put(skb, pkt_stat.pkt_len + pkt_offset);
+		rtw_fw_c2h_cmd_rx_irqsafe(rtwdev, pkt_offset, skb);
+		return;
+	}
+
+	skb_put(skb, pkt_stat.pkt_len);
+	skb_reserve(skb, pkt_offset);
+	ieee80211_rx_irqsafe(rtwdev->hw, skb);
+}
+
+static void rtw_sdio_rx_isr(struct rtw_dev *rtwdev)
+{
+	u32 rx_len;
+
+	while (true) {
+		if (rtw_chip_wcpu_11n(rtwdev))
+			rx_len = rtw_read16(rtwdev, REG_SDIO_RX0_REQ_LEN);
+		else
+			rx_len = rtw_read32(rtwdev, REG_SDIO_RX0_REQ_LEN);
+
+		if (!rx_len)
+			break;
+
+		rtw_sdio_rxfifo_recv(rtwdev, rx_len);
+	}
+}
+
+static void rtw_sdio_handle_interrupt(struct sdio_func *sdio_func)
+{
+	struct ieee80211_hw *hw = sdio_get_drvdata(sdio_func);
+	struct rtw_dev *rtwdev = hw->priv;
+	struct rtw_sdio *rtwsdio = (struct rtw_sdio *)rtwdev->priv;
+	u32 hisr;
+
+	rtwsdio->irq_thread = current;
+
+	hisr = rtw_read32(rtwdev, REG_SDIO_HISR);
+
+	if (hisr & REG_SDIO_HISR_TXERR)
+		rtw_sdio_tx_err_isr(rtwdev);
+	if (hisr & REG_SDIO_HISR_RX_REQUEST) {
+		hisr &= ~REG_SDIO_HISR_RX_REQUEST;
+		rtw_sdio_rx_isr(rtwdev);
+	}
+
+	rtw_write32(rtwdev, REG_SDIO_HISR, hisr);
+
+	rtwsdio->irq_thread = NULL;
+}
+
+static int __maybe_unused rtw_sdio_suspend(struct device *dev)
+{
+	return 0;
+}
+
+static int __maybe_unused rtw_sdio_resume(struct device *dev)
+{
+	return 0;
+}
+
+SIMPLE_DEV_PM_OPS(rtw_sdio_pm_ops, rtw_sdio_suspend, rtw_sdio_resume);
+EXPORT_SYMBOL(rtw_sdio_pm_ops);
+
+static int rtw_sdio_claim(struct rtw_dev *rtwdev, struct sdio_func *sdio_func)
+{
+	struct rtw_sdio *rtwsdio = (struct rtw_sdio *)rtwdev->priv;
+	int ret;
+
+	sdio_claim_host(sdio_func);
+
+	ret = sdio_enable_func(sdio_func);
+	if (ret) {
+		rtw_err(rtwdev, "Failed to enable SDIO func");
+		goto err_release_host;
+	}
+
+	ret = sdio_set_block_size(sdio_func, RTW_SDIO_BLOCK_SIZE);
+	if (ret) {
+		rtw_err(rtwdev, "Failed to set SDIO block size to 512");
+		goto err_disable_func;
+	}
+
+	rtwsdio->sdio_func = sdio_func;
+
+	if (sdio_func->card->host->ios.timing >= MMC_TIMING_UHS_SDR12 &&
+	    sdio_func->card->host->ios.timing <= MMC_TIMING_UHS_DDR50)
+		rtwsdio->sdio3_bus_mode = true;
+
+	sdio_set_drvdata(sdio_func, rtwdev->hw);
+	SET_IEEE80211_DEV(rtwdev->hw, &sdio_func->dev);
+
+	sdio_release_host(sdio_func);
+
+	return 0;
+
+err_disable_func:
+	sdio_disable_func(sdio_func);
+err_release_host:
+	sdio_release_host(sdio_func);
+	return ret;
+}
+
+static void rtw_sdio_declaim(struct rtw_dev *rtwdev,
+			     struct sdio_func *sdio_func)
+{
+	sdio_disable_func(sdio_func);
+}
+
+static struct rtw_hci_ops rtw_sdio_ops = {
+	.tx_write = rtw_sdio_tx_write,
+	.tx_kick_off = rtw_sdio_tx_kick_off,
+	.setup = rtw_sdio_setup,
+	.start = rtw_sdio_start,
+	.stop = rtw_sdio_stop,
+	.deep_ps = rtw_sdio_deep_ps,
+	.link_ps = rtw_sdio_link_ps,
+	.interface_cfg = rtw_sdio_interface_cfg,
+
+	.power_switch = rtw_sdio_power_switch,
+
+	.read8 = rtw_sdio_read8,
+	.read16 = rtw_sdio_read16,
+	.read32 = rtw_sdio_read32,
+	.write8 = rtw_sdio_write8,
+	.write16 = rtw_sdio_write16,
+	.write32 = rtw_sdio_write32,
+	.write_data_rsvd_page = rtw_sdio_write_data_rsvd_page,
+	.write_data_h2c = rtw_sdio_write_data_h2c,
+};
+
+static int rtw_sdio_request_irq(struct rtw_dev *rtwdev,
+				struct sdio_func *sdio_func)
+{
+	int ret;
+
+	sdio_claim_host(sdio_func);
+	ret = sdio_claim_irq(sdio_func, &rtw_sdio_handle_interrupt);
+	sdio_release_host(sdio_func);
+
+	if (ret) {
+		rtw_err(rtwdev, "failed to claim SDIO IRQ");
+		return ret;
+	}
+
+	return 0;
+}
+
+static void rtw_sdio_tx_handler(struct work_struct *work)
+{
+	struct rtw_sdio_work_data *work_data =
+		container_of(work, struct rtw_sdio_work_data, work);
+	struct rtw_dev *rtwdev = work_data->rtwdev;
+	struct rtw_sdio *rtwsdio = (struct rtw_sdio *)rtwdev->priv;
+	struct sk_buff *skb;
+	int index, limit;
+
+	for (index = RTK_MAX_TX_QUEUE_NUM - 1; index >= 0; index--) {
+		for (limit = 0; limit < 200; limit++) {
+			skb = skb_dequeue(&rtwsdio->tx_queue[index]);
+			if (!skb)
+				break;
+
+			rtw_sdio_write_port(rtwdev, skb->data, skb->len, index);
+			dev_kfree_skb_any(skb);
+		}
+	}
+}
+
+static void rtw_sdio_free_irq(struct rtw_dev *rtwdev,
+			      struct sdio_func *sdio_func)
+{
+	sdio_release_irq(sdio_func);
+}
+
+static int rtw_sdio_init_tx(struct rtw_dev *rtwdev)
+{
+	struct rtw_sdio *rtwsdio = (struct rtw_sdio *)rtwdev->priv;
+	int i;
+
+	rtwsdio->txwq = create_singlethread_workqueue("rtw88_sdio: tx wq");
+	if (!rtwsdio->txwq) {
+		rtw_err(rtwdev, "failed to create TX work queue\n");
+		return -ENOMEM;
+	}
+
+	for (i = 0; i < RTK_MAX_TX_QUEUE_NUM; i++)
+		skb_queue_head_init(&rtwsdio->tx_queue[i]);
+	rtwsdio->tx_handler_data = kmalloc(sizeof(*rtwsdio->tx_handler_data),
+					   GFP_KERNEL);
+	if (!rtwsdio->tx_handler_data)
+		goto err_destroy_wq;
+
+	rtwsdio->tx_handler_data->rtwdev = rtwdev;
+	INIT_WORK(&rtwsdio->tx_handler_data->work, rtw_sdio_tx_handler);
+
+	return 0;
+
+err_destroy_wq:
+	destroy_workqueue(rtwsdio->txwq);
+	return -ENOMEM;
+}
+
+static void rtw_sdio_deinit_tx(struct rtw_dev *rtwdev)
+{
+	struct rtw_sdio *rtwsdio = (struct rtw_sdio *)rtwdev->priv;
+	int i;
+
+	for (i = 0; i < RTK_MAX_TX_QUEUE_NUM; i++)
+		skb_queue_purge(&rtwsdio->tx_queue[i]);
+
+	flush_workqueue(rtwsdio->txwq);
+	destroy_workqueue(rtwsdio->txwq);
+	kfree(rtwsdio->tx_handler_data);
+}
+
+int rtw_sdio_probe(struct sdio_func *sdio_func,
+		   const struct sdio_device_id *id)
+{
+	struct ieee80211_hw *hw;
+	struct rtw_dev *rtwdev;
+	int drv_data_size;
+	int ret;
+
+	drv_data_size = sizeof(struct rtw_dev) + sizeof(struct rtw_sdio);
+	hw = ieee80211_alloc_hw(drv_data_size, &rtw_ops);
+	if (!hw) {
+		dev_err(&sdio_func->dev, "failed to allocate hw");
+		return -ENOMEM;
+	}
+
+	rtwdev = hw->priv;
+	rtwdev->hw = hw;
+	rtwdev->dev = &sdio_func->dev;
+	rtwdev->chip = (struct rtw_chip_info *)id->driver_data;
+	rtwdev->hci.ops = &rtw_sdio_ops;
+	rtwdev->hci.type = RTW_HCI_TYPE_SDIO;
+
+	ret = rtw_core_init(rtwdev);
+	if (ret)
+		goto err_release_hw;
+
+	rtw_dbg(rtwdev, RTW_DBG_SDIO,
+		"rtw88 SDIO probe: vendor=0x%04x device=%04x class=%02x",
+		id->vendor, id->device, id->class);
+
+	ret = rtw_sdio_claim(rtwdev, sdio_func);
+	if (ret) {
+		rtw_err(rtwdev, "failed to claim SDIO device");
+		goto err_deinit_core;
+	}
+
+	rtw_sdio_init(rtwdev);
+
+	ret = rtw_sdio_init_tx(rtwdev);
+	if (ret) {
+		rtw_err(rtwdev, "failed to init SDIO TX queue\n");
+		goto err_sdio_declaim;
+	}
+
+	ret = rtw_chip_info_setup(rtwdev);
+	if (ret) {
+		rtw_err(rtwdev, "failed to setup chip information");
+		goto err_destroy_txwq;
+	}
+
+	ret = rtw_register_hw(rtwdev, hw);
+	if (ret) {
+		rtw_err(rtwdev, "failed to register hw");
+		goto err_destroy_txwq;
+	}
+
+	ret = rtw_sdio_request_irq(rtwdev, sdio_func);
+	if (ret)
+		goto err_unregister_hw;
+
+	return 0;
+
+err_unregister_hw:
+	rtw_unregister_hw(rtwdev, hw);
+err_destroy_txwq:
+	rtw_sdio_deinit_tx(rtwdev);
+err_sdio_declaim:
+	rtw_sdio_declaim(rtwdev, sdio_func);
+err_deinit_core:
+	rtw_core_deinit(rtwdev);
+err_release_hw:
+	ieee80211_free_hw(hw);
+
+	return ret;
+}
+EXPORT_SYMBOL(rtw_sdio_probe);
+
+void rtw_sdio_remove(struct sdio_func *sdio_func)
+{
+	struct ieee80211_hw *hw = sdio_get_drvdata(sdio_func);
+	struct rtw_dev *rtwdev;
+
+	if (!hw)
+		return;
+
+	rtwdev = hw->priv;
+
+	rtw_unregister_hw(rtwdev, hw);
+	rtw_sdio_disable_interrupt(rtwdev);
+	rtw_sdio_declaim(rtwdev, sdio_func);
+	rtw_sdio_free_irq(rtwdev, sdio_func);
+	rtw_sdio_deinit_tx(rtwdev);
+	rtw_core_deinit(rtwdev);
+	ieee80211_free_hw(hw);
+}
+EXPORT_SYMBOL(rtw_sdio_remove);
+
+void rtw_sdio_shutdown(struct device *dev)
+{
+	struct sdio_func *sdio_func = dev_to_sdio_func(dev);
+	struct ieee80211_hw *hw = sdio_get_drvdata(sdio_func);
+	struct rtw_dev *rtwdev;
+	struct rtw_chip_info *chip;
+
+	if (!hw)
+		return;
+
+	rtwdev = hw->priv;
+	chip = rtwdev->chip;
+
+	if (chip->ops->shutdown)
+		chip->ops->shutdown(rtwdev);
+}
+EXPORT_SYMBOL(rtw_sdio_shutdown);
+
+MODULE_AUTHOR("Martin Blumenstingl");
+MODULE_AUTHOR("Jernej Skrabec");
+MODULE_DESCRIPTION("Realtek 802.11ac wireless SDIO driver");
+MODULE_LICENSE("Dual BSD/GPL");
diff -Naur a/drivers/net/wireless/realtek/rtw88/sdio.h b/drivers/net/wireless/realtek/rtw88/sdio.h
--- a/drivers/net/wireless/realtek/rtw88/sdio.h	1969-12-31 19:00:00.000000000 -0500
+++ b/drivers/net/wireless/realtek/rtw88/sdio.h	2021-10-31 20:41:20.000000000 -0400
@@ -0,0 +1,167 @@
+/* SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause */
+/* Copyright (C) 2020 Martin Blumenstingl <martin.blumenstingl@googlemail.com>
+ */
+
+#ifndef __REG_SDIO_H_
+#define __REG_SDIO_H_
+
+#include "main.h"
+
+/* I/O bus domain address mapping */
+#define SDIO_LOCAL_OFFSET			0x10250000
+#define WLAN_IOREG_OFFSET			0x10260000
+#define FIRMWARE_FIFO_OFFSET			0x10270000
+#define TX_HIQ_OFFSET				0x10310000
+#define TX_MIQ_OFFSET				0x10320000
+#define TX_LOQ_OFFSET				0x10330000
+#define TX_EPQ_OFFSET				0x10350000
+#define RX_RX0FF_OFFSET				0x10340000
+
+#define RTW_SDIO_BUS_MSK			0xffff0000
+#define SDIO_LOCAL_REG_MSK			0x00000fff
+#define WLAN_IOREG_REG_MSK			0x0000ffff
+
+/* HCI Current Power Mode */
+#define REG_SDIO_HCPWM				(SDIO_LOCAL_OFFSET + 0x0019)
+/* RXDMA Request Length */
+#define REG_SDIO_RX0_REQ_LEN			(SDIO_LOCAL_OFFSET + 0x001C)
+/* OQT Free Page */
+#define REG_SDIO_OQT_FREE_PG			(SDIO_LOCAL_OFFSET + 0x001E)
+/* Free Tx Buffer Page */
+#define REG_SDIO_FREE_TXPG			(SDIO_LOCAL_OFFSET + 0x0020)
+/* HCI Current Power Mode 1 */
+#define REG_SDIO_HCPWM1				(SDIO_LOCAL_OFFSET + 0x0024)
+/* HCI Current Power Mode 2 */
+#define REG_SDIO_HCPWM2				(SDIO_LOCAL_OFFSET + 0x0026)
+/* Free Tx Page Sequence */
+#define REG_SDIO_FREE_TXPG_SEQ			(SDIO_LOCAL_OFFSET + 0x0028)
+/* HTSF Informaion */
+#define REG_SDIO_HTSFR_INFO			(SDIO_LOCAL_OFFSET + 0x0030)
+/* H2C */
+#define REG_SDIO_H2C				(SDIO_LOCAL_OFFSET + 0x0060)
+/* HCI Request Power Mode 1 */
+#define REG_SDIO_HRPWM1				(SDIO_LOCAL_OFFSET + 0x0080)
+/* HCI Request Power Mode 2 */
+#define REG_SDIO_HRPWM2				(SDIO_LOCAL_OFFSET + 0x0082)
+/* HCI Power Save Clock */
+#define REG_SDIO_HPS_CLKR			(SDIO_LOCAL_OFFSET + 0x0084)
+/* SDIO HCI Suspend Control */
+#define REG_SDIO_HSUS_CTRL			(SDIO_LOCAL_OFFSET + 0x0086)
+/* SDIO Host Extension Interrupt Mask Always */
+#define REG_SDIO_HIMR_ON			(SDIO_LOCAL_OFFSET + 0x0090)
+/* SDIO Host Extension Interrupt Status Always */
+#define REG_SDIO_HISR_ON			(SDIO_LOCAL_OFFSET + 0x0091)
+#define REG_SDIO_HCPWM1_V2			(SDIO_LOCAL_OFFSET + 0x0038)
+
+/* SDIO Tx Control */
+#define REG_SDIO_TX_CTRL	(SDIO_LOCAL_OFFSET + 0x0000)
+#define REG_SDIO_TX_ERRSTPINTEN			BIT(0)
+#define REG_SDIO_TX_ENMSKTMR			BIT(1)
+#define REG_SDIO_TX_ENRXDMAMSKINT		BIT(2)
+
+/*SDIO status timeout*/
+#define REG_SDIO_TIMEOUT			(SDIO_LOCAL_OFFSET + 0x0002)
+
+/* SDIO Host Interrupt Mask */
+#define REG_SDIO_HIMR				(SDIO_LOCAL_OFFSET + 0x0014)
+#define REG_SDIO_HIMR_RX_REQUEST		BIT(0)
+#define REG_SDIO_HIMR_AVAL			BIT(1)
+#define REG_SDIO_HIMR_TXERR			BIT(2)
+#define REG_SDIO_HIMR_RXERR			BIT(3)
+#define REG_SDIO_HIMR_TXFOVW			BIT(4)
+#define REG_SDIO_HIMR_RXFOVW			BIT(5)
+#define REG_SDIO_HIMR_TXBCNOK			BIT(6)
+#define REG_SDIO_HIMR_TXBCNERR			BIT(7)
+#define REG_SDIO_HIMR_BCNERLY_INT		BIT(16)
+#define REG_SDIO_HIMR_C2HCMD			BIT(17)
+#define REG_SDIO_HIMR_CPWM1			BIT(18)
+#define REG_SDIO_HIMR_CPWM2			BIT(19)
+#define REG_SDIO_HIMR_HSISR_IND			BIT(20)
+#define REG_SDIO_HIMR_GTINT3_IND		BIT(21)
+#define REG_SDIO_HIMR_GTINT4_IND		BIT(22)
+#define REG_SDIO_HIMR_PSTIMEOUT			BIT(23)
+#define REG_SDIO_HIMR_OCPINT			BIT(24)
+#define REG_SDIO_HIMR_ATIMEND			BIT(25)
+#define REG_SDIO_HIMR_ATIMEND_E			BIT(26)
+#define REG_SDIO_HIMR_CTWEND			BIT(27)
+/* the following two are RTL8188 SDIO Specific */
+#define REG_SDIO_HIMR_MCU_ERR			BIT(28)
+#define REG_SDIO_HIMR_TSF_BIT32_TOGGLE		BIT(29)
+
+/* SDIO Host Interrupt Service Routine */
+#define REG_SDIO_HISR				(SDIO_LOCAL_OFFSET + 0x0018)
+#define REG_SDIO_HISR_RX_REQUEST		BIT(0)
+#define REG_SDIO_HISR_AVAL			BIT(1)
+#define REG_SDIO_HISR_TXERR			BIT(2)
+#define REG_SDIO_HISR_RXERR			BIT(3)
+#define REG_SDIO_HISR_TXFOVW			BIT(4)
+#define REG_SDIO_HISR_RXFOVW			BIT(5)
+#define REG_SDIO_HISR_TXBCNOK			BIT(6)
+#define REG_SDIO_HISR_TXBCNERR			BIT(7)
+#define REG_SDIO_HISR_BCNERLY_INT		BIT(16)
+#define REG_SDIO_HISR_C2HCMD			BIT(17)
+#define REG_SDIO_HISR_CPWM1			BIT(18)
+#define REG_SDIO_HISR_CPWM2			BIT(19)
+#define REG_SDIO_HISR_HSISR_IND			BIT(20)
+#define REG_SDIO_HISR_GTINT3_IND		BIT(21)
+#define REG_SDIO_HISR_GTINT4_IND		BIT(22)
+#define REG_SDIO_HISR_PSTIMEOUT			BIT(23)
+#define REG_SDIO_HISR_OCPINT			BIT(24)
+#define REG_SDIO_HISR_ATIMEND			BIT(25)
+#define REG_SDIO_HISR_ATIMEND_E			BIT(26)
+#define REG_SDIO_HISR_CTWEND			BIT(27)
+/* the following two are RTL8188 SDIO Specific */
+#define REG_SDIO_HISR_MCU_ERR			BIT(28)
+#define REG_SDIO_HISR_TSF_BIT32_TOGGLE		BIT(29)
+
+#define REG_SDIO_INDIRECT_REG_CFG		(SDIO_LOCAL_OFFSET + 0x0040)
+#define REG_SDIO_INDIRECT_REG_DATA		(SDIO_LOCAL_OFFSET + 0x0044)
+
+/* Sdio Address for SDIO Local Reg, TRX FIFO, MAC Reg */
+#define REG_SDIO_CMD_ADDR_MSK			GENMASK(16, 13)
+#define REG_SDIO_CMD_ADDR_SDIO_REG		0
+#define REG_SDIO_CMD_ADDR_MAC_REG		8
+#define REG_SDIO_CMD_ADDR_TXFF_HIGH		4
+#define REG_SDIO_CMD_ADDR_TXFF_LOW		6
+#define REG_SDIO_CMD_ADDR_TXFF_NORMAL		5
+#define REG_SDIO_CMD_ADDR_TXFF_EXTRA		7
+#define REG_SDIO_CMD_ADDR_RXFF			7
+
+#define RTW_SDIO_BLOCK_SIZE			512
+#define RTW_SDIO_ADDR_RX_RX0FF_GEN(_id)		(0x0e000 | ((_id) & 0x3))
+
+struct sdio_func;
+struct sdio_device_id;
+
+struct rtw_sdio_work_data {
+	struct work_struct work;
+	struct rtw_dev *rtwdev;
+};
+
+struct rtw_sdio {
+	struct sdio_func *sdio_func;
+
+	u32 irq_mask;
+	u8 rx_addr;
+	bool sdio3_bus_mode;
+	bool is_powered_on;
+
+	void *irq_thread;
+
+	/* for indirect register reads */
+	struct mutex indirect_mutex;
+
+	struct workqueue_struct *txwq, *rxwq;
+
+	struct sk_buff_head tx_queue[RTK_MAX_TX_QUEUE_NUM];
+	struct rtw_sdio_work_data *tx_handler_data;
+};
+
+extern const struct dev_pm_ops rtw_sdio_pm_ops;
+
+int rtw_sdio_probe(struct sdio_func *sdio_func,
+		   const struct sdio_device_id *id);
+void rtw_sdio_remove(struct sdio_func *sdio_func);
+void rtw_sdio_shutdown(struct device *dev);
+
+#endif
diff -Naur a/drivers/net/wireless/realtek/rtw88/tx.h b/drivers/net/wireless/realtek/rtw88/tx.h
--- a/drivers/net/wireless/realtek/rtw88/tx.h	2021-10-31 16:53:10.000000000 -0400
+++ b/drivers/net/wireless/realtek/rtw88/tx.h	2021-10-31 20:41:20.000000000 -0400
@@ -67,6 +67,8 @@
 	le32p_replace_bits((__le32 *)(txdesc) + 0x03, value, BIT(15))
 #define SET_TX_DESC_BT_NULL(txdesc, value)				       \
 	le32p_replace_bits((__le32 *)(txdesc) + 0x02, value, BIT(23))
+#define SET_TX_DESC_TXDESC_CHECKSUM(txdesc, value)                             \
+	le32p_replace_bits((__le32 *)(txdesc) + 0x07, value, GENMASK(15, 0))
 
 enum rtw_tx_desc_queue_select {
 	TX_DESC_QSEL_TID0	= 0,
@@ -119,4 +121,19 @@
 			  struct rtw_tx_pkt_info *pkt_info,
 			  u8 *buf, u32 size);
 
+static inline
+void fill_txdesc_checksum_common(void *txdesc)
+{
+	__le16 *data = (__le16 *)(txdesc);
+	__le16 chksum = 0;
+	size_t words = 16;
+
+	SET_TX_DESC_TXDESC_CHECKSUM(txdesc, 0x0000);
+
+	while (words--)
+		chksum ^= *data++;
+
+	SET_TX_DESC_TXDESC_CHECKSUM(txdesc, __le16_to_cpu(chksum));
+}
+
 #endif
diff -Naur a/drivers/net/wireless/realtek/rtw88/util.h b/drivers/net/wireless/realtek/rtw88/util.h
--- a/drivers/net/wireless/realtek/rtw88/util.h	2021-10-31 16:53:10.000000000 -0400
+++ b/drivers/net/wireless/realtek/rtw88/util.h	2021-10-31 20:41:20.000000000 -0400
@@ -13,12 +13,12 @@
 #define rtw_iterate_vifs_atomic(rtwdev, iterator, data)                        \
 	ieee80211_iterate_active_interfaces_atomic(rtwdev->hw,                 \
 			IEEE80211_IFACE_ITER_NORMAL, iterator, data)
+#define rtw_iterate_stas(rtwdev, iterator, data)                        \
+	ieee80211_iterate_stations(rtwdev->hw, iterator, data)
 #define rtw_iterate_stas_atomic(rtwdev, iterator, data)                        \
 	ieee80211_iterate_stations_atomic(rtwdev->hw, iterator, data)
 #define rtw_iterate_keys(rtwdev, vif, iterator, data)			       \
 	ieee80211_iter_keys(rtwdev->hw, vif, iterator, data)
-#define rtw_iterate_keys_rcu(rtwdev, vif, iterator, data)		       \
-	ieee80211_iter_keys_rcu((rtwdev)->hw, vif, iterator, data)
 
 static inline u8 *get_hdr_bssid(struct ieee80211_hdr *hdr)
 {
diff -Naur a/drivers/net/wireless/realtek/rtw88/wow.c b/drivers/net/wireless/realtek/rtw88/wow.c
--- a/drivers/net/wireless/realtek/rtw88/wow.c	2021-10-31 16:53:10.000000000 -0400
+++ b/drivers/net/wireless/realtek/rtw88/wow.c	2021-10-31 20:41:20.000000000 -0400
@@ -468,7 +468,7 @@
 	data.rtwdev = rtwdev;
 	data.connect = connect;
 
-	rtw_iterate_stas_atomic(rtwdev, rtw_wow_fw_media_status_iter, &data);
+	rtw_iterate_stas(rtwdev, rtw_wow_fw_media_status_iter, &data);
 }
 
 static int rtw_wow_config_wow_fw_rsvd_page(struct rtw_dev *rtwdev)
diff -Naur a/drivers/nvmem/meson-mx-efuse.c b/drivers/nvmem/meson-mx-efuse.c
--- a/drivers/nvmem/meson-mx-efuse.c	2021-10-31 16:53:10.000000000 -0400
+++ b/drivers/nvmem/meson-mx-efuse.c	2021-10-31 20:41:20.000000000 -0400
@@ -9,6 +9,7 @@
 #include <linux/bitops.h>
 #include <linux/clk.h>
 #include <linux/delay.h>
+#include <linux/firmware/meson/meson_mx_trustzone.h>
 #include <linux/io.h>
 #include <linux/iopoll.h>
 #include <linux/module.h>
@@ -167,6 +168,28 @@
 	return err;
 }
 
+static int meson_mx_efuse_read_trustzone_firmware(void *context,
+						  unsigned int offset,
+						  void *buf, size_t bytes)
+{
+	struct meson_mx_efuse *efuse = context;
+	unsigned int tmp;
+	int i, ret;
+
+	for (i = 0; i < bytes; i += efuse->config.word_size) {
+		ret = meson_mx_trustzone_firmware_efuse_read(offset + i,
+							     sizeof(tmp),
+							     &tmp);
+		if (ret)
+			return ret;
+
+		memcpy(buf + i, &tmp,
+		       min_t(size_t, bytes - i, efuse->config.word_size));
+	}
+
+	return 0;
+}
+
 static const struct meson_mx_efuse_platform_data meson6_efuse_data = {
 	.name = "meson6-efuse",
 	.word_size = 1,
@@ -218,7 +241,11 @@
 	efuse->config.word_size = drvdata->word_size;
 	efuse->config.size = SZ_512;
 	efuse->config.read_only = true;
-	efuse->config.reg_read = meson_mx_efuse_read;
+
+	if (meson_mx_trustzone_firmware_available())
+		efuse->config.reg_read = meson_mx_efuse_read_trustzone_firmware;
+	else
+		efuse->config.reg_read = meson_mx_efuse_read;
 
 	efuse->core_clk = devm_clk_get(&pdev->dev, "core");
 	if (IS_ERR(efuse->core_clk)) {
diff -Naur a/drivers/phy/amlogic/Kconfig b/drivers/phy/amlogic/Kconfig
--- a/drivers/phy/amlogic/Kconfig	2021-10-31 16:53:10.000000000 -0400
+++ b/drivers/phy/amlogic/Kconfig	2021-10-31 20:41:20.000000000 -0400
@@ -2,6 +2,16 @@
 #
 # Phy drivers for Amlogic platforms
 #
+config PHY_MESON8_HDMI_TX
+	tristate "Meson8, Meson8b and Meson8m2 HDMI TX PHY driver"
+	depends on (ARCH_MESON && ARM) || COMPILE_TEST
+	depends on OF
+	select MFD_SYSCON
+	help
+	  Enable this to support the HDMI TX PHYs found in Meson8,
+	  Meson8b and Meson8m2 SoCs.
+	  If unsure, say N.
+
 config PHY_MESON8B_USB2
 	tristate "Meson8, Meson8b, Meson8m2 and GXBB USB2 PHY driver"
 	default ARCH_MESON
@@ -15,6 +25,16 @@
 	  Meson8b and GXBB SoCs.
 	  If unsure, say N.
 
+config PHY_MESON_CVBS_DAC
+	tristate "Amlogic Meson CVBS DAC PHY driver"
+	depends on ARCH_MESON || COMPILE_TEST
+	depends on OF
+	select MFD_SYSCON
+	help
+	  Enable this to support the CVBS DAC (PHY) found in Amlogic
+	  Meson SoCs.
+	  If unsure, say N.
+
 config PHY_MESON_GXL_USB2
 	tristate "Meson GXL and GXM USB2 PHY drivers"
 	default ARCH_MESON
diff -Naur a/drivers/phy/amlogic/Makefile b/drivers/phy/amlogic/Makefile
--- a/drivers/phy/amlogic/Makefile	2021-10-31 16:53:10.000000000 -0400
+++ b/drivers/phy/amlogic/Makefile	2021-10-31 20:41:20.000000000 -0400
@@ -1,5 +1,7 @@
 # SPDX-License-Identifier: GPL-2.0-only
+obj-$(CONFIG_PHY_MESON8_HDMI_TX)		+= phy-meson8-hdmi-tx.o
 obj-$(CONFIG_PHY_MESON8B_USB2)			+= phy-meson8b-usb2.o
+obj-$(CONFIG_PHY_MESON_CVBS_DAC)		+= phy-meson-cvbs-dac.o
 obj-$(CONFIG_PHY_MESON_GXL_USB2)		+= phy-meson-gxl-usb2.o
 obj-$(CONFIG_PHY_MESON_G12A_USB2)		+= phy-meson-g12a-usb2.o
 obj-$(CONFIG_PHY_MESON_G12A_USB3_PCIE)		+= phy-meson-g12a-usb3-pcie.o
diff -Naur a/drivers/phy/amlogic/phy-meson8b-usb2.c b/drivers/phy/amlogic/phy-meson8b-usb2.c
--- a/drivers/phy/amlogic/phy-meson8b-usb2.c	2021-10-31 16:53:10.000000000 -0400
+++ b/drivers/phy/amlogic/phy-meson8b-usb2.c	2021-10-31 20:41:20.000000000 -0400
@@ -7,6 +7,7 @@
 
 #include <linux/clk.h>
 #include <linux/delay.h>
+#include <linux/gpio/driver.h>
 #include <linux/io.h>
 #include <linux/module.h>
 #include <linux/of_device.h>
@@ -127,6 +128,7 @@
 	struct clk					*clk_usb_general;
 	struct clk					*clk_usb;
 	struct reset_control				*reset;
+	struct gpio_chip				gpiochip;
 	const struct phy_meson8b_usb2_match_data	*match;
 };
 
@@ -232,12 +234,47 @@
 	.owner		= THIS_MODULE,
 };
 
+static int phy_meson8b_usb2_id_gpio_get_direction(struct gpio_chip *gc,
+						  unsigned int offset)
+{
+	return GPIO_LINE_DIRECTION_IN;
+}
+
+static int phy_meson8b_usb2_id_gpio_get_value(struct gpio_chip *gc,
+					      unsigned int offset)
+{
+	struct phy_meson8b_usb2_priv *priv = gpiochip_get_data(gc);
+	unsigned int val;
+
+	regmap_read(priv->regmap, REG_ADP_BC, &val);
+
+	return (val & REG_ADP_BC_ID_DIG) ? 1 : 0;
+}
+
+static int phy_meson8b_usb2_id_gpiochip_add(struct device *dev,
+					    struct phy_meson8b_usb2_priv *priv)
+{
+	if (!device_property_read_bool(dev, "gpio-controller"))
+		return 0;
+
+	priv->gpiochip.label = dev_name(dev);
+	priv->gpiochip.parent = dev;
+	priv->gpiochip.get_direction = phy_meson8b_usb2_id_gpio_get_direction;
+	priv->gpiochip.get = phy_meson8b_usb2_id_gpio_get_value;
+	priv->gpiochip.of_gpio_n_cells = 2;
+	priv->gpiochip.base = -1;
+	priv->gpiochip.ngpio = 1;
+
+	return devm_gpiochip_add_data(dev, &priv->gpiochip, priv);
+}
+
 static int phy_meson8b_usb2_probe(struct platform_device *pdev)
 {
 	struct phy_meson8b_usb2_priv *priv;
-	struct phy *phy;
 	struct phy_provider *phy_provider;
 	void __iomem *base;
+	struct phy *phy;
+	int ret;
 
 	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
 	if (!priv)
@@ -275,6 +312,10 @@
 		return -EINVAL;
 	}
 
+	ret = phy_meson8b_usb2_id_gpiochip_add(&pdev->dev, priv);
+	if (ret)
+		return ret;
+
 	phy = devm_phy_create(&pdev->dev, NULL, &phy_meson8b_usb2_ops);
 	if (IS_ERR(phy)) {
 		return dev_err_probe(&pdev->dev, PTR_ERR(phy),
diff -Naur a/drivers/phy/amlogic/phy-meson8-hdmi-tx.c b/drivers/phy/amlogic/phy-meson8-hdmi-tx.c
--- a/drivers/phy/amlogic/phy-meson8-hdmi-tx.c	1969-12-31 19:00:00.000000000 -0500
+++ b/drivers/phy/amlogic/phy-meson8-hdmi-tx.c	2021-10-31 20:41:20.000000000 -0400
@@ -0,0 +1,160 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Meson8, Meson8b and Meson8m2 HDMI TX PHY.
+ *
+ * Copyright (C) 2021 Martin Blumenstingl <martin.blumenstingl@googlemail.com>
+ */
+
+#include <linux/bitfield.h>
+#include <linux/bits.h>
+#include <linux/clk.h>
+#include <linux/mfd/syscon.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/phy/phy.h>
+#include <linux/platform_device.h>
+#include <linux/property.h>
+#include <linux/regmap.h>
+
+/*
+ * Unfortunately there is no detailed documentation available for the
+ * HHI_HDMI_PHY_CNTL0 register. CTL0 and CTL1 is all we know about.
+ * Magic register values in the driver below are taken from the vendor
+ * BSP / kernel.
+ */
+#define HHI_HDMI_PHY_CNTL0				0x3a0
+	#define HHI_HDMI_PHY_CNTL0_HDMI_CTL1		GENMASK(31, 16)
+	#define HHI_HDMI_PHY_CNTL0_HDMI_CTL0		GENMASK(15, 0)
+
+#define HHI_HDMI_PHY_CNTL1				0x3a4
+	#define HHI_HDMI_PHY_CNTL1_CLOCK_ENABLE		BIT(1)
+	#define HHI_HDMI_PHY_CNTL1_SOFT_RESET		BIT(0)
+
+#define HHI_HDMI_PHY_CNTL2				0x3a8
+
+struct phy_meson8_hdmi_tx_priv {
+	struct regmap		*hhi;
+	struct clk		*tmds_clk;
+};
+
+static int phy_meson8_hdmi_tx_init(struct phy *phy)
+{
+	struct phy_meson8_hdmi_tx_priv *priv = phy_get_drvdata(phy);
+
+	return clk_prepare_enable(priv->tmds_clk);
+}
+
+static int phy_meson8_hdmi_tx_exit(struct phy *phy)
+{
+	struct phy_meson8_hdmi_tx_priv *priv = phy_get_drvdata(phy);
+
+	clk_disable_unprepare(priv->tmds_clk);
+
+	return 0;
+}
+
+static int phy_meson8_hdmi_tx_power_on(struct phy *phy)
+{
+	struct phy_meson8_hdmi_tx_priv *priv = phy_get_drvdata(phy);
+	unsigned int i;
+	u16 hdmi_ctl0;
+
+	if (clk_get_rate(priv->tmds_clk) >= 2970UL * 1000 * 1000)
+		hdmi_ctl0 = 0x1e8b;
+	else
+		hdmi_ctl0 = 0x4d0b;
+
+	regmap_write(priv->hhi, HHI_HDMI_PHY_CNTL0,
+		     FIELD_PREP(HHI_HDMI_PHY_CNTL0_HDMI_CTL1, 0x08c3) |
+		     FIELD_PREP(HHI_HDMI_PHY_CNTL0_HDMI_CTL0, hdmi_ctl0));
+
+	regmap_write(priv->hhi, HHI_HDMI_PHY_CNTL1, 0x0);
+
+	/* Reset three times, just like the vendor driver does */
+	for (i = 0; i < 3; i++) {
+		regmap_write(priv->hhi, HHI_HDMI_PHY_CNTL1,
+			     HHI_HDMI_PHY_CNTL1_CLOCK_ENABLE |
+			     HHI_HDMI_PHY_CNTL1_SOFT_RESET);
+		usleep_range(1000, 2000);
+
+		regmap_write(priv->hhi, HHI_HDMI_PHY_CNTL1,
+			     HHI_HDMI_PHY_CNTL1_CLOCK_ENABLE);
+		usleep_range(1000, 2000);
+	}
+
+	return 0;
+}
+
+static int phy_meson8_hdmi_tx_power_off(struct phy *phy)
+{
+	struct phy_meson8_hdmi_tx_priv *priv = phy_get_drvdata(phy);
+
+	regmap_write(priv->hhi, HHI_HDMI_PHY_CNTL0,
+		     FIELD_PREP(HHI_HDMI_PHY_CNTL0_HDMI_CTL1, 0x0841) |
+		     FIELD_PREP(HHI_HDMI_PHY_CNTL0_HDMI_CTL0, 0x8d00));
+
+	return 0;
+}
+
+static const struct phy_ops phy_meson8_hdmi_tx_ops = {
+	.init		= phy_meson8_hdmi_tx_init,
+	.exit		= phy_meson8_hdmi_tx_exit,
+	.power_on	= phy_meson8_hdmi_tx_power_on,
+	.power_off	= phy_meson8_hdmi_tx_power_off,
+	.owner		= THIS_MODULE,
+};
+
+static int phy_meson8_hdmi_tx_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct phy_meson8_hdmi_tx_priv *priv;
+	struct phy_provider *phy_provider;
+	struct resource *res;
+	struct phy *phy;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res)
+		return -EINVAL;
+
+	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	priv->hhi = syscon_node_to_regmap(np->parent);
+	if (IS_ERR(priv->hhi))
+		return PTR_ERR(priv->hhi);
+
+	priv->tmds_clk = devm_clk_get(&pdev->dev, NULL);
+	if (IS_ERR(priv->tmds_clk))
+		return PTR_ERR(priv->tmds_clk);
+
+	phy = devm_phy_create(&pdev->dev, np, &phy_meson8_hdmi_tx_ops);
+	if (IS_ERR(phy))
+		return PTR_ERR(phy);
+
+	phy_set_drvdata(phy, priv);
+
+	phy_provider = devm_of_phy_provider_register(&pdev->dev,
+						     of_phy_simple_xlate);
+
+	return PTR_ERR_OR_ZERO(phy_provider);
+}
+
+static const struct of_device_id phy_meson8_hdmi_tx_of_match[] = {
+	{ .compatible = "amlogic,meson8-hdmi-tx-phy" },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, phy_meson8_hdmi_tx_of_match);
+
+static struct platform_driver phy_meson8_hdmi_tx_driver = {
+	.probe	= phy_meson8_hdmi_tx_probe,
+	.driver	= {
+		.name		= "phy-meson8-hdmi-tx",
+		.of_match_table	= phy_meson8_hdmi_tx_of_match,
+	},
+};
+module_platform_driver(phy_meson8_hdmi_tx_driver);
+
+MODULE_AUTHOR("Martin Blumenstingl <martin.blumenstingl@googlemail.com>");
+MODULE_DESCRIPTION("Meson8, Meson8b and Meson8m2 HDMI TX PHY driver");
+MODULE_LICENSE("GPL v2");
diff -Naur a/drivers/phy/amlogic/phy-meson-cvbs-dac.c b/drivers/phy/amlogic/phy-meson-cvbs-dac.c
--- a/drivers/phy/amlogic/phy-meson-cvbs-dac.c	1969-12-31 19:00:00.000000000 -0500
+++ b/drivers/phy/amlogic/phy-meson-cvbs-dac.c	2021-10-31 20:41:20.000000000 -0400
@@ -0,0 +1,310 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2016 BayLibre, SAS
+ * Copyright (C) 2021 Martin Blumenstingl <martin.blumenstingl@googlemail.com>
+ */
+
+#include <linux/clk.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/mod_devicetable.h>
+#include <linux/phy/phy.h>
+#include <linux/platform_device.h>
+#include <linux/regmap.h>
+#include <linux/property.h>
+#include <linux/mfd/syscon.h>
+#include <linux/nvmem-consumer.h>
+
+#define HHI_VDAC_CNTL0_MESON8			0x2F4 /* 0xbd offset in data sheet */
+#define HHI_VDAC_CNTL1_MESON8			0x2F8 /* 0xbe offset in data sheet */
+
+#define HHI_VDAC_CNTL0_G12A			0x2EC /* 0xbd offset in data sheet */
+#define HHI_VDAC_CNTL1_G12A			0x2F0 /* 0xbe offset in data sheet */
+
+enum phy_meson_cvbs_dac_reg {
+	MESON_CDAC_CTRL_RESV1,
+	MESON_CDAC_CTRL_RESV2,
+	MESON_CDAC_VREF_ADJ,
+	MESON_CDAC_RL_ADJ,
+	MESON_CDAC_CLK_PHASE_SEL,
+	MESON_CDAC_DRIVER_ADJ,
+	MESON_CDAC_EXT_VREF_EN,
+	MESON_CDAC_BIAS_C,
+	MESON_VDAC_CNTL0_RESERVED,
+	MESON_CDAC_GSW,
+	MESON_CDAC_PWD,
+	MESON_VDAC_CNTL1_RESERVED,
+	MESON_CVBS_DAC_NUM_REGS
+};
+
+struct phy_meson_cvbs_dac_data {
+	const struct reg_field	*reg_fields;
+	u8			cdac_ctrl_resv2_enable_val;
+	u8			cdac_vref_adj_enable_val;
+	u8			cdac_rl_adj_enable_val;
+	bool			disable_ignore_cdac_pwd;
+	bool			has_cvbs_trimming_nvmem_cell;
+};
+
+struct phy_meson_cvbs_dac_priv {
+	struct regmap_field			*regs[MESON_CVBS_DAC_NUM_REGS];
+	const struct phy_meson_cvbs_dac_data	*data;
+	u8					cdac_gsw_enable_val;
+};
+
+static const struct reg_field phy_meson8_cvbs_dac_reg_fields[] = {
+	[MESON_CDAC_CTRL_RESV1] =	REG_FIELD(HHI_VDAC_CNTL0_MESON8, 0, 7),
+	[MESON_CDAC_CTRL_RESV2] =	REG_FIELD(HHI_VDAC_CNTL0_MESON8, 8, 15),
+	[MESON_CDAC_VREF_ADJ] =		REG_FIELD(HHI_VDAC_CNTL0_MESON8, 16, 20),
+	[MESON_CDAC_RL_ADJ] =		REG_FIELD(HHI_VDAC_CNTL0_MESON8, 21, 23),
+	[MESON_CDAC_CLK_PHASE_SEL] =	REG_FIELD(HHI_VDAC_CNTL0_MESON8, 24, 24),
+	[MESON_CDAC_DRIVER_ADJ] =	REG_FIELD(HHI_VDAC_CNTL0_MESON8, 25, 25),
+	[MESON_CDAC_EXT_VREF_EN] =	REG_FIELD(HHI_VDAC_CNTL0_MESON8, 26, 26),
+	[MESON_CDAC_BIAS_C] =		REG_FIELD(HHI_VDAC_CNTL0_MESON8, 27, 27),
+	[MESON_VDAC_CNTL0_RESERVED] =	REG_FIELD(HHI_VDAC_CNTL0_MESON8, 28, 31),
+	[MESON_CDAC_GSW] =		REG_FIELD(HHI_VDAC_CNTL1_MESON8, 0, 2),
+	[MESON_CDAC_PWD] =		REG_FIELD(HHI_VDAC_CNTL1_MESON8, 3, 3),
+	[MESON_VDAC_CNTL1_RESERVED] =	REG_FIELD(HHI_VDAC_CNTL1_MESON8, 4, 31),
+};
+
+static const struct reg_field phy_meson_g12a_cvbs_dac_reg_fields[] = {
+	[MESON_CDAC_CTRL_RESV1] =	REG_FIELD(HHI_VDAC_CNTL0_G12A, 0, 7),
+	[MESON_CDAC_CTRL_RESV2] =	REG_FIELD(HHI_VDAC_CNTL0_G12A, 8, 15),
+	[MESON_CDAC_VREF_ADJ] =		REG_FIELD(HHI_VDAC_CNTL0_G12A, 16, 20),
+	[MESON_CDAC_RL_ADJ] =		REG_FIELD(HHI_VDAC_CNTL0_G12A, 21, 23),
+	[MESON_CDAC_CLK_PHASE_SEL] =	REG_FIELD(HHI_VDAC_CNTL0_G12A, 24, 24),
+	[MESON_CDAC_DRIVER_ADJ] =	REG_FIELD(HHI_VDAC_CNTL0_G12A, 25, 25),
+	[MESON_CDAC_EXT_VREF_EN] =	REG_FIELD(HHI_VDAC_CNTL0_G12A, 26, 26),
+	[MESON_CDAC_BIAS_C] =		REG_FIELD(HHI_VDAC_CNTL0_G12A, 27, 27),
+	[MESON_VDAC_CNTL0_RESERVED] =	REG_FIELD(HHI_VDAC_CNTL0_G12A, 28, 31),
+	[MESON_CDAC_GSW] =		REG_FIELD(HHI_VDAC_CNTL1_G12A, 0, 2),
+	[MESON_CDAC_PWD] =		REG_FIELD(HHI_VDAC_CNTL1_G12A, 3, 3),
+	[MESON_VDAC_CNTL1_RESERVED] =	REG_FIELD(HHI_VDAC_CNTL1_G12A, 4, 31),
+};
+
+static const struct phy_meson_cvbs_dac_data phy_meson8_cvbs_dac_data = {
+	.reg_fields			= phy_meson8_cvbs_dac_reg_fields,
+	.cdac_ctrl_resv2_enable_val	= 0x0,
+	.cdac_vref_adj_enable_val	= 0x0,
+	.cdac_rl_adj_enable_val		= 0x0,
+	.disable_ignore_cdac_pwd	= false,
+	.has_cvbs_trimming_nvmem_cell	= true,
+};
+
+static const struct phy_meson_cvbs_dac_data phy_meson_gxbb_cvbs_dac_data = {
+	.reg_fields			= phy_meson8_cvbs_dac_reg_fields,
+	.cdac_ctrl_resv2_enable_val	= 0x0,
+	.cdac_vref_adj_enable_val	= 0x0,
+	.cdac_rl_adj_enable_val		= 0x0,
+	.disable_ignore_cdac_pwd	= false,
+	.has_cvbs_trimming_nvmem_cell	= false,
+};
+
+static const struct phy_meson_cvbs_dac_data phy_meson_gxl_cvbs_dac_data = {
+	.reg_fields			= phy_meson8_cvbs_dac_reg_fields,
+	.cdac_ctrl_resv2_enable_val	= 0x0,
+	.cdac_vref_adj_enable_val	= 0xf,
+	.cdac_rl_adj_enable_val		= 0x0,
+	.disable_ignore_cdac_pwd	= false,
+	.has_cvbs_trimming_nvmem_cell	= false,
+};
+
+static const struct phy_meson_cvbs_dac_data phy_meson_g12a_cvbs_dac_data = {
+	.reg_fields			= phy_meson_g12a_cvbs_dac_reg_fields,
+	.cdac_ctrl_resv2_enable_val	= 0x60,
+	.cdac_vref_adj_enable_val	= 0x10,
+	.cdac_rl_adj_enable_val		= 0x4,
+	.disable_ignore_cdac_pwd	= true,
+	.has_cvbs_trimming_nvmem_cell	= false,
+};
+
+static int phy_meson_cvbs_dac_power_on(struct phy *phy)
+{
+	struct phy_meson_cvbs_dac_priv *priv = phy_get_drvdata(phy);
+
+	regmap_field_write(priv->regs[MESON_CDAC_CTRL_RESV1], 0x1);
+	regmap_field_write(priv->regs[MESON_CDAC_CTRL_RESV2],
+			   priv->data->cdac_ctrl_resv2_enable_val);
+	regmap_field_write(priv->regs[MESON_CDAC_VREF_ADJ],
+			   priv->data->cdac_vref_adj_enable_val);
+	regmap_field_write(priv->regs[MESON_CDAC_RL_ADJ],
+			   priv->data->cdac_rl_adj_enable_val);
+	regmap_field_write(priv->regs[MESON_CDAC_GSW],
+			   priv->cdac_gsw_enable_val);
+	regmap_field_write(priv->regs[MESON_CDAC_PWD], 0x0);
+
+	return 0;
+}
+
+static int phy_meson_cvbs_dac_power_off(struct phy *phy)
+{
+	struct phy_meson_cvbs_dac_priv *priv = phy_get_drvdata(phy);
+
+	regmap_field_write(priv->regs[MESON_CDAC_CTRL_RESV1], 0x0);
+	regmap_field_write(priv->regs[MESON_CDAC_CTRL_RESV2], 0x0);
+	regmap_field_write(priv->regs[MESON_CDAC_VREF_ADJ], 0x0);
+	regmap_field_write(priv->regs[MESON_CDAC_RL_ADJ], 0x0);
+	regmap_field_write(priv->regs[MESON_CDAC_GSW], 0x0);
+
+	if (priv->data->disable_ignore_cdac_pwd)
+		regmap_field_write(priv->regs[MESON_CDAC_PWD], 0x0);
+	else
+		regmap_field_write(priv->regs[MESON_CDAC_PWD], 0x1);
+
+	return 0;
+}
+
+static int phy_meson_cvbs_dac_init(struct phy *phy)
+{
+	struct phy_meson_cvbs_dac_priv *priv = phy_get_drvdata(phy);
+
+	regmap_field_write(priv->regs[MESON_CDAC_CLK_PHASE_SEL], 0x0);
+	regmap_field_write(priv->regs[MESON_CDAC_DRIVER_ADJ], 0x0);
+	regmap_field_write(priv->regs[MESON_CDAC_EXT_VREF_EN], 0x0);
+	regmap_field_write(priv->regs[MESON_CDAC_BIAS_C], 0x0);
+	regmap_field_write(priv->regs[MESON_VDAC_CNTL0_RESERVED], 0x0);
+	regmap_field_write(priv->regs[MESON_VDAC_CNTL1_RESERVED], 0x0);
+
+	return phy_meson_cvbs_dac_power_off(phy);
+}
+
+static const struct phy_ops phy_meson_cvbs_dac_ops = {
+	.init		= phy_meson_cvbs_dac_init,
+	.power_on	= phy_meson_cvbs_dac_power_on,
+	.power_off	= phy_meson_cvbs_dac_power_off,
+	.owner		= THIS_MODULE,
+};
+
+static u8 phy_meson_cvbs_trimming_version(u8 trimming1)
+{
+	if ((trimming1 & 0xf0) == 0xa0)
+		return 5;
+	else if ((trimming1 & 0xf0) == 0x40)
+		return 2;
+	else if ((trimming1 & 0xc0) == 0x80)
+		return 1;
+	else if ((trimming1 & 0xc0) == 0x00)
+		return 0;
+	else
+		return 0xff;
+}
+
+static int phy_meson_cvbs_read_trimming(struct device *dev,
+					struct phy_meson_cvbs_dac_priv *priv)
+{
+	struct nvmem_cell *cell;
+	u8 *trimming;
+	size_t len;
+
+	cell = devm_nvmem_cell_get(dev, "cvbs_trimming");
+	if (IS_ERR(cell))
+		return dev_err_probe(dev, PTR_ERR(cell),
+				     "Failed to get the 'cvbs_trimming' nvmem-cell\n");
+
+	trimming = nvmem_cell_read(cell, &len);
+	if (IS_ERR(trimming))
+		return dev_err_probe(dev, PTR_ERR(trimming),
+				     "Failed to read the 'cvbs_trimming' nvmem-cell\n");
+
+	if (len != 2)
+		return dev_err_probe(dev, -EINVAL,
+				     "Read the 'cvbs_trimming' nvmem-cell with invalid length\n");
+
+	switch (phy_meson_cvbs_trimming_version(trimming[1])) {
+	case 1:
+	case 2:
+	case 5:
+		priv->cdac_gsw_enable_val = trimming[0] & 0x7;
+		break;
+	default:
+		priv->cdac_gsw_enable_val = 0x0;
+		break;
+	}
+
+	kfree(trimming);
+
+	return 0;
+}
+
+static int phy_meson_cvbs_dac_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct phy_meson_cvbs_dac_priv *priv;
+	struct phy_provider *phy_provider;
+	struct device *dev = &pdev->dev;
+	struct regmap *hhi;
+	struct phy *phy;
+	int ret;
+
+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	priv->data = device_get_match_data(dev);
+	if (!priv->data)
+		return dev_err_probe(dev, -EINVAL,
+				     "Could not find match data\n");
+
+	hhi = syscon_node_to_regmap(np->parent);
+	if (IS_ERR(hhi))
+		return PTR_ERR(hhi);
+
+	if (priv->data->has_cvbs_trimming_nvmem_cell) {
+		ret = phy_meson_cvbs_read_trimming(dev, priv);
+		if (ret)
+			return ret;
+	}
+
+	ret = devm_regmap_field_bulk_alloc(dev, hhi, priv->regs,
+					   priv->data->reg_fields,
+					   MESON_CVBS_DAC_NUM_REGS);
+	if (ret)
+		return dev_err_probe(dev, ret,
+				     "Failed to create regmap fields\n");
+
+	phy = devm_phy_create(dev, np, &phy_meson_cvbs_dac_ops);
+	if (IS_ERR(phy))
+		return PTR_ERR(phy);
+
+	phy_set_drvdata(phy, priv);
+
+	phy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);
+
+	return PTR_ERR_OR_ZERO(phy_provider);
+}
+
+static const struct of_device_id phy_meson_cvbs_dac_of_match[] = {
+	{
+		.compatible = "amlogic,meson8-cvbs-dac",
+		.data = &phy_meson8_cvbs_dac_data,
+	},
+	{
+		.compatible = "amlogic,meson-gxbb-cvbs-dac",
+		.data = &phy_meson_gxbb_cvbs_dac_data,
+	},
+	{
+		.compatible = "amlogic,meson-gxl-cvbs-dac",
+		.data = &phy_meson_gxl_cvbs_dac_data,
+	},
+	{
+		.compatible = "amlogic,meson-g12a-cvbs-dac",
+		.data = &phy_meson_g12a_cvbs_dac_data,
+	},
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, phy_meson_cvbs_dac_of_match);
+
+static struct platform_driver phy_meson_cvbs_dac_driver = {
+	.probe	= phy_meson_cvbs_dac_probe,
+	.driver	= {
+		.name		= "phy-meson-cvbs-dac",
+		.of_match_table	= phy_meson_cvbs_dac_of_match,
+	},
+};
+module_platform_driver(phy_meson_cvbs_dac_driver);
+
+MODULE_AUTHOR("Martin Blumenstingl <martin.blumenstingl@googlemail.com>");
+MODULE_DESCRIPTION("Amlogic Meson CVBS DAC driver");
+MODULE_LICENSE("GPL v2");
diff -Naur a/drivers/pinctrl/meson/pinctrl-meson8b.c b/drivers/pinctrl/meson/pinctrl-meson8b.c
--- a/drivers/pinctrl/meson/pinctrl-meson8b.c	2021-10-31 16:53:10.000000000 -0400
+++ b/drivers/pinctrl/meson/pinctrl-meson8b.c	2021-10-31 20:41:20.000000000 -0400
@@ -100,6 +100,13 @@
 	MESON_PIN(DIF_3_N),
 	MESON_PIN(DIF_4_P),
 	MESON_PIN(DIF_4_N),
+
+	/*
+	 * The following pin is not mentioned in the public datasheet.
+	 * According to this datasheet it can't be used with the GPIO
+	 * interrupt controller.
+	 */
+	MESON_PIN(GPIO_BSD_EN),
 };
 
 static const struct pinctrl_pin_desc meson8b_aobus_pins[] = {
@@ -119,11 +126,10 @@
 	MESON_PIN(GPIOAO_13),
 
 	/*
-	 * The following 2 pins are not mentionned in the public datasheet
-	 * According to this datasheet, they can't be used with the gpio
-	 * interrupt controller
+	 * The following pin is not mentioned in the public datasheet.
+	 * According to this datasheet it can't be used with the GPIO
+	 * interrupt controller.
 	 */
-	MESON_PIN(GPIO_BSD_EN),
 	MESON_PIN(GPIO_TEST_N),
 };
 
@@ -440,6 +446,8 @@
 	GPIO_GROUP(DIF_4_P),
 	GPIO_GROUP(DIF_4_N),
 
+	GPIO_GROUP(GPIO_BSD_EN),
+
 	/* bank X */
 	GROUP(sd_d0_a,		8,	5),
 	GROUP(sd_d1_a,		8,	4),
@@ -618,7 +626,6 @@
 	GPIO_GROUP(GPIOAO_11),
 	GPIO_GROUP(GPIOAO_12),
 	GPIO_GROUP(GPIOAO_13),
-	GPIO_GROUP(GPIO_BSD_EN),
 	GPIO_GROUP(GPIO_TEST_N),
 
 	/* bank AO */
@@ -678,14 +685,16 @@
 
 	"DIF_0_P", "DIF_0_N", "DIF_1_P", "DIF_1_N",
 	"DIF_2_P", "DIF_2_N", "DIF_3_P", "DIF_3_N",
-	"DIF_4_P", "DIF_4_N"
+	"DIF_4_P", "DIF_4_N",
+
+	"GPIO_BSD_EN"
 };
 
 static const char * const gpio_aobus_groups[] = {
 	"GPIOAO_0", "GPIOAO_1", "GPIOAO_2", "GPIOAO_3",
 	"GPIOAO_4", "GPIOAO_5", "GPIOAO_6", "GPIOAO_7",
 	"GPIOAO_8", "GPIOAO_9", "GPIOAO_10", "GPIOAO_11",
-	"GPIOAO_12", "GPIOAO_13", "GPIO_BSD_EN", "GPIO_TEST_N"
+	"GPIOAO_12", "GPIOAO_13", "GPIO_TEST_N"
 };
 
 static const char * const sd_a_groups[] = {
@@ -931,11 +940,18 @@
 	BANK("BOOT",	 BOOT_0,	BOOT_18,    24,  42,  2,  0,   2,  0,   9,  0,  10,  0,  11,  0),
 
 	/*
-	 * The following bank is not mentionned in the public datasheet
+	 * The following banks is not mentionned in the public datasheet
 	 * There is no information whether it can be used with the gpio
 	 * interrupt controller
 	 */
 	BANK("DIF",	 DIF_0_P,	DIF_4_N,    -1,  -1,  5,  8,   5,  8,  12, 12,  13, 12,  14, 12),
+
+	/*
+	 * BSD_EN may need some extra gpio_chip.request handling as the vendor kernel:
+	 * - clears CBUS PREG_PAD_GPIO0_O[29]
+	 * - sets SECBUS2 AO_SECURE_REG0[0]
+	 */
+	BANK("BSD_EN",	 GPIO_BSD_EN,	GPIO_BSD_EN, -1, -1,  0, -1,   2, 31,   1, 30,   1, 31,   0, -1),
 };
 
 static struct meson_bank meson8b_aobus_banks[] = {
diff -Naur a/drivers/pinctrl/meson/pinctrl-meson8.c b/drivers/pinctrl/meson/pinctrl-meson8.c
--- a/drivers/pinctrl/meson/pinctrl-meson8.c	2021-10-31 16:53:10.000000000 -0400
+++ b/drivers/pinctrl/meson/pinctrl-meson8.c	2021-10-31 20:41:20.000000000 -0400
@@ -130,6 +130,7 @@
 	MESON_PIN(BOOT_16),
 	MESON_PIN(BOOT_17),
 	MESON_PIN(BOOT_18),
+	MESON_PIN(GPIO_BSD_EN),
 };
 
 static const struct pinctrl_pin_desc meson8_aobus_pins[] = {
@@ -147,7 +148,6 @@
 	MESON_PIN(GPIOAO_11),
 	MESON_PIN(GPIOAO_12),
 	MESON_PIN(GPIOAO_13),
-	MESON_PIN(GPIO_BSD_EN),
 	MESON_PIN(GPIO_TEST_N),
 };
 
@@ -526,6 +526,7 @@
 	GPIO_GROUP(BOOT_16),
 	GPIO_GROUP(BOOT_17),
 	GPIO_GROUP(BOOT_18),
+	GPIO_GROUP(GPIO_BSD_EN),
 
 	/* bank X */
 	GROUP(sd_d0_a,		8,	5),
@@ -760,7 +761,6 @@
 	GPIO_GROUP(GPIOAO_11),
 	GPIO_GROUP(GPIOAO_12),
 	GPIO_GROUP(GPIOAO_13),
-	GPIO_GROUP(GPIO_BSD_EN),
 	GPIO_GROUP(GPIO_TEST_N),
 
 	/* bank AO */
@@ -827,13 +827,15 @@
 	"BOOT_5", "BOOT_6", "BOOT_7", "BOOT_8", "BOOT_9",
 	"BOOT_10", "BOOT_11", "BOOT_12", "BOOT_13", "BOOT_14",
 	"BOOT_15", "BOOT_16", "BOOT_17", "BOOT_18",
+
+	"GPIO_BSD_EN",
 };
 
 static const char * const gpio_aobus_groups[] = {
 	"GPIOAO_0", "GPIOAO_1", "GPIOAO_2", "GPIOAO_3",
 	"GPIOAO_4", "GPIOAO_5", "GPIOAO_6", "GPIOAO_7",
 	"GPIOAO_8", "GPIOAO_9", "GPIOAO_10", "GPIOAO_11",
-	"GPIOAO_12", "GPIOAO_13", "GPIO_BSD_EN", "GPIO_TEST_N"
+	"GPIOAO_12", "GPIOAO_13", "GPIO_TEST_N"
 };
 
 static const char * const sd_a_groups[] = {
@@ -1072,6 +1074,14 @@
 	BANK("Z",    GPIOZ_0,  GPIOZ_14,    14,   28, 1,  0,  1,  0,  3, 17,  4, 17,  5, 17),
 	BANK("CARD", CARD_0,   CARD_6,      58,   64, 2, 20,  2, 20,  0, 22,  1, 22,  2, 22),
 	BANK("BOOT", BOOT_0,   BOOT_18,     39,   57, 2,  0,  2,  0,  9,  0, 10,  0, 11,  0),
+
+	/*
+	 * BSD_EN may need some extra gpio_chip.request handling as the vendor kernel:
+	 * - clears CBUS PREG_PAD_GPIO0_O[29]
+	 * - sets SECBUS2 AO_SECURE_REG0[0]
+	 */
+	BANK("BSD_EN", GPIO_BSD_EN, GPIO_BSD_EN,
+					    -1,   -1, 0, -1,  2, 31,  1, 30,  1, 31,  0, -1),
 };
 
 static struct meson_bank meson8_aobus_banks[] = {
diff -Naur a/drivers/remoteproc/Kconfig b/drivers/remoteproc/Kconfig
--- a/drivers/remoteproc/Kconfig	2021-10-31 16:53:10.000000000 -0400
+++ b/drivers/remoteproc/Kconfig	2021-10-31 20:41:20.000000000 -0400
@@ -127,6 +127,17 @@
 	  It's safe to say N here if you're not interested in the Keystone
 	  DSPs or just want to use a bare minimum kernel.
 
+config MESON_MX_AO_ARC_REMOTEPROC
+	tristate "Amlogic Meson6/8/8b/8m2 AO ARC remote processor support"
+	depends on HAS_IOMEM
+	depends on (ARM && ARCH_MESON) || COMPILE_TEST
+	select GENERIC_ALLOCATOR
+	help
+	  Say m or y here to have support for the AO ARC remote processor
+	  on Amlogic Meson6/Meson8/Meson8b/Meson8m2 SoCs. This is
+	  typically used for system suspend.
+	  If unsure say N.
+
 config PRU_REMOTEPROC
 	tristate "TI PRU remoteproc support"
 	depends on TI_PRUSS
diff -Naur a/drivers/remoteproc/Makefile b/drivers/remoteproc/Makefile
--- a/drivers/remoteproc/Makefile	2021-10-31 16:53:10.000000000 -0400
+++ b/drivers/remoteproc/Makefile	2021-10-31 20:41:20.000000000 -0400
@@ -18,6 +18,7 @@
 obj-$(CONFIG_WKUP_M3_RPROC)		+= wkup_m3_rproc.o
 obj-$(CONFIG_DA8XX_REMOTEPROC)		+= da8xx_remoteproc.o
 obj-$(CONFIG_KEYSTONE_REMOTEPROC)	+= keystone_remoteproc.o
+obj-$(CONFIG_MESON_MX_AO_ARC_REMOTEPROC)+= meson_mx_ao_arc.o
 obj-$(CONFIG_PRU_REMOTEPROC)		+= pru_rproc.o
 obj-$(CONFIG_QCOM_PIL_INFO)		+= qcom_pil_info.o
 obj-$(CONFIG_QCOM_RPROC_COMMON)		+= qcom_common.o
diff -Naur a/drivers/remoteproc/meson_mx_ao_arc.c b/drivers/remoteproc/meson_mx_ao_arc.c
--- a/drivers/remoteproc/meson_mx_ao_arc.c	1969-12-31 19:00:00.000000000 -0500
+++ b/drivers/remoteproc/meson_mx_ao_arc.c	2021-10-31 20:41:20.000000000 -0400
@@ -0,0 +1,261 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2020 Martin Blumenstingl <martin.blumenstingl@googlemail.com>
+ */
+
+#include <linux/bitfield.h>
+#include <linux/bitops.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/property.h>
+#include <linux/genalloc.h>
+#include <linux/io.h>
+#include <linux/mfd/syscon.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/regmap.h>
+#include <linux/remoteproc.h>
+#include <linux/reset.h>
+#include <linux/sizes.h>
+
+#include "remoteproc_internal.h"
+
+#define AO_REMAP_REG0						0x0
+#define AO_REMAP_REG0_REMAP_AHB_SRAM_BITS_17_14_FOR_ARM_CPU	GENMASK(3, 0)
+
+#define AO_REMAP_REG1						0x4
+#define AO_REMAP_REG1_MOVE_AHB_SRAM_TO_0X0_INSTEAD_OF_DDR	BIT(4)
+#define AO_REMAP_REG1_REMAP_AHB_SRAM_BITS_17_14_FOR_MEDIA_CPU	GENMASK(3, 0)
+
+#define AO_CPU_CNTL						0x0
+#define AO_CPU_CNTL_AHB_SRAM_BITS_31_20				GENMASK(28, 16)
+#define AO_CPU_CNTL_HALT					BIT(9)
+#define AO_CPU_CNTL_UNKNONWN					BIT(8)
+#define AO_CPU_CNTL_RUN						BIT(0)
+
+#define AO_CPU_STAT						0x4
+
+#define AO_SECURE_REG0						0x0
+#define AO_SECURE_REG0_AHB_SRAM_BITS_19_12			GENMASK(15, 8)
+
+/* Only bits [31:20] and [17:14] are usable, all other bits must be zero */
+#define MESON_AO_RPROC_SRAM_USABLE_BITS				0xfff3c000
+
+#define MESON_AO_RPROC_MEMORY_OFFSET				0x10000000
+
+struct meson_mx_ao_arc_rproc_priv {
+	void __iomem		*remap_base;
+	void __iomem		*cpu_base;
+	unsigned long		sram_va;
+	phys_addr_t		sram_pa;
+	size_t			sram_size;
+	struct gen_pool		*sram_pool;
+	struct reset_control	*arc_reset;
+	struct clk		*arc_pclk;
+	struct regmap		*secbus2_regmap;
+};
+
+static int meson_mx_ao_arc_rproc_start(struct rproc *rproc)
+{
+	struct meson_mx_ao_arc_rproc_priv *priv = rproc->priv;
+	phys_addr_t translated_sram_addr;
+	u32 tmp;
+	int ret;
+
+	ret = clk_prepare_enable(priv->arc_pclk);
+	if (ret)
+		return ret;
+
+	tmp = FIELD_PREP(AO_REMAP_REG0_REMAP_AHB_SRAM_BITS_17_14_FOR_ARM_CPU,
+			 priv->sram_pa >> 14);
+	writel(tmp, priv->remap_base + AO_REMAP_REG0);
+
+	/*
+	 * The SRAM content as seen by the ARC core always starts at 0x0
+	 * regardless of the value given here (this was discovered by trial and
+	 * error). For SoCs older than Meson6 we probably have to set
+	 * AO_REMAP_REG1_MOVE_AHB_SRAM_TO_0X0_INSTEAD_OF_DDR to achieve the
+	 * same. (At least) For Meson8 and newer that bit must not be set.
+	 */
+	writel(0x0, priv->remap_base + AO_REMAP_REG1);
+
+	regmap_update_bits(priv->secbus2_regmap, AO_SECURE_REG0,
+			   AO_SECURE_REG0_AHB_SRAM_BITS_19_12,
+			   FIELD_PREP(AO_SECURE_REG0_AHB_SRAM_BITS_19_12,
+				      priv->sram_pa >> 12));
+
+	ret = reset_control_reset(priv->arc_reset);
+	if (ret) {
+		clk_disable_unprepare(priv->arc_pclk);
+		return ret;
+	}
+
+	usleep_range(10, 100);
+
+	/*
+	 * Convert from 0xd9000000 to 0xc9000000 as the vendor driver does.
+	 * This only seems to be relevant for the AO_CPU_CNTL register. It is
+	 * unknown why this is needed.
+	 */
+	translated_sram_addr = priv->sram_pa - MESON_AO_RPROC_MEMORY_OFFSET;
+
+	tmp = FIELD_PREP(AO_CPU_CNTL_AHB_SRAM_BITS_31_20,
+			 translated_sram_addr >> 20);
+	tmp |= AO_CPU_CNTL_UNKNONWN | AO_CPU_CNTL_RUN;
+	writel(tmp, priv->cpu_base + AO_CPU_CNTL);
+
+	usleep_range(20, 200);
+
+	return 0;
+}
+
+static int meson_mx_ao_arc_rproc_stop(struct rproc *rproc)
+{
+	struct meson_mx_ao_arc_rproc_priv *priv = rproc->priv;
+
+	writel(AO_CPU_CNTL_HALT, priv->cpu_base + AO_CPU_CNTL);
+
+	clk_disable_unprepare(priv->arc_pclk);
+
+	return 0;
+}
+
+static void *meson_mx_ao_arc_rproc_da_to_va(struct rproc *rproc, u64 da,
+					    size_t len, bool *is_iomem)
+{
+	struct meson_mx_ao_arc_rproc_priv *priv = rproc->priv;
+
+	/* The memory from the ARC core's perspective always starts at 0x0. */
+	if ((da + len) > priv->sram_size)
+		return NULL;
+
+	return (void *)priv->sram_va + da;
+}
+
+static struct rproc_ops meson_mx_ao_arc_rproc_ops = {
+	.start		= meson_mx_ao_arc_rproc_start,
+	.stop		= meson_mx_ao_arc_rproc_stop,
+	.da_to_va	= meson_mx_ao_arc_rproc_da_to_va,
+	.get_boot_addr	= rproc_elf_get_boot_addr,
+	.load		= rproc_elf_load_segments,
+	.sanity_check	= rproc_elf_sanity_check,
+};
+
+static int meson_mx_ao_arc_rproc_probe(struct platform_device *pdev)
+{
+	struct meson_mx_ao_arc_rproc_priv *priv;
+	struct device *dev = &pdev->dev;
+	const char *fw_name = NULL;
+	struct rproc *rproc;
+	int ret;
+
+	device_property_read_string(dev, "firmware-name", &fw_name);
+
+	rproc = devm_rproc_alloc(dev, "meson-mx-ao-arc",
+				 &meson_mx_ao_arc_rproc_ops, fw_name,
+				 sizeof(*priv));
+	if (!rproc)
+		return -ENOMEM;
+
+	rproc->has_iommu = false;
+	priv = rproc->priv;
+
+	priv->sram_pool = of_gen_pool_get(dev->of_node, "sram", 0);
+	if (!priv->sram_pool) {
+		dev_err(dev, "Could not get SRAM pool\n");
+		return -ENODEV;
+	}
+
+	priv->sram_size = gen_pool_avail(priv->sram_pool);
+
+	priv->sram_va = gen_pool_alloc(priv->sram_pool, priv->sram_size);
+	if (!priv->sram_va) {
+		dev_err(dev, "Could not alloc memory in SRAM pool\n");
+		return -ENOMEM;
+	}
+
+	priv->sram_pa = gen_pool_virt_to_phys(priv->sram_pool, priv->sram_va);
+	if (priv->sram_pa & ~MESON_AO_RPROC_SRAM_USABLE_BITS) {
+		dev_err(dev, "SRAM address contains unusable bits\n");
+		ret = -EINVAL;
+		goto err_free_genpool;
+	}
+
+	priv->secbus2_regmap = syscon_regmap_lookup_by_phandle(dev->of_node,
+							       "amlogic,secbus2");
+	if (IS_ERR(priv->secbus2_regmap)) {
+		dev_err(dev, "Failed to find SECBUS2 regmap\n");
+		ret = PTR_ERR(priv->secbus2_regmap);
+		goto err_free_genpool;
+	}
+
+	priv->remap_base = devm_platform_ioremap_resource_byname(pdev, "remap");
+	if (IS_ERR(priv->remap_base)) {
+		ret = PTR_ERR(priv->remap_base);
+		goto err_free_genpool;
+	}
+
+	priv->cpu_base = devm_platform_ioremap_resource_byname(pdev, "cpu");
+	if (IS_ERR(priv->cpu_base)) {
+		ret = PTR_ERR(priv->cpu_base);
+		goto err_free_genpool;
+	}
+
+	priv->arc_reset = devm_reset_control_get_exclusive(dev, NULL);
+	if (IS_ERR(priv->arc_reset)) {
+		dev_err(dev, "Failed to get ARC reset\n");
+		ret = PTR_ERR(priv->arc_reset);
+		goto err_free_genpool;
+	}
+
+	priv->arc_pclk = devm_clk_get(dev, NULL);
+	if (IS_ERR(priv->arc_pclk)) {
+		dev_err(dev, "Failed to get the ARC PCLK\n");
+		ret = PTR_ERR(priv->arc_pclk);
+		goto err_free_genpool;
+	}
+
+	platform_set_drvdata(pdev, rproc);
+
+	ret = rproc_add(rproc);
+	if (ret)
+		goto err_free_genpool;
+
+	return 0;
+
+err_free_genpool:
+	gen_pool_free(priv->sram_pool, priv->sram_va, priv->sram_size);
+	return ret;
+}
+
+static int meson_mx_ao_arc_rproc_remove(struct platform_device *pdev)
+{
+	struct rproc *rproc = platform_get_drvdata(pdev);
+	struct meson_mx_ao_arc_rproc_priv *priv = rproc->priv;
+
+	rproc_del(rproc);
+	gen_pool_free(priv->sram_pool, priv->sram_va, priv->sram_size);
+
+	return 0;
+}
+
+static const struct of_device_id meson_mx_ao_arc_rproc_match[] = {
+	{ .compatible = "amlogic,meson8-ao-arc" },
+	{ .compatible = "amlogic,meson8b-ao-arc" },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, meson_mx_ao_arc_rproc_match);
+
+static struct platform_driver meson_mx_ao_arc_rproc_driver = {
+	.probe = meson_mx_ao_arc_rproc_probe,
+	.remove = meson_mx_ao_arc_rproc_remove,
+	.driver = {
+		.name = "meson-mx-ao-arc-rproc",
+		.of_match_table = meson_mx_ao_arc_rproc_match,
+	},
+};
+module_platform_driver(meson_mx_ao_arc_rproc_driver);
+
+MODULE_DESCRIPTION("Amlogic Meson6/8/8b/8m2 AO ARC remote processor driver");
+MODULE_AUTHOR("Martin Blumenstingl <martin.blumenstingl@googlemail.com>");
+MODULE_LICENSE("GPL v2");
diff -Naur a/drivers/soc/amlogic/meson-mx-socinfo.c b/drivers/soc/amlogic/meson-mx-socinfo.c
--- a/drivers/soc/amlogic/meson-mx-socinfo.c	2021-10-31 16:53:10.000000000 -0400
+++ b/drivers/soc/amlogic/meson-mx-socinfo.c	2021-10-31 20:41:20.000000000 -0400
@@ -4,6 +4,7 @@
  * SPDX-License-Identifier: GPL-2.0+
  */
 
+#include <linux/firmware/meson/meson_mx_trustzone.h>
 #include <linux/io.h>
 #include <linux/of.h>
 #include <linux/of_address.h>
@@ -118,10 +119,12 @@
 	if (IS_ERR(assist_regmap))
 		return PTR_ERR(assist_regmap);
 
-	bootrom_regmap =
-		syscon_regmap_lookup_by_compatible("amlogic,meson-mx-bootrom");
-	if (IS_ERR(bootrom_regmap))
-		return PTR_ERR(bootrom_regmap);
+	if (!meson_mx_trustzone_firmware_available()) {
+		bootrom_regmap =
+			syscon_regmap_lookup_by_compatible("amlogic,meson-mx-bootrom");
+		if (IS_ERR(bootrom_regmap))
+			return PTR_ERR(bootrom_regmap);
+	}
 
 	np = of_find_matching_node(NULL, meson_mx_socinfo_analog_top_ids);
 	if (np) {
@@ -140,10 +143,14 @@
 	if (ret < 0)
 		return ret;
 
-	ret = regmap_read(bootrom_regmap, MESON_MX_BOOTROM_MISC_VER,
-			  &misc_ver);
-	if (ret < 0)
-		return ret;
+	if (meson_mx_trustzone_firmware_available()) {
+		misc_ver = meson_mx_trustzone_read_soc_rev1();
+	} else {
+		ret = regmap_read(bootrom_regmap, MESON_MX_BOOTROM_MISC_VER,
+				  &misc_ver);
+		if (ret < 0)
+			return ret;
+	}
 
 	soc_dev_attr = kzalloc(sizeof(*soc_dev_attr), GFP_KERNEL);
 	if (!soc_dev_attr)
diff -Naur a/drivers/usb/common/usb-conn-gpio.c b/drivers/usb/common/usb-conn-gpio.c
--- a/drivers/usb/common/usb-conn-gpio.c	2021-10-31 16:53:10.000000000 -0400
+++ b/drivers/usb/common/usb-conn-gpio.c	2021-10-31 20:41:20.000000000 -0400
@@ -23,6 +23,7 @@
 
 #define USB_GPIO_DEB_MS		20	/* ms */
 #define USB_GPIO_DEB_US		((USB_GPIO_DEB_MS) * 1000)	/* us */
+#define USB_GPIO_POLL_MS	1000
 
 #define USB_CONN_IRQF	\
 	(IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING | IRQF_ONESHOT)
@@ -44,6 +45,23 @@
 	struct power_supply *charger;
 };
 
+static void usb_conn_queue_dwork(struct usb_conn_info *info,
+				 unsigned long delay)
+{
+	queue_delayed_work(system_power_efficient_wq, &info->dw_det, delay);
+}
+
+static void usb_conn_gpio_start_polling(struct usb_conn_info *info)
+{
+	usb_conn_queue_dwork(info, msecs_to_jiffies(USB_GPIO_POLL_MS));
+}
+
+static bool usb_conn_gpio_needs_polling(struct usb_conn_info *info)
+{
+	/* We need to poll if one of the GPIOs cannot generate an IRQ. */
+	return info->id_irq < 0 || info->vbus_irq < 0;
+}
+
 /*
  * "DEVICE" = VBUS and "HOST" = !ID, so we have:
  * Both "DEVICE" and "HOST" can't be set as active at the same time
@@ -87,7 +105,12 @@
 		usb_role_string(info->last_role), usb_role_string(role), id, vbus);
 
 	if (info->last_role == role) {
-		dev_warn(info->dev, "repeated role: %s\n", usb_role_string(role));
+		if (usb_conn_gpio_needs_polling(info))
+			usb_conn_gpio_start_polling(info);
+		else
+			dev_warn(info->dev, "repeated role: %s\n",
+				 usb_role_string(role));
+
 		return;
 	}
 
@@ -111,12 +134,9 @@
 			regulator_is_enabled(info->vbus) ? "enabled" : "disabled");
 
 	power_supply_changed(info->charger);
-}
 
-static void usb_conn_queue_dwork(struct usb_conn_info *info,
-				 unsigned long delay)
-{
-	queue_delayed_work(system_power_efficient_wq, &info->dw_det, delay);
+	if (usb_conn_gpio_needs_polling(info))
+		usb_conn_gpio_start_polling(info);
 }
 
 static irqreturn_t usb_conn_isr(int irq, void *dev_id)
@@ -239,34 +259,34 @@
 	if (info->id_gpiod) {
 		info->id_irq = gpiod_to_irq(info->id_gpiod);
 		if (info->id_irq < 0) {
-			dev_err(dev, "failed to get ID IRQ\n");
-			ret = info->id_irq;
-			goto put_role_sw;
-		}
-
-		ret = devm_request_threaded_irq(dev, info->id_irq, NULL,
-						usb_conn_isr, USB_CONN_IRQF,
-						pdev->name, info);
-		if (ret < 0) {
-			dev_err(dev, "failed to request ID IRQ\n");
-			goto put_role_sw;
+			dev_info(dev,
+				 "failed to get ID IRQ - falling back to polling\n");
+		} else {
+			ret = devm_request_threaded_irq(dev, info->id_irq,
+							NULL, usb_conn_isr,
+							USB_CONN_IRQF,
+							pdev->name, info);
+			if (ret < 0) {
+				dev_err(dev, "failed to request ID IRQ\n");
+				goto put_role_sw;
+			}
 		}
 	}
 
 	if (info->vbus_gpiod) {
 		info->vbus_irq = gpiod_to_irq(info->vbus_gpiod);
 		if (info->vbus_irq < 0) {
-			dev_err(dev, "failed to get VBUS IRQ\n");
-			ret = info->vbus_irq;
-			goto put_role_sw;
-		}
-
-		ret = devm_request_threaded_irq(dev, info->vbus_irq, NULL,
-						usb_conn_isr, USB_CONN_IRQF,
-						pdev->name, info);
-		if (ret < 0) {
-			dev_err(dev, "failed to request VBUS IRQ\n");
-			goto put_role_sw;
+			dev_info(dev,
+				 "failed to get VBUS IRQ - falling back to polling\n");
+		} else {
+			ret = devm_request_threaded_irq(dev, info->vbus_irq,
+							NULL, usb_conn_isr,
+							USB_CONN_IRQF,
+							pdev->name, info);
+			if (ret < 0) {
+				dev_err(dev, "failed to request VBUS IRQ\n");
+				goto put_role_sw;
+			}
 		}
 	}
 
@@ -305,6 +325,8 @@
 	if (info->vbus_gpiod)
 		disable_irq(info->vbus_irq);
 
+	cancel_delayed_work_sync(&info->dw_det);
+
 	pinctrl_pm_select_sleep_state(dev);
 
 	return 0;
diff -Naur a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
--- a/drivers/usb/dwc2/platform.c	2021-10-31 16:53:10.000000000 -0400
+++ b/drivers/usb/dwc2/platform.c	2021-10-31 20:41:20.000000000 -0400
@@ -639,6 +639,19 @@
 		}
 	}
 #endif /* CONFIG_USB_DWC2_PERIPHERAL || CONFIG_USB_DWC2_DUAL_ROLE */
+
+	retval = devm_of_platform_populate(&dev->dev);
+	if (retval) {
+		dev_err(hsotg->dev,
+			"Failed to create child devices/connectors for %p\n",
+			dev->dev.of_node);
+
+		if (hsotg->gadget_enabled)
+			dwc2_hsotg_remove(hsotg);
+
+		goto error_debugfs;
+	}
+
 	return 0;
 
 #if IS_ENABLED(CONFIG_USB_DWC2_PERIPHERAL) || \
diff -Naur a/drivers/usb/host/Kconfig b/drivers/usb/host/Kconfig
--- a/drivers/usb/host/Kconfig	2021-10-31 16:53:10.000000000 -0400
+++ b/drivers/usb/host/Kconfig	2021-10-31 20:41:20.000000000 -0400
@@ -43,6 +43,16 @@
 	depends on USB_XHCI_PCI_RENESAS || !USB_XHCI_PCI_RENESAS
 	default y
 
+config USB_XHCI_PCI_ETRON
+	tristate "Support for GPIOs in the Etron EJ168/EJ188/EJ198 controllers"
+	depends on USB_XHCI_PCI && OF_GPIO
+	default n
+	help
+	  Say 'Y' to enable the support for the GPIO controller inside the
+	  Etron EJ168/EJ188/EJ198 xHCI controllers.
+
+	  If unsure, say 'N'.
+
 config USB_XHCI_PCI_RENESAS
 	tristate "Support for additional Renesas xHCI controller with firmware"
 	help
diff -Naur a/drivers/usb/host/Makefile b/drivers/usb/host/Makefile
--- a/drivers/usb/host/Makefile	2021-10-31 16:53:10.000000000 -0400
+++ b/drivers/usb/host/Makefile	2021-10-31 20:41:20.000000000 -0400
@@ -68,6 +68,7 @@
 obj-$(CONFIG_USB_FHCI_HCD)	+= fhci.o
 obj-$(CONFIG_USB_XHCI_HCD)	+= xhci-hcd.o
 obj-$(CONFIG_USB_XHCI_PCI)	+= xhci-pci.o
+obj-$(CONFIG_USB_XHCI_PCI_ETRON)	+= xhci-pci-etron.o
 obj-$(CONFIG_USB_XHCI_PCI_RENESAS)	+= xhci-pci-renesas.o
 obj-$(CONFIG_USB_XHCI_PLATFORM) += xhci-plat-hcd.o
 obj-$(CONFIG_USB_XHCI_HISTB)	+= xhci-histb.o
diff -Naur a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
--- a/drivers/usb/host/xhci.h	2021-10-31 16:53:10.000000000 -0400
+++ b/drivers/usb/host/xhci.h	2021-10-31 20:41:20.000000000 -0400
@@ -1900,6 +1900,7 @@
 #define XHCI_NO_SOFT_RETRY	BIT_ULL(40)
 #define XHCI_BROKEN_D3COLD	BIT_ULL(41)
 #define XHCI_EP_CTX_BROKEN_DCS	BIT_ULL(42)
+#define XHCI_ETRON_GPIO_QUIRK	BIT_ULL(43)
 
 	unsigned int		num_active_eps;
 	unsigned int		limit_active_eps;
diff -Naur a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
--- a/drivers/usb/host/xhci-pci.c	2021-10-31 16:53:10.000000000 -0400
+++ b/drivers/usb/host/xhci-pci.c	2021-10-31 20:41:20.000000000 -0400
@@ -262,6 +262,7 @@
 		xhci->quirks |= XHCI_RESET_ON_RESUME;
 		xhci->quirks |= XHCI_TRUST_TX_LENGTH;
 		xhci->quirks |= XHCI_BROKEN_STREAMS;
+		xhci->quirks |= XHCI_ETRON_GPIO_QUIRK;
 	}
 	if (pdev->vendor == PCI_VENDOR_ID_RENESAS &&
 	    pdev->device == 0x0014) {
@@ -437,8 +438,16 @@
 	if (xhci->quirks & XHCI_DEFAULT_PM_RUNTIME_ALLOW)
 		pm_runtime_allow(&dev->dev);
 
+	if (xhci->quirks & XHCI_ETRON_GPIO_QUIRK) {
+		retval = etron_xhci_pci_probe(dev);
+		if (retval)
+			goto remove_usb3_hcd;
+	}
+
 	return 0;
 
+remove_usb3_hcd:
+	usb_remove_hcd(xhci->shared_hcd);
 put_usb3_hcd:
 	usb_put_hcd(xhci->shared_hcd);
 dealloc_usb2_hcd:
diff -Naur a/drivers/usb/host/xhci-pci-etron.c b/drivers/usb/host/xhci-pci-etron.c
--- a/drivers/usb/host/xhci-pci-etron.c	1969-12-31 19:00:00.000000000 -0500
+++ b/drivers/usb/host/xhci-pci-etron.c	2021-10-31 20:41:20.000000000 -0400
@@ -0,0 +1,287 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/* Copyright (C) 2020 Martin Blumenstingl <martin.blumenstingl@googlemail.com> */
+
+#include <linux/bitfield.h>
+#include <linux/delay.h>
+#include <linux/gpio/driver.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/property.h>
+#include <linux/spinlock.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+
+#include "xhci-pci.h"
+
+#define EJ1X8_GPIO_INIT					0x44
+#define EJ1X8_GPIO_WRITE				0x68
+#define EJ1X8_GPIO_READ					0x6c
+
+#define EJ1X8_GPIO_CTRL					0x18005020
+#define EJ1X8_GPIO_CTRL_READ_ALL_MASK			GENMASK(7, 0)
+#define EJ1X8_GPIO_CTRL_WRITE_ALL_MASK			GENMASK(23, 16)
+#define EJ1X8_GPIO_CTRL_OUT_LOW				0x0
+#define EJ1X8_GPIO_CTRL_OUT_HIGH			0x1
+#define EJ1X8_GPIO_CTRL_IN				0x2
+#define EJ1X8_GPIO_CTRL_MASK				0x3
+
+#define EJ1X8_GPIO_MODE					0x18005022
+#define EJ1X8_GPIO_MODE_READ_WRITE_ALL_MASK		GENMASK(23, 16)
+#define EJ1X8_GPIO_MODE_DISABLE				0x0
+#define EJ1X8_GPIO_MODE_ENABLE				0x1
+#define EJ1X8_GPIO_MODE_MASK				0x3
+
+struct etron_xhci_pci_priv {
+	spinlock_t			lock;
+	struct pci_dev			*pci_dev;
+	struct gpio_chip		chip;
+};
+
+static u8 etron_xhci_pci_gpio_shift(unsigned int gpio, u8 mask)
+{
+	return (gpio * fls(mask));
+}
+
+static u8 etron_xhci_pci_gpio_mask(unsigned int gpio, u8 mask)
+{
+	return mask << etron_xhci_pci_gpio_shift(gpio, mask);
+}
+
+static int etron_xhci_pci_gpio_read(struct gpio_chip *gc, u32 reg, u32 *value)
+{
+	struct etron_xhci_pci_priv *etron_priv = gpiochip_get_data(gc);
+	int err;
+
+	err = pci_write_config_dword(etron_priv->pci_dev, EJ1X8_GPIO_WRITE, reg);
+	if (err) {
+		dev_err(gc->parent, "Failed to select 0x%08x register\n", reg);
+		return err;
+	}
+
+	usleep_range(1000, 10000);
+
+	err = pci_read_config_dword(etron_priv->pci_dev, EJ1X8_GPIO_READ, value);
+	if (err) {
+		dev_err(gc->parent, "Failed to read 0x%08x register\n", reg);
+		return err;
+	}
+
+	return 0;
+}
+
+static int etron_xhci_pci_gpio_write(struct gpio_chip *gc, u32 reg, u32 value)
+{
+	struct etron_xhci_pci_priv *etron_priv = gpiochip_get_data(gc);
+	int err;
+
+	err = pci_write_config_dword(etron_priv->pci_dev, EJ1X8_GPIO_WRITE,
+				     reg | value | BIT(24));
+	if (err) {
+		dev_err(gc->parent, "Failed to write 0x%08x register\n", reg);
+		return err;
+	}
+
+	usleep_range(1000, 10000);
+
+	return 0;
+}
+
+static int etron_xhci_pci_gpio_config(struct gpio_chip *gc, unsigned int gpio,
+				      u8 mode, u8 ctrl)
+{
+	struct etron_xhci_pci_priv *etron_priv = gpiochip_get_data(gc);
+	u8 all_gpio_ctrl, all_gpio_mode;
+	u32 temp;
+	int err;
+
+	spin_lock(&etron_priv->lock);
+
+	err = pci_read_config_dword(etron_priv->pci_dev, EJ1X8_GPIO_INIT, &temp);
+	if (err) {
+		dev_err(gc->parent, "Failed to read INIT register\n");
+		return err;
+	}
+
+	err = pci_write_config_dword(etron_priv->pci_dev, EJ1X8_GPIO_INIT,
+				     temp | 0x1);
+	if (err) {
+		dev_err(gc->parent, "Failed to write INIT register\n");
+		return err;
+	}
+
+	err = etron_xhci_pci_gpio_read(gc, EJ1X8_GPIO_CTRL, &temp);
+	if (err)
+		goto err_unlock;
+
+	all_gpio_ctrl = FIELD_GET(EJ1X8_GPIO_CTRL_READ_ALL_MASK, temp);
+	all_gpio_ctrl &= ~etron_xhci_pci_gpio_mask(gpio, EJ1X8_GPIO_CTRL_MASK);
+	all_gpio_ctrl |= ctrl << etron_xhci_pci_gpio_shift(gpio,
+							   EJ1X8_GPIO_CTRL_MASK);
+
+	err = etron_xhci_pci_gpio_read(gc, EJ1X8_GPIO_MODE, &temp);
+	if (err)
+		goto err_unlock;
+
+	all_gpio_mode = FIELD_GET(EJ1X8_GPIO_MODE_READ_WRITE_ALL_MASK, temp);
+	all_gpio_mode &= ~etron_xhci_pci_gpio_mask(gpio, EJ1X8_GPIO_MODE_MASK);
+	all_gpio_mode |= mode << etron_xhci_pci_gpio_shift(gpio,
+							   EJ1X8_GPIO_MODE_MASK);
+
+	err = etron_xhci_pci_gpio_write(gc, EJ1X8_GPIO_CTRL,
+			       FIELD_PREP(EJ1X8_GPIO_CTRL_WRITE_ALL_MASK,
+					  all_gpio_ctrl));
+	if (err)
+		goto err_unlock;
+
+	err = etron_xhci_pci_gpio_write(gc, EJ1X8_GPIO_MODE,
+			       FIELD_PREP(EJ1X8_GPIO_MODE_READ_WRITE_ALL_MASK,
+					  all_gpio_mode));
+	if (err)
+		goto err_unlock;
+
+	spin_unlock(&etron_priv->lock);
+
+	return 0;
+
+err_unlock:
+	spin_unlock(&etron_priv->lock);
+	return err;
+}
+
+static int etron_xhci_pci_gpio_get_mode(struct gpio_chip *gc, unsigned int gpio,
+					u8 *mode)
+{
+	struct etron_xhci_pci_priv *etron_priv = gpiochip_get_data(gc);
+	u32 temp, all_gpio_mode;
+	int err;
+
+	spin_lock(&etron_priv->lock);
+	err = etron_xhci_pci_gpio_read(gc, EJ1X8_GPIO_MODE, &temp);
+	spin_unlock(&etron_priv->lock);
+
+	if (err)
+		return err;
+
+	all_gpio_mode = FIELD_GET(EJ1X8_GPIO_MODE_READ_WRITE_ALL_MASK, temp);
+	*mode = all_gpio_mode >> etron_xhci_pci_gpio_shift(gpio,
+							   EJ1X8_GPIO_MODE_MASK);
+	*mode &= EJ1X8_GPIO_MODE_MASK;
+
+	return 0;
+}
+
+static void etron_xhci_pci_gpio_free(struct gpio_chip *gc, unsigned int gpio)
+{
+	etron_xhci_pci_gpio_config(gc, gpio, EJ1X8_GPIO_MODE_DISABLE,
+				   EJ1X8_GPIO_CTRL_IN);
+}
+
+static int etron_xhci_pci_gpio_get_direction(struct gpio_chip *gc,
+					     unsigned int gpio)
+{
+	u8 mode;
+	int err;
+
+	err = etron_xhci_pci_gpio_get_mode(gc, gpio, &mode);
+	if (err)
+		return err;
+
+	switch (mode) {
+	case EJ1X8_GPIO_CTRL_IN:
+		return GPIO_LINE_DIRECTION_IN;
+
+	case EJ1X8_GPIO_CTRL_OUT_HIGH:
+	case EJ1X8_GPIO_CTRL_OUT_LOW:
+		return GPIO_LINE_DIRECTION_OUT;
+
+	default:
+		return -EINVAL;
+	}
+}
+
+static int etron_xhci_pci_gpio_direction_output(struct gpio_chip *gc,
+						unsigned int gpio, int value)
+{
+	u8 gpio_ctrl;
+
+	if (value)
+		gpio_ctrl = EJ1X8_GPIO_CTRL_OUT_HIGH;
+	else
+		gpio_ctrl = EJ1X8_GPIO_CTRL_OUT_LOW;
+
+	return etron_xhci_pci_gpio_config(gc, gpio, EJ1X8_GPIO_MODE_ENABLE,
+					  gpio_ctrl);
+}
+
+static int etron_xhci_pci_gpio_get_value(struct gpio_chip *gc, unsigned int gpio)
+{
+	u8 mode;
+	int err;
+
+	err = etron_xhci_pci_gpio_get_mode(gc, gpio, &mode);
+	if (err)
+		return err;
+
+	switch (mode) {
+	case EJ1X8_GPIO_CTRL_OUT_HIGH:
+		return 1;
+
+	case EJ1X8_GPIO_CTRL_OUT_LOW:
+		return 0;
+
+	default:
+		return -EINVAL;
+	}
+}
+
+static void etron_xhci_pci_gpio_set_value(struct gpio_chip *gc,
+					  unsigned int gpio, int value)
+{
+	etron_xhci_pci_gpio_direction_output(gc, gpio, value);
+}
+
+int etron_xhci_pci_probe(struct pci_dev *pci_dev)
+{
+	struct etron_xhci_pci_priv *etron_priv;
+	struct device *dev = &pci_dev->dev;
+	int err;
+
+	if (!device_property_read_bool(dev, "gpio-controller"))
+		return 0;
+
+	etron_priv = devm_kzalloc(dev, sizeof(*etron_priv), GFP_KERNEL);
+	if (!etron_priv)
+		return -ENOMEM;
+
+	spin_lock_init(&etron_priv->lock);
+	etron_priv->pci_dev = pci_dev;
+
+	/* TODO: input mode is supported by the hardware but not the driver */
+	etron_priv->chip.label = dev_name(dev);
+	etron_priv->chip.owner = THIS_MODULE;
+	etron_priv->chip.parent = dev;
+	etron_priv->chip.of_node = dev->of_node;
+	etron_priv->chip.free = etron_xhci_pci_gpio_free;
+	etron_priv->chip.get_direction = etron_xhci_pci_gpio_get_direction;
+	etron_priv->chip.direction_output = etron_xhci_pci_gpio_direction_output;
+	etron_priv->chip.get = etron_xhci_pci_gpio_get_value;
+	etron_priv->chip.set = etron_xhci_pci_gpio_set_value;
+	etron_priv->chip.base = -1;
+	etron_priv->chip.ngpio = 4;
+
+	err = devm_gpiochip_add_data(dev, &etron_priv->chip, etron_priv);
+	if (err) {
+		dev_warn(dev, "Failed to register GPIO device: %d\n", err);
+		return err;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(etron_xhci_pci_probe);
+
+MODULE_SOFTDEP("pre: xhci-pci");
+MODULE_AUTHOR("Martin Blumenstingl <martin.blumenstingl@googlemail.com>");
+MODULE_DESCRIPTION("Etron Technology Inc. EJ168/EJ188/EJ198 GPIO driver");
+MODULE_LICENSE("GPL v2");
diff -Naur a/drivers/usb/host/xhci-pci.h b/drivers/usb/host/xhci-pci.h
--- a/drivers/usb/host/xhci-pci.h	2021-10-31 16:53:10.000000000 -0400
+++ b/drivers/usb/host/xhci-pci.h	2021-10-31 20:41:20.000000000 -0400
@@ -4,6 +4,15 @@
 #ifndef XHCI_PCI_H
 #define XHCI_PCI_H
 
+#if IS_REACHABLE(CONFIG_USB_XHCI_PCI_ETRON)
+int etron_xhci_pci_probe(struct pci_dev *pci_dev);
+#else
+static inline int etron_xhci_pci_probe(struct pci_dev *pci_dev)
+{
+	return 0;
+}
+#endif
+
 #if IS_ENABLED(CONFIG_USB_XHCI_PCI_RENESAS)
 int renesas_xhci_check_request_fw(struct pci_dev *dev,
 				  const struct pci_device_id *id);
diff -Naur a/include/dt-bindings/clock/meson8b-clkc.h b/include/dt-bindings/clock/meson8b-clkc.h
--- a/include/dt-bindings/clock/meson8b-clkc.h	2021-10-31 16:53:10.000000000 -0400
+++ b/include/dt-bindings/clock/meson8b-clkc.h	2021-10-31 20:41:20.000000000 -0400
@@ -105,6 +105,16 @@
 #define CLKID_PERIPH		126
 #define CLKID_AXI		128
 #define CLKID_L2_DRAM		130
+#define CLKID_HDMI_PLL_HDMI_OUT	132
+#define CLKID_VID_PLL_FINAL_DIV	137
+#define CLKID_VCLK_IN_SEL	138
+#define CLKID_VCLK2_IN_SEL	149
+#define CLKID_CTS_ENCT		161
+#define CLKID_CTS_ENCP		163
+#define CLKID_CTS_ENCI		165
+#define CLKID_HDMI_TX_PIXEL	167
+#define CLKID_CTS_ENCL		169
+#define CLKID_CTS_VDAC0		171
 #define CLKID_HDMI_SYS		174
 #define CLKID_VPU		190
 #define CLKID_VDEC_1		196
@@ -114,5 +124,6 @@
 #define CLKID_CTS_AMCLK		209
 #define CLKID_CTS_MCLK_I958	212
 #define CLKID_CTS_I958		213
+#define CLKID_ETH_CLK		222
 
 #endif /* __MESON8B_CLKC_H */
diff -Naur a/include/dt-bindings/gpio/meson8b-gpio.h b/include/dt-bindings/gpio/meson8b-gpio.h
--- a/include/dt-bindings/gpio/meson8b-gpio.h	2021-10-31 16:53:10.000000000 -0400
+++ b/include/dt-bindings/gpio/meson8b-gpio.h	2021-10-31 20:41:20.000000000 -0400
@@ -100,6 +100,8 @@
 #define DIF_4_P		81
 #define DIF_4_N		82
 
+#define GPIO_BSD_EN	83
+
 /* AO GPIO chip */
 #define GPIOAO_0	0
 #define GPIOAO_1	1
@@ -115,7 +117,6 @@
 #define GPIOAO_11	11
 #define GPIOAO_12	12
 #define GPIOAO_13	13
-#define GPIO_BSD_EN	14
-#define GPIO_TEST_N	15
+#define GPIO_TEST_N	14
 
 #endif /* _DT_BINDINGS_MESON8B_GPIO_H */
diff -Naur a/include/dt-bindings/gpio/meson8-gpio.h b/include/dt-bindings/gpio/meson8-gpio.h
--- a/include/dt-bindings/gpio/meson8-gpio.h	2021-10-31 16:53:10.000000000 -0400
+++ b/include/dt-bindings/gpio/meson8-gpio.h	2021-10-31 20:41:20.000000000 -0400
@@ -129,6 +129,7 @@
 #define BOOT_16		117
 #define BOOT_17		118
 #define BOOT_18		119
+#define GPIO_BSD_EN	120
 
 /* Second GPIO chip */
 #define GPIOAO_0	0
@@ -145,7 +146,6 @@
 #define GPIOAO_11	11
 #define GPIOAO_12	12
 #define GPIOAO_13	13
-#define GPIO_BSD_EN	14
-#define GPIO_TEST_N	15
+#define GPIO_TEST_N	14
 
 #endif /* _DT_BINDINGS_MESON8_GPIO_H */
diff -Naur a/include/dt-bindings/net/realtek-rtl8211f.h b/include/dt-bindings/net/realtek-rtl8211f.h
--- a/include/dt-bindings/net/realtek-rtl8211f.h	1969-12-31 19:00:00.000000000 -0500
+++ b/include/dt-bindings/net/realtek-rtl8211f.h	2021-10-31 20:41:20.000000000 -0400
@@ -0,0 +1,12 @@
+/* SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause) */
+
+#ifndef _DT_BINDINGS_REALTEK_RTL8211F_H
+#define _DT_BINDINGS_REALTEK_RTL8211F_H
+
+#define RTL8211F_LED_LINK_10			(1 << 0)
+#define RTL8211F_LED_LINK_100			(1 << 1)
+#define RTL8211F_LED_LINK_1000			(1 << 2)
+#define RTL8211F_LED_ACTIVITY			(1 << 3)
+#define RTL8211F_LED_EEE			(1 << 4)
+
+#endif /* _DT_BINDINGS_REALTEK_RTL8211F_H */
diff -Naur a/include/linux/firmware/meson/meson_mx_trustzone.h b/include/linux/firmware/meson/meson_mx_trustzone.h
--- a/include/linux/firmware/meson/meson_mx_trustzone.h	1969-12-31 19:00:00.000000000 -0500
+++ b/include/linux/firmware/meson/meson_mx_trustzone.h	2021-10-31 20:41:20.000000000 -0400
@@ -0,0 +1,42 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2021 Martin Blumenstingl <martin.blumenstingl@googlemail.com>
+ */
+
+#include <linux/errno.h>
+#include <linux/types.h>
+
+#if defined(CONFIG_ARM) && defined(CONFIG_ARCH_MESON)
+
+bool meson_mx_trustzone_firmware_available(void);
+
+int meson_mx_trustzone_firmware_efuse_read(unsigned int offset,
+					   unsigned int bytes, void *buf);
+
+unsigned int meson_mx_trustzone_read_soc_rev1(void);
+
+int meson_mx_trustzone_firmware_auxcoreboot_addr(unsigned int cpu,
+						 unsigned int addr);
+int meson_mx_trustzone_firmware_modify_corectrl(unsigned int cpu,
+						bool power_on);
+
+#else
+
+static inline bool meson_mx_trustzone_firmware_available(void)
+{
+	return false;
+}
+
+static inline int meson_mx_trustzone_firmware_efuse_read(unsigned int offset,
+							 unsigned int bytes,
+							 void *buf)
+{
+	return -EINVAL;
+}
+
+static inline unsigned int meson_mx_trustzone_read_soc_rev1(void)
+{
+	return 0;
+}
+
+#endif
diff -Naur a/include/linux/mmc/sdio_ids.h b/include/linux/mmc/sdio_ids.h
--- a/include/linux/mmc/sdio_ids.h	2021-10-31 16:53:10.000000000 -0400
+++ b/include/linux/mmc/sdio_ids.h	2021-10-31 20:41:20.000000000 -0400
@@ -109,6 +109,13 @@
 #define SDIO_VENDOR_ID_MICROCHIP_WILC		0x0296
 #define SDIO_DEVICE_ID_MICROCHIP_WILC1000	0x5347
 
+#define SDIO_VENDOR_ID_REALTEK			0x024c
+#define SDIO_DEVICE_ID_REALTEK_RTW8723BS	0xb723
+#define SDIO_DEVICE_ID_REALTEK_RTW8723DS	0xd723
+#define SDIO_DEVICE_ID_REALTEK_RTW8821DS	0xd821
+#define SDIO_DEVICE_ID_REALTEK_RTW8822BS	0xb822
+#define SDIO_DEVICE_ID_REALTEK_RTW8822CS	0xc822
+
 #define SDIO_VENDOR_ID_SIANO			0x039a
 #define SDIO_DEVICE_ID_SIANO_NOVA_B0		0x0201
 #define SDIO_DEVICE_ID_SIANO_NICE		0x0202
diff -Naur a/include/net/mac80211.h b/include/net/mac80211.h
--- a/include/net/mac80211.h	2021-10-31 16:53:10.000000000 -0400
+++ b/include/net/mac80211.h	2021-10-31 20:41:20.000000000 -0400
@@ -5610,6 +5610,24 @@
  * This function iterates over all stations associated with a given
  * hardware that are currently uploaded to the driver and calls the callback
  * function for them.
+ * This function allows the iterator function to sleep, when the iterator
+ * function is atomic @ieee80211_iterate_stations_atomic can be used.
+ *
+ * @hw: the hardware struct of which the interfaces should be iterated over
+ * @iterator: the iterator function to call, cannot sleep
+ * @data: first argument of the iterator function
+ */
+void ieee80211_iterate_stations(struct ieee80211_hw *hw,
+				void (*iterator)(void *data,
+						 struct ieee80211_sta *sta),
+				void *data);
+
+/**
+ * ieee80211_iterate_stations_atomic - iterate stations
+ *
+ * This function iterates over all stations associated with a given
+ * hardware that are currently uploaded to the driver and calls the callback
+ * function for them.
  * This function requires the iterator callback function to be atomic,
  *
  * @hw: the hardware struct of which the interfaces should be iterated over
diff -Naur a/net/mac80211/util.c b/net/mac80211/util.c
--- a/net/mac80211/util.c	2021-10-31 16:53:10.000000000 -0400
+++ b/net/mac80211/util.c	2021-10-31 20:41:20.000000000 -0400
@@ -862,6 +862,19 @@
 	}
 }
 
+void ieee80211_iterate_stations(struct ieee80211_hw *hw,
+				void (*iterator)(void *data,
+						 struct ieee80211_sta *sta),
+				void *data)
+{
+	struct ieee80211_local *local = hw_to_local(hw);
+
+	mutex_lock(&local->sta_mtx);
+	__iterate_stations(local, iterator, data);
+	mutex_unlock(&local->sta_mtx);
+}
+EXPORT_SYMBOL_GPL(ieee80211_iterate_stations);
+
 void ieee80211_iterate_stations_atomic(struct ieee80211_hw *hw,
 			void (*iterator)(void *data,
 					 struct ieee80211_sta *sta),
diff -Naur a/sound/soc/codecs/Kconfig b/sound/soc/codecs/Kconfig
--- a/sound/soc/codecs/Kconfig	2021-10-31 16:53:10.000000000 -0400
+++ b/sound/soc/codecs/Kconfig	2021-10-31 20:41:20.000000000 -0400
@@ -73,6 +73,7 @@
 	imply SND_SOC_CS4271_SPI
 	imply SND_SOC_CS42XX8_I2C
 	imply SND_SOC_CS43130
+	imply SND_SOC_CS4334
 	imply SND_SOC_CS4341
 	imply SND_SOC_CS4349
 	imply SND_SOC_CS47L15
@@ -678,6 +679,9 @@
 	tristate "Cirrus Logic CS43130 CODEC"
 	depends on I2C
 
+config SND_SOC_CS4334
+	tristate "Cirrus Logic CS4334 CODEC"
+
 config SND_SOC_CS4341
 	tristate "Cirrus Logic CS4341 CODEC"
 	depends on SND_SOC_I2C_AND_SPI
diff -Naur a/sound/soc/codecs/Makefile b/sound/soc/codecs/Makefile
--- a/sound/soc/codecs/Makefile	2021-10-31 16:53:10.000000000 -0400
+++ b/sound/soc/codecs/Makefile	2021-10-31 20:41:20.000000000 -0400
@@ -69,6 +69,7 @@
 snd-soc-cs42xx8-objs := cs42xx8.o
 snd-soc-cs42xx8-i2c-objs := cs42xx8-i2c.o
 snd-soc-cs43130-objs := cs43130.o
+snd-soc-cs4334-objs := cs4334.o
 snd-soc-cs4341-objs := cs4341.o
 snd-soc-cs4349-objs := cs4349.o
 snd-soc-cs47l15-objs := cs47l15.o
@@ -400,6 +401,7 @@
 obj-$(CONFIG_SND_SOC_CS42XX8)	+= snd-soc-cs42xx8.o
 obj-$(CONFIG_SND_SOC_CS42XX8_I2C) += snd-soc-cs42xx8-i2c.o
 obj-$(CONFIG_SND_SOC_CS43130)   += snd-soc-cs43130.o
+obj-$(CONFIG_SND_SOC_CS4334)	+= snd-soc-cs4334.o
 obj-$(CONFIG_SND_SOC_CS4341)	+= snd-soc-cs4341.o
 obj-$(CONFIG_SND_SOC_CS4349)	+= snd-soc-cs4349.o
 obj-$(CONFIG_SND_SOC_CS47L24)	+= snd-soc-cs47l24.o
diff -Naur a/sound/soc/codecs/rt5640.c b/sound/soc/codecs/rt5640.c
--- a/sound/soc/codecs/rt5640.c	2021-10-31 16:53:10.000000000 -0400
+++ b/sound/soc/codecs/rt5640.c	2021-10-31 20:41:20.000000000 -0400
@@ -12,11 +12,10 @@
 #include <linux/init.h>
 #include <linux/delay.h>
 #include <linux/pm.h>
-#include <linux/gpio.h>
+#include <linux/gpio/consumer.h>
 #include <linux/i2c.h>
 #include <linux/regmap.h>
 #include <linux/of.h>
-#include <linux/of_gpio.h>
 #include <linux/platform_device.h>
 #include <linux/spi/spi.h>
 #include <linux/acpi.h>
@@ -2636,8 +2635,7 @@
 	rt5640_reset(component);
 	regcache_cache_only(rt5640->regmap, true);
 	regcache_mark_dirty(rt5640->regmap);
-	if (gpio_is_valid(rt5640->ldo1_en))
-		gpio_set_value_cansleep(rt5640->ldo1_en, 0);
+	gpiod_set_value_cansleep(rt5640->ldo1_en, 0);
 
 	return 0;
 }
@@ -2646,8 +2644,8 @@
 {
 	struct rt5640_priv *rt5640 = snd_soc_component_get_drvdata(component);
 
-	if (gpio_is_valid(rt5640->ldo1_en)) {
-		gpio_set_value_cansleep(rt5640->ldo1_en, 1);
+	if (rt5640->ldo1_en) {
+		gpiod_set_value_cansleep(rt5640->ldo1_en, 1);
 		msleep(400);
 	}
 
@@ -2779,22 +2777,6 @@
 MODULE_DEVICE_TABLE(acpi, rt5640_acpi_match);
 #endif
 
-static int rt5640_parse_dt(struct rt5640_priv *rt5640, struct device_node *np)
-{
-	rt5640->ldo1_en = of_get_named_gpio(np, "realtek,ldo1-en-gpios", 0);
-	/*
-	 * LDO1_EN is optional (it may be statically tied on the board).
-	 * -ENOENT means that the property doesn't exist, i.e. there is no
-	 * GPIO, so is not an error. Any other error code means the property
-	 * exists, but could not be parsed.
-	 */
-	if (!gpio_is_valid(rt5640->ldo1_en) &&
-			(rt5640->ldo1_en != -ENOENT))
-		return rt5640->ldo1_en;
-
-	return 0;
-}
-
 static int rt5640_i2c_probe(struct i2c_client *i2c,
 		    const struct i2c_device_id *id)
 {
@@ -2809,12 +2791,13 @@
 		return -ENOMEM;
 	i2c_set_clientdata(i2c, rt5640);
 
-	if (i2c->dev.of_node) {
-		ret = rt5640_parse_dt(rt5640, i2c->dev.of_node);
-		if (ret)
-			return ret;
-	} else
-		rt5640->ldo1_en = -EINVAL;
+	rt5640->ldo1_en = devm_gpiod_get_optional(&i2c->dev, "realtek,ldo1-en",
+						  0);
+	if (IS_ERR(rt5640->ldo1_en)) {
+		ret = PTR_ERR(rt5640->ldo1_en);
+		dev_err(&i2c->dev, "Failed to request LDO1_EN: %d\n", ret);
+		return ret;
+	}
 
 	rt5640->regmap = devm_regmap_init_i2c(i2c, &rt5640_regmap);
 	if (IS_ERR(rt5640->regmap)) {
@@ -2824,15 +2807,8 @@
 		return ret;
 	}
 
-	if (gpio_is_valid(rt5640->ldo1_en)) {
-		ret = devm_gpio_request_one(&i2c->dev, rt5640->ldo1_en,
-					    GPIOF_OUT_INIT_HIGH,
-					    "RT5640 LDO1_EN");
-		if (ret < 0) {
-			dev_err(&i2c->dev, "Failed to request LDO1_EN %d: %d\n",
-				rt5640->ldo1_en, ret);
-			return ret;
-		}
+	if (rt5640->ldo1_en) {
+		gpiod_set_value_cansleep(rt5640->ldo1_en, 1);
 		msleep(400);
 	}
 
diff -Naur a/sound/soc/codecs/rt5640.h b/sound/soc/codecs/rt5640.h
--- a/sound/soc/codecs/rt5640.h	2021-10-31 16:53:10.000000000 -0400
+++ b/sound/soc/codecs/rt5640.h	2021-10-31 20:41:20.000000000 -0400
@@ -2122,7 +2122,7 @@
 	struct regmap *regmap;
 	struct clk *mclk;
 
-	int ldo1_en; /* GPIO for LDO1_EN */
+	struct gpio_desc *ldo1_en;
 	int irq;
 	int sysclk;
 	int sysclk_src;
diff -Naur a/sound/soc/meson/aiu-codec-ctrl.c b/sound/soc/meson/aiu-codec-ctrl.c
--- a/sound/soc/meson/aiu-codec-ctrl.c	2021-10-31 16:53:10.000000000 -0400
+++ b/sound/soc/meson/aiu-codec-ctrl.c	2021-10-31 20:41:20.000000000 -0400
@@ -12,14 +12,59 @@
 #include "aiu.h"
 #include "meson-codec-glue.h"
 
-#define CTRL_CLK_SEL		GENMASK(1, 0)
-#define CTRL_DATA_SEL_SHIFT	4
-#define CTRL_DATA_SEL		(0x3 << CTRL_DATA_SEL_SHIFT)
-
-static const char * const aiu_codec_ctrl_mux_texts[] = {
-	"DISABLED", "PCM", "I2S",
+#define AIU_HDMI_CLK_DATA_CTRL_CLK_SEL			GENMASK(1, 0)
+#define AIU_HDMI_CLK_DATA_CTRL_CLK_SEL_DISABLE		0x0
+#define AIU_HDMI_CLK_DATA_CTRL_CLK_SEL_PCM		0x1
+#define AIU_HDMI_CLK_DATA_CTRL_CLK_SEL_AIU		0x2
+#define AIU_HDMI_CLK_DATA_CTRL_DATA_SEL			GENMASK(5, 4)
+#define AIU_HDMI_CLK_DATA_CTRL_DATA_SEL_OUTPUT_ZERO	0x0
+#define AIU_HDMI_CLK_DATA_CTRL_DATA_SEL_PCM_DATA	0x1
+#define AIU_HDMI_CLK_DATA_CTRL_DATA_SEL_I2S_DATA	0x2
+
+#define AIU_CLK_CTRL_MORE_AMCLK				BIT(6)
+
+#define AIU_HDMI_CTRL_MUX_DISABLED			0
+#define AIU_HDMI_CTRL_MUX_PCM				1
+#define AIU_HDMI_CTRL_MUX_I2S				2
+#define AIU_HDMI_CTRL_MUX_SPDIF				3
+
+static const char * const aiu_codec_hdmi_ctrl_mux_texts[] = {
+	[AIU_HDMI_CTRL_MUX_DISABLED] =  "DISABLED",
+	[AIU_HDMI_CTRL_MUX_PCM] = "PCM",
+	[AIU_HDMI_CTRL_MUX_I2S] = "I2S",
+	[AIU_HDMI_CTRL_MUX_SPDIF] = "SPDIF",
 };
 
+static int aiu_codec_ctrl_mux_get_enum(struct snd_kcontrol *kcontrol,
+				       struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component =
+		snd_soc_dapm_kcontrol_component(kcontrol);
+	unsigned int more, ctrl, clk_sel, data_sel, mux;
+
+	more = snd_soc_component_read(component, AIU_CLK_CTRL_MORE);
+
+	ctrl = snd_soc_component_read(component, AIU_HDMI_CLK_DATA_CTRL);
+	clk_sel = FIELD_GET(AIU_HDMI_CLK_DATA_CTRL_CLK_SEL, ctrl);
+	data_sel = FIELD_GET(AIU_HDMI_CLK_DATA_CTRL_DATA_SEL, ctrl);
+
+	if (clk_sel == AIU_HDMI_CLK_DATA_CTRL_CLK_SEL_PCM &&
+	    data_sel == AIU_HDMI_CLK_DATA_CTRL_DATA_SEL_PCM_DATA)
+		mux = AIU_HDMI_CTRL_MUX_PCM;
+	else if (clk_sel == AIU_HDMI_CLK_DATA_CTRL_CLK_SEL_AIU &&
+		 data_sel == AIU_HDMI_CLK_DATA_CTRL_DATA_SEL_I2S_DATA &&
+		 !!(more & AIU_CLK_CTRL_MORE_AMCLK))
+		mux = AIU_HDMI_CTRL_MUX_I2S;
+	else if (clk_sel == AIU_HDMI_CLK_DATA_CTRL_CLK_SEL_AIU &&
+		 !(more & AIU_CLK_CTRL_MORE_AMCLK))
+		mux = AIU_HDMI_CTRL_MUX_SPDIF;
+	else
+		mux = AIU_HDMI_CTRL_MUX_DISABLED;
+
+	ucontrol->value.enumerated.item[0] = mux;
+	return 0;
+}
+
 static int aiu_codec_ctrl_mux_put_enum(struct snd_kcontrol *kcontrol,
 				       struct snd_ctl_elem_value *ucontrol)
 {
@@ -28,45 +73,68 @@
 	struct snd_soc_dapm_context *dapm =
 		snd_soc_dapm_kcontrol_dapm(kcontrol);
 	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
-	unsigned int mux, changed;
+	unsigned int mux, ctrl, more;
 
 	mux = snd_soc_enum_item_to_val(e, ucontrol->value.enumerated.item[0]);
-	changed = snd_soc_component_test_bits(component, e->reg,
-					      CTRL_DATA_SEL,
-					      FIELD_PREP(CTRL_DATA_SEL, mux));
 
-	if (!changed)
-		return 0;
+	switch (mux) {
+	case AIU_HDMI_CTRL_MUX_PCM:
+		ctrl = FIELD_PREP(AIU_HDMI_CLK_DATA_CTRL_CLK_SEL,
+				  AIU_HDMI_CLK_DATA_CTRL_CLK_SEL_PCM);
+		ctrl |= FIELD_PREP(AIU_HDMI_CLK_DATA_CTRL_DATA_SEL,
+				   AIU_HDMI_CLK_DATA_CTRL_DATA_SEL_PCM_DATA);
+		more = 0;
+		break;
+
+	case AIU_HDMI_CTRL_MUX_I2S:
+		ctrl = FIELD_PREP(AIU_HDMI_CLK_DATA_CTRL_CLK_SEL,
+				  AIU_HDMI_CLK_DATA_CTRL_CLK_SEL_AIU);
+		ctrl |= FIELD_PREP(AIU_HDMI_CLK_DATA_CTRL_DATA_SEL,
+				   AIU_HDMI_CLK_DATA_CTRL_DATA_SEL_I2S_DATA);
+		more = AIU_CLK_CTRL_MORE_AMCLK;
+		break;
+
+	case AIU_HDMI_CTRL_MUX_SPDIF:
+		ctrl = FIELD_PREP(AIU_HDMI_CLK_DATA_CTRL_CLK_SEL,
+				  AIU_HDMI_CLK_DATA_CTRL_CLK_SEL_AIU);
+		ctrl |= FIELD_PREP(AIU_HDMI_CLK_DATA_CTRL_DATA_SEL,
+				   AIU_HDMI_CLK_DATA_CTRL_DATA_SEL_OUTPUT_ZERO);
+		more = 0;
+		break;
+
+	case AIU_HDMI_CTRL_MUX_DISABLED:
+	default:
+		ctrl = FIELD_PREP(AIU_HDMI_CLK_DATA_CTRL_CLK_SEL,
+				  AIU_HDMI_CLK_DATA_CTRL_CLK_SEL_DISABLE);
+		ctrl |= FIELD_PREP(AIU_HDMI_CLK_DATA_CTRL_DATA_SEL,
+				   AIU_HDMI_CLK_DATA_CTRL_DATA_SEL_OUTPUT_ZERO);
+		more = 0;
+		break;
+	}
 
 	/* Force disconnect of the mux while updating */
 	snd_soc_dapm_mux_update_power(dapm, kcontrol, 0, NULL, NULL);
 
-	/* Reset the source first */
-	snd_soc_component_update_bits(component, e->reg,
-				      CTRL_CLK_SEL |
-				      CTRL_DATA_SEL,
-				      FIELD_PREP(CTRL_CLK_SEL, 0) |
-				      FIELD_PREP(CTRL_DATA_SEL, 0));
-
-	/* Set the appropriate source */
-	snd_soc_component_update_bits(component, e->reg,
-				      CTRL_CLK_SEL |
-				      CTRL_DATA_SEL,
-				      FIELD_PREP(CTRL_CLK_SEL, mux) |
-				      FIELD_PREP(CTRL_DATA_SEL, mux));
+	snd_soc_component_update_bits(component, AIU_HDMI_CLK_DATA_CTRL,
+				      AIU_HDMI_CLK_DATA_CTRL_CLK_SEL |
+				      AIU_HDMI_CLK_DATA_CTRL_DATA_SEL,
+				      ctrl);
+
+	snd_soc_component_update_bits(component, AIU_CLK_CTRL_MORE,
+				      AIU_CLK_CTRL_MORE_AMCLK,
+				      more);
 
 	snd_soc_dapm_mux_update_power(dapm, kcontrol, mux, e, NULL);
 
 	return 0;
 }
 
-static SOC_ENUM_SINGLE_DECL(aiu_hdmi_ctrl_mux_enum, AIU_HDMI_CLK_DATA_CTRL,
-			    CTRL_DATA_SEL_SHIFT,
-			    aiu_codec_ctrl_mux_texts);
+static SOC_ENUM_SINGLE_VIRT_DECL(aiu_hdmi_ctrl_mux_enum,
+				 aiu_codec_hdmi_ctrl_mux_texts);
 
 static const struct snd_kcontrol_new aiu_hdmi_ctrl_mux =
 	SOC_DAPM_ENUM_EXT("HDMI Source", aiu_hdmi_ctrl_mux_enum,
-			  snd_soc_dapm_get_enum_double,
+			  aiu_codec_ctrl_mux_get_enum,
 			  aiu_codec_ctrl_mux_put_enum);
 
 static const struct snd_soc_dapm_widget aiu_hdmi_ctrl_widgets[] = {
diff -Naur a/sound/soc/meson/aiu-encoder-i2s.c b/sound/soc/meson/aiu-encoder-i2s.c
--- a/sound/soc/meson/aiu-encoder-i2s.c	2021-10-31 16:53:10.000000000 -0400
+++ b/sound/soc/meson/aiu-encoder-i2s.c	2021-10-31 20:41:20.000000000 -0400
@@ -24,7 +24,6 @@
 #define AIU_CLK_CTRL_AOCLK_INVERT	BIT(6)
 #define AIU_CLK_CTRL_LRCLK_INVERT	BIT(7)
 #define AIU_CLK_CTRL_LRCLK_SKEW		GENMASK(9, 8)
-#define AIU_CLK_CTRL_MORE_HDMI_AMCLK	BIT(6)
 #define AIU_CLK_CTRL_MORE_I2S_DIV	GENMASK(5, 0)
 #define AIU_CODEC_DAC_LRCLK_CTRL_DIV	GENMASK(11, 0)
 
@@ -208,11 +207,6 @@
 	if (ret)
 		return ret;
 
-	/* Make sure amclk is used for HDMI i2s as well */
-	snd_soc_component_update_bits(component, AIU_CLK_CTRL_MORE,
-				      AIU_CLK_CTRL_MORE_HDMI_AMCLK,
-				      AIU_CLK_CTRL_MORE_HDMI_AMCLK);
-
 	return 0;
 }
 
