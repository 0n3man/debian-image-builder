From 79fd1038c3df96b3e72a7f5a1ad3a305be9fc148 Mon Sep 17 00:00:00 2001
From: Patrick Yavitz <pyavitz@xxxxx.com>
Date: Sun, 30 Jul 2023 19:33:24 -0400
Subject: [PATCH] meson64 general patch set

Signed-off-by: Patrick Yavitz <pyavitz@xxxxx.com>
---
 drivers/gpu/drm/meson/Makefile                |   2 +-
 drivers/gpu/drm/meson/meson_crtc.c            |  89 ++-
 drivers/gpu/drm/meson/meson_cursor.c          | 244 ++++++++
 drivers/gpu/drm/meson/meson_cursor.h          |  14 +
 drivers/gpu/drm/meson/meson_drv.c             |  20 +-
 drivers/gpu/drm/meson/meson_drv.h             |  17 +
 drivers/gpu/drm/meson/meson_plane.c           |   1 -
 drivers/gpu/drm/meson/meson_registers.h       |   5 -
 drivers/gpu/drm/meson/meson_vclk.c            |  18 +
 drivers/gpu/drm/meson/meson_venc.c            |   5 +-
 drivers/gpu/drm/meson/meson_viu.c             |   2 +
 drivers/gpu/drm/tiny/Kconfig                  |  13 +
 drivers/gpu/drm/tiny/Makefile                 |   1 +
 drivers/gpu/drm/tiny/ili9341.c                |   2 +
 drivers/gpu/drm/tiny/ili9488_pio.c            | 366 ++++++++++++
 drivers/hid/hid-ids.h                         |   6 +
 drivers/hid/hid-quirks.c                      |   4 +
 drivers/hwmon/pwm-fan.c                       |  67 ++-
 drivers/input/touchscreen/Kconfig             |  10 +
 drivers/input/touchscreen/Makefile            |   1 +
 drivers/input/touchscreen/dwav-usb-mt.c       | 554 ++++++++++++++++++
 drivers/media/platform/s5p-jpeg/jpeg-core.c   |  45 +-
 drivers/media/platform/s5p-mfc/s5p_mfc.c      |   9 +-
 drivers/media/platform/s5p-mfc/s5p_mfc_dec.c  |   8 +-
 drivers/media/platform/s5p-mfc/s5p_mfc_enc.c  |   9 +
 drivers/regulator/s2mps11.c                   |  80 +++
 drivers/spi/spidev.c                          |   2 +
 drivers/staging/fbtft/Kconfig                 |  14 +
 drivers/staging/fbtft/Makefile                |   2 +
 drivers/staging/fbtft/fb_hktft32.c            | 156 +++++
 drivers/thermal/thermal_helpers.c             |  28 +
 sound/soc/meson/Kconfig                       |   2 +
 sound/soc/meson/axg-frddr.c                   |   4 +-
 35 files changed, 1801 insertions(+), 55 deletions(-)
 create mode 100644 drivers/gpu/drm/meson/meson_cursor.c
 create mode 100644 drivers/gpu/drm/meson/meson_cursor.h
 create mode 100644 drivers/gpu/drm/tiny/ili9488_pio.c
 create mode 100644 drivers/input/touchscreen/dwav-usb-mt.c
 create mode 100644 drivers/staging/fbtft/fb_hktft32.c

diff --git a/drivers/gpu/drm/meson/Makefile b/drivers/gpu/drm/meson/Makefile
index 523fce45f16b..e339c45fa691 100644
--- a/drivers/gpu/drm/meson/Makefile
+++ b/drivers/gpu/drm/meson/Makefile
@@ -1,5 +1,5 @@
 # SPDX-License-Identifier: GPL-2.0-only
-meson-drm-y := meson_drv.o meson_plane.o meson_crtc.o meson_venc_cvbs.o
+meson-drm-y := meson_drv.o meson_plane.o meson_cursor.o meson_crtc.o meson_venc_cvbs.o
 meson-drm-y += meson_viu.o meson_vpp.o meson_venc.o meson_vclk.o meson_overlay.o
 meson-drm-y += meson_rdma.o meson_osd_afbcd.o
 meson-drm-y += meson_encoder_hdmi.o
diff --git a/drivers/gpu/drm/meson/meson_crtc.c b/drivers/gpu/drm/meson/meson_crtc.c
index d70616da8ce2..c1ba3b4fe7ce 100644
--- a/drivers/gpu/drm/meson/meson_crtc.c
+++ b/drivers/gpu/drm/meson/meson_crtc.c
@@ -36,6 +36,7 @@ struct meson_crtc {
 	struct drm_pending_vblank_event *event;
 	struct meson_drm *priv;
 	void (*enable_osd1)(struct meson_drm *priv);
+	void (*enable_osd2)(struct meson_drm *priv);
 	void (*enable_vd1)(struct meson_drm *priv);
 	void (*enable_osd1_afbc)(struct meson_drm *priv);
 	void (*disable_osd1_afbc)(struct meson_drm *priv);
@@ -110,6 +111,20 @@ static void meson_g12a_crtc_atomic_enable(struct drm_crtc *crtc,
 	writel_relaxed(0 << 16 |
 			(crtc_state->mode.vdisplay - 1),
 			priv->io_base + _REG(VPP_OSD1_BLD_V_SCOPE));
+	writel_relaxed(0 << 16 |
+			(crtc_state->mode.hdisplay - 1),
+			priv->io_base + _REG(VPP_OSD2_BLD_H_SCOPE));
+	writel_relaxed(0 << 16 |
+			(crtc_state->mode.vdisplay - 1),
+			priv->io_base + _REG(VPP_OSD2_BLD_V_SCOPE));
+	writel_relaxed(crtc_state->mode.hdisplay |
+			crtc_state->mode.vdisplay << 16,
+		       priv->io_base +
+		       _REG(VIU_OSD_BLEND_BLEND0_SIZE));
+	writel_relaxed(crtc_state->mode.hdisplay |
+			crtc_state->mode.vdisplay << 16,
+		       priv->io_base +
+		       _REG(VIU_OSD_BLEND_BLEND1_SIZE));
 	writel_relaxed(crtc_state->mode.hdisplay << 16 |
 			crtc_state->mode.vdisplay,
 			priv->io_base + _REG(VPP_OUT_H_V_SIZE));
@@ -158,6 +173,9 @@ static void meson_g12a_crtc_atomic_disable(struct drm_crtc *crtc,
 	priv->viu.osd1_enabled = false;
 	priv->viu.osd1_commit = false;
 
+	priv->viu.osd2_enabled = false;
+	priv->viu.osd2_commit = false;
+
 	priv->viu.vd1_enabled = false;
 	priv->viu.vd1_commit = false;
 
@@ -183,11 +201,14 @@ static void meson_crtc_atomic_disable(struct drm_crtc *crtc,
 	priv->viu.osd1_enabled = false;
 	priv->viu.osd1_commit = false;
 
+	priv->viu.osd2_enabled = false;
+	priv->viu.osd2_commit = false;
+
 	priv->viu.vd1_enabled = false;
 	priv->viu.vd1_commit = false;
 
 	/* Disable VPP Postblend */
-	writel_bits_relaxed(VPP_OSD1_POSTBLEND | VPP_VD1_POSTBLEND |
+	writel_bits_relaxed(VPP_OSD1_POSTBLEND | VPP_OSD2_POSTBLEND | VPP_VD1_POSTBLEND |
 			    VPP_VD1_PREBLEND | VPP_POSTBLEND_ENABLE, 0,
 			    priv->io_base + _REG(VPP_MISC));
 
@@ -223,6 +244,7 @@ static void meson_crtc_atomic_flush(struct drm_crtc *crtc,
 	struct meson_drm *priv = meson_crtc->priv;
 
 	priv->viu.osd1_commit = true;
+	priv->viu.osd2_commit = true;
 	priv->viu.vd1_commit = true;
 }
 
@@ -246,6 +268,12 @@ static void meson_crtc_enable_osd1(struct meson_drm *priv)
 			    priv->io_base + _REG(VPP_MISC));
 }
 
+static void meson_crtc_enable_osd2(struct meson_drm *priv)
+{
+	writel_bits_relaxed(VPP_OSD2_POSTBLEND, VPP_OSD2_POSTBLEND,
+			    priv->io_base + _REG(VPP_MISC));
+}
+
 static void meson_crtc_g12a_enable_osd1_afbc(struct meson_drm *priv)
 {
 	writel_relaxed(priv->viu.osd1_blk2_cfg4,
@@ -274,14 +302,20 @@ static void meson_g12a_crtc_enable_osd1(struct meson_drm *priv)
 	writel_relaxed(priv->viu.osd_blend_din0_scope_v,
 		       priv->io_base +
 		       _REG(VIU_OSD_BLEND_DIN0_SCOPE_V));
-	writel_relaxed(priv->viu.osb_blend0_size,
+	writel_bits_relaxed(OSD_BLEND_POSTBLD_SRC_OSD1, OSD_BLEND_POSTBLD_SRC_OSD1,
+			    priv->io_base + _REG(OSD1_BLEND_SRC_CTRL));
+}
+
+static void meson_g12a_crtc_enable_osd2(struct meson_drm *priv)
+{
+	writel_relaxed(priv->viu.osd_blend_din3_scope_h,
 		       priv->io_base +
-		       _REG(VIU_OSD_BLEND_BLEND0_SIZE));
-	writel_relaxed(priv->viu.osb_blend1_size,
+		       _REG(VIU_OSD_BLEND_DIN1_SCOPE_H));
+	writel_relaxed(priv->viu.osd_blend_din3_scope_v,
 		       priv->io_base +
-		       _REG(VIU_OSD_BLEND_BLEND1_SIZE));
-	writel_bits_relaxed(3 << 8, 3 << 8,
-			    priv->io_base + _REG(OSD1_BLEND_SRC_CTRL));
+		       _REG(VIU_OSD_BLEND_DIN1_SCOPE_V));
+	writel_bits_relaxed(OSD_BLEND_POSTBLD_SRC_OSD2, OSD_BLEND_POSTBLD_SRC_OSD2,
+			    priv->io_base + _REG(OSD2_BLEND_SRC_CTRL));
 }
 
 static void meson_crtc_enable_vd1(struct meson_drm *priv)
@@ -388,6 +422,43 @@ void meson_crtc_irq(struct meson_drm *priv)
 		priv->viu.osd1_commit = false;
 	}
 
+	if (priv->viu.osd2_enabled && priv->viu.osd2_commit) {
+		writel_relaxed(priv->viu.osd2_ctrl_stat,
+				priv->io_base + _REG(VIU_OSD2_CTRL_STAT));
+		writel_relaxed(priv->viu.osd2_ctrl_stat2,
+				priv->io_base + _REG(VIU_OSD2_CTRL_STAT2));
+		writel_relaxed(priv->viu.osd2_blk0_cfg[0],
+				priv->io_base + _REG(VIU_OSD2_BLK0_CFG_W0));
+		writel_relaxed(priv->viu.osd2_blk0_cfg[1],
+				priv->io_base + _REG(VIU_OSD2_BLK0_CFG_W1));
+		writel_relaxed(priv->viu.osd2_blk0_cfg[2],
+				priv->io_base + _REG(VIU_OSD2_BLK0_CFG_W2));
+		writel_relaxed(priv->viu.osd2_blk0_cfg[3],
+				priv->io_base + _REG(VIU_OSD2_BLK0_CFG_W3));
+		writel_relaxed(priv->viu.osd2_blk0_cfg[4],
+				priv->io_base + _REG(VIU_OSD2_BLK0_CFG_W4));
+
+		/* vsync forced to update INTERLACE_SEL_ODD in interlace mode */
+		meson_crtc->vsync_forced = priv->viu.osd2_interlace;
+
+		meson_canvas_config(priv->canvas, priv->canvas_id_osd2,
+				priv->viu.osd2_addr,
+				priv->viu.osd2_stride,
+				priv->viu.osd2_height,
+				MESON_CANVAS_WRAP_NONE,
+				MESON_CANVAS_BLKMODE_LINEAR, 0);
+
+		/* Enable OSD2 */
+		if (meson_crtc->enable_osd2)
+			meson_crtc->enable_osd2(priv);
+
+		priv->viu.osd2_commit = false;
+	} else if (priv->viu.osd2_enabled && priv->viu.osd2_interlace) {
+		u32 reg = readl_relaxed(priv->io_base + _REG(VIU_OSD2_BLK0_CFG_W0)) & ~BIT(0);
+		writel_relaxed(reg | meson_venci_get_field(priv) ? 1 : 0,
+				priv->io_base + _REG(VIU_OSD2_BLK0_CFG_W0));
+	}
+
 	/* Update the VD1 registers */
 	if (priv->viu.vd1_enabled && priv->viu.vd1_commit) {
 
@@ -685,7 +756,7 @@ int meson_crtc_create(struct meson_drm *priv)
 	meson_crtc->priv = priv;
 	crtc = &meson_crtc->base;
 	ret = drm_crtc_init_with_planes(priv->drm, crtc,
-					priv->primary_plane, NULL,
+					priv->primary_plane, priv->cursor_plane,
 					&meson_crtc_funcs, "meson_crtc");
 	if (ret) {
 		dev_err(priv->drm->dev, "Failed to init CRTC\n");
@@ -694,6 +765,7 @@ int meson_crtc_create(struct meson_drm *priv)
 
 	if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A)) {
 		meson_crtc->enable_osd1 = meson_g12a_crtc_enable_osd1;
+		meson_crtc->enable_osd2 = meson_g12a_crtc_enable_osd2;
 		meson_crtc->enable_vd1 = meson_g12a_crtc_enable_vd1;
 		meson_crtc->viu_offset = MESON_G12A_VIU_OFFSET;
 		meson_crtc->enable_osd1_afbc =
@@ -703,6 +775,7 @@ int meson_crtc_create(struct meson_drm *priv)
 		drm_crtc_helper_add(crtc, &meson_g12a_crtc_helper_funcs);
 	} else {
 		meson_crtc->enable_osd1 = meson_crtc_enable_osd1;
+		meson_crtc->enable_osd2 = meson_crtc_enable_osd2;
 		meson_crtc->enable_vd1 = meson_crtc_enable_vd1;
 		if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXM)) {
 			meson_crtc->enable_osd1_afbc =
diff --git a/drivers/gpu/drm/meson/meson_cursor.c b/drivers/gpu/drm/meson/meson_cursor.c
new file mode 100644
index 000000000000..6ba733c511e7
--- /dev/null
+++ b/drivers/gpu/drm/meson/meson_cursor.c
@@ -0,0 +1,244 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2021 BayLibre, SAS
+ * Author: Neil Armstrong <narmstrong@baylibre.com>
+ */
+
+#include <linux/bitfield.h>
+
+#include <drm/drm_atomic.h>
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_device.h>
+#include <drm/drm_fb_cma_helper.h>
+#include <drm/drm_fourcc.h>
+#include <drm/drm_gem_atomic_helper.h>
+#include <drm/drm_gem_cma_helper.h>
+#include <drm/drm_plane_helper.h>
+
+#include "meson_cursor.h"
+#include "meson_registers.h"
+#include "meson_viu.h"
+
+struct meson_cursor {
+	struct drm_plane base;
+	struct meson_drm *priv;
+};
+#define to_meson_cursor(x) container_of(x, struct meson_cursor, base)
+
+static int meson_cursor_atomic_check(struct drm_plane *plane,
+				    struct drm_atomic_state *state)
+{
+	struct drm_plane_state *new_plane_state = drm_atomic_get_new_plane_state(state,
+										 plane);
+	struct drm_crtc_state *crtc_state;
+
+	if (!new_plane_state->crtc)
+		return 0;
+
+	crtc_state = drm_atomic_get_crtc_state(state,
+					       new_plane_state->crtc);
+	if (IS_ERR(crtc_state))
+		return PTR_ERR(crtc_state);
+
+	return drm_atomic_helper_check_plane_state(new_plane_state,
+						   crtc_state,
+						   DRM_PLANE_HELPER_NO_SCALING,
+						   DRM_PLANE_HELPER_NO_SCALING,
+						   true, true);
+}
+
+/* Takes a fixed 16.16 number and converts it to integer. */
+static inline int64_t fixed16_to_int(int64_t value)
+{
+	return value >> 16;
+}
+
+static void meson_cursor_atomic_update(struct drm_plane *plane,
+				      struct drm_atomic_state *state)
+{
+	struct meson_cursor *meson_cursor = to_meson_cursor(plane);
+	struct drm_plane_state *new_state = drm_atomic_get_new_plane_state(state,
+									   plane);
+	struct drm_rect dest = drm_plane_state_dest(new_state);
+	struct meson_drm *priv = meson_cursor->priv;
+	struct drm_framebuffer *fb = new_state->fb;
+	struct drm_gem_cma_object *gem;
+	unsigned long flags;
+	int dst_w, dst_h;
+
+	/*
+	 * Update Coordinates
+	 * Update Formats
+	 * Update Buffer
+	 * Enable Plane
+	 */
+	spin_lock_irqsave(&priv->drm->event_lock, flags);
+
+	/* Enable OSD and BLK0, set max global alpha */
+	priv->viu.osd2_ctrl_stat = OSD_ENABLE |
+				   (0xFF << OSD_GLOBAL_ALPHA_SHIFT) |
+				   OSD_BLK0_ENABLE;
+
+	priv->viu.osd2_ctrl_stat2 = readl(priv->io_base +
+					  _REG(VIU_OSD2_CTRL_STAT2));
+
+	/* Set up BLK0 to point to the right canvas */
+	priv->viu.osd2_blk0_cfg[0] = priv->canvas_id_osd2 << OSD_CANVAS_SEL;
+	priv->viu.osd2_blk0_cfg[0] |= OSD_ENDIANNESS_LE;
+
+	/* On GXBB, Use the old non-HDR RGB2YUV converter */
+	if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXBB))
+		priv->viu.osd2_blk0_cfg[0] |= OSD_OUTPUT_COLOR_RGB;
+
+	switch (fb->format->format) {
+	case DRM_FORMAT_XRGB8888:
+	case DRM_FORMAT_ARGB8888:
+		priv->viu.osd2_blk0_cfg[0] |= OSD_BLK_MODE_32 |
+			OSD_COLOR_MATRIX_32_ARGB;
+		break;
+	case DRM_FORMAT_XBGR8888:
+	case DRM_FORMAT_ABGR8888:
+		priv->viu.osd2_blk0_cfg[0] |= OSD_BLK_MODE_32 |
+			OSD_COLOR_MATRIX_32_ABGR;
+		break;
+	case DRM_FORMAT_RGB888:
+		priv->viu.osd2_blk0_cfg[0] |= OSD_BLK_MODE_24 |
+			OSD_COLOR_MATRIX_24_RGB;
+		break;
+	case DRM_FORMAT_RGB565:
+		priv->viu.osd2_blk0_cfg[0] |= OSD_BLK_MODE_16 |
+			OSD_COLOR_MATRIX_16_RGB565;
+		break;
+	}
+
+	switch (fb->format->format) {
+	case DRM_FORMAT_XRGB8888:
+	case DRM_FORMAT_XBGR8888:
+		/* For XRGB, replace the pixel's alpha by 0xFF */
+		priv->viu.osd2_ctrl_stat2 |= OSD_REPLACE_EN;
+		break;
+	case DRM_FORMAT_ARGB8888:
+	case DRM_FORMAT_ABGR8888:
+		/* For ARGB, use the pixel's alpha */
+		priv->viu.osd2_ctrl_stat2 &= ~OSD_REPLACE_EN;
+		break;
+	}
+
+	dst_w = new_state->crtc_w;
+	dst_h = new_state->crtc_h;
+
+	if (new_state->crtc->mode.flags & DRM_MODE_FLAG_INTERLACE)
+		priv->viu.osd2_interlace = true;
+	else
+		priv->viu.osd2_interlace = false;
+
+	/*
+	 * The format of these registers is (x2 << 16 | x1),
+	 * where x2 is exclusive.
+	 * e.g. +30x1920 would be (1919 << 16) | 30
+	 */
+	priv->viu.osd2_blk0_cfg[1] =
+				((fixed16_to_int(new_state->src.x2) - 1) << 16) |
+				fixed16_to_int(new_state->src.x1);
+	priv->viu.osd2_blk0_cfg[2] =
+				((fixed16_to_int(new_state->src.y2) - 1) << 16) |
+				fixed16_to_int(new_state->src.y1);
+	priv->viu.osd2_blk0_cfg[3] = ((dest.x2 - 1) << 16) | dest.x1;
+	priv->viu.osd2_blk0_cfg[4] = ((dest.y2 - 1) << 16) | dest.y1;
+
+	if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A)) {
+		priv->viu.osd_blend_din3_scope_h = ((dest.x2 - 1) << 16) | dest.x1;
+		priv->viu.osd_blend_din3_scope_v = ((dest.y2 - 1) << 16) | dest.y1;
+		priv->viu.osb_blend1_size = dst_h << 16 | dst_w;
+	}
+
+	/* Update Canvas with buffer address */
+	gem = drm_fb_cma_get_gem_obj(fb, 0);
+
+	priv->viu.osd2_addr = gem->paddr;
+	priv->viu.osd2_stride = fb->pitches[0];
+	priv->viu.osd2_height = fb->height;
+	priv->viu.osd2_width = fb->width;
+
+	/* TOFIX: Reset OSD2 before enabling it on GXL+ SoCs ? */
+
+	priv->viu.osd2_enabled = true;
+
+	spin_unlock_irqrestore(&priv->drm->event_lock, flags);
+}
+
+static void meson_cursor_atomic_disable(struct drm_plane *plane,
+				       struct drm_atomic_state *state)
+{
+	struct meson_cursor *meson_cursor = to_meson_cursor(plane);
+	struct meson_drm *priv = meson_cursor->priv;
+
+	/* Disable OSD2 */
+	if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A))
+		writel_bits_relaxed(OSD_BLEND_POSTBLD_SRC_OSD2, 0,
+				    priv->io_base + _REG(OSD2_BLEND_SRC_CTRL));
+	else
+		writel_bits_relaxed(VPP_OSD2_POSTBLEND, 0,
+				    priv->io_base + _REG(VPP_MISC));
+
+	priv->viu.osd2_enabled = false;
+}
+
+static const struct drm_plane_helper_funcs meson_cursor_helper_funcs = {
+	.atomic_check	= meson_cursor_atomic_check,
+	.atomic_disable	= meson_cursor_atomic_disable,
+	.atomic_update	= meson_cursor_atomic_update,
+};
+
+static const struct drm_plane_funcs meson_cursor_funcs = {
+	.update_plane		= drm_atomic_helper_update_plane,
+	.disable_plane		= drm_atomic_helper_disable_plane,
+	.destroy		= drm_plane_cleanup,
+	.reset			= drm_atomic_helper_plane_reset,
+	.atomic_duplicate_state = drm_atomic_helper_plane_duplicate_state,
+	.atomic_destroy_state	= drm_atomic_helper_plane_destroy_state,
+};
+
+static const uint32_t supported_drm_formats[] = {
+	DRM_FORMAT_ARGB8888,
+	DRM_FORMAT_ABGR8888,
+	DRM_FORMAT_XRGB8888,
+	DRM_FORMAT_XBGR8888,
+	DRM_FORMAT_RGB888,
+	DRM_FORMAT_RGB565,
+};
+
+static const uint64_t format_modifiers_default[] = {
+	DRM_FORMAT_MOD_LINEAR,
+	DRM_FORMAT_MOD_INVALID,
+};
+
+int meson_cursor_create(struct meson_drm *priv)
+{
+	struct meson_cursor *meson_cursor;
+	struct drm_plane *cursor;
+
+	meson_cursor = devm_kzalloc(priv->drm->dev, sizeof(*meson_cursor),
+				   GFP_KERNEL);
+	if (!meson_cursor)
+		return -ENOMEM;
+
+	meson_cursor->priv = priv;
+	cursor = &meson_cursor->base;
+
+	drm_universal_plane_init(priv->drm, cursor, 0xFF,
+				 &meson_cursor_funcs,
+				 supported_drm_formats,
+				 ARRAY_SIZE(supported_drm_formats),
+				 format_modifiers_default,
+				 DRM_PLANE_TYPE_CURSOR, "meson_cursor_plane");
+
+	drm_plane_helper_add(cursor, &meson_cursor_helper_funcs);
+
+	/* For now, OSD Cursor is always on top of the primary plane */
+	drm_plane_create_zpos_immutable_property(cursor, 2);
+
+	priv->cursor_plane = cursor;
+
+	return 0;
+}
diff --git a/drivers/gpu/drm/meson/meson_cursor.h b/drivers/gpu/drm/meson/meson_cursor.h
new file mode 100644
index 000000000000..28b5de49a646
--- /dev/null
+++ b/drivers/gpu/drm/meson/meson_cursor.h
@@ -0,0 +1,14 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (C) 2021 BayLibre, SAS
+ * Author: Neil Armstrong <narmstrong@baylibre.com>
+ */
+
+#ifndef __MESON_CURSOR_H
+#define __MESON_CURSOR_H
+
+#include "meson_drv.h"
+
+int meson_cursor_create(struct meson_drm *priv);
+
+#endif /* __MESON_CURSOR_H */
diff --git a/drivers/gpu/drm/meson/meson_drv.c b/drivers/gpu/drm/meson/meson_drv.c
index 207b309a21c0..f59d6fe2dcf7 100644
--- a/drivers/gpu/drm/meson/meson_drv.c
+++ b/drivers/gpu/drm/meson/meson_drv.c
@@ -29,6 +29,7 @@
 #include "meson_drv.h"
 #include "meson_overlay.h"
 #include "meson_plane.h"
+#include "meson_cursor.h"
 #include "meson_osd_afbcd.h"
 #include "meson_registers.h"
 #include "meson_venc_cvbs.h"
@@ -245,6 +246,9 @@ static int meson_drv_bind_master(struct device *dev, bool has_components)
 	}
 
 	ret = meson_canvas_alloc(priv->canvas, &priv->canvas_id_osd1);
+	if (ret)
+		goto free_drm;
+	ret = meson_canvas_alloc(priv->canvas, &priv->canvas_id_osd2);
 	if (ret)
 		goto free_drm;
 	ret = meson_canvas_alloc(priv->canvas, &priv->canvas_id_vd1_0);
@@ -326,6 +330,10 @@ static int meson_drv_bind_master(struct device *dev, bool has_components)
 	if (ret)
 		goto unbind_all;
 
+	ret = meson_cursor_create(priv);
+	if (ret)
+		goto free_drm;
+
 	ret = meson_plane_create(priv);
 	if (ret)
 		goto unbind_all;
@@ -478,17 +486,6 @@ static int meson_probe_remote(struct platform_device *pdev,
 	return count;
 }
 
-static void meson_drv_shutdown(struct platform_device *pdev)
-{
-	struct meson_drm *priv = dev_get_drvdata(&pdev->dev);
-
-	if (!priv)
-		return;
-
-	drm_kms_helper_poll_fini(priv->drm);
-	drm_atomic_helper_shutdown(priv->drm);
-}
-
 static int meson_drv_probe(struct platform_device *pdev)
 {
 	struct component_match *match = NULL;
@@ -568,7 +565,6 @@ static const struct dev_pm_ops meson_drv_pm_ops = {
 static struct platform_driver meson_drm_platform_driver = {
 	.probe      = meson_drv_probe,
 	.remove     = meson_drv_remove,
-	.shutdown   = meson_drv_shutdown,
 	.driver     = {
 		.name	= "meson-drm",
 		.of_match_table = dt_match,
diff --git a/drivers/gpu/drm/meson/meson_drv.h b/drivers/gpu/drm/meson/meson_drv.h
index 177dac3ca3be..ebe8b050c704 100644
--- a/drivers/gpu/drm/meson/meson_drv.h
+++ b/drivers/gpu/drm/meson/meson_drv.h
@@ -43,12 +43,14 @@ struct meson_drm {
 
 	struct meson_canvas *canvas;
 	u8 canvas_id_osd1;
+	u8 canvas_id_osd2;
 	u8 canvas_id_vd1_0;
 	u8 canvas_id_vd1_1;
 	u8 canvas_id_vd1_2;
 
 	struct drm_device *drm;
 	struct drm_crtc *crtc;
+	struct drm_plane *cursor_plane;
 	struct drm_plane *primary_plane;
 	struct drm_plane *overlay_plane;
 
@@ -82,6 +84,21 @@ struct meson_drm {
 		uint32_t osd_blend_din0_scope_h;
 		uint32_t osd_blend_din0_scope_v;
 		uint32_t osb_blend0_size;
+
+		bool osd2_enabled;
+		bool osd2_interlace;
+		bool osd2_commit;
+		uint32_t osd2_ctrl_stat;
+		uint32_t osd2_ctrl_stat2;
+		uint32_t osd2_blk0_cfg[5];
+		uint32_t osd2_blk1_cfg4;
+		uint32_t osd2_blk2_cfg4;
+		uint32_t osd2_addr;
+		uint32_t osd2_stride;
+		uint32_t osd2_height;
+		uint32_t osd2_width;
+		uint32_t osd_blend_din3_scope_h;
+		uint32_t osd_blend_din3_scope_v;
 		uint32_t osb_blend1_size;
 
 		bool vd1_enabled;
diff --git a/drivers/gpu/drm/meson/meson_plane.c b/drivers/gpu/drm/meson/meson_plane.c
index 44aa52629443..3c397bd14fe5 100644
--- a/drivers/gpu/drm/meson/meson_plane.c
+++ b/drivers/gpu/drm/meson/meson_plane.c
@@ -360,7 +360,6 @@ static void meson_plane_atomic_update(struct drm_plane *plane,
 		priv->viu.osd_blend_din0_scope_h = ((dest.x2 - 1) << 16) | dest.x1;
 		priv->viu.osd_blend_din0_scope_v = ((dest.y2 - 1) << 16) | dest.y1;
 		priv->viu.osb_blend0_size = dst_h << 16 | dst_w;
-		priv->viu.osb_blend1_size = dst_h << 16 | dst_w;
 	}
 
 	/* Update Canvas with buffer address */
diff --git a/drivers/gpu/drm/meson/meson_registers.h b/drivers/gpu/drm/meson/meson_registers.h
index 0f3cafab8860..446e7961da48 100644
--- a/drivers/gpu/drm/meson/meson_registers.h
+++ b/drivers/gpu/drm/meson/meson_registers.h
@@ -634,11 +634,6 @@
 #define VPP_WRAP_OSD3_MATRIX_PRE_OFFSET2 0x3dbc
 #define VPP_WRAP_OSD3_MATRIX_EN_CTRL 0x3dbd
 
-/* osd1 HDR */
-#define OSD1_HDR2_CTRL 0x38a0
-#define OSD1_HDR2_CTRL_VDIN0_HDR2_TOP_EN       BIT(13)
-#define OSD1_HDR2_CTRL_REG_ONLY_MAT            BIT(16)
-
 /* osd2 scaler */
 #define OSD2_VSC_PHASE_STEP 0x3d00
 #define OSD2_VSC_INI_PHASE 0x3d01
diff --git a/drivers/gpu/drm/meson/meson_vclk.c b/drivers/gpu/drm/meson/meson_vclk.c
index 2a82119eb58e..eb4c251d79b7 100644
--- a/drivers/gpu/drm/meson/meson_vclk.c
+++ b/drivers/gpu/drm/meson/meson_vclk.c
@@ -357,6 +357,8 @@ enum {
 	MESON_VCLK_HDMI_594000,
 /* 2970 /1 /1 /1 /5 /1  => /1 /2 */
 	MESON_VCLK_HDMI_594000_YUV420,
+/* 4830 /2 /1 /2 /5 /1  => /1 /1 */
+	MESON_VCLK_HDMI_241500,
 };
 
 struct meson_vclk_params {
@@ -467,6 +469,18 @@ struct meson_vclk_params {
 		.vid_pll_div = VID_PLL_DIV_5,
 		.vclk_div = 1,
 	},
+	[MESON_VCLK_HDMI_241500] = {
+		.pll_freq = 4830000,
+		.phy_freq = 2415000,
+		.venc_freq = 241500,
+		.vclk_freq = 241500,
+		.pixel_freq = 241500,
+		.pll_od1 = 2,
+		.pll_od2 = 1,
+		.pll_od3 = 2,
+		.vid_pll_div = VID_PLL_DIV_5,
+		.vclk_div = 1,
+	},
 	{ /* sentinel */ },
 };
 
@@ -873,6 +887,10 @@ static void meson_vclk_set(struct meson_drm *priv, unsigned int pll_base_freq,
 			m = 0xf7;
 			frac = vic_alternate_clock ? 0x8148 : 0x10000;
 			break;
+		case 4830000:
+			m = 0xc9;
+			frac = 0xd560;
+			break;
 		}
 
 		meson_hdmi_pll_set_params(priv, m, frac, od1, od2, od3);
diff --git a/drivers/gpu/drm/meson/meson_venc.c b/drivers/gpu/drm/meson/meson_venc.c
index 3c55ed003359..559ab3b5e212 100644
--- a/drivers/gpu/drm/meson/meson_venc.c
+++ b/drivers/gpu/drm/meson/meson_venc.c
@@ -866,10 +866,11 @@ meson_venc_hdmi_supported_mode(const struct drm_display_mode *mode)
 			    DRM_MODE_FLAG_PVSYNC | DRM_MODE_FLAG_NVSYNC))
 		return MODE_BAD;
 
-	if (mode->hdisplay < 640 || mode->hdisplay > 1920)
+	/* support higher resolution than 1920x1080 */
+	if (mode->hdisplay < 640 || mode->hdisplay > 2560)
 		return MODE_BAD_HVALUE;
 
-	if (mode->vdisplay < 480 || mode->vdisplay > 1200)
+	if (mode->vdisplay < 480 || mode->vdisplay > 1600)
 		return MODE_BAD_VVALUE;
 
 	return MODE_OK;
diff --git a/drivers/gpu/drm/meson/meson_viu.c b/drivers/gpu/drm/meson/meson_viu.c
index cd399b0b7181..4b155367c115 100644
--- a/drivers/gpu/drm/meson/meson_viu.c
+++ b/drivers/gpu/drm/meson/meson_viu.c
@@ -425,6 +425,7 @@ void meson_viu_init(struct meson_drm *priv)
 	if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXM) ||
 	    meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXL))
 		meson_viu_load_matrix(priv);
+#if 0
 	else if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A)) {
 		meson_viu_set_g12a_osd1_matrix(priv, RGB709_to_YUV709l_coeff,
 					       true);
@@ -433,6 +434,7 @@ void meson_viu_init(struct meson_drm *priv)
 				OSD1_HDR2_CTRL_VDIN0_HDR2_TOP_EN, 0,
 				priv->io_base + _REG(OSD1_HDR2_CTRL));
 	}
+#endif
 
 	/* Initialize OSD1 fifo control register */
 	reg = VIU_OSD_DDR_PRIORITY_URGENT |
diff --git a/drivers/gpu/drm/tiny/Kconfig b/drivers/gpu/drm/tiny/Kconfig
index d31be274a2bd..19638f4b0a71 100644
--- a/drivers/gpu/drm/tiny/Kconfig
+++ b/drivers/gpu/drm/tiny/Kconfig
@@ -119,6 +119,19 @@ config TINYDRM_ILI9486
 
 	  If M is selected the module will be called ili9486.
 
+config TINYDRM_ILI9488_PIO
+	tristate "DRM support for ILI9488 display panels (8bit PIO)"
+	depends on DRM
+	select DRM_KMS_HELPER
+	select DRM_KMS_CMA_HELPER
+	select DRM_MIPI_DBI
+	select BACKLIGHT_CLASS_DEVICE
+	help
+	  DRM driver for th following Ilitek ILI9488 panels:
+          * Hardkernel 3.5" 480x320 TFT (HKTFT 3.5")
+
+	  If M is selected the module will be called hktft35.
+
 config TINYDRM_MI0283QT
 	tristate "DRM support for MI0283QT"
 	depends on DRM && SPI
diff --git a/drivers/gpu/drm/tiny/Makefile b/drivers/gpu/drm/tiny/Makefile
index e09942895c77..bc1512bd0eb5 100644
--- a/drivers/gpu/drm/tiny/Makefile
+++ b/drivers/gpu/drm/tiny/Makefile
@@ -9,6 +9,7 @@ obj-$(CONFIG_TINYDRM_HX8357D)		+= hx8357d.o
 obj-$(CONFIG_TINYDRM_ILI9225)		+= ili9225.o
 obj-$(CONFIG_TINYDRM_ILI9341)		+= ili9341.o
 obj-$(CONFIG_TINYDRM_ILI9486)		+= ili9486.o
+obj-$(CONFIG_TINYDRM_ILI9488_PIO)	+= ili9488_pio.o
 obj-$(CONFIG_TINYDRM_MI0283QT)		+= mi0283qt.o
 obj-$(CONFIG_TINYDRM_REPAPER)		+= repaper.o
 obj-$(CONFIG_TINYDRM_ST7586)		+= st7586.o
diff --git a/drivers/gpu/drm/tiny/ili9341.c b/drivers/gpu/drm/tiny/ili9341.c
index 37e0c33399c8..96f0d67b1702 100644
--- a/drivers/gpu/drm/tiny/ili9341.c
+++ b/drivers/gpu/drm/tiny/ili9341.c
@@ -162,12 +162,14 @@ static const struct drm_driver ili9341_driver = {
 
 static const struct of_device_id ili9341_of_match[] = {
 	{ .compatible = "adafruit,yx240qv29" },
+	{ .compatible = "hardkernel,hktft32" },
 	{ }
 };
 MODULE_DEVICE_TABLE(of, ili9341_of_match);
 
 static const struct spi_device_id ili9341_id[] = {
 	{ "yx240qv29", 0 },
+	{ "hktft32", 0 },
 	{ }
 };
 MODULE_DEVICE_TABLE(spi, ili9341_id);
diff --git a/drivers/gpu/drm/tiny/ili9488_pio.c b/drivers/gpu/drm/tiny/ili9488_pio.c
new file mode 100644
index 000000000000..f3a0b1fb885a
--- /dev/null
+++ b/drivers/gpu/drm/tiny/ili9488_pio.c
@@ -0,0 +1,366 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * DRM driver for Hardkernel 3.5 ISP TFT display
+ *
+ * Copyright 2021 Dongjin Kim <tobetter@gmail.com>
+ *
+ */
+
+#include <linux/delay.h>
+#include <linux/dma-buf.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/property.h>
+#include <linux/of_gpio.h>
+#include <linux/of_address.h>
+#include <linux/io.h>
+#include <video/mipi_display.h>
+
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_damage_helper.h>
+#include <drm/drm_drv.h>
+#include <drm/drm_fb_cma_helper.h>
+#include <drm/drm_fb_helper.h>
+#include <drm/drm_fourcc.h>
+#include <drm/drm_gem_atomic_helper.h>
+#include <drm/drm_gem_cma_helper.h>
+#include <drm/drm_gem_framebuffer_helper.h>
+#include <drm/drm_managed.h>
+#include <drm/drm_mipi_dbi.h>
+#include <drm/drm_rect.h>
+
+#define ILI9488_COLUMN_ADDR	0x2a
+#define ILI9488_PAGE_ADDR	0x2b
+#define ILI9488_MEMORY_WRITE	0x2c
+#define ILI9488_ITFCTR1         0xb0
+#define ILI9488_FRMCTR1		0xb1
+#define ILI9488_PWCTRL1         0xc2
+#define ILI9488_VMCTRL1         0xc5
+#define ILI9488_PGAMCTRL        0xe0
+#define ILI9488_NGAMCTRL        0xe1
+#define ILI9488_MADCTL_BGR      BIT(3)
+#define ILI9488_MADCTL_MV       BIT(5)
+#define ILI9488_MADCTL_MX       BIT(6)
+#define ILI9488_MADCTL_MY       BIT(7)
+
+struct ili9488_data {
+	struct mipi_dbi_dev *dbidev;
+	struct gpio_desc *wr;
+	struct gpio_desc *cs;
+	struct gpio_desc *db[8];
+	void __iomem *membase;
+	u32 mask;
+	u32 bits[8];
+	u32 bits_wr;
+};
+
+static struct ili9488_data *pdata;
+static u32 *rgb;
+
+static u32 ili9488_rgb565_to_gpiobus(struct ili9488_data *pdata, u8 color)
+{
+	int i;
+	u32 value = 0;
+
+	for (i = 0; i < 8; i++) {
+		if (color & 1)
+			value |= pdata->bits[i];
+		else
+			value &= ~(pdata->bits[i]);
+		color >>= 1;
+	}
+
+	return value;
+}
+
+static int ili9488_bus_write(struct mipi_dbi *dbi, u8 data)
+{
+	int i;
+
+	if (pdata->membase) {
+		u32 v = (readl(pdata->membase) & ~pdata->mask) | *(rgb + data);
+		writel(v, pdata->membase);
+		writel(v | pdata->bits_wr, pdata->membase);
+		return 0;
+	}
+
+	gpiod_set_value(pdata->wr, 0);
+	for (i = 0; i < 8; i++) {
+		gpiod_set_value(pdata->db[i], data & 1);
+		data >>= 1;
+	}
+	gpiod_set_value(pdata->wr, 1);
+
+	return 0;
+}
+
+static int ili9488_command(struct mipi_dbi *dbi, u8 *cmd, u8 *par, size_t num)
+{
+	u8 *p = par;
+
+	gpiod_set_value(dbi->dc, 0);
+	ili9488_bus_write(dbi, *cmd);
+	gpiod_set_value(dbi->dc, 1);
+
+	while (num--)
+		ili9488_bus_write(dbi, *p++);
+
+	return 0;
+}
+
+static void ili9488_pipe_enable(struct drm_simple_display_pipe *pipe,
+				struct drm_crtc_state *crtc_state,
+				struct drm_plane_state *plane_state)
+{
+	struct mipi_dbi_dev *dbidev = drm_to_mipi_dbi_dev(pipe->crtc.dev);
+	struct mipi_dbi *dbi = &dbidev->dbi;
+	u8 addr_mode;
+	int ret, idx;
+
+	if (!drm_dev_enter(pipe->crtc.dev, &idx))
+		return;
+
+	ret = mipi_dbi_poweron_reset(dbidev);
+	if (ret < 0)
+		goto out_exit;
+	if (ret == 1)
+		goto out_enable;
+
+	gpiod_set_value(pdata->cs, 0);
+
+	mipi_dbi_command(dbi, ILI9488_ITFCTR1, 0x00);
+	mipi_dbi_command(dbi, MIPI_DCS_EXIT_SLEEP_MODE);
+	msleep(250);
+
+	mipi_dbi_command(dbi, MIPI_DCS_SET_PIXEL_FORMAT, 0x55);
+	mipi_dbi_command(dbi, ILI9488_PWCTRL1, 0x33);
+	mipi_dbi_command(dbi, ILI9488_VMCTRL1, 0x00, 0x1e, 0x80, 0x00);
+	mipi_dbi_command(dbi, ILI9488_FRMCTR1, 0xb0, 0x11);
+	mipi_dbi_command(dbi, ILI9488_PGAMCTRL,
+			0x00, 0x04, 0x0e, 0x08, 0x17, 0x0a, 0x40, 0x79,
+			0x4d, 0x07, 0x0e, 0x0a, 0x1a, 0x1d, 0x0f);
+	mipi_dbi_command(dbi, ILI9488_NGAMCTRL,
+			0x00, 0x1b, 0x1f, 0x02, 0x10, 0x05, 0x32, 0x34,
+			0x43, 0x02, 0x0a, 0x09, 0x33, 0x37, 0x0f);
+	mipi_dbi_command(dbi, MIPI_DCS_SET_DISPLAY_ON);
+	msleep(100);
+
+ out_enable:
+	switch (dbidev->rotation) {
+		case 90:
+			addr_mode = ILI9488_MADCTL_MY;
+			break;
+		case 180:
+			addr_mode = ILI9488_MADCTL_MV;
+			break;
+		case 270:
+			addr_mode = ILI9488_MADCTL_MX;
+			break;
+		default:
+			addr_mode = ILI9488_MADCTL_MV | ILI9488_MADCTL_MY |
+				ILI9488_MADCTL_MX;
+			break;
+	}
+
+	addr_mode |= ILI9488_MADCTL_BGR;
+	mipi_dbi_command(dbi, MIPI_DCS_SET_ADDRESS_MODE, addr_mode);
+	mipi_dbi_enable_flush(dbidev, crtc_state, plane_state);
+
+out_exit:
+	drm_dev_exit(idx);
+}
+
+static const struct drm_simple_display_pipe_funcs ili9488_pipe_funcs = {
+	.enable = ili9488_pipe_enable,
+	.disable = mipi_dbi_pipe_disable,
+	.update = mipi_dbi_pipe_update,
+	.prepare_fb = drm_gem_simple_display_pipe_prepare_fb,
+};
+
+static const struct drm_display_mode ili9488_mode = {
+	DRM_SIMPLE_MODE(480, 320, 73, 49),
+};
+
+DEFINE_DRM_GEM_CMA_FOPS(ili9488_fops);
+
+static struct drm_driver ili9488_driver = {
+	.driver_features	= DRIVER_GEM | DRIVER_MODESET | DRIVER_ATOMIC,
+	.fops			= &ili9488_fops,
+	DRM_GEM_CMA_DRIVER_OPS_VMAP,
+	.name			= "ili9488",
+	.desc			= "Ilitek ILI9488",
+	.date			= "20210201",
+	.major			= 1,
+	.minor			= 0,
+};
+
+static int ili9488_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node;
+	struct mipi_dbi *dbi;
+	struct drm_device *drm;
+	struct mipi_dbi_dev *dbidev;
+	int ret;
+	int i;
+	u32 rotation = 0;
+	struct resource res;
+	char str[32];
+
+	pdata = devm_kzalloc(dev, sizeof(struct ili9488_data), GFP_KERNEL);
+	if (!pdata)
+		return -ENOMEM;
+
+	dbidev = devm_drm_dev_alloc(dev, &ili9488_driver,
+			struct mipi_dbi_dev, drm);
+	if (IS_ERR(dbidev))
+		return PTR_ERR(dbidev);
+
+	dbi = &dbidev->dbi;
+	drm = &dbidev->drm;
+
+	dbi->reset = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(dbi->reset)) {
+		DRM_DEV_ERROR(dev, "Failed to get gpio 'reset'\n");
+		return PTR_ERR(dbi->reset);
+	}
+
+	dbi->dc = devm_gpiod_get(dev, "dc", GPIOD_OUT_LOW);
+	if (IS_ERR(dbi->dc)) {
+		DRM_DEV_ERROR(dev, "Failed to get gpio 'dc'\n");
+		return PTR_ERR(dbi->dc);
+	}
+
+	pdata->wr = devm_gpiod_get(dev, "wr", GPIOD_OUT_HIGH);
+	if (IS_ERR(pdata->wr)) {
+		DRM_DEV_ERROR(dev, "Failed to get gpio 'wr'\n");
+		return PTR_ERR(pdata->wr);
+	}
+
+	pdata->cs = devm_gpiod_get(dev, "cs", GPIOD_OUT_LOW);
+	if (IS_ERR(pdata->cs)) {
+		DRM_DEV_ERROR(dev, "Failed to get gpio 'cs'\n");
+		return PTR_ERR(pdata->cs);
+	}
+
+	for (i = 0; i < 8; i++) {
+		struct gpio_desc *desc;
+		int gpio = of_get_named_gpio(np, "db-gpios", i);
+		if (gpio < 0)
+			break;	/* FIXME */
+
+		desc = gpio_to_desc(gpio);
+
+		devm_gpio_request(dev, gpio, NULL);
+		gpiod_direction_output(desc, 1);
+
+		pdata->db[i] = desc;
+	}
+
+	ret = of_address_to_resource(np, 0, &res);
+	if (!ret) {
+		pdata->membase = devm_ioremap(dev, res.start,
+				resource_size(&res));
+		if (!IS_ERR(pdata->membase)) {
+			for (i = 0; i < 8; i++) {
+				sprintf(str, "db-bits-%d", i);
+				ret = of_property_read_u32(np, str,
+						&pdata->bits[i]);
+				if (ret)
+					continue;
+				pdata->mask |= pdata->bits[i];
+			}
+
+			ret = of_property_read_u32(np, "db-bits-wr",
+					&pdata->bits_wr);
+			if (!ret)
+				pdata->mask |= pdata->bits_wr;
+		}
+	}
+
+	dbidev->backlight = devm_of_find_backlight(dev);
+	if (IS_ERR(dbidev->backlight))
+		return PTR_ERR(dbidev->backlight);
+
+	device_property_read_u32(dev, "rotation", &rotation);
+
+	rgb = devm_kzalloc(dev, sizeof(u32) * 256, GFP_KERNEL);
+	if (rgb) {
+		u32 *p = rgb;
+		for (i = 0; i < 256; i++)
+			*p++ = ili9488_rgb565_to_gpiobus(pdata, i);
+	}
+
+	gpiod_set_value(pdata->wr, 1);
+	gpiod_set_value(dbi->dc, 0);
+
+	/* override the command function set in  mipi_dbi_spi_init() */
+	dbi->command = ili9488_command;
+	dbi->read_commands = NULL;
+	dbi->swap_bytes = true;
+
+	ret = mipi_dbi_dev_init(dbidev, &ili9488_pipe_funcs,
+			&ili9488_mode, rotation);
+	if (ret)
+		return ret;
+
+	drm_mode_config_reset(drm);
+
+	ret = drm_dev_register(drm, 0);
+	if (ret)
+		return ret;
+
+	platform_set_drvdata(pdev, pdata);
+	pdata->dbidev = dbidev;
+
+	drm_fbdev_generic_setup(drm, 0);
+
+	return 0;
+}
+
+static int ili9488_remove(struct platform_device *pdev)
+{
+	struct ili9488_data *pdata = platform_get_drvdata(pdev);
+	struct mipi_dbi_dev *dbidev = pdata->dbidev;
+	struct drm_device *drm = &dbidev->drm;
+
+	drm_dev_unplug(drm);
+	drm_atomic_helper_shutdown(drm);
+
+	return 0;
+}
+
+static const struct of_device_id ili9488_dt_ids[] = {
+	{ .compatible = "ili9488", 0 },
+	{ .compatible = "hardkernel,ili9488", 0 },
+	{ },
+};
+
+MODULE_DEVICE_TABLE(of, ili9488_dt_ids);
+
+static struct platform_driver ili9488_platform_driver = {
+	.driver = {
+		.name = "ili9488",
+		.of_match_table = ili9488_dt_ids,
+	},
+	.probe = ili9488_probe,
+	.remove = ili9488_remove,
+};
+
+static int __init ili9488_init(void)
+{
+	return platform_driver_register(&ili9488_platform_driver);
+}
+
+static void __exit ili9488_exit(void)
+{
+	platform_driver_unregister(&ili9488_platform_driver);
+}
+
+module_init(ili9488_init);
+module_exit(ili9488_exit);
+
+MODULE_DESCRIPTION("Ilitek ILI9488 DRM driver (8bit PIO mode)");
+MODULE_AUTHOR("Dongjin Kim <tobetter@gmail.com>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/hid/hid-ids.h b/drivers/hid/hid-ids.h
index 5daec769df7a..59d08c9f4525 100644
--- a/drivers/hid/hid-ids.h
+++ b/drivers/hid/hid-ids.h
@@ -1374,4 +1374,10 @@
 #define USB_VENDOR_ID_SIGNOTEC			0x2133
 #define USB_DEVICE_ID_SIGNOTEC_VIEWSONIC_PD1011	0x0018
 
+#define USB_DEVICE_ID_DWAV_MULTITOUCH	0x0005
+
+#define USB_VENDOR_ID_ODROID	0x16b4
+#define USB_DEVICE_ID_VU5	0x0704
+#define USB_DEVICE_ID_VU7PLUS	0x0705
+
 #endif
diff --git a/drivers/hid/hid-quirks.c b/drivers/hid/hid-quirks.c
index c7c06aa958c4..c14fe85a0543 100644
--- a/drivers/hid/hid-quirks.c
+++ b/drivers/hid/hid-quirks.c
@@ -867,6 +867,10 @@ static const struct hid_device_id hid_ignore_list[] = {
 	{ HID_USB_DEVICE(USB_VENDOR_ID_SYNAPTICS, USB_DEVICE_ID_SYNAPTICS_DPAD) },
 #endif
 	{ HID_USB_DEVICE(USB_VENDOR_ID_YEALINK, USB_DEVICE_ID_YEALINK_P1K_P4K_B2K) },
+
+	{ HID_USB_DEVICE(USB_VENDOR_ID_DWAV, USB_DEVICE_ID_DWAV_MULTITOUCH) },
+	{ HID_USB_DEVICE(USB_VENDOR_ID_ODROID, USB_DEVICE_ID_VU5) },
+	{ HID_USB_DEVICE(USB_VENDOR_ID_ODROID, USB_DEVICE_ID_VU7PLUS) },
 	{ }
 };
 
diff --git a/drivers/hwmon/pwm-fan.c b/drivers/hwmon/pwm-fan.c
index f12b9a28a232..383a24316985 100644
--- a/drivers/hwmon/pwm-fan.c
+++ b/drivers/hwmon/pwm-fan.c
@@ -8,6 +8,7 @@
  */
 
 #include <linux/hwmon.h>
+#include <linux/hwmon-sysfs.h>
 #include <linux/interrupt.h>
 #include <linux/module.h>
 #include <linux/mutex.h>
@@ -44,6 +45,7 @@ struct pwm_fan_ctx {
 	unsigned int pwm_fan_max_state;
 	unsigned int *pwm_fan_cooling_levels;
 	struct thermal_cooling_device *cdev;
+	int enable;
 
 	struct hwmon_chip_info info;
 	struct hwmon_channel_info fan_channel;
@@ -99,6 +101,10 @@ static int  __set_pwm(struct pwm_fan_ctx *ctx, unsigned long pwm)
 	struct pwm_state *state = &ctx->pwm_state;
 
 	mutex_lock(&ctx->lock);
+
+	if (!ctx->enable)
+		pwm = MAX_PWM;
+
 	if (ctx->pwm_value == pwm)
 		goto exit_set_pwm_err;
 
@@ -183,6 +189,51 @@ static const struct hwmon_ops pwm_fan_hwmon_ops = {
 	.write = pwm_fan_write,
 };
 
+static ssize_t enable_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	struct pwm_fan_ctx *ctx = dev_get_drvdata(dev);
+	int err;
+	unsigned long val;
+
+	err = kstrtoul(buf, 10, &val);
+	if (err)
+		return err;
+
+	mutex_lock(&ctx->lock);
+	ctx->enable = val;
+	mutex_unlock(&ctx->lock);
+
+	err = __set_pwm(ctx, ctx->pwm_fan_cooling_levels[ctx->pwm_fan_state]);
+
+	return err ? err : count;
+}
+
+static ssize_t enable_show(struct device *dev, struct device_attribute *attr,
+		char *buf)
+{
+	struct pwm_fan_ctx *ctx = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%u\n", ctx->enable);
+}
+
+static SENSOR_DEVICE_ATTR_RW(pwm1_enable, enable, 0);
+
+static struct attribute *pwm_fan_attrs[] = {
+	&sensor_dev_attr_pwm1_enable.dev_attr.attr,
+	NULL,
+};
+
+static const struct attribute_group pwm_fan_group = {
+	.attrs = pwm_fan_attrs,
+};
+
+static const struct attribute_group *pwm_fan_groups[] = {
+	&pwm_fan_group,
+	NULL,
+};
+
 /* thermal cooling device callbacks */
 static int pwm_fan_get_max_state(struct thermal_cooling_device *cdev,
 				 unsigned long *state)
@@ -214,7 +265,7 @@ static int
 pwm_fan_set_cur_state(struct thermal_cooling_device *cdev, unsigned long state)
 {
 	struct pwm_fan_ctx *ctx = cdev->devdata;
-	int ret;
+	int ret = 0;
 
 	if (!ctx || (state > ctx->pwm_fan_max_state))
 		return -EINVAL;
@@ -222,10 +273,12 @@ pwm_fan_set_cur_state(struct thermal_cooling_device *cdev, unsigned long state)
 	if (state == ctx->pwm_fan_state)
 		return 0;
 
-	ret = __set_pwm(ctx, ctx->pwm_fan_cooling_levels[state]);
-	if (ret) {
-		dev_err(&cdev->device, "Cannot set pwm!\n");
-		return ret;
+	if (ctx->enable >= 2) {
+		ret = __set_pwm(ctx, ctx->pwm_fan_cooling_levels[state]);
+		if (ret) {
+			dev_err(&cdev->device, "Cannot set pwm!\n");
+			return ret;
+		}
 	}
 
 	ctx->pwm_fan_state = state;
@@ -316,6 +369,8 @@ static int pwm_fan_probe(struct platform_device *pdev)
 	if (IS_ERR(ctx->pwm))
 		return dev_err_probe(dev, PTR_ERR(ctx->pwm), "Could not get PWM\n");
 
+	ctx->enable = 2;
+
 	platform_set_drvdata(pdev, ctx);
 
 	ctx->reg_en = devm_regulator_get_optional(dev, "fan");
@@ -434,7 +489,7 @@ static int pwm_fan_probe(struct platform_device *pdev)
 	ctx->info.info = channels;
 
 	hwmon = devm_hwmon_device_register_with_info(dev, "pwmfan",
-						     ctx, &ctx->info, NULL);
+						     ctx, &ctx->info, pwm_fan_groups);
 	if (IS_ERR(hwmon)) {
 		dev_err(dev, "Failed to register hwmon device\n");
 		return PTR_ERR(hwmon);
diff --git a/drivers/input/touchscreen/Kconfig b/drivers/input/touchscreen/Kconfig
index d4e74738c5a8..f96428569e19 100644
--- a/drivers/input/touchscreen/Kconfig
+++ b/drivers/input/touchscreen/Kconfig
@@ -1366,4 +1366,14 @@ config TOUCHSCREEN_ZINITIX
 	  To compile this driver as a module, choose M here: the
 	  module will be called zinitix.
 
+config TOUCHSCREEN_DWAV_USB_MT
+	tristate "D-WAV Scientific USB MultiTouch"
+	depends on USB_ARCH_HAS_HCD
+	select USB
+	help
+	  Say Y here if you have a D-WAV Scientific USB(HID) based MultiTouch
+	  controller.
+
+	  module will be called dwav-usb-mt.
+
 endif
diff --git a/drivers/input/touchscreen/Makefile b/drivers/input/touchscreen/Makefile
index 7d34100f7f22..5a47f4e8c66a 100644
--- a/drivers/input/touchscreen/Makefile
+++ b/drivers/input/touchscreen/Makefile
@@ -114,3 +114,4 @@ obj-$(CONFIG_TOUCHSCREEN_ROHM_BU21023)	+= rohm_bu21023.o
 obj-$(CONFIG_TOUCHSCREEN_RASPBERRYPI_FW)	+= raspberrypi-ts.o
 obj-$(CONFIG_TOUCHSCREEN_IQS5XX)	+= iqs5xx.o
 obj-$(CONFIG_TOUCHSCREEN_ZINITIX)	+= zinitix.o
+obj-$(CONFIG_TOUCHSCREEN_DWAV_USB_MT)	+= dwav-usb-mt.o
diff --git a/drivers/input/touchscreen/dwav-usb-mt.c b/drivers/input/touchscreen/dwav-usb-mt.c
new file mode 100644
index 000000000000..2e1dd0f2986f
--- /dev/null
+++ b/drivers/input/touchscreen/dwav-usb-mt.c
@@ -0,0 +1,554 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * D-WAV Scientific USB(HID) MultiTouch Screen Driver(Based on usbtouchscreen.c)
+ *
+ * Copyright (C) Hardkernel, 2015
+ */
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/input.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/usb.h>
+#include <linux/usb/input.h>
+#include <linux/hid.h>
+
+#include <linux/input/mt.h>
+
+#define USB_VENDOR_ID_DWAV	0x0eef	/* 800 x 480, 7" DWAV touch */
+#define USB_DEVICE_ID_VU7	0x0005
+
+#define USB_VENDOR_ID_ODROID	0x16b4
+#define	USB_DEVICE_ID_VU5	0x0704
+#define	USB_DEVICE_ID_VU7PLUS	0x0705
+
+enum	{
+	ODROID_VU7 = 0,	/* 800 x 480, 7" Touch */
+	ODROID_VU5,	/* 800 x 480, 5" Touch */
+	ODROID_VU7PLUS,	/* 1024 x 600, 7" Touch */
+};
+
+struct usbtouch_device_info	{
+	char	name[64];
+	int	max_x;
+	int	max_y;
+	int	max_press;
+	int	max_finger;
+};
+
+const struct usbtouch_device_info DEV_INFO[] = {
+	[ODROID_VU7] = {
+		.name = "ODROID VU7 MultiTouch(800x480)",
+		.max_x = 800,
+		.max_y = 480,
+		.max_press = 255,
+		.max_finger = 5,
+	},
+	[ODROID_VU5] = {
+		.name = "ODROID VU5 MultiTouch(800x480)",
+		.max_x = 800,
+		.max_y = 480,
+		.max_press = 255,
+		.max_finger = 5,
+	},
+	[ODROID_VU7PLUS] = {
+		.name = "ODROID VU7 Plus MultiTouch(1024x600)",
+		.max_x = 1024,
+		.max_y = 600,
+		.max_press = 255,
+		.max_finger = 5,
+	},
+};
+
+static const struct usb_device_id dwav_usb_mt_devices[] = {
+	{USB_DEVICE(USB_VENDOR_ID_DWAV,   USB_DEVICE_ID_VU7),
+		.driver_info = ODROID_VU7},
+	{USB_DEVICE(USB_VENDOR_ID_ODROID, USB_DEVICE_ID_VU5),
+		.driver_info = ODROID_VU5},
+	{USB_DEVICE(USB_VENDOR_ID_ODROID, USB_DEVICE_ID_VU7PLUS),
+		.driver_info = ODROID_VU7PLUS},
+	{}
+};
+
+struct dwav_raw {                   /* Total 25 bytes */
+	unsigned char   header;     /* frame header 0xAA*/
+	unsigned char   press;
+	/* Touch flag (1:valid touch data, 0:touch finished) */
+	unsigned short  x1;         /* 1st x */
+	unsigned short  y1;         /* 1st y */
+	unsigned char   end;
+	/* 1st touch finish flags 0xBB, RPI only uses the first 7 bytes */
+	unsigned char   ids;        /* touch ID(bit field) */
+	unsigned short  y2;
+	unsigned short  x2;
+	unsigned short  y3;
+	unsigned short  x3;
+	unsigned short  y4;
+	unsigned short  x4;
+	unsigned short  y5;
+	unsigned short  x5;
+	unsigned char   tail;       /* frame end 0xCC */
+};
+
+#define	TS_EVENT_UNKNOWN	0x00
+#define	TS_EVENT_PRESS		0x01
+#define	TS_EVENT_RELEASE	0x02
+
+struct	finger_t	{
+	unsigned int	status;	/* ts event type */
+	unsigned int	x;	/* ts data x */
+	unsigned int	y;	/* ts data y */
+}	__packed;
+
+struct dwav_usb_mt  {
+	char		name[128], phys[64];
+
+	int		dev_id;
+	/* for URB Data DMA */
+	dma_addr_t	data_dma;
+	unsigned char	*data;
+	int		data_size;
+
+	struct urb		*irq;
+	struct usb_interface	*interface;
+	struct input_dev	*input;
+
+	struct finger_t		*finger;
+};
+
+static void dwav_usb_mt_report(struct dwav_usb_mt *dwav_usb_mt)
+{
+	int	id, max_x, max_y, max_press, max_finger;
+
+	max_x = DEV_INFO[dwav_usb_mt->dev_id].max_x;
+	max_y = DEV_INFO[dwav_usb_mt->dev_id].max_y;
+	max_press = DEV_INFO[dwav_usb_mt->dev_id].max_press;
+	max_finger = DEV_INFO[dwav_usb_mt->dev_id].max_finger;
+
+	for (id = 0; id < max_finger; id++)	{
+
+		if (dwav_usb_mt->finger[id].status == TS_EVENT_UNKNOWN)
+			continue;
+
+		if (dwav_usb_mt->finger[id].x >= max_x ||
+		    dwav_usb_mt->finger[id].y >= max_y)
+			continue;
+
+		input_mt_slot(dwav_usb_mt->input, id);
+
+		if (dwav_usb_mt->finger[id].status != TS_EVENT_RELEASE) {
+			input_mt_report_slot_state(dwav_usb_mt->input,
+					MT_TOOL_FINGER, true);
+			input_report_abs(dwav_usb_mt->input,
+					ABS_MT_POSITION_X,
+					dwav_usb_mt->finger[id].x);
+			input_report_abs(dwav_usb_mt->input,
+					ABS_MT_POSITION_Y,
+					dwav_usb_mt->finger[id].y);
+			input_report_abs(dwav_usb_mt->input,
+					ABS_MT_PRESSURE,
+					max_press);
+		} else {
+			input_mt_report_slot_state(dwav_usb_mt->input,
+					MT_TOOL_FINGER, false);
+			dwav_usb_mt->finger[id].status = TS_EVENT_UNKNOWN;
+		}
+		input_mt_report_pointer_emulation(dwav_usb_mt->input, true);
+		input_sync(dwav_usb_mt->input);
+	}
+}
+
+static void dwav_usb_mt_process(struct dwav_usb_mt *dwav_usb_mt,
+		unsigned char *pkt, int len)
+{
+	struct  dwav_raw *dwav_raw = (struct dwav_raw *)pkt;
+	unsigned char bit_mask, cnt;
+
+	for (cnt = 0, bit_mask = 0x01;
+	     cnt < DEV_INFO[dwav_usb_mt->dev_id].max_finger;
+	     cnt++, bit_mask <<= 1) {
+		if ((dwav_raw->ids & bit_mask) && dwav_raw->press) {
+			dwav_usb_mt->finger[cnt].status = TS_EVENT_PRESS;
+			switch (cnt) {
+			case	0:
+				dwav_usb_mt->finger[cnt].x
+					= cpu_to_be16(dwav_raw->x1);
+				dwav_usb_mt->finger[cnt].y
+					= cpu_to_be16(dwav_raw->y1);
+				break;
+			case	1:
+				dwav_usb_mt->finger[cnt].x
+					= cpu_to_be16(dwav_raw->x2);
+				dwav_usb_mt->finger[cnt].y
+					= cpu_to_be16(dwav_raw->y2);
+				break;
+			case	2:
+				dwav_usb_mt->finger[cnt].x
+					= cpu_to_be16(dwav_raw->x3);
+				dwav_usb_mt->finger[cnt].y
+					= cpu_to_be16(dwav_raw->y3);
+				break;
+			case	3:
+				dwav_usb_mt->finger[cnt].x
+					= cpu_to_be16(dwav_raw->x4);
+				dwav_usb_mt->finger[cnt].y
+					= cpu_to_be16(dwav_raw->y4);
+				break;
+			case	4:
+				dwav_usb_mt->finger[cnt].x
+					= cpu_to_be16(dwav_raw->x5);
+				dwav_usb_mt->finger[cnt].y
+					= cpu_to_be16(dwav_raw->y5);
+				break;
+			default:
+				break;
+			}
+		} else {
+			if (dwav_usb_mt->finger[cnt].status == TS_EVENT_PRESS)
+				dwav_usb_mt->finger[cnt].status
+					= TS_EVENT_RELEASE;
+			else
+				dwav_usb_mt->finger[cnt].status
+					= TS_EVENT_UNKNOWN;
+		}
+	}
+	dwav_usb_mt_report(dwav_usb_mt);
+}
+
+static void dwav_usb_mt_irq(struct urb *urb)
+{
+	struct dwav_usb_mt *dwav_usb_mt = urb->context;
+	struct device *dev = &dwav_usb_mt->interface->dev;
+	int retval;
+
+	switch (urb->status) {
+	case 0:
+		/* success */
+		break;
+	case -ETIME:
+		/* this urb is timing out */
+		dev_dbg(dev, "%s - urb timed out - was the device unplugged?\n",
+				__func__);
+		return;
+	case -ECONNRESET:
+	case -ENOENT:
+	case -ESHUTDOWN:
+	case -EPIPE:
+		/* this urb is terminated, clean up */
+		dev_dbg(dev, "%s - urb shutting down with status: %d\n",
+				__func__, urb->status);
+		return;
+	default:
+		dev_dbg(dev, "%s - nonzero urb status received: %d\n",
+				__func__, urb->status);
+		goto exit;
+	}
+
+	dwav_usb_mt_process(dwav_usb_mt, dwav_usb_mt->data, urb->actual_length);
+
+exit:
+	usb_mark_last_busy(interface_to_usbdev(dwav_usb_mt->interface));
+	retval = usb_submit_urb(urb, GFP_ATOMIC);
+	if (retval) {
+		dev_err(dev, "%s - usb_submit_urb failed with result: %d\n",
+				__func__, retval);
+	}
+}
+
+static int dwav_usb_mt_open(struct input_dev *input)
+{
+	struct dwav_usb_mt *dwav_usb_mt = input_get_drvdata(input);
+	int r;
+
+	dwav_usb_mt->irq->dev = interface_to_usbdev(dwav_usb_mt->interface);
+
+	r = usb_autopm_get_interface(dwav_usb_mt->interface) ? -EIO : 0;
+	if (r < 0)
+		goto out;
+
+	if (usb_submit_urb(dwav_usb_mt->irq, GFP_KERNEL)) {
+		r = -EIO;
+		goto out_put;
+	}
+
+	dwav_usb_mt->interface->needs_remote_wakeup = 1;
+out_put:
+	usb_autopm_put_interface(dwav_usb_mt->interface);
+out:
+	return r;
+}
+
+static void dwav_usb_mt_close(struct input_dev *input)
+{
+	struct dwav_usb_mt *dwav_usb_mt = input_get_drvdata(input);
+	int r;
+
+	usb_kill_urb(dwav_usb_mt->irq);
+
+	r = usb_autopm_get_interface(dwav_usb_mt->interface);
+
+	dwav_usb_mt->interface->needs_remote_wakeup = 0;
+	if (!r)
+		usb_autopm_put_interface(dwav_usb_mt->interface);
+}
+
+static int dwav_usb_mt_suspend(struct usb_interface *intf, pm_message_t message)
+{
+	struct dwav_usb_mt *dwav_usb_mt = usb_get_intfdata(intf);
+
+	usb_kill_urb(dwav_usb_mt->irq);
+
+	return 0;
+}
+
+static int dwav_usb_mt_resume(struct usb_interface *intf)
+{
+	struct dwav_usb_mt *dwav_usb_mt = usb_get_intfdata(intf);
+	struct input_dev *input = dwav_usb_mt->input;
+	int result = 0;
+
+	mutex_lock(&input->mutex);
+	if (input->users)
+		result = usb_submit_urb(dwav_usb_mt->irq, GFP_NOIO);
+	mutex_unlock(&input->mutex);
+
+	return result;
+}
+
+static int dwav_usb_mt_reset_resume(struct usb_interface *intf)
+{
+	struct dwav_usb_mt *dwav_usb_mt = usb_get_intfdata(intf);
+	struct input_dev *input = dwav_usb_mt->input;
+	int err = 0;
+
+	/* restart IO if needed */
+	mutex_lock(&input->mutex);
+	if (input->users)
+		err = usb_submit_urb(dwav_usb_mt->irq, GFP_NOIO);
+	mutex_unlock(&input->mutex);
+
+	return err;
+}
+
+static void dwav_usb_mt_free_buffers(struct usb_device *udev,
+				  struct dwav_usb_mt *dwav_usb_mt)
+{
+	usb_free_coherent(udev, dwav_usb_mt->data_size,
+			dwav_usb_mt->data, dwav_usb_mt->data_dma);
+}
+
+static struct usb_endpoint_descriptor *dwav_usb_mt_get_input_endpoint(
+		struct usb_host_interface *interface)
+{
+	int i;
+
+	for (i = 0; i < interface->desc.bNumEndpoints; i++) {
+		if (usb_endpoint_dir_in(&interface->endpoint[i].desc))
+			return &interface->endpoint[i].desc;
+	}
+
+	return NULL;
+}
+
+static int dwav_usb_mt_init(struct dwav_usb_mt *dwav_usb_mt, void *dev)
+{
+	int err;
+	struct input_dev *input_dev = (struct input_dev *)dev;
+
+	input_dev->name = dwav_usb_mt->name;
+	input_dev->phys = dwav_usb_mt->phys;
+
+	input_set_drvdata(input_dev, dwav_usb_mt);
+
+	input_dev->open = dwav_usb_mt_open;
+	input_dev->close = dwav_usb_mt_close;
+
+	input_dev->id.bustype = BUS_USB;
+
+	/* single touch */
+	input_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
+	input_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);
+
+	input_set_abs_params(input_dev, ABS_X, 0,
+			     DEV_INFO[dwav_usb_mt->dev_id].max_x, 0, 0);
+	input_set_abs_params(input_dev, ABS_Y, 0,
+			     DEV_INFO[dwav_usb_mt->dev_id].max_y, 0, 0);
+
+	/* multi touch */
+	input_set_abs_params(input_dev, ABS_MT_POSITION_X, 0,
+			     DEV_INFO[dwav_usb_mt->dev_id].max_x, 0, 0);
+	input_set_abs_params(input_dev, ABS_MT_POSITION_Y, 0,
+			     DEV_INFO[dwav_usb_mt->dev_id].max_y, 0, 0);
+	input_mt_init_slots(input_dev,
+			     DEV_INFO[dwav_usb_mt->dev_id].max_finger, 0);
+
+	err = input_register_device(input_dev);
+	if (err) {
+		pr_err("%s - input_register_device failed, err: %d\n",
+				__func__, err);
+		return  err;
+	}
+
+	dwav_usb_mt->input = input_dev;
+
+	return  0;
+}
+
+static int dwav_usb_mt_probe(struct usb_interface *intf,
+			  const struct usb_device_id *id)
+{
+	struct dwav_usb_mt *dwav_usb_mt = NULL;
+	struct input_dev *input_dev = NULL;
+	struct usb_endpoint_descriptor *endpoint;
+	struct usb_device *udev = interface_to_usbdev(intf);
+
+	int err = 0;
+
+	endpoint = dwav_usb_mt_get_input_endpoint(intf->cur_altsetting);
+	if (!endpoint)
+		return  -ENXIO;
+
+	dwav_usb_mt = kzalloc(sizeof(struct dwav_usb_mt), GFP_KERNEL);
+	if (!dwav_usb_mt)
+		return  -ENOMEM;
+
+	dwav_usb_mt->dev_id = id->driver_info;
+
+	dwav_usb_mt->finger = kzalloc(sizeof(struct finger_t) *
+				      DEV_INFO[dwav_usb_mt->dev_id].max_finger,
+				      GFP_KERNEL);
+
+	if (!dwav_usb_mt->finger)
+		goto err_free_mem;
+
+	input_dev = input_allocate_device();
+	if (!input_dev)
+		goto err_free_mem;
+
+	dwav_usb_mt->data_size = sizeof(struct dwav_raw);
+	dwav_usb_mt->data = usb_alloc_coherent(udev, dwav_usb_mt->data_size,
+			GFP_KERNEL, &dwav_usb_mt->data_dma);
+	if (!dwav_usb_mt->data)
+		goto err_free_mem;
+
+	dwav_usb_mt->irq = usb_alloc_urb(0, GFP_KERNEL);
+	if (!dwav_usb_mt->irq) {
+		dev_dbg(&intf->dev,
+				"%s - usb_alloc_urb failed: usbtouch->irq\n",
+				__func__);
+		goto err_free_buffers;
+	}
+
+	if (usb_endpoint_type(endpoint) == USB_ENDPOINT_XFER_INT)   {
+		usb_fill_int_urb(dwav_usb_mt->irq, udev,
+			usb_rcvintpipe(udev, endpoint->bEndpointAddress),
+			dwav_usb_mt->data, dwav_usb_mt->data_size,
+			dwav_usb_mt_irq, dwav_usb_mt, endpoint->bInterval);
+	} else {
+		usb_fill_bulk_urb(dwav_usb_mt->irq, udev,
+			 usb_rcvbulkpipe(udev, endpoint->bEndpointAddress),
+			 dwav_usb_mt->data, dwav_usb_mt->data_size,
+			 dwav_usb_mt_irq, dwav_usb_mt);
+	}
+
+	dwav_usb_mt->irq->dev = udev;
+	dwav_usb_mt->irq->transfer_dma = dwav_usb_mt->data_dma;
+	dwav_usb_mt->irq->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
+
+	dwav_usb_mt->interface  = intf;
+
+	if (udev->manufacturer)
+		strlcpy(dwav_usb_mt->name,
+				udev->manufacturer, sizeof(dwav_usb_mt->name));
+
+	if (udev->product) {
+		if (udev->manufacturer)
+			strlcat(dwav_usb_mt->name,
+					" ", sizeof(dwav_usb_mt->name));
+
+		strlcat(dwav_usb_mt->name,
+				udev->product, sizeof(dwav_usb_mt->name));
+	}
+
+	if (!strlen(dwav_usb_mt->name)) {
+		snprintf(dwav_usb_mt->name, sizeof(dwav_usb_mt->name),
+				"D-WAV Scientific MultiTouch %04x:%04x",
+				le16_to_cpu(udev->descriptor.idVendor),
+				le16_to_cpu(udev->descriptor.idProduct));
+	}
+
+	usb_make_path(udev, dwav_usb_mt->phys, sizeof(dwav_usb_mt->phys));
+	strlcat(dwav_usb_mt->phys, "/input0", sizeof(dwav_usb_mt->phys));
+
+	usb_to_input_id(udev, &input_dev->id);
+
+	input_dev->dev.parent = &intf->dev;
+
+	err = dwav_usb_mt_init(dwav_usb_mt, (void *)input_dev);
+	if (err)
+		goto err_free_urb;
+
+	usb_set_intfdata(intf, dwav_usb_mt);
+
+	dev_info(&intf->dev, "%s\n", DEV_INFO[dwav_usb_mt->dev_id].name);
+
+	return 0;
+
+err_free_urb:
+	usb_free_urb(dwav_usb_mt->irq);
+
+err_free_buffers:
+	dwav_usb_mt_free_buffers(udev, dwav_usb_mt);
+
+err_free_mem:
+	if (input_dev)
+		input_free_device(input_dev);
+	kfree(dwav_usb_mt);
+
+	return err;
+}
+
+static void dwav_usb_mt_disconnect(struct usb_interface *intf)
+{
+	struct dwav_usb_mt *dwav_usb_mt = usb_get_intfdata(intf);
+
+	if (!dwav_usb_mt)
+		return;
+
+	dev_dbg(&intf->dev,
+			"%s - dwav_usb_mt is initialized, cleaning up\n",
+			__func__);
+
+	usb_set_intfdata(intf, NULL);
+
+	/* this will stop IO via close */
+	input_unregister_device(dwav_usb_mt->input);
+
+	usb_free_urb(dwav_usb_mt->irq);
+
+	dwav_usb_mt_free_buffers(interface_to_usbdev(intf), dwav_usb_mt);
+
+	kfree(dwav_usb_mt);
+}
+
+MODULE_DEVICE_TABLE(usb, dwav_usb_mt_devices);
+
+static struct usb_driver dwav_usb_mt_driver = {
+	.name = "dwav_usb_mt",
+	.probe = dwav_usb_mt_probe,
+	.disconnect = dwav_usb_mt_disconnect,
+	.suspend = dwav_usb_mt_suspend,
+	.resume = dwav_usb_mt_resume,
+	.reset_resume = dwav_usb_mt_reset_resume,
+	.id_table = dwav_usb_mt_devices,
+	.supports_autosuspend = 1,
+};
+
+module_usb_driver(dwav_usb_mt_driver);
+
+MODULE_AUTHOR("Hardkernel Co.,Ltd");
+MODULE_DESCRIPTION("D-WAV USB(HID) MultiTouch Driver");
+MODULE_LICENSE("GPL");
+
+MODULE_ALIAS("dwav_usb_mt");
diff --git a/drivers/media/platform/s5p-jpeg/jpeg-core.c b/drivers/media/platform/s5p-jpeg/jpeg-core.c
index 7d0ab19c38bb..f1acefdd8bbd 100644
--- a/drivers/media/platform/s5p-jpeg/jpeg-core.c
+++ b/drivers/media/platform/s5p-jpeg/jpeg-core.c
@@ -1785,6 +1785,31 @@ static int exynos3250_jpeg_try_crop(struct s5p_jpeg_ctx *ctx,
  * V4L2 controls
  */
 
+static int vidioc_decoder_cmd(struct file *file, void *priv,
+			struct v4l2_decoder_cmd *cmd)
+{
+	struct s5p_jpeg_ctx *ctx = fh_to_ctx(priv);
+	struct vb2_queue *vq_src = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT);
+	struct vb2_v4l2_buffer *buf;
+
+	switch (cmd->cmd) {
+	case V4L2_DEC_CMD_STOP:
+		if (cmd->flags != 0)
+			return -EINVAL;
+		if (!vb2_is_streaming(vq_src))
+			return -EINVAL;
+
+		buf = v4l2_m2m_last_src_buf(ctx->fh.m2m_ctx);
+		buf->flags |= V4L2_BUF_FLAG_LAST;
+
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
 static int s5p_jpeg_g_selection(struct file *file, void *priv,
 			 struct v4l2_selection *s)
 {
@@ -1819,9 +1844,6 @@ static int s5p_jpeg_g_selection(struct file *file, void *priv,
 	return 0;
 }
 
-/*
- * V4L2 controls
- */
 static int s5p_jpeg_s_selection(struct file *file, void *fh,
 				  struct v4l2_selection *s)
 {
@@ -2013,6 +2035,8 @@ static const struct v4l2_ioctl_ops s5p_jpeg_ioctl_ops = {
 	.vidioc_streamon		= v4l2_m2m_ioctl_streamon,
 	.vidioc_streamoff		= v4l2_m2m_ioctl_streamoff,
 
+	.vidioc_decoder_cmd             = vidioc_decoder_cmd,
+
 	.vidioc_g_selection		= s5p_jpeg_g_selection,
 	.vidioc_s_selection		= s5p_jpeg_s_selection,
 
@@ -2459,13 +2483,6 @@ static int s5p_jpeg_queue_setup(struct vb2_queue *vq,
 
 	size = q_data->size;
 
-	/*
-	 * header is parsed during decoding and parsed information stored
-	 * in the context so we do not allow another buffer to overwrite it
-	 */
-	if (ctx->mode == S5P_JPEG_DECODE)
-		count = 1;
-
 	*nbuffers = count;
 	*nplanes = 1;
 	sizes[0] = size;
@@ -2573,6 +2590,7 @@ static int s5p_jpeg_start_streaming(struct vb2_queue *q, unsigned int count)
 static void s5p_jpeg_stop_streaming(struct vb2_queue *q)
 {
 	struct s5p_jpeg_ctx *ctx = vb2_get_drv_priv(q);
+	struct vb2_v4l2_buffer *buf;
 
 	/*
 	 * STREAMOFF is an acknowledgment for resolution change event.
@@ -2585,6 +2603,11 @@ static void s5p_jpeg_stop_streaming(struct vb2_queue *q)
 		ctx->state = JPEGCTX_RUNNING;
 	}
 
+	while ((buf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx)))
+		v4l2_m2m_buf_done(buf, VB2_BUF_STATE_ERROR);
+	while ((buf = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx)))
+		v4l2_m2m_buf_done(buf, VB2_BUF_STATE_ERROR);
+
 	pm_runtime_put(ctx->jpeg->dev);
 }
 
@@ -2824,6 +2847,8 @@ static irqreturn_t exynos3250_jpeg_irq(int irq, void *dev_id)
 	v4l2_m2m_buf_done(src_buf, state);
 	if (curr_ctx->mode == S5P_JPEG_ENCODE)
 		vb2_set_plane_payload(&dst_buf->vb2_buf, 0, payload_size);
+	if (src_buf->flags & V4L2_BUF_FLAG_LAST)
+		dst_buf->flags |= V4L2_BUF_FLAG_LAST;
 	v4l2_m2m_buf_done(dst_buf, state);
 
 	curr_ctx->subsampling =
diff --git a/drivers/media/platform/s5p-mfc/s5p_mfc.c b/drivers/media/platform/s5p-mfc/s5p_mfc.c
index 4c511b026bd7..2cde673cd6c3 100644
--- a/drivers/media/platform/s5p-mfc/s5p_mfc.c
+++ b/drivers/media/platform/s5p-mfc/s5p_mfc.c
@@ -858,7 +858,7 @@ static int s5p_mfc_open(struct file *file)
 	 * We'll do mostly sequential access, so sacrifice TLB efficiency for
 	 * faster allocation.
 	 */
-	q->dma_attrs = DMA_ATTR_ALLOC_SINGLE_PAGES;
+	q->dma_attrs = DMA_ATTR_ALLOC_SINGLE_PAGES | DMA_ATTR_NO_KERNEL_MAPPING;
 	q->mem_ops = &vb2_dma_contig_memops;
 	q->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;
 	ret = vb2_queue_init(q);
@@ -893,7 +893,7 @@ static int s5p_mfc_open(struct file *file)
 	 * We'll do mostly sequential access, so sacrifice TLB efficiency for
 	 * faster allocation.
 	 */
-	q->dma_attrs = DMA_ATTR_ALLOC_SINGLE_PAGES;
+	q->dma_attrs = DMA_ATTR_ALLOC_SINGLE_PAGES | DMA_ATTR_NO_KERNEL_MAPPING;
 	q->mem_ops = &vb2_dma_contig_memops;
 	q->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;
 	ret = vb2_queue_init(q);
@@ -941,6 +941,11 @@ static int s5p_mfc_release(struct file *file)
 	mfc_debug_enter();
 	if (dev)
 		mutex_lock(&dev->mfc_mutex);
+
+	/* stop streaming */
+	vb2_streamoff(&ctx->vq_src, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE);
+	vb2_streamoff(&ctx->vq_dst, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);
+
 	vb2_queue_release(&ctx->vq_src);
 	vb2_queue_release(&ctx->vq_dst);
 	if (dev) {
diff --git a/drivers/media/platform/s5p-mfc/s5p_mfc_dec.c b/drivers/media/platform/s5p-mfc/s5p_mfc_dec.c
index c1d3bda8385b..16614e26c52c 100644
--- a/drivers/media/platform/s5p-mfc/s5p_mfc_dec.c
+++ b/drivers/media/platform/s5p-mfc/s5p_mfc_dec.c
@@ -615,8 +615,8 @@ static int vidioc_qbuf(struct file *file, void *priv, struct v4l2_buffer *buf)
 	struct s5p_mfc_ctx *ctx = fh_to_ctx(priv);
 
 	if (ctx->state == MFCINST_ERROR) {
-		mfc_err("Call on QBUF after unrecoverable error\n");
-		return -EIO;
+		//mfc_err("Call on QBUF after unrecoverable error\n");
+		return -EAGAIN;
 	}
 	if (buf->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)
 		return vb2_qbuf(&ctx->vq_src, NULL, buf);
@@ -635,8 +635,8 @@ static int vidioc_dqbuf(struct file *file, void *priv, struct v4l2_buffer *buf)
 	int ret;
 
 	if (ctx->state == MFCINST_ERROR) {
-		mfc_err_limited("Call on DQBUF after unrecoverable error\n");
-		return -EIO;
+		//mfc_err_limited("Call on DQBUF after unrecoverable error\n");
+		return -EAGAIN;
 	}
 
 	switch (buf->type) {
diff --git a/drivers/media/platform/s5p-mfc/s5p_mfc_enc.c b/drivers/media/platform/s5p-mfc/s5p_mfc_enc.c
index 3da1775a65f1..e39709736a57 100644
--- a/drivers/media/platform/s5p-mfc/s5p_mfc_enc.c
+++ b/drivers/media/platform/s5p-mfc/s5p_mfc_enc.c
@@ -1214,6 +1214,7 @@ static int enc_post_frame_start(struct s5p_mfc_ctx *ctx)
 {
 	struct s5p_mfc_dev *dev = ctx->dev;
 	struct s5p_mfc_buf *mb_entry;
+	struct s5p_mfc_buf *dst_buf;
 	unsigned long enc_y_addr = 0, enc_c_addr = 0;
 	unsigned long mb_y_addr, mb_c_addr;
 	int slice_type;
@@ -1234,8 +1235,12 @@ static int enc_post_frame_start(struct s5p_mfc_ctx *ctx)
 					&mb_entry->b->vb2_buf, 0);
 			mb_c_addr = vb2_dma_contig_plane_dma_addr(
 					&mb_entry->b->vb2_buf, 1);
+			dst_buf = list_entry(ctx->dst_queue.next,
+					struct s5p_mfc_buf, list);
 			if ((enc_y_addr == mb_y_addr) &&
 						(enc_c_addr == mb_c_addr)) {
+				dst_buf->b->timecode = mb_entry->b->timecode;
+				dst_buf->b->vb2_buf.timestamp = mb_entry->b->vb2_buf.timestamp;
 				list_del(&mb_entry->list);
 				ctx->src_queue_cnt--;
 				vb2_buffer_done(&mb_entry->b->vb2_buf,
@@ -1248,8 +1253,12 @@ static int enc_post_frame_start(struct s5p_mfc_ctx *ctx)
 					&mb_entry->b->vb2_buf, 0);
 			mb_c_addr = vb2_dma_contig_plane_dma_addr(
 					&mb_entry->b->vb2_buf, 1);
+			dst_buf = list_entry(ctx->dst_queue.next,
+					struct s5p_mfc_buf, list);
 			if ((enc_y_addr == mb_y_addr) &&
 						(enc_c_addr == mb_c_addr)) {
+				dst_buf->b->timecode = mb_entry->b->timecode;
+				dst_buf->b->vb2_buf.timestamp = mb_entry->b->vb2_buf.timestamp;
 				list_del(&mb_entry->list);
 				ctx->ref_queue_cnt--;
 				vb2_buffer_done(&mb_entry->b->vb2_buf,
diff --git a/drivers/regulator/s2mps11.c b/drivers/regulator/s2mps11.c
index ebc67e3ddd4f..9239d4f303cc 100644
--- a/drivers/regulator/s2mps11.c
+++ b/drivers/regulator/s2mps11.c
@@ -1117,6 +1117,57 @@ static const struct regulator_desc s2mpu02_regulators[] = {
 	regulator_desc_s2mpu02_buck7(7),
 };
 
+static int s2mps11_pmic_ethonoff(struct platform_device *pdev, bool onoff)
+{
+	struct sec_pmic_dev *iodev = dev_get_drvdata(pdev->dev.parent);
+	unsigned int reg_val = 0;
+	int ret = 0;
+
+	ret = regmap_read(iodev->regmap_pmic, S2MPS11_REG_L15CTRL, &reg_val);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to read S2MPS11_REG_L15CTRL value\n");
+		return ret;
+	}
+
+	ret = regmap_read(iodev->regmap_pmic, S2MPS11_REG_L17CTRL, &reg_val);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to read S2MPS11_REG_L17CTRL value\n");
+		return ret;
+	}
+
+	if (onoff) {
+		/* ETH VDD0 ON */
+		ret = regmap_update_bits(iodev->regmap_pmic, S2MPS11_REG_L15CTRL, 0xFF, 0x72);
+		if (ret) {
+			dev_err(&pdev->dev, "cannot update S2MPS11 LDO CTRL15 register\n");
+			return ret;
+		}
+
+		/* ETH VDD1 ON */
+		ret = regmap_update_bits(iodev->regmap_pmic, S2MPS11_REG_L17CTRL, 0xFF, 0x72);
+		if (ret) {
+			dev_err(&pdev->dev, "cannot update S2MPS11 LDO CTRL17 register\n");
+			return ret;
+		}
+	} else {
+		/* ETH VDD0 OFF */
+		ret = regmap_update_bits(iodev->regmap_pmic, S2MPS11_REG_L15CTRL, 0x3F, 0x00);
+		if (ret) {
+			dev_err(&pdev->dev, "cannot update S2MPS11 LDO CTRL15 register\n");
+			return ret;
+		}
+
+		/* ETH VDD1 OFF */
+		ret = regmap_update_bits(iodev->regmap_pmic, S2MPS11_REG_L17CTRL, 0x3F, 0x00);
+		if (ret) {
+			dev_err(&pdev->dev, "cannot update S2MPS11 LDO CTRL17 register\n");
+			return ret;
+		}
+	}
+
+	return ret;
+}
+
 static int s2mps11_pmic_probe(struct platform_device *pdev)
 {
 	struct sec_pmic_dev *iodev = dev_get_drvdata(pdev->dev.parent);
@@ -1225,6 +1276,34 @@ static int s2mps11_pmic_probe(struct platform_device *pdev)
 	return ret;
 }
 
+static void s2mps11_pmic_shutdown(struct platform_device *pdev)
+{
+	struct sec_pmic_dev *iodev = dev_get_drvdata(pdev->dev.parent);
+	unsigned int reg_val, ret;
+
+	ret = regmap_read(iodev->regmap_pmic, S2MPS11_REG_CTRL1, &reg_val);
+	if (ret < 0) {
+		dev_crit(&pdev->dev, "could not read S2MPS11_REG_CTRL1 value\n");
+	} else {
+		/*
+		 * s2mps11-pmic: S2MPS11_REG_CTRL1 reg value
+		 * is 00000000000000000000000000010000
+		 * clear the S2MPS11_REG_CTRL1 0x10 value to shutdown.
+		 */
+		if (reg_val & BIT(4)) {
+			ret = regmap_update_bits(iodev->regmap_pmic,
+						 S2MPS11_REG_CTRL1,
+						 BIT(4), BIT(0));
+			if (ret)
+				dev_crit(&pdev->dev,
+					 "could not write S2MPS11_REG_CTRL1 value\n");
+		}
+	}
+	s2mps11_pmic_ethonoff(pdev, false);
+	mdelay(10);
+	s2mps11_pmic_ethonoff(pdev, true);
+}
+
 static const struct platform_device_id s2mps11_pmic_id[] = {
 	{ "s2mps11-regulator", S2MPS11X},
 	{ "s2mps13-regulator", S2MPS13X},
@@ -1240,6 +1319,7 @@ static struct platform_driver s2mps11_pmic_driver = {
 		.name = "s2mps11-pmic",
 	},
 	.probe = s2mps11_pmic_probe,
+	.shutdown = s2mps11_pmic_shutdown,
 	.id_table = s2mps11_pmic_id,
 };
 
diff --git a/drivers/spi/spidev.c b/drivers/spi/spidev.c
index 922d778df064..0a2af2169ab7 100644
--- a/drivers/spi/spidev.c
+++ b/drivers/spi/spidev.c
@@ -705,6 +705,8 @@ static const struct of_device_id spidev_dt_ids[] = {
 	{ .compatible = "menlo,m53cpld" },
 	{ .compatible = "cisco,spi-petra" },
 	{ .compatible = "micron,spi-authenta" },
+	/* ODROID Modification */
+	{ .compatible = "amlogic,spi-dev" },
 	{},
 };
 MODULE_DEVICE_TABLE(of, spidev_dt_ids);
diff --git a/drivers/staging/fbtft/Kconfig b/drivers/staging/fbtft/Kconfig
index dad1ddcd7b0c..408ef1a2f978 100644
--- a/drivers/staging/fbtft/Kconfig
+++ b/drivers/staging/fbtft/Kconfig
@@ -206,3 +206,17 @@ config FB_TFT_WATTEROTT
 	depends on FB_TFT
 	help
 	  Generic Framebuffer support for WATTEROTT
+
+config FB_TFT_HKTFT35
+	tristate "FB driver for the Hardkernel 3.5 inch TFT LCD"
+	depends on FB_TFT
+	help
+	  Generic Framebuffer support for the Hardkernel 3.5 inch TFT LCD
+	  that uses the ILI9488 LCD Controller
+
+config FB_TFT_HKTFT32
+	tristate "FB driver for the Hardkernel 3.2 inch TFT LCD"
+	depends on FB_TFT
+	help
+	  Generic Framebuffer support for the Hardkernel 3.2 inch TFT LCD
+	  that uses the ILI9340 LCD Controller
diff --git a/drivers/staging/fbtft/Makefile b/drivers/staging/fbtft/Makefile
index e87193f7df14..34a5a14d1ab4 100644
--- a/drivers/staging/fbtft/Makefile
+++ b/drivers/staging/fbtft/Makefile
@@ -37,3 +37,5 @@ obj-$(CONFIG_FB_TFT_UC1611)      += fb_uc1611.o
 obj-$(CONFIG_FB_TFT_UC1701)      += fb_uc1701.o
 obj-$(CONFIG_FB_TFT_UPD161704)   += fb_upd161704.o
 obj-$(CONFIG_FB_TFT_WATTEROTT)   += fb_watterott.o
+obj-$(CONFIG_FB_TFT_HKTFT35)     += fb_hktft35.o
+obj-$(CONFIG_FB_TFT_HKTFT32)     += fb_hktft32.o
diff --git a/drivers/staging/fbtft/fb_hktft32.c b/drivers/staging/fbtft/fb_hktft32.c
new file mode 100644
index 000000000000..33ac19603cad
--- /dev/null
+++ b/drivers/staging/fbtft/fb_hktft32.c
@@ -0,0 +1,156 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * FB driver for the Hardkernel 3.2 inch TFT LCD
+ * that uses the ILI9340 LCD Controller
+ *
+ * Copyright (C) 2019 Yang Deokgyu
+ *
+ * Based on fb_ili9340.c by Noralf Tronnes
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/gpio/consumer.h>
+#include <linux/delay.h>
+#include <video/mipi_display.h>
+
+#include "fbtft.h"
+
+#define DRVNAME		"fb_hktft32"
+#define WIDTH		240
+#define HEIGHT		320
+
+/* Init sequence taken from: Arduino Library for the Adafruit 2.2" display */
+static int init_display(struct fbtft_par *par)
+{
+	par->fbtftops.reset(par);
+
+	write_reg(par, 0xEF, 0x03, 0x80, 0x02);
+	write_reg(par, 0xCF, 0x00, 0XC1, 0X30);
+	write_reg(par, 0xED, 0x64, 0x03, 0X12, 0X81);
+	write_reg(par, 0xE8, 0x85, 0x00, 0x78);
+	write_reg(par, 0xCB, 0x39, 0x2C, 0x00, 0x34, 0x02);
+	write_reg(par, 0xF7, 0x20);
+	write_reg(par, 0xEA, 0x00, 0x00);
+
+	/* Power Control 1 */
+	write_reg(par, 0xC0, 0x23);
+
+	/* Power Control 2 */
+	write_reg(par, 0xC1, 0x10);
+
+	/* VCOM Control 1 */
+	write_reg(par, 0xC5, 0x3e, 0x28);
+
+	/* VCOM Control 2 */
+	write_reg(par, 0xC7, 0x86);
+
+	/* COLMOD: Pixel Format Set */
+	/* 16 bits/pixel */
+	write_reg(par, MIPI_DCS_SET_PIXEL_FORMAT, 0x55);
+
+	/* Frame Rate Control */
+	/* Division ratio = fosc, Frame Rate = 79Hz */
+	write_reg(par, 0xB1, 0x00, 0x18);
+
+	/* Display Function Control */
+	write_reg(par, 0xB6, 0x08, 0x82, 0x27);
+
+	/* Gamma Function Disable */
+	write_reg(par, 0xF2, 0x00);
+
+	/* Gamma curve selection */
+	write_reg(par, MIPI_DCS_SET_GAMMA_CURVE, 0x01);
+
+	/* Positive Gamma Correction */
+	write_reg(par, 0xE0,
+		  0x0F, 0x31, 0x2B, 0x0C, 0x0E, 0x08, 0x4E, 0xF1,
+		  0x37, 0x07, 0x10, 0x03, 0x0E, 0x09, 0x00);
+
+	/* Negative Gamma Correction */
+	write_reg(par, 0xE1,
+		  0x00, 0x0E, 0x14, 0x03, 0x11, 0x07, 0x31, 0xC1,
+		  0x48, 0x08, 0x0F, 0x0C, 0x31, 0x36, 0x0F);
+
+	write_reg(par, MIPI_DCS_EXIT_SLEEP_MODE);
+
+	mdelay(120);
+
+	write_reg(par, MIPI_DCS_SET_DISPLAY_ON);
+
+	return 0;
+}
+
+static void set_addr_win(struct fbtft_par *par, int xs, int ys, int xe, int ye)
+{
+	write_reg(par, MIPI_DCS_SET_COLUMN_ADDRESS,
+		  xs >> 8, xs & 0xFF, xe >> 8, xe & 0xFF);
+
+	write_reg(par, MIPI_DCS_SET_PAGE_ADDRESS,
+		  ys >> 8, ys & 0xFF, ye >> 8, ye & 0xFF);
+
+	write_reg(par, MIPI_DCS_WRITE_MEMORY_START);
+}
+
+#define ILI9340_MADCTL_MV  0x20
+#define ILI9340_MADCTL_MX  0x40
+#define ILI9340_MADCTL_MY  0x80
+static int set_var(struct fbtft_par *par)
+{
+	u8 val;
+
+	switch (par->info->var.rotate) {
+	case 270:
+		val = ILI9340_MADCTL_MV;
+		break;
+	case 180:
+		val = ILI9340_MADCTL_MY;
+		break;
+	case 90:
+		val = ILI9340_MADCTL_MV | ILI9340_MADCTL_MY | ILI9340_MADCTL_MX;
+		break;
+	default:
+		val = ILI9340_MADCTL_MX;
+		break;
+	}
+	/* Memory Access Control  */
+	write_reg(par, MIPI_DCS_SET_ADDRESS_MODE, val | (par->bgr << 3));
+
+	return 0;
+}
+
+static void reset(struct fbtft_par *par)
+{
+	if (!par->gpio.reset)
+		return;
+	fbtft_par_dbg(DEBUG_RESET, par, "%s()\n", __func__);
+	gpiod_set_value_cansleep(par->gpio.reset, 0);
+	usleep_range(20, 40);
+	gpiod_set_value_cansleep(par->gpio.reset, 1);
+	msleep(120);
+}
+
+static struct fbtft_display display = {
+	.regwidth = 8,
+	.buswidth = 8,
+	.width = WIDTH,
+	.height = HEIGHT,
+	.fbtftops = {
+		.init_display = init_display,
+		.set_addr_win = set_addr_win,
+		.set_var = set_var,
+		.reset = reset,
+	},
+};
+
+FBTFT_REGISTER_DRIVER(DRVNAME, "odroid,hktft32", &display);
+
+MODULE_ALIAS("spi:" DRVNAME);
+MODULE_ALIAS("platform:" DRVNAME);
+MODULE_ALIAS("spi:hktft32");
+MODULE_ALIAS("platform:hktft32");
+
+MODULE_DESCRIPTION("FB driver for the Hardkernel 3.2 inch TFT LCD uses the ILI9340 LCD Controller");
+MODULE_AUTHOR("Yang Deokgyu");
+MODULE_LICENSE("GPL");
diff --git a/drivers/thermal/thermal_helpers.c b/drivers/thermal/thermal_helpers.c
index ee7027bdcafa..2ee98e68e930 100644
--- a/drivers/thermal/thermal_helpers.c
+++ b/drivers/thermal/thermal_helpers.c
@@ -75,6 +75,10 @@ EXPORT_SYMBOL(get_thermal_instance);
  *
  * Return: On success returns 0, an error code otherwise
  */
+
+#define	CRITICAL_TEMP	120000
+int thermal_zone_data[4] = { 0, };
+
 int thermal_zone_get_temp(struct thermal_zone_device *tz, int *temp)
 {
 	int ret = -EINVAL;
@@ -108,6 +112,30 @@ int thermal_zone_get_temp(struct thermal_zone_device *tz, int *temp)
 			*temp = tz->emul_temperature;
 	}
 
+	/* save thermal_zone data */
+	if (!ret)
+		thermal_zone_data[tz->id] = *temp;
+	/*
+	 * This case is that the thermal sensor is broken.
+	 * That's not real temperature. Set the fake temperature value in order to
+	 * avoid reaching the ciritical temperature.
+	 */
+	if ((thermal_zone_data[tz->id] > CRITICAL_TEMP) && (tz->id != 4)) {
+		int i, broken_sensor = 0, correct_temp = 0;
+		for (i = 0; i < 4; i++) {
+			if ((thermal_zone_data[i] <= CRITICAL_TEMP) &&
+			    (correct_temp <= thermal_zone_data[i]))
+				correct_temp = thermal_zone_data[i];
+			if (thermal_zone_data[i] > CRITICAL_TEMP)
+				broken_sensor++;
+		}
+		/*
+		 * if all thermal sensor broken then critical temperature data send
+		 * for system poweroff.
+		 */
+		*temp = (broken_sensor == 4) ? CRITICAL_TEMP : correct_temp;
+	}
+
 	mutex_unlock(&tz->lock);
 exit:
 	return ret;
diff --git a/sound/soc/meson/Kconfig b/sound/soc/meson/Kconfig
index b93ea33739f2..9f5e3952e54e 100644
--- a/sound/soc/meson/Kconfig
+++ b/sound/soc/meson/Kconfig
@@ -70,6 +70,8 @@ config SND_MESON_AXG_SOUND_CARD
 	imply SND_MESON_AXG_PDM
 	imply SND_MESON_G12A_TOACODEC
 	imply SND_MESON_G12A_TOHDMITX if DRM_MESON_DW_HDMI
+	imply SND_SOC_MESON_T9015
+	imply SND_SOC_SIMPLE_AMPLIFIER
 	help
 	  Select Y or M to add support for the AXG SoC sound card
 
diff --git a/sound/soc/meson/axg-frddr.c b/sound/soc/meson/axg-frddr.c
index 37f4bb3469b5..b1cbeef98a73 100644
--- a/sound/soc/meson/axg-frddr.c
+++ b/sound/soc/meson/axg-frddr.c
@@ -106,7 +106,7 @@ static struct snd_soc_dai_driver axg_frddr_dai_drv = {
 	.name = "FRDDR",
 	.playback = {
 		.stream_name	= "Playback",
-		.channels_min	= 1,
+		.channels_min	= 2,
 		.channels_max	= AXG_FIFO_CH_MAX,
 		.rates		= AXG_FIFO_RATES,
 		.formats	= AXG_FIFO_FORMATS,
@@ -180,7 +180,7 @@ static struct snd_soc_dai_driver g12a_frddr_dai_drv = {
 	.name = "FRDDR",
 	.playback = {
 		.stream_name	= "Playback",
-		.channels_min	= 1,
+		.channels_min	= 2,
 		.channels_max	= AXG_FIFO_CH_MAX,
 		.rates		= AXG_FIFO_RATES,
 		.formats	= AXG_FIFO_FORMATS,
-- 
2.39.2

